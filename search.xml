<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[置顶 SCOI2020游记]]></title>
    <url>%2F9202%2F06%2F29%2F%E7%BD%AE%E9%A1%B6-SCOI2020-%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[波澜起伏的第二乐章 $Day\ 0$上午复习了一些板子,下午打了场所谓的信心赛,信心崩塌了. 晚上吃完饭后坐车去成都,到了之后发现住的宾馆和 CSP 时的是同一家,感觉我的青春又回来了. 稍微颓了会隔膜就睡觉了. $Day\ 1$上午睡到十点,起床后听教练讲了会注意事项,吃了午饭后就去考场了. 考场居然是个半露天的大厅,有几排位置还会被太阳晒着,而且还是用笔记本考试,把我震撼到了. 先写了个快读板子,发现键盘十分神必,一直按错键, Ctrl 总是按成 Fn , 并且很容易碰到触控板,感觉很不妙. 开考后大致看了下三个题, T1 是个计算几何, T2 是个组合计数, T3 题面比较长,不知道是个什么牛逼东西. 决定先开 T2, 一开始把题意读错了,浪费了半个小时,看清题意后想了一会,我会 $O(n^4)$ ,能获得 10 分的好成绩! 感觉不太对劲,跑去看 T3, 冷静分析了下,发现直接暴力维护线性基就能获得 20 分的好成绩!中间一堆子任务都没什么用,会一个就能写出 80 分了,感觉 SCOI 的 T3 的 80 分应该不会很好拿(flag), 就跑路了. 看了 T1, 发现 40 分暴力很好写, 100 分也不是很难想,把两个特殊点连起来,对其他点分同侧异侧讨论,做二维数点就必能搞出来.然后发现坐标范围是 $10^9$ ,因为有之前在 CF 被安排的经验,感觉用 double 写可能会直接爆成 0 分(flag). 此时冷静了一下,决定写全整数,但是发现需要用到 $10^{36}$ 级别的数做运算,又不给用 __int128 ,于是 rush 了一个压位高精, 因为有负数参与运算,写着还是有点小麻烦,然后发现这玩意跑得巨慢,数据也没设置梯度,直接 T 成暴力了. 回过去看 T2 ,把生成函数写出来之后运用初中所学的因式分解一通乱推,顺利解决了一元和二元的情况,获得了 50 分的好成绩!可惜没能把三元的情况给整出来,感觉三元可能另有高论吧(flag). 此时时间已经所剩无几,检查了一下代码, T2 用大样例调出来一个错误,就到时间了,感觉我的青春又结束了. 期望: 40 + 50 + 20 = 110 = 在进队的边缘试探. 实际: 40 + 50 + 30 = 120 = 在进队的边缘试探. 这个分数在 sc 的排名有点出乎我的意料,感觉 sc 药丸. 四川今年有 15 个 AB 名额,最后算上 CSP 统计出来是 rk16 ,喜提 D 队队长 ,不过 cdqz 有两位神仙被 1/3 卡了,于是侥幸混入省队,发现是唯一的一道题都没过的人,纯暴力混子选手石锤了. 同校的两名同学发挥不佳,没能进入省队,比较可惜. 赛后出来才发现 T1 直接 double 过了一片, T2 被 ldx 大佬教育了因式分解正确姿势, T3 的 80 分是个丝帛并查集. 自此 flag 全部回收,感觉考场降智 debuff 严重,只能说这波和出题人配合得并不是很好. 返校之后,因为在省选中打出了演员般的迷惑表现,被教练喷了. NOI 也没多久了,自己的姿势水平还需要提高,希望在最后能做到不留遗憾吧. 简单写了一下这场的题意和做法,感兴趣的大佬可以看一下.]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转置原理及其应用]]></title>
    <url>%2F2020%2F08%2F04%2F%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[rushcheyo -《转置原理及其应用》学习整理. 由于本人学艺不精,这里仅从比较粗浅的角度记录一些应用. 原文链接 多点求值新科技 给定一个 $n$ 次多项式 $F(x)$ 和 $m$ 个数 $a_i$ ,需要求出每个 $F(a_i)$ 的值. 定义减法卷积 ${\rm MULT}(F(x),G(x))=\sum_{i\ge0}(\sum_{j\ge 0}f_{i+j}g_j)x^i$ ,可以将一个多项式取反后再卷积来实现. 有 $F(a_i)=[x^0]{\rm MULT}(F(x),\frac{1}{1-a_ix})$ . 且$${\rm MULT}(F(x),G(x)H(x))={\rm MULT}({\rm MULT}(F(x),G(x)),H(x))$$ 分治地来求每个 $F(a_i)$ .$$G(l,r,x):={\rm MULT}(F(x),\frac 1{\prod_{i=l}^r(1-a_ix)}) \bmod x^{r-l+1}\\G(l,mid,x)={\rm MULT}(G(l,r,x),\prod_{i=mid+1}^r (1-a_ix))\bmod x^{mid-l+1}\\G(mid+1,r,x)={\rm MULT}(G(l,r,x),\prod_{i=l}^{mid} (1-a_ix)) \bmod x^{r-mid}$$当递归到 $l=r$ 时,此时的 $G(l,r,x)$ 的常数项就是我们要求的点值了. 每个要用到的 $\prod_{i=l}^r (1-a_ix)$ 可以用分治 NTT 预处理出来,时间复杂度 $O(n\log^2 n)$ . code 例题真实无妄她们的人生之路 有 $n$ 件物品,第 $i$ 件物品有属性 $0\le p_i\le 1$ .主人公等级初始为 $0$ ,使用第 $i$ 件物品会有 $p_i$ 的概率让等级加 $1$ , $1-p_i$ 的概率不变.若最后等级为 $j$ ,则会产生 $a_j$ 的攻击力.令 $f(i)$ 表示使用除 $i$ 外的 $n-1$ 个物品后,主人公产生的期望攻击力,需要求出 $f(1),f(2)\dots f(n)$ .$1\le n\le 10^5$ ,答案对 998244353 取模. Source : Comet OJ #2 F 设位置 $i$ 的多项式 $F_i(x)=p_ix+1-p_i$ ,则 $i$ 的答案就是多项式 $\prod_{j\neq i} F_j(x)$ 与 $A(x)=\sum_i a_ix^i​$ 的点积. 我们知道点积可以表示成减法卷积结果的常数项,即 $f(i)=[x^0] {\rm MULT}(A,\prod_{j\neq i} F_j)$ . 可以像做多点求值那样,由于减法卷积满足 $${\rm MULT}(F(x),G(x)H(x))={\rm MULT}({\rm MULT}(F(x),G(x)),H(x))$$ 在分治时,向左儿子传入当前乘积与右儿子 $\prod F​$ 的减法卷积,向右儿子传入当前乘积与左儿子 $\prod F​$ 的减法卷积. 时间复杂度 $O(n\log^2 n)$ .]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu U124868 第〇类循环数·行]]></title>
    <url>%2F2020%2F08%2F04%2FLuogu-U124868-%E7%AC%AC%E3%80%87%E7%B1%BB%E5%BE%AA%E7%8E%AF%E6%95%B0%C2%B7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[组合计数 + 循环卷积. 多测不清空,爆零两行泪. 从递推式入手,简单整理合并同类项可得$$f(i,j)=f(i-1,j-1)\cdot \frac{i+1}{i}\cdot \frac{j+1}{j}+f(i-1,j)\cdot \frac{i+1}{i}$$把超出边界的值都看成 $0​$ ,可以发现第 $0​$ 列仍然不满足递推式,算一下差的值,不难发现在最左边再补一列 $1,2,3,4,\dots​$ 就行了,其中第 $j​$ 列的值为 $j+1​$ .可以看成从左上角出发,每次向下或向右下走一步. 其中第 $i-1$ 行到第 $i$ 行的贡献是 $\frac{i+1}i$ ,从第 $j-1$ 列到第 $j$ 列的贡献是 $\frac{j+1}{j}$ . 把所有贡献和行走的方案数乘在一起,可以算出 $f(i,j)=\binom{i}{j+1}\cdot (i+1)\cdot (j+1)$ . 要求的是$$ans=\sum_{1\le a\le A}\sum_{1\le b\le B}\sum_{1\le c\le C}f(k,(ax^2+bx+c)\bmod k)$$尝试对每个 $i​$ 算出有几组 $a,b,c​$ 满足 $(ax^2+bx+c)\bmod k=i​$ . 预处理$$f_a(i)=\sum_{1\le a\le A}[ax^2\bmod k=i],\\f_b(i)=\sum_{1\le b\le B}[bx\bmod k=i],\\f_c(i)=\sum_{1\le c\le C}[c\bmod k=i].$$ 考虑如何求 $f_a(i)$ ,记 $v=x^2\bmod k$ ,由于 $k$ 是 $2$ 的幂,特判 $v=0$ ,否则将 $v$ 分解成 $v=2^p\cdot t$ ,其中 $t$ 为奇数. 显然每 $\frac k {2^p}$ 个 $a$ 就会将 $0,2^p,2\times 2^p,\dots,(\frac{k}{2^p}-1)\times 2^p$ 遍历,算一下完整循环节个数,多余部分 $O(k)$ 暴力. $f_b,f_c$ 的预处理同理,都可以在 $O(k)$ 内完成. 然后将 $f_a,f_b,f_c$ 做长度为 $k$ 的循环卷积就能求出每个 $i$ 有几组 $a,b,c$ 满足 $(ax^2+bx+c)\bmod k=i$ 了. 保证了 $k$ 为 $2$ 的幂,且对于模数有 $2\times 10^6\le 2^{21}$ ,只用做 $3$ 次长度为 $k$ 的 DFT ,一次长度为 $k$ 的 IDFT 即可. 时间复杂度 $O(T\cdot k\log k)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define y1 ysghinline ll read()&#123; ll out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;namespace Module&#123; const int P = 1004535809; int add(int a, int b) &#123; return a + b &gt;= P ? a + b - P : a + b; &#125; void inc(int &amp;a, int b) &#123; a = add(a, b); &#125; void dec(int &amp;a, int b) &#123; a = add(a, P - b); &#125; int mul(int a, int b) &#123; return 1LL * a * b % P; &#125; int fpow(int a, int b) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res; &#125;&#125;using namespace Module;// f(x, y) = binom(x, y + 1) * (y + 1) * (x + 1) = x * (x + 1) * binom(x - 1, y)const int N = 1 &lt;&lt; 21 | 10;int fac[N], invfac[N];int binom(int x, int y)&#123; return mul(fac[x], mul(invfac[y], invfac[x - y]));&#125;int omega[N], inv_omega[N], rev[N];void init(int n)&#123; for (int i = 0; i &lt; n; ++i) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) * (n &gt;&gt; 1)); for (int l = 2; l &lt;= n; l &lt;&lt;= 1) &#123; omega[l] = fpow(3, (P - 1) / l); inv_omega[l] = fpow(omega[l], P - 2); &#125;&#125;void DFT(int *a, int n, bool invflag)&#123; for (int i = 0; i &lt; n; ++i) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (int l = 2; l &lt;= n; l &lt;&lt;= 1) &#123; int m = l &gt;&gt; 1, gi = invflag ? inv_omega[l] : omega[l]; for (int *p = a; p != a + n; p += l) &#123; int g = 1; for (int i = 0; i &lt; m; ++i) &#123; int t = mul(g, p[i + m]); p[i + m] = add(p[i], P - t); p[i] = add(p[i], t); g = mul(g, gi); &#125; &#125; &#125; if (invflag) &#123; int invn = fpow(n, P - 2); for (int i = 0; i &lt; n; ++i) a[i] = mul(a[i], invn); &#125;&#125;int a[N], b[N], c[N], _a[N], _b[N];void solve()&#123; int A = read(), B = read(), C = read(), k = read(), x = read() % k, v; for (int i = 0; i &lt; k; ++i) a[i] = b[i] = c[i] = 0; v = 1LL * x * x % k; if (v) &#123; int mod = k, t = v; while (t % 2 == 0) mod &gt;&gt;= 1, t &gt;&gt;= 1; for (int i = 0; i &lt; mod; ++i) a[1LL * i * (k / mod) % k] = A / mod; for (int i = 1; i &lt;= A % mod; ++i) a[1LL * i * v % k]++; &#125; else a[0] = A; v = x; if (v) &#123; int mod = k, t = v; while (t % 2 == 0) mod &gt;&gt;= 1, t &gt;&gt;= 1; for (int i = 0; i &lt; mod; ++i) b[1LL * i * (k / mod) % k] = B / mod; for (int i = 1; i &lt;= B % mod; ++i) b[1LL * i * v % k]++; &#125; else b[0] = B; for (int i = 0; i &lt; k; ++i) c[i] = C / k; for (int i = 1; i &lt;= C % k; ++i) inc(c[i], 1); init(k); DFT(a, k, false), DFT(b, k, false), DFT(c, k, false); for (int i = 0; i &lt; k; ++i) a[i] = mul(a[i], mul(b[i], c[i])); DFT(a, k, true); int ans = 0; for (int i = 0; i &lt; k; ++i) inc(ans, mul(a[i], binom(k - 1, i))); ans = mul(ans, mul(k, k + 1)); ans = mul(ans, fpow(mul(A, mul(B, C)), P - 2)); cout &lt;&lt; ans &lt;&lt; '\n';&#125;int main()&#123; int mx = 2000000; fac[0] = 1; for (int i = 1; i &lt;= mx; ++i) fac[i] = mul(fac[i - 1], i); invfac[mx] = fpow(fac[mx], P - 2); for (int i = mx - 1; i &gt;= 0; --i) invfac[i] = mul(invfac[i + 1], i + 1); int T = read(); while (T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2773 学习轨迹]]></title>
    <url>%2F2020%2F07%2F31%2FLoj-2773-%E5%AD%A6%E4%B9%A0%E8%BD%A8%E8%BF%B9%2F</url>
    <content type="text"><![CDATA[单调栈 + 线段树. 首先,若在学校 $A$ 选的课权值和不超过 $A$ 权值总和一半,且在学校 $B$ 选的课权值和也不超过 $B$ 权值一半,显然是不如将 $A$ 的课选完或将 $B$ 的课选完其中之一优的,所以至少要有一所学校选的课权值和超过它权值总和的一半. 先假定在学校 $A$ 选的课权值必须超过其总权值一半,算完后交换两个学校再做一次. 记 $p$ 为 $A$ 中第一个权值前缀和超过总权值一半的位置,则在 $A$ 选的区间必定包含 $p$ ,否则肯定不能超过总权值一半. 此时在学校 $B$ 中选择一个区间 $[l,r]$ ,区间内的点会 ban 掉学校 $A$ 中的一些点,此时在学校 $A$ 的选择方法就是从 $p$ 向两边延伸,直到遇到被 ban 掉的点,中间的点权值和就是在 $A$ 中的最大收益. 枚举 $B$ 中选择的区间右端点 $r$ ,用线段树维护选择每个 $l$ 对应的区间 $[l,r]$ 时 $p$ 能拓展到的最远左右端点. $r$ 增大 $1$ 时, 每个 $[l,r]$ 会新增同一个被 ban 掉的点,若这个被 ban 掉的点已在 $p$ 能拓展到的区间之外,就不用考虑,于是对 $p$ 的左右端点各维护一个单调栈,每次新增 ban 掉的点时,不断将它能覆盖的点弹出,在线段树上做修改即可. 时间复杂度 $O(n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define y1 ysghinline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int N = 5e5 + 10;int n, m, a[N], b[N], c[N &lt;&lt; 1], p1, p2, p3, p4, swaped = 0;ll ans, suma[N], sumb[N];ll mx[N &lt;&lt; 2], ext[N &lt;&lt; 2];void pushup(int x)&#123; mx[x] = max(mx[x &lt;&lt; 1], mx[x &lt;&lt; 1 | 1]) + ext[x];&#125;void BuildTree(int x, int l, int r)&#123; ext[x] = 0; if (l == r) &#123; mx[x] = suma[n] - sumb[l - 1]; return; &#125; int mid = (l + r) &gt;&gt; 1; BuildTree(x &lt;&lt; 1, l, mid); BuildTree(x &lt;&lt; 1 | 1, mid + 1, r); pushup(x);&#125;void upd(int x, int l, int r, int L, int R, ll d)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; mx[x] += d, ext[x] += d; return; &#125; int mid = (l + r) &gt;&gt; 1; if (L &lt;= mid) upd(x &lt;&lt; 1, l, mid, L, R, d); if (R &gt; mid) upd(x &lt;&lt; 1 | 1, mid + 1, r, L, R, d); pushup(x);&#125;int query(int x, int l, int r)&#123; if (l == r) return l; int mid = (l + r) &gt;&gt; 1; if (mx[x] == mx[x &lt;&lt; 1] + ext[x]) return query(x &lt;&lt; 1, l, mid); return query(x &lt;&lt; 1 | 1, mid + 1, r);&#125;void report(ll val, int a, int b, int c, int d)&#123; if (val &gt; ans) &#123; if (swaped) swap(a, c), swap(b, d); ans = val, p1 = a, p2 = b, p3 = c, p4 = d; &#125;&#125;int tpl, tpr, sl[N], sr[N];void solve()&#123; int p = lower_bound(suma + 1, suma + n + 1, (suma[n] + 1) &gt;&gt; 1) - suma; BuildTree(1, 1, m); tpl = tpr = 0; for (int i = 1; i &lt;= m; ++i) &#123; if (b[i]) &#123; if (b[i] &lt;= p) &#123; while (tpl &amp;&amp; b[i] &gt; b[sl[tpl]]) &#123; upd(1, 1, m, sl[tpl - 1] + 1, sl[tpl], suma[b[sl[tpl]]]); --tpl; &#125; upd(1, 1, m, sl[tpl] + 1, i, -suma[b[i]]); sl[++tpl] = i; &#125; else &#123; while (tpr &amp;&amp; b[i] &lt; b[sr[tpr]]) &#123; upd(1, 1, m, sr[tpr - 1] + 1, sr[tpr], suma[n] - suma[b[sr[tpr]] - 1]); --tpr; &#125; upd(1, 1, m, sr[tpr] + 1, i, suma[b[i] - 1] - suma[n]); sr[++tpr] = i; &#125; &#125; int j = query(1, 1, m); int pl = lower_bound(sl + 1, sl + tpl + 1, j) - sl; int pr = lower_bound(sr + 1, sr + tpr + 1, j) - sr; pl = pl &lt;= tpl ? b[sl[pl]] + 1 : 1; pr = pr &lt;= tpr ? b[sr[pr]] - 1 : n; report(sumb[i] + mx[1], pl, pr, j, i); &#125;&#125;int main()&#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt;= n; ++i) suma[i] = suma[i - 1] + read(); for (int i = 1; i &lt;= m; ++i) c[read()] = i; for (int i = 1; i &lt;= m; ++i) sumb[i] = sumb[i - 1] + read(); for (int i = 1; i &lt;= n; ++i) a[i] = c[a[i]], b[a[i]] = i; report(suma[n], 1, n, 0, 0), report(sumb[m], 0, 0, 1, m); solve(); swap(n, m), swap(a, b), swap(suma, sumb), swaped = 1; solve(); printf("%lld\n", ans); printf("%d %d\n", p1, p2); printf("%d %d\n", p3, p4); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 3080 国际象棋]]></title>
    <url>%2F2020%2F07%2F30%2FLoj-3080-%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%2F</url>
    <content type="text"><![CDATA[主元法求解网格图上的随机游走问题. 朴素的高斯消元是 $O((nm)^3)$ 的,无法通过. 考虑主元法,将前 $2$ 行,第 $1$ 列的共计 $2m+n-2$ 个变量作为主元,尝试将其他变量用主元表示,并解出主元的值. 从上到下,从左到右依次考虑每个位置的方程,可以发现其中只有 $x_{i+2,j+1}$ 还没有被主元表示. 根据方程,若 $(i+2,j+1)$ 在棋盘内,就可以将 $x_{i+2,j+1}$ 也用主元表示,若不在棋盘内,则得到了一个关于主元的方程. 最后恰好能得到 $2m+n-2$ 个关于主元的线性方程,用高斯消元求解主元的值即可,时间复杂度 $O((n+m)^3)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145//%std#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define y1 ysghinline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;namespace Module&#123; const int P = 998244353; int add(int a, int b) &#123; return a + b &gt;= P ? a + b - P : a + b; &#125; void inc(int &amp;a, int b) &#123; a = add(a, b); &#125; int mul(int a, int b) &#123; return 1LL * a * b % P; &#125; int fpow(int a, int b) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res; &#125;&#125;using namespace Module;const int N = 200 + 10;int dx[8] = &#123; -2, -1, 1, 2, 2, 1, -1, -2 &#125;, dy[8] = &#123; -1, -2, -2, -1, 1, 2, 2, 1 &#125;;int p[8], inv[8], n, m, swaped = 0, k, coef[N][N][3 * N];int a[3 * N][3 * N], val[3 * N], tmp[3 * N], t = 0;bool in(int x, int y)&#123; return 1 &lt;= x &amp;&amp; x &lt;= n &amp;&amp; 1 &lt;= y &amp;&amp; y &lt;= m;&#125;void InitPivot()&#123; k = 2 * m + n - 2; val[0] = 1; for (int j = 1; j &lt;= m; ++j) coef[1][j][j] = 1, coef[2][j][j + m] = 1; for (int i = 3; i &lt;= n; ++i) coef[i][1][2 * m + i - 2] = 1;&#125;void BuildEquations()&#123; for (int x = 1; x &lt;= n; ++x) for (int y = 1; y &lt;= m; ++y) &#123; for (int i = 0; i &lt;= k; ++i) tmp[i] = add(0, P - coef[x][y][i]); inc(tmp[0], 1); for (int d = 0; d &lt; 8; ++d) if (d != 4) &#123; int cx = x + dx[d], cy = y + dy[d]; if (in(cx, cy)) for (int i = 0; i &lt;= k; ++i) inc(tmp[i], mul(p[d], coef[cx][cy][i])); &#125; if (x + 2 &lt;= n &amp;&amp; y + 1 &lt;= m) &#123; for (int i = 0; i &lt;= k; ++i) coef[x + 2][y + 1][i] = mul(inv[4], P - tmp[i]); &#125; else &#123; ++t; for (int i = 0; i &lt;= k; ++i) a[t][i] = tmp[i]; a[t][0] = add(0, P - a[t][0]); &#125; &#125; assert(t == k);&#125;void Gauss()&#123; for (int i = 1; i &lt;= k; ++i) &#123; for (int j = i; j &lt;= k; ++j) if (a[j][i]) &#123; if (i != j) for (int l = 0; l &lt;= k; ++l) swap(a[j][l], a[i][l]); break; &#125; int f = fpow(a[i][i], P - 2); for (int j = 1; j &lt;= k; ++j) if (i != j &amp;&amp; a[j][i]) &#123; int g = mul(f, P - a[j][i]); for (int l = 0; l &lt;= k; ++l) inc(a[j][l], mul(a[i][l], g)); &#125; &#125; for (int i = 1; i &lt;= k; ++i) val[i] = mul(a[i][0], fpow(a[i][i], P - 2));&#125;int main()&#123; n = read(), m = read(); int sum = 0; for (int i = 0; i &lt; 8; ++i) inc(sum, p[i] = read()); for (int i = 0; i &lt; 8; ++i) &#123; p[i] = mul(p[i], fpow(sum, P - 2)); inv[i] = fpow(p[i], P - 2); &#125; InitPivot(); BuildEquations(); Gauss(); int q = read(); while (q--) &#123; int x = read(), y = read(); int s = 0; for (int i = 0; i &lt;= k; ++i) inc(s, mul(val[i], coef[x][y][i])); write(s, '\n'); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1383]]></title>
    <url>%2F2020%2F07%2F28%2FCF1383%2F</url>
    <content type="text"><![CDATA[Div.1 vp. A - String Transformation 1若初始时存在 $A_i&gt;B_i​$ 就无解. 否则贪心,不难发现每种字符最多被改掉一次,从小到大枚举字符 $c$ ,考虑对串 $A$ 中的字符 $c$ 修改, $A_i=B_i=c$ 的位置是不用改的,对于其他 $A_i=c$ 的位置,全部改成满足 $A_i=c,B_i\neq c$ 中最小的 $B_i$ 即可. code B - GameGame从高往低考虑每个二进制位,若到某一位时,有奇数个 $a_i$ 在这一位上为 $1​$ ,就能分出胜负了, 记有 $t$ 个 $a_i$ 在这一位上为 $1$ ,若 $t\bmod 4=1$ ,则先取 $1$ 就必胜了, 若 $t\bmod 4=3$ ,再讨论下 $n$ 的奇偶性即可. 若每一位都不能分出胜负,则最后为平局. code C - String Transformation 2建一个有 $|\sum|$ 个点的有向图,对于每个 $i$ ,从 $A_i$ 向 $B_i$ 连边.问题转化为只加 $k$ 条边,使得每个 $A_i$ 仍能到 $B_i$ ,最小化这个 $k$ ,即操作次数. 图上每个弱连通分量的答案是独立的,对于一个大小为 $s$ 的弱连通分量,有高论,答案为 $2s-1-|{\rm LDAG}|$ .其中 $|{\rm LDAG}|​$ 表示这个弱连通分量中,导出子图是 DAG 的最大子点集大小. 下面是简要证明. 考虑将边逐次加入到图中,并维护每个点 $x$ 所属的某个合法 DAG 子图大小 $siz(x)$ ,记 $sum=\sum siz(x)$.初始时 $siz(x)=1,sum=s$ ,加入一条边 $u\to v$ 时: 若 $u,v$ 已经弱连通,为了保证不出现环,将 $v$ 从 $u$ 的 DAG 子图中删掉,弱连通分量个数不变,而 $sum$ 减少 $1$ .否则,可以将两者的 DAG 子图合并,弱连通分量个数减少 $1$ , 而 $sum​$ 不变. 最后弱连通分量的个数为 $1$ ,说明有 $s-1$ 条边用于减少弱连通分量个数, $k+1-s$ 条边用于减少 $sum$ .这说明最后的 $sum$ 为 $2s-1-k$ ,而最大的 $sum$ 就是 $|{\rm LDAG}|$ ,此时 $k$ 最小,为 $2s-1-|{\rm LDAG}|$ . 求每个弱连通分量的 $|{\rm LDAG}|$ 可以用状压 dp 求出每个子点集 $S$ 的导出子图是否为 DAG .一个 DAG 一定存在拓扑序,按拓扑序顺序加点,若 $S$ 合法,且 $x$ 出边指向的所有顶点与 $S$ 没有交,则 $S\cup \lbrace{x\rbrace}$ 也合法. code D - Rearrange考虑把所有数从大到小依次填入矩阵中,并且用一个队列维护接下来需要填数的位置,初始时矩阵行列数都是 $0$ . 若下一个数是行 max 或列 max ,就新增一行/一列,将它放在右下角,并从它出发,将其左方 / 上方的位置依次入队. 若它不是行 max 或列 max ,就取出队首的那个位置,将这个数填进去. 这样构造显然能满足行列 max 的限制. 对于一行来说,新增它的时候保证了左侧是递增的,而右侧一定是一列一列加入,是递减的,一定合法,同理,列也合法. code E - Strange Operation如果要在最后的串中加入 $k$ 个 $0$ ,则一定是由原串中长度 $\ge k$ 的全为 $0$ 的某个子串合并来的.如果要在最后的串中加入 $k$ 个 $1$ ,则一定是由原串中 $1$ 的个数 $\ge k​$ 的某个子串合并来的. 以此为依据不难设计出线性的 dp ,注意对于不同合并方法,若最后串相同就只算一次,所以要钦定一些转移避免算重. code F - Special Edges复杂度看上去很神必,明天再说.]]></content>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6703 小Q的序列]]></title>
    <url>%2F2020%2F07%2F27%2FLoj-6703-%E5%B0%8FQ%E7%9A%84%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[给 dp 编组合意义转为 GF 问题,利用多项式操作优化. 考虑朴素 dp , 设 $dp(i,j)$ 表示考虑了前 $i$ 个元素,选了 $j$ 个到子序列中的权值之和,则有$$dp(i,j)=(c_i+j)\cdot dp(i-1,j-1)+dp(i-1,j)$$如果 $c_i=0$ ,这个递推式和第二类斯特林数很像,考虑把 $j$ 这一维变换一下,凑成相同的形式. 显然当 $i\ge j$ 时 $dp(i,j)$ 才可能有值,可以做一个变换,令 $dp(i,j)$ 表示原来的 $dp(i,i+j)$ ,变为$$dp(i,j)=(i-j+c_i)\cdot dp(i-1,j)+dp(i-1,j-1)$$可以给这个 dp 编一个类似第二类斯特林数的组合意义,将至多 $i$ 个元素分到 $j$ 个非空集合中: $(i+c_i)\cdot dp(i-1,j)$ 表示第 $i$ 个元素没有被加入任何一个集合,贡献为 $i+c_i$ . $-j\cdot dp(i-1,j)$ 表示第 $i$ 个元素加入了已有的 $j$ 个集合之一,产生了 $-1$ 的贡献. $dp(i-1,j-1)​$ 表示第 $i​$ 个元素单独占据了新的一个集合. 枚举有 $k$ 个元素没有加入任何一个集合,答案为$$ans=\sum_{k=0}^n ([x^k]\prod_{i=1}^n((c_i+i)x+1)) \cdot f_{n-k}$$其中 $f_i=\sum dp(i,j)$ 表示有 $i$ 个数加入了集合中的贡献总和,求出每个 $f_i$ 即可算出答案. 由于一个数加入之前已有的集合时会有 $-1​$ 的贡献,相当于最后要乘上 $(-1)^{i-j}​$ , $i​$ 表示元素数, $j​$ 表示集合数. 可以先令这个系数为 $(-1)^j​$ ,那么就是 $dp(i,j)=(-1)^j\cdot {i\brace j}​$ 最后再对每个 $f_i​$ 乘上 $(-1)^i​$ 即可. 第二类斯特林数关于列 $j$ 的 EGF 为 $\frac {(\exp(x)-1)^j}{j!}$ , 那么 $dp(i,j)$ 关于列 $j$ 的 EGF 就是 $\frac {(1-\exp(x))^j}{j!}$ .$$f_i=\sum_{j} dp(i,j)\\f_i=\cdot\sum_{j} i!\cdot[x^i] \frac {(1-\exp(x))^j}{j!}\\f_i=i!\cdot[x^i] \sum_j \frac {(1-\exp(x))^j}{j!}\\f_i=i!\cdot[x_i] \exp((1-\exp(x))$$做一次多项式 exp 求出所有的 $f_i$ ,前面的 $\prod_{i=1}^n((c_i+i)x+1)$ 用分治 NTT 计算,时间复杂度 $O(n\log^2 n)$ . 可以用分治 NTT 实现多项式 exp ,这里不是复杂度瓶颈. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231//%std#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define y1 ysghinline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int P = 998244353;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a, int b)&#123; int res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res;&#125;const int N = 1 &lt;&lt; 18 | 10;namespace Polynomial&#123; int curn = 0, rev[N], omega[N], inv[N], invn; void init(int n) &#123; if (n == curn) return; for (int i = 0; i &lt; n; ++i) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) * (n &gt;&gt; 1)); for (int l = 2; l &lt;= n; l &lt;&lt;= 1) &#123; omega[l] = fpow(3, (P - 1) / l); inv[l] = fpow(omega[l], P - 2); &#125; invn = fpow(n, P - 2); curn = n; &#125; void DFT(int *a, int n, bool invflag) &#123; init(n); for (int i = 0; i &lt; n; ++i) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (int l = 2; l &lt;= n; l &lt;&lt;= 1) &#123; int gi = omega[l], m = l &gt;&gt; 1; if (invflag) gi = inv[l]; for (int *p = a; p != a + n; p += l) &#123; int g = 1; for (int i = 0; i &lt; m; ++i) &#123; int t = mul(g, p[i + m]); p[i + m] = add(p[i], P - t); p[i] = add(p[i], t); g = mul(g, gi); &#125; &#125; &#125; if (invflag) &#123; for (int i = 0; i &lt; n; ++i) a[i] = mul(a[i], invn); &#125; &#125; void NTT(int *A, int *B, int *C, int lenA, int lenB) &#123; int lenC = lenA + lenB - 1, n = 1; while (n &lt; lenC) n &lt;&lt;= 1; static int a[N], b[N]; copy(A, A + lenA, a), fill(a + lenA, a + n, 0); copy(B, B + lenB, b), fill(b + lenB, b + n, 0); DFT(a, n, false); DFT(b, n, false); for (int i = 0; i &lt; n; ++i) C[i] = mul(a[i], b[i]); DFT(C, n, true); &#125; void Inverse(int *A, int *B, int len) &#123; int n = 1; while (n &lt; len) n &lt;&lt;= 1; static int res[N], tmp[N]; res[0] = fpow(A[0], P - 2); for (int i = 2; i &lt;= n; i &lt;&lt;= 1) &#123; NTT(A, res, tmp, i, i); NTT(tmp, res, tmp, i, i); for (int j = 0; j &lt; i; ++j) res[j] = add(mul(2, res[j]), P - tmp[j]); &#125; copy(res, res + len, B); &#125; void Derivate(int *A, int n) &#123; for (int i = 0; i &lt; n - 1; ++i) A[i] = mul(i + 1, A[i + 1]); A[n - 1] = 0; &#125; void Integrate(int *A, int n) &#123; for (int i = n + 1; i &gt;= 1; --i) A[i] = mul(fpow(i, P - 2), A[i - 1]); A[0] = 0; &#125; void Ln(int *A, int *B, int n) &#123; static int invA[N], tmp[N]; Inverse(A, invA, n); copy(A, A + n, tmp); Derivate(tmp, n); NTT(tmp, invA, tmp, n, n); Integrate(tmp, n); copy(tmp, tmp + n, B); &#125; void Exp(int *A, int *B, int len) &#123; int n = 1; while (n &lt; len) n &lt;&lt;= 1; static int res[N], tmp[N]; res[0] = 1; for (int i = 2; i &lt;= n; i &lt;&lt;= 1) &#123; Ln(res, tmp, i); for (int j = 0; j &lt; i; ++j) tmp[j] = add(A[j], P - tmp[j]); inc(tmp[0], 1); NTT(tmp, res, res, i, i); &#125; copy(res, res + len, B); &#125; typedef vector&lt;int&gt; poly; poly operator*(const poly &amp;A, const poly &amp;B) &#123; int len = A.size() + B.size() - 1, n = 1; while (n &lt; len) n &lt;&lt;= 1; poly C(len); static int a[N], b[N]; memcpy(a, &amp;A[0], A.size() * 4), memset(a + A.size(), 0, (n - A.size()) * 4); memcpy(b, &amp;B[0], B.size() * 4), memset(b + B.size(), 0, (n - B.size()) * 4); DFT(a, n, false); DFT(b, n, false); for (int i = 0; i &lt; n; ++i) a[i] = mul(a[i], b[i]); DFT(a, n, true); memcpy(&amp;C[0], a, len * 4); return C; &#125; poly Prod(int *a, int l, int r) &#123; if (l == r) return poly &#123; 1, a[l] &#125;; int mid = (l + r) &gt;&gt; 1; return Prod(a, l, mid) * Prod(a, mid + 1, r); &#125;&#125;using namespace Polynomial;int n, a[N], fac[N], invfac[N], G[N];int binom(int x, int y)&#123; if (x &lt; 0 || y &lt; 0 || x &lt; y) return 0; return mul(fac[x], mul(invfac[y], invfac[x - y]));&#125;int main()&#123; n = read(); fac[0] = 1; for (int i = 1; i &lt;= n; ++i) fac[i] = mul(fac[i - 1], i); invfac[n] = fpow(fac[n], P - 2); for (int i = n - 1; i &gt;= 0; --i) invfac[i] = mul(invfac[i + 1], i + 1); for (int i = 1; i &lt;= n; ++i) a[i] = add(i, read()); poly F = Prod(a, 1, n); for (int i = 1; i &lt;= n; ++i) G[i] = add(0, P - invfac[i]); Exp(G, G, n + 1); for (int i = 0; i &lt;= n; ++i) G[i] = mul(G[i], fac[i]); int ans = P - 1; for (int i = 0; i &lt;= n; ++i) &#123; int t = mul(F[i], G[n - i]); if ((n - i) &amp; 1) inc(ans, P - t); else inc(ans, t); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; return 0;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 6593 Coefficient]]></title>
    <url>%2F2020%2F07%2F25%2FHdu-6593-Coefficient%2F</url>
    <content type="text"><![CDATA[多项式多点求值. 给定 $a,b,c,d,n$ ,有一个函数$$f(x)=\frac{b}{c+\exp(ax+d)}$$记 $x_0$ 为 $ax+d=0$ 的唯一实根,即 $-\frac{d}{a}$ ,将 $f(x)$ 在 $x=x_0$ 处做泰勒展开,求 $(x-x_0)^n$ 这一项的系数. 每组数据的 $n$ 是一样的,有 $q$ 次询问,每次询问给出 $a,b,c,d$ ,需要求出对应的答案,系数对 $998244353$ 取模.$0\le n,q\le 3\times 10^5,a\neq 0$ . 一个靠谱做法显然 $a,b,d$ 都没什么大用, $a,b$ 可以先忽略掉,最后乘上 $a^n\cdot b$ ,而 $d$ 只有平移的作用,可以直接忽略. 于是转化为求$$ans=[x^n]\frac{1}{c+\exp(x)} \\$$尝试把分母构造成 $1-q\cdot (\exp(x)-1)$ 的形式,对比系数不难发现 $q=-\frac 1{c+1}$ .$$\begin{aligned}ans&amp;=\frac{-1}{q}[x^n]\frac{1}{1-q\cdot (\exp(x)-1)} \\&amp;=\frac{-1}{q}[x^n] \sum_{k=0}^n q^k(\exp(x)-1)^k \\\end{aligned}$$这里就能做了, $(\exp(x)-1)^k$ 再除个 $k!$ 就是第二类斯特林数一列的 EGF, 问题转化为求一行的第二类斯特林数. 如果继续往下推也不是很复杂,$$\begin{aligned}ans&amp;=\frac{-1}{q}[x^n] \sum_{k\ge 0}q^k\sum_{i=0}^k \binom k i\cdot \exp(ix)\cdot (-1)^{k-i}\\&amp;=\frac{-1}{q}[x^n] \sum_{i+j\le n}q^{i+j}\cdot\binom{i+j}{i}\cdot\exp(ix)\cdot(-1)^j\\&amp;=\frac{-1}{q}[x^n] \sum_{i+j\le n}q^{i+j}\cdot\binom{i+j}{i}\cdot \frac{i^n}{n!}\cdot(-1)^j\end{aligned}$$ EI : 处理倒数上有些奇怪东西的时候,就得强行加一再减一. 这里可以看出,强行凑出 $\exp(x)-1$ 的形式后,它的常数项是 $0$ ,枚举它的指数时就只用枚举到 $n$ 了. 不难发现这是个关于 $q$ 的 $n$ 次多项式,做一次卷积求出它,然后做多点求值即可. 特判掉 $c=-1$ 和 $n=0$ 的情况. 一个玄学做法由于某种原因,答案为$$\frac{a^n\cdot b}{n!(c+1)^{n+1}}\cdot \sum_{i=0}^{n-1}(-1)^{n+i}\cdot E(n,i)\cdot c^i$$$E(n,k)$ 表示长度为 $n$ 的排列 $p$ ,恰有 $k$ 个位置满足 $p_i&lt;p_{i+1}$ ,即恰有 $k+1$ 个极长单调下降的连续段方案数. 考虑容斥,钦定这 $k+1$ 段有 $i$ 个拼接的位置不合法,注意段可以为空,开头结尾也要算上,贡献是 $\binom{n+1}{i}$ . 然后把 $n$ 个数分到剩下的 $k+1-i$ 段中,段内会自动排成单调下降,且根据每一段的长度,分割的位置也会唯一确定.$$E(n,k)=\sum_{i=0}^k (-1)^i\binom{n+1}{i}(k+1-i)^n$$做一次卷积即可求出一行所有的 $E(n,k)$ ,得到 $\sum$ 这一坨关于 $c$ 的 $n-1$ 多项式,然后做多点求值即可. 特判掉 $c=-1$ 和 $n=0​$ 的情况. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define y1 ysghconst int P = 998244353;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh &lt; 0 ? out * fh % P + P : out * fh % P;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a, int b)&#123; int res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res;&#125;const int N = 1 &lt;&lt; 20 | 10;const int M = 3e5 + 10;namespace Polynomial&#123; int curn = 0, rev[N], omega[N], inv[N], invn; void init(int n) &#123; if (n == curn) return; for (int i = 0; i &lt; n; ++i) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) * (n &gt;&gt; 1)); for (int l = 2; l &lt;= n; l &lt;&lt;= 1) &#123; omega[l] = fpow(3, (P - 1) / l); inv[l] = fpow(omega[l], P - 2); &#125; invn = fpow(n, P - 2); curn = n; &#125; void DFT(int *a, int n, bool invflag) &#123; init(n); for (int i = 0; i &lt; n; ++i) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (int l = 2; l &lt;= n; l &lt;&lt;= 1) &#123; int gi = omega[l], m = l &gt;&gt; 1; if (invflag) gi = inv[l]; for (int *p = a; p != a + n; p += l) &#123; int g = 1; for (int i = 0; i &lt; m; ++i) &#123; int t = mul(g, p[i + m]); p[i + m] = add(p[i], P - t); p[i] = add(p[i], t); g = mul(g, gi); &#125; &#125; &#125; if (invflag) &#123; for (int i = 0; i &lt; n; ++i) a[i] = mul(a[i], invn); &#125; &#125; void NTT(int *A, int *B, int *C, int lenA, int lenB) &#123; int lenC = lenA + lenB - 1, n = 1; while (n &lt; lenC) n &lt;&lt;= 1; static int a[N], b[N]; copy(A, A + lenA, a), fill(a + lenA, a + n, 0); copy(B, B + lenB, b), fill(b + lenB, b + n, 0); DFT(a, n, false); DFT(b, n, false); for (int i = 0; i &lt; n; ++i) C[i] = mul(a[i], b[i]); DFT(C, n, true); &#125; typedef vector&lt;int&gt; poly; void debug(poly A) &#123; for (int i = 0; i &lt; A.size(); ++i) write(A[i], ' '); puts(""); &#125; poly operator * (const poly &amp;A, const poly &amp;B) &#123; int len = A.size() + B.size() - 1, n = 1; while (n &lt; len) n &lt;&lt;= 1; poly C(len); static int a[N], b[N]; memcpy(a, &amp;A[0], A.size() * 4), memset(a + A.size(), 0, (n - A.size()) * 4); memcpy(b, &amp;B[0], B.size() * 4), memset(b + B.size(), 0, (n - B.size()) * 4); DFT(a, n, false); DFT(b, n, false); for (int i = 0; i &lt; n; ++i) a[i] = mul(a[i], b[i]); DFT(a, n, true); memcpy(&amp;C[0], a, len * 4); return C; &#125; poly MULT(poly A, const poly &amp;B) &#123; reverse(A.begin(), A.end()); int lenA = A.size(), n = 1, lenB = min(lenA, (int)B.size()); while (n &lt; lenA + lenB - 1) n &lt;&lt;= 1; poly C(lenA); static int a[N], b[N]; memcpy(a, &amp;A[0], lenA * 4), memset(a + lenA, 0, (n - lenA) * 4); memcpy(b, &amp;B[0], lenB * 4), memset(b + lenB, 0, (n - lenB) * 4); DFT(a, n, false); DFT(b, n, false); for (int i = 0; i &lt; n; ++i) a[i] = mul(a[i], b[i]); DFT(a, n, true); memcpy(&amp;C[0], a, lenA * 4); reverse(C.begin(), C.end()); return C; &#125; poly inverse(const poly &amp;A) &#123; int len = A.size(), n = 1; while (n &lt; len) n &lt;&lt;= 1; static int a[N], res[N], tmp[N]; memcpy(a, &amp;A[0], len * 4), memset(a + len, 0, (n - len) * 4); res[0] = fpow(a[0], P - 2); for (int i = 2; i &lt;= n; i &lt;&lt;= 1) &#123; NTT(a, res, tmp, i, i); NTT(tmp, res, tmp, i, i); for (int j = 0; j &lt; i; ++j) res[j] = add(mul(2, res[j]), P - tmp[j]); &#125; poly B(len); memcpy(&amp;B[0], res, len * 4); return B; &#125; int pos[M], idx = 1, ls[M * 2], rs[M * 2], ans[M], id[M]; poly prod[M &lt;&lt; 1], G[M &lt;&lt; 1]; void BuildTree(int x, int l, int r) &#123; if (l == r) &#123; prod[x].resize(2); prod[x][0] = 1, prod[x][1] = add(0, P - pos[l]); return; &#125; int mid = (l + r) &gt;&gt; 1; BuildTree(ls[x] = ++idx, l, mid); BuildTree(rs[x] = ++idx, mid + 1, r); prod[x] = prod[ls[x]] * prod[rs[x]]; &#125; void dfs(int x, int l, int r) &#123; G[x].resize(r - l + 1); if (l == r) &#123; ans[id[l]] = G[x][0]; return; &#125; int mid = (l + r) &gt;&gt; 1; G[ls[x]] = MULT(G[x], prod[rs[x]]); dfs(ls[x], l, mid); G[rs[x]] = MULT(G[x], prod[ls[x]]); dfs(rs[x], mid + 1, r); &#125;&#125;using namespace Polynomial;int n, m, a[M], b[M], c[M], d[M], fac[M], invfac[M];int binom(int x, int y)&#123; if (x &lt; 0 || y &lt; 0 || x &lt; y) return 0; return mul(fac[x], mul(invfac[y], invfac[x - y]));&#125;void solve()&#123; if (!m) return; if (n == 0) &#123; while (m--) &#123; int A = read(), B = read(), C = read(), D = read(); if (C == P - 1) puts("-1"); else write(mul(B, fpow(C + 1, P - 2)), '\n'); &#125; return; &#125; poly F(n + 1), g(n + 1); for (int i = 0; i &lt;= n; ++i) &#123; F[i] = binom(n + 1, i); if (i &amp; 1) F[i] = add(0, P - F[i]); g[i] = fpow(i, n); &#125; F = F * g; for (int i = 0; i &lt; n; ++i) &#123; F[i] = F[i + 1]; if ((i + n) &amp; 1) F[i] = add(0, P - F[i]); &#125; F.resize(n); int tot = 0; for (int i = 1; i &lt;= m; ++i) &#123; int A = read(), B = read(), C = read(), D = read(); if (C == P - 1) ans[i] = -1; else &#123; ans[i] = 0; ++tot; a[tot] = A, b[tot] = B, c[tot] = pos[tot] = C, d[tot] = D; id[tot] = i; &#125; &#125; if (tot) &#123; idx = 1; BuildTree(1, 1, tot); poly Inv = prod[1]; Inv.resize(n), Inv = inverse(Inv); G[1] = MULT(F, Inv); dfs(1, 1, tot); &#125; for (int i = 1; i &lt;= m; ++i) &#123; if (ans[i] != -1) &#123; ans[i] = mul(ans[i], mul(fpow(a[i], n), b[i])); ans[i] = mul(ans[i], invfac[n]); ans[i] = mul(ans[i], fpow(fpow(c[i] + 1, n + 1), P - 2)); &#125; write(ans[i], '\n'); &#125;&#125;int main()&#123; fac[0] = 1; for (int i = 1; i &lt;= M - 1; ++i) fac[i] = mul(fac[i - 1], i); invfac[M - 1] = fpow(fac[M - 1], P - 2); for (int i = M - 2; i &gt;= 0; --i) invfac[i] = mul(invfac[i + 1], i + 1); while (~scanf("%d%d", &amp;n, &amp;m)) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RPS Robots]]></title>
    <url>%2F2020%2F07%2F22%2FRPS-Robots%2F</url>
    <content type="text"><![CDATA[DFT 处理循环卷积 + 状压 dp. Source: Topcoder 2016 TCO Algorithm Round 3B Hard 有 $n$ 个人, 第 $i$ 个人有一个长度为 $k$ 的石头剪刀布字符串 $S_i$ ,由 R,S,P 三种字符组成,表示每次比赛的选择.建一个 $n$ 个点的新图,每个点对应一个人.两个人之间有边当且仅当不管字符串怎么循环移位,两个人进行 $k$ 次比赛后的胜场数和负场数不变.求这个新图中团的个数, $n\le 10^5,k\le 18$ . 考虑如何判定 $A,B$ 两个人在图中是否有边. 对 $A$ 构造一个多项式 $A(x)$ ,第 $i$ 个字符确定第 $i$ 项的系数,令 R,S,P 分别对应 $a_i=1,\omega,\omega^2$ ,对 $B$ 构造一个多项式 $B(x)$, 第 $i$ 个字符确定第 $i$ 项的系数,令 R,S,P 分别对应 $b_i=1,\omega^2,\omega$ .其中 $\omega$ 为 $3$ 次单位根. 在某个循环移位下,比赛对应的两个字符在原串中下标之差在模 $k$ 意义下是确定的,即 $(i-j)\bmod k$ 为定值. 于是我们将 $A(x),B^R(x)$ 这两个多项式做循环卷积,若胜负场数都一样,则得到的多项式每一项的系数是相同的. 循环卷积可以用 DFT 来计算,乘出来的多项式为 ${\rm IDFT}({\rm DFT}(A) \cdot {\rm DFT}(B^R))$ ,点乘为各项系数对应相乘. 考虑 IDFT 的本质是代入了 $k$ 个点值,将得到的每个值作为系数,而我们要求每个系数相同,说明我们代入点值的 $k-1$ 次多项式,即 ${\rm DFT}(A) \cdot {\rm DFT}(B^R)$ 应当是一个常数函数,即除了常数项外,其余系数都是 $0$ .忽略常数项,就等价于要求 ${\rm DFT}(A),{\rm DFT}(B)$ 不能存在某一项的系数同时不为 $0$ ,将非 $0$ 的视作 $1$ ,可以看成二进制数按位与为 $0$ . $A,B$ 的构造形式不一样,不便于我们统计答案,但由于我们此时只考虑系数是否为 $0$ ,所以可以对 $B^R(x)$ 大胆操作:$${\rm DFT}(B^R(x))=\sum_{j=0}^{k-1}x^j\cdot \sum_{i=0}^{k-1}b_{k-i-1}\omega_k^{ij}\\{\rm DFT}(B^R(x))=\sum_{j=0}^{k-1}x^j\cdot \omega_{k}^{k-j}\cdot\sum_{i=0}^{k-1}(\frac 1 {b_{k-i-1}}\omega_k^{(k-i)j})^{-1}\\{\rm DFT}(B^R(x))=\sum_{j=0}^{k-1}x^j\cdot \omega_{k}^{k-j}\cdot\sum_{i=0}^{k-1}(a_i\omega_k^{ij})^{-1}\\{\rm DFT}(B^R(x))=\sum_{j=0}^{k-1}x^j\cdot \omega_{k}^{k-j}\cdot\sum_{i=0}^{k-1}\overline {a_i\omega_k^{ij}}$$ 变式的依据是单位根的任意次幂模长都为 $1$ ,此时它的共轭和倒数是相等的. 这意味着在构造 $B(x)$ 时,也同样使用 $a_i$ 作为系数,也不用反转,直接 DFT, 不会影响系数是否为 $0$ ,形式就统一了. 用 Bluestein 暴力求出每个人的 ${\rm DFT}(A)$ ,去掉常数项后,将非 $0$ 的系数用 $1$ 替换,得到一个二进制数 $x_i$ ,则答案转化为,从 $n$ 个人中选出一个非空子集,满足子集中所有的 $x_i$ 两两按为与都为 $0​$ ,即交集为空,求合法方案数. 接下来就是个状压 dp 了,记 $cnt(x)$ 表示满足 $x_i=x$ 的 $i$ 的数目,记 $dp(S)$ 表示选择的 $x_i$ 并集为 $S$ 的合法方案数,转移时枚举一个 $S\cap T=\emptyset$ 的 $T$ ,表示加入一个 $x_i=T$ 的数,将 $dp(S)\cdot cnt(T)$ 加到 $dp(S\cup T)$ 中即可. 时间复杂度 $O(nk^2+3^k)$ ,用 Bluestein 求每个人的 ${\rm DFT}(A)$ 可以做到 $O(nk\log k+3^k)​$ ,但应该打不过暴力. 感觉 Topcoder 的题提交比较麻烦,代码就先鸽了,反正看上去应该不难实现.]]></content>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 3315 抽卡]]></title>
    <url>%2F2020%2F07%2F21%2FLoj-3315-%E6%8A%BD%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[除了老生常谈的拉格朗日反演之外,还有一个 dp + 分治 NTT 的做法. 问题转化每经过一个非终止状态,步数都会加一,答案可以转化为每个非终止状态期望经过的次数之和. 考虑一个有 $i$ 张牌的非终止状态,会经过它的概率是 ${\binom m i}^{-1}$ ,到达它之后期望停留的步数为 $\frac{m}{m-i}$ . 如果我们能求出 $cnt(i)$ ,表示有 $i$ 张牌的非终止状态(即不存在 k-顺子 的状态)的数目,那么答案就是$$ans=\sum_{i=0}^{m-1} \binom m i^{-1}\frac m {m-i}\cdot cnt(i)$$ dp 设计每个值域连续段可以分开计算,最后卷在一起.于是只需要求出牌为 $1,2,3,\dots,m$ 时,有 $i$ 张牌的非终止状态数目. 设 $dp(i,j)$ 表示考虑了前 $i$ 张牌,选了 $j$ 张牌,且没有出现 k-顺子的方案数. 讨论第 $i$ 张牌选不选,再减去选了 $i$ 出现的不合法的情况,即 $i-k+1,\dots i$ 这些牌形成了 k-顺子,而 $i-k$ 没有被选.$$dp(i,j)=dp(i-1,j-1)+dp(i-1,j)-dp(i-k-1,j-k)$$我们需要求出每个 $dp(m,j)$ ,按照转移式朴素地进行 dp 是 $O(m^2)$ 的. 分治 NTT 优化考虑将每个 $dp(i)$ 用一个多项式 $F_i$ 表示,即,设 $F_i=\sum_{j=0}^i dp(i,j)\cdot x^j$ ,那么转移式可以表示成$$F_i=(x+1)F_{i-1}-x^k\cdot F_{i-k-1}$$可以看成是上楼梯,每次上 $1$ 级有 $x+1$ 种方案,每次上 $k+1$ 级有 $-x^k$ 种方案,枚举上 $k+1$ 级的次数,可得$$F_m=\sum_{i=0}^{\lfloor m /(k+1)\rfloor}(-x^k)^{i}\cdot (x+1)^{m-i(k+1)}\cdot \binom{m-ik}{i}$$考虑利用分治 NTT 优化,令 $n=\lfloor m /(k+1)\rfloor$ ,$$\begin{aligned}F_m&amp;=\sum_{i=0}^{\lfloor m /(k+1)\rfloor}(-x^k)^{i}\cdot (x+1)^{m-i(k+1)}\cdot \binom{m-ik}{i}\\&amp;=(x+1)^{m\bmod (k+1)}\sum_{i=0}^{n}(-x^k)^i\cdot [(x+1)^{(k+1)}]^{(n-i)}\cdot\binom{m-ik}{i}\end{aligned}$$令 $A=-x^k,B=(x+1)^{k+1},coef_i=\binom{m-ik}{i}​$ ,则后面那个式子就是 $\sum_{i=0}^n A^i\cdot B^{n-i}\cdot coef_i​$ . 设 $G(l,r)=\sum_{i=l}^r A^{i-l} B^{r-i}coef_i$ ,则 $G(l,r)=G(l,mid)\cdot B^{r-mid}+G(mid+1,r)\cdot A^{mid+1-l}$ . 时间复杂度 $O(m\log^2 m)​$ . 注意当 $i=k$ 时也有 $-x^k\cdot F_{i-k-1}$ 的转移,答案应该是 $G(0,m) + [m\ge k]x^k\cdot G(0,m-k)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define y1 ysghinline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int P = 998244353, G = 3;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a, int b)&#123; int res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res;&#125;const int N = 1 &lt;&lt; 19 | 10;int curn = 0, invn, omega[N], inv[N], rev[N];void init(int n)&#123; if (n == curn) return; curn = n; invn = fpow(n, P - 2); for (int l = 2; l &lt;= n; l &lt;&lt;= 1) &#123; omega[l] = fpow(G, (P - 1) / l); inv[l] = fpow(omega[l], P - 2); &#125; for (int i = 0; i &lt; n; ++i) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) * (n &gt;&gt; 1));&#125;void DFT(int *a, int n, bool invflag)&#123; init(n); for (int i = 0; i &lt; n; ++i) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (int l = 2; l &lt;= n; l &lt;&lt;= 1) &#123; int gi = omega[l]; if (invflag) gi = inv[l]; int m = l &gt;&gt; 1; for (int *p = a; p != a + n; p += l) &#123; int g = 1; for (int i = 0; i &lt; m; ++i) &#123; int t = mul(g, p[i + m]); p[i + m] = add(p[i], P - t); p[i] = add(p[i], t); g = mul(g, gi); &#125; &#125; &#125; if (invflag) &#123; for (int i = 0; i &lt; n; ++i) a[i] = mul(a[i], invn); &#125;&#125;typedef vector&lt;int&gt; poly;poly operator + (const poly &amp;A, const poly &amp;B)&#123; int len = max(A.size(), B.size()); poly C(len); if (A.size() &lt; B.size()) &#123; for (int i = 0; i &lt; A.size(); ++i) C[i] = add(A[i], B[i]); for (int i = A.size(); i &lt; B.size(); ++i) C[i] = B[i]; &#125; else &#123; for (int i = 0; i &lt; B.size(); ++i) C[i] = add(B[i], A[i]); for (int i = B.size(); i &lt; A.size(); ++i) C[i] = A[i]; &#125; return C;&#125;poly operator * (const poly &amp;A, const poly &amp;B)&#123; static int a[N], b[N], c[N]; int len = A.size() + B.size() - 1, n = 1; poly C(len); while (n &lt; len) n &lt;&lt;= 1; int lenA = A.size(), lenB = B.size(); for (int i = 0; i &lt; lenA; ++i) a[i] = A[i]; for (int i = lenA; i &lt; n; ++i) a[i] = 0; for (int i = 0; i &lt; lenB; ++i) b[i] = B[i]; for (int i = lenB; i &lt; n; ++i) b[i] = 0; DFT(a, n, false); DFT(b, n, false); for (int i = 0; i &lt; n; ++i) c[i] = mul(a[i], b[i]); DFT(c, n, true); for (int i = 0; i &lt; len; ++i) C[i] = c[i]; return C;&#125;void debug(poly A)&#123; for (int i = 0; i &lt; A.size(); ++i) write(A[i], ' '); puts("");&#125;void shift(poly &amp;A, int p)&#123; int len = A.size(); A.resize(len + p); for (int i = len + p - 1; i &gt;= p; --i) A[i] = A[i - p]; for (int i = p - 1; i &gt;= 0; --i) A[i] = 0;&#125;int k, fac[N], invfac[N];int binom(int x, int y)&#123; if (x &lt; 0 || y &lt; 0 || x &lt; y) return 0; return mul(fac[x], mul(invfac[y], invfac[x - y]));&#125;poly binom_poly(int n)&#123; poly A(n + 1); for (int i = 0; i &lt;= n; ++i) A[i] = binom(n, i); return A;&#125;poly Prod(int l, int r, int m)&#123; if (l == r) return poly&#123;binom(m - l * k, l)&#125;; int mid = (l + r) &gt;&gt; 1; poly L = Prod(l, mid, m) * binom_poly((r - mid) * (k + 1)); poly R = Prod(mid + 1, r, m); shift(R, (mid + 1 - l) * k); if ((mid + 1 - l) &amp; 1) for (int i = 0; i &lt; R.size(); ++i) R[i] = add(0, P - R[i]); return L + R;&#125;poly calc(int m)&#123; poly A = Prod(0, m / (k + 1), m); A = A * binom_poly(m % (k + 1)); return A;&#125;poly solve(int m)&#123; if (m &gt;= k) &#123; poly A = calc(m), B = calc(m - k); shift(B, k); for (int i = 0; i &lt; B.size(); ++i) B[i] = add(0, P - B[i]); return A + B; &#125; return calc(m);&#125;int m, a[N], tot = 0;poly seg[N];poly prod(int l, int r)&#123; if (l == r) return seg[l]; int mid = (l + r) &gt;&gt; 1; return prod(l, mid) * prod(mid + 1, r);&#125;int main()&#123; m = read(), k = read(); fac[0] = 1; for (int i = 1; i &lt;= m; ++i) a[i] = read(), fac[i] = mul(fac[i - 1], i); invfac[m] = fpow(fac[m], P - 2); for (int i = m - 1; i &gt;= 0; --i) invfac[i] = mul(invfac[i + 1], i + 1); sort(a + 1, a + 1 + m); for (int l = 1, r = 0; l &lt;= m; l = ++r) &#123; while (r + 1 &lt;= m &amp;&amp; a[r + 1] == a[r] + 1) ++r; seg[++tot] = solve(r - l + 1); &#125; poly cnt = prod(1, tot); int ans = 0; for (int i = 0; i &lt; m; ++i) &#123; int tmp = fpow(mul(binom(m, i), m - i), P - 2); tmp = mul(tmp, mul(m, cnt[i])); inc(ans, tmp); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; return 0;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1379]]></title>
    <url>%2F2020%2F07%2F19%2FCF1379%2F</url>
    <content type="text"><![CDATA[在这场比赛中暴露了自己的真实水平(指只会做 Div.2 的 ABC ),被所有人打爆了. A - Acacius and String枚举 abacaba 出现的位置,其他 ? 用 d 填充,检查是否合法即可. B - Dubious Cyrpto显然最多只会有一种物品拿超过 $1$ 个,枚举这种物品即可. C - Choosing flowers枚举 $a$ ,检查 $n=\lfloor\frac m a\rfloor,\lceil \frac m a\rfloor$ 是否合法. D - New Passenger Trams只用考虑 ban 掉的区间的右端点 $+1$ 为关键点或左端点 $-1$ 为关键点的 $O(n)$ 个区间即可. E - Inverse Genealogy$n$ 是偶数无解, $n = 1$ 时 $k = 0$ 才有解.$n$ 是 $\ge 3$ 的奇数时，$k &gt; (n - 3) / 2$ 无解，$(n + 1)$ 是 $2$ 的幂且 $k = 1$ 无解，不是 $2$ 的幂且 $k = 0$ 无解.$n = 9$ 且 $k = 2$ 无解. 其余情况都有解,构造方案时为两个儿子分配有解的 $n,k$ ,变成子问题继续处理. F - Chess Strikes Back将棋盘分成 $nm$ 个 $2\times 2$ 的正方形,那么就需要在每个正方形内放恰好一个国王.若一个正方形左上角的格子被 ban 掉了,称它为 L 类小正方形,若右下角被 ban 掉了,称它为 R 类正方形.一个正方形可以既是 L 类也是 R 类,也可以都不是. 若一个 L 类正方形在一个 R 类正方形的左上方(可以在同一行或同一列),就无解,因为此时这两个正方形的路径上一定会出现两个相邻的国王,其余情况都是有解的. 于是问题转化为如何判定是否存在这样的一对正方形,每次修改可能会加入 / 删除一个 L 类 / R 类正方形.记 $S_L,S_R$ 为 L,R 类正方形的集合,用 set 维护 $a_x=\min \lbrace y \ |\ (x,y) \in S_L\rbrace, b_x=\min \lbrace y\ |\ (x-1,y) \in S_R\rbrace$ .有解可以转化为对任意 $i&gt;j$ ,有 $a_i&gt;b_j$ 成立,用线段树维护区间的 $\min a_i,\max b_i$ ,合并区间时 check 是否合法.]]></content>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6389 好图计数]]></title>
    <url>%2F2020%2F07%2F19%2FLoj-6389-%E5%A5%BD%E5%9B%BE%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[生成函数. 对于一张连通的图,若它的补图也是连通图,根据定义,当 $n&gt;1$ 时,它们都不是好图.而不连通的图的补图一定是连通的,于是可以得出,当 $n&gt;1​$ 时,连通好图和不连通好图是可以用补图关系一一对应的,两者数目相等. 设 $f_i$ 表示 $i$ 个点的好图的数目, $g_i$ 表示 $i$ 个点连通好图的数目,则有 $f_0=f_1=g_1=1,f_i=2\cdot g_i(i&gt;1)$ . 考虑 $f_i$ 的生成函数 $F(x)$ ,枚举大小为 $k​$ 的连通块数目,在无标号下可以得出$$F=\prod_{k\ge 1}(1-x^k)^{-g_k}\\\ln(F)=\sum_{k\ge 1}-g_k\cdot \ln(1-x^k) \\\frac{F’}{F}=\sum_{k\ge 1} g_k\cdot \frac{kx^{k-1}}{1-x^k}\\[x^n]F’=[x^n] (F\cdot \sum_{k\ge 1} g_k\cdot \frac{kx^{k-1}}{1-x^k})\\(n+1)f_{n+1}=\sum_{i=0}^n f_i\cdot [x^{n-i}]\sum_{k\ge1} g_k\cdot \frac{kx^{k-1}}{1-x^k}\\(n+1)f_{n+1}=\sum_{i=0}^n f_i\cdot\sum_{k\ge 1,k|n-i+1}g_k\cdot k\\\frac{n+1} 2f_{n+1}=\sum_{i=0}^n f_i\cdot\sum_{1\le k&lt;n+1,k|n-i+1}g_k\cdot k$$依次枚举 $n$ ,过程中暴力维护每个 $\sum g_k\cdot k$ ,时间复杂度 $O(n^2)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define y1 ysghinline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;int T, P;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;typedef unsigned long long ull;const ull bound = 1ULL &lt;&lt; 62;const int N = 23333 + 10;int m = 23333, inv[N], f[N], g[N], h[N];void upd(int k)&#123; int val = mul(k, g[k]); for (int i = k; i &lt;= m; i += k) inc(h[i], val);&#125;int main()&#123; T = read(), P = read(); f[0] = f[1] = g[1] = inv[1] = 1; upd(1); for (int n = 1; n &lt; m; ++n) &#123; ull tmp = 0; for (int i = 0; i &lt;= n; ++i) &#123; tmp += 1ULL * f[i] * h[n - i + 1]; if (tmp &gt; bound) tmp %= P; &#125; inv[n + 1] = mul(P - P / (n + 1), inv[P % (n + 1)]); g[n + 1] = mul(tmp % P, inv[n + 1]); f[n + 1] = add(g[n + 1], g[n + 1]); upd(n + 1); &#125; while (T--) write(f[read()], '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6094 归乡迷途]]></title>
    <url>%2F2020%2F07%2F18%2FLoj-6094-%E5%BD%92%E4%B9%A1%E8%BF%B7%E9%80%94%2F</url>
    <content type="text"><![CDATA[bfs 树 + dp 计数问题. 限制可以简单归纳为,图的 bfs 树中,每个点的父亲编号小于自己,且非树边只在同一深度的点间出现.对 bfs 树进行 dp, 每一层加入的数都一定是编号连续的一段,并且只需要记录上一层的信息就可以转移. 设 $f(i,j)$ 表示考虑了前 $i$ 个点,最深的一层有 $j$ 个点,前 $i-j$ 个点度数已经满足限制,最后 $j$ 个点只考虑向父亲连边.设 $g(i,j,k)$ 表示上一层有 $j$ 个点度数要求为 $2$ , $k$ 个点度数要求为 $3$ ,这层有 $i$ 个点时的拼接以及上一层内部连边.枚举上一层有 $k$ 个点,有 $f(i,j)=\sum_{k\le i-j}f(i-j,k)\cdot g(j,c_2,c_3)$ , $c_2,c_3$ 表示 $k$ 个点中要求度数为 $2,3$ 的点,由于它们都各自向父亲连了一条边,实际上还需要连的边数是 $1,2$ . 考虑如何计算转移系数 $g(i,j,k)$ . 当 $i&gt;0​$ 时,考虑该层第一个点的父亲是哪个点,有$$g(i,j,k)=j\cdot g(i-1,j-1,k)+k\cdot g(i-1,j+1,k-1)$$ 当 $i=0$ 时,此时需要在上一层内互相连边,使得它们满足度数限制,此时再分 $j&gt;0$ 和 $j=0$ 讨论. 当 $i=0,j&gt;0$ 时,枚举第一个还要连 $1$ 条边的点连的哪个点,有$$g(0,j,k)=(j-1)\cdot g(0,j-2,k)+k\cdot g(0,j,k-1)$$ 当 $i=j=0$ 时, $k$ 个点都要连 $2$ 条边,一定是若干个互不相交的,大小 $&gt;2$ 的环,这里犯不着 $\exp$ ,暴力预处理即可. 最后答案就是 $\sum f(n,i)\cdot g(0,c_2,c_3)$ ,时间复杂度 $O(n^3)$ . 注意根节点没有向父亲连的边,儿子方向上的度数不会 $-1​$ ,需要特判一下,即先将前两层的 $f​$ 单独算出来. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define y1 ysghinline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int P = 1e9 + 7;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;const int N = 300 + 10;int n, d[N], f[N][N], g[N][N][N], dp[N], fac[N], binom[N][N], c2, c3, ans = 0;int main()&#123; n = read(); binom[0][0] = 1, fac[0] = (P + 1) &gt;&gt; 1; for (int i = 1; i &lt;= n; ++i) &#123; fac[i] = mul(fac[i - 1], i); d[i] = read(); binom[i][0] = 1; for (int j = 1; j &lt;= i; ++j) binom[i][j] = add(binom[i - 1][j - 1], binom[i - 1][j]); &#125; dp[0] = 1; for (int i = 3; i &lt;= n; ++i) for (int j = 3; j &lt;= i; ++j) inc(dp[i], mul(mul(fac[j - 1], dp[i - j]), binom[i - 1][j - 1])); for (int i = 0; i &lt;= n; ++i) for (int j = 0; i + j &lt;= n; ++j) for (int k = 0; i + j + k &lt;= n; ++k) &#123; if (i == 0) &#123; if (j == 0) g[i][j][k] = dp[k]; else &#123; if (j &gt;= 2) inc(g[i][j][k], mul(j - 1, g[i][j - 2][k])); if (k &gt;= 1) inc(g[i][j][k], mul(k, g[i][j][k - 1])); &#125; &#125; else &#123; if (j &gt;= 1) inc(g[i][j][k], mul(j, g[i - 1][j - 1][k])); if (k &gt;= 1) inc(g[i][j][k], mul(k, g[i - 1][j + 1][k - 1])); &#125; &#125; f[1 + d[1]][d[1]] = 1; for (int i = d[1] + 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i - d[1] - 1; ++j) &#123; c2 = c3 = 0; for (int k = 1; j + k &lt;= i - 1; ++k) &#123; if (d[i - j - k + 1] == 2) ++c2; else ++c3; inc(f[i][j], mul(f[i - j][k], g[j][c2][c3])); &#125; &#125; &#125; c2 = c3 = 0; for (int i = 1; i &lt; n; ++i) &#123; if (d[n - i + 1] == 2) ++c2; else ++c3; inc(ans, mul(f[n][i], g[0][c2][c3])); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些 trick 及结论]]></title>
    <url>%2F2020%2F07%2F17%2F%E4%B8%80%E4%BA%9B-trick-%E5%8F%8A%E7%BB%93%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[主要记录了最近考试遇到的一些(可能)比较有用的 trick / 结论,不定时更新. 系数模合数的截断多项式行列式计算 矩阵 $A$ 的每个元素是一个次数小于 $k$ 的关于 $x$ 的多项式,在 ${\rm mod}\ x^k$ 意义下计算行列式,系数对某个合数取模. 构造以二元多项式 $f(x,y)$ 为元素的矩阵 $B=I+y(A-I)$ ,计算出 $B$ 的行列式,代入 $y=1$ 即得 $A$ 的行列式.矩阵 $B$ 只有对角线上的元素有常数项 $1$ ,并且在高斯消元的过程中这个性质不会被破坏.常数项为 $1$ 保证了每次都可以求出逆元,只需要实现二元多项式的加法,乘法,即可完成高斯消元,求出行列式. 一元多项式方程实数根求数值解 给出一个关于 $x$ 的 $n$ 次多项式 $f(x)$ ,求出它的所有实数根,用近似值表示. 考虑求出 $f(x)$ 的所有驻点,相邻两个驻点之间 $f(x)$ 是单调的,最多有一个解,可以在每个区间内二分尝试求解.根还有可能位于最小的驻点左侧或最大的驻点右侧,找一个合适的上下界,在对应的区间内同样二分求解.$f(x)$ 的所有驻点就是 $f’(x)$ 的所有零点,可以变成子任务递归求解,递归到多项式次数 $=1$ 时可以直接算出解. 循环矩阵的行列式计算若 $n​$ 阶方阵 $\mathbf C​$ 满足如下形式,则称它为循环矩阵:$$\mathbf C=\begin{bmatrix}a_0&amp; a_1&amp; a_2&amp; \cdots&amp; a_{n-2}&amp; a_{n-1} \\a_{n-1}&amp; a_0&amp; a_1&amp; \cdots&amp; a_{n-3}&amp; a_{n-2}\\a_{n-2}&amp; a_{n-1}&amp; a_0&amp; \cdots&amp; a_{n-4}&amp; a_{n-3}\\\vdots&amp; \vdots&amp; \vdots&amp; \ddots&amp; \vdots&amp; \vdots\\a_2&amp; a_3&amp; a_4&amp; \cdots&amp; a_0&amp; a_1\\a_1&amp; a_2&amp; a_3&amp; \cdots&amp; a_{n-1}&amp; a_0\end{bmatrix}$$ 记 $\displaystyle A(x)=\sum_{i=0}^{n-1}a_i x^i,\omega_n$ 为 $n$ 次单位根,则 $\displaystyle \det(\mathbf C)=\prod_{k=0}^{n-1} A(\omega_n^k)$ .对向量 $a$ 做一次 DFT 即可求出每个 $A(\omega_n^k)$ . 由于我不会证, 此处证明略去. 前缀和优化数列递推 给定一个 $m$ 次多项式 $F(x)$ ,有递推式 $f_0=1,f_i=\sum_{j=0}^{i-1} f_j\cdot F(i-j)$ ,需要求出 $f_1,f_2,\dots, f_n$ .系数对 $10^9+7$ 取模, $n$ 较大, $m$ 较小,要求时间复杂度做到 $O(nm)$ . 设多项式 $G_i(x)=\sum_{j&lt; i} f_j\cdot F(x-j)​$ ,那么 $f_i=G_i(i)​$ . 这里涉及到多项式的平移,考虑用点值维护 $G(x)​$ ,即维护 $G(0),G(1),\dots G(m)​$ 的值. 由于 $G_i(x)=G_{i-1}(x)+ f_{i-1}\cdot F(x-i+1)$ ,预处理 $F(-n+1)\sim F(n+m-1)$ 这 $n+m$ 个点值就足够了. 每次询问 $G(x)​$ 的值时使用拉格朗日插值,$$G(x)=\sum_{i=0}^m G(i)\cdot \prod_{j\neq i} \frac{x-j}{i-j}$$可以先算出 $\prod (x-j)​$ ,枚举 $i​$ 时将它除掉 $(x-i)​$ ,单次就可以 $O(m)​$ 计算 $G(x)​$ 了,总时间复杂度 $O(nm)​$ . 拓展性比较强,可以钦定某些位置转移,比如给每个位置安排一个 $col_i​$ ,规定只有 $col_j\neq col_i​$ 的 $f_j​$ 才能转移.那么我们维护原来的 $G​$ 和每种 $col​$ 的 $G​$ ,询问时将 $col​$ 相同部分的贡献减去即可. 把 $F(x)$ 换成某个线性递推的第 $x$ 项的值仍是可做的,算出通项公式后相似地维护前缀和即可. 一类线性递推数列的计算给定常量 $a,b$ ,有递推数列 $f_0=1,f_i=af_{i-1}+[i\ge k]bf_{i-k}$ ,求 $f_n$ . 可以看成要上 $n$ 步阶梯,每次上 $1$ 步的方案数是 $a$ ,每次上 $k$ 步的方案数是 $b$ ,问上 $n$ 步的方案数, 枚举有 $i$ 次上了 $k$ 步,可得 $f_n=\sum_{i\ge 0,ik\le n}a^{n-ik}b^i\binom{n-ik+i}{i}$ ,时间复杂度 $O(\frac n k)$ .但需要先花 $O(n)$ 的时间去预处理阶乘及其逆元,只有在多次询问,或转移系数是多项式等情况下才比较有用. 在线 “莫队” 也不知道这个东西还能不能算莫队,不过最基础的思想和莫队是一样的,姑且叫在线 “莫队” 好了. 这里假定从 $[L,R]$ 转移到 $[L,R+1],[L,R-1],[L+1,R],[L-1,R]$ 时更新信息的代价都是 $O(1)$ 的. 莫队算法需要先将所有询问离线下来,经过适当排序后处理,若强制在线,可以用这个 trick 进行处理: 考虑莫队的本质,可以看作是将一个询问 $[l,r]​$ 看作二维平面上的一个点,从一个区间转移到另一个区间的代价是对应的两个点之间的 Manhattan 距离,需要找一条总代价能接受的路径,经过每个点至少一次. 莫队就是给这些点按照某种方式排了序,使得路径总代价是 $O(n\sqrt m)$ 的. 而现在强制在线,每次必须走到一个给定的点,一个简单的想法是在平面上找一些关键点,预处理它们的信息,询问时找一个 Manhattan 距离最小的关键点转移过去就行了. 均匀撒点,在所有 $L=i\cdot S,R=j\cdot S$ 的 $(L,R)$ 都设立一个关键点,并预处理每个关键点对应区间信息.共 ${n^2}/{S^2}$ 个关键点,预处理复杂度 $O({n^3}/{S^2})$ ,每次询问到最近关键点 Manhattan 距离 $O(S)$ ,复杂度 $O(mS)$ .假定 $n,m$ 同阶,则取 $S=n^{\frac 2 3}$ 可得到总时间复杂度与空间复杂度均为 $O(n^{\frac 5 3})$ . 这个东西也可以方便地支持单点修改,每次将所有区间包含它的关键点都 $O(1)$ 更新一遍,总复杂度仍为 $O(n^{\frac 5 3})$ . 在较小 NTT 模数下的多项式多点求值 Codechef POLYEVAL Evaulate the Polynomial 给一个 $n$ 次多项式 $f(x)=\sum_{i=0}^n a_i x^i$ ,在模 $P=3\times 2^{18}+1$ 意义下做多点求值, $n\le 2.5\times 10^5$ . 直接冲一个 $E 多点求值可以通过. 取 $P-1$ 次单位根 $\omega_{P-1}\equiv g$ ,其中 $g$ 为 $P​$ 的任意一个原根. 用 Bluestein 对向量 $a$ 做一次模长为 $P-1$ 的 DFT 即可求出所有的 $f(g^i)$ ,也就得到了 $f(1),f(2),\dots f(P-1)$ . 再特判 $f(0)=a_0$ 即可,时间复杂度 $O(P\log P)​$ . 竞赛图 $n$ 个点的竞赛图是一张有向图,满足每两个点之间都恰有一条边,由一者指向另外一者. 三元环竞赛图要么是一张 DAG, 要么存在至少一个三元环.若是 DAG, 则对于两个不同的点 $u,v$ ,$u$ 能到 $v$ 与 $v$ 能到 $u$ ,恰有一个是成立的.竞赛图的三元环数目为 $\binom n 3-\sum_{i=1}^n \binom{outdeg(i)}2$ ,其中 $outdeg(i)$ 表示 $i$ 的出度. 哈密尔顿路径$x$ 能成为哈密尔顿路径起点的充要条件是从 $x$ 出发能到达所有其他的 $n-1$ 个点,必要性显然,充分性可以归纳证明.更一般地,若从 $x$ 出发能到达恰好 $k$ 个点(包括 $x$ 自己),则从 $x$ 出发的最长简单路径经过的点数恰好也为 $k$ .从这个结论出发,不难分析出,竞赛图中必定存在至少一条哈密尔顿路径. 哈密尔顿回路竞赛图存在一条哈密尔顿回路的充要条件是这个竞赛图强连通,必要性显然,充分性可以归纳证明.]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2306 蔬菜]]></title>
    <url>%2F2020%2F07%2F16%2FLoj-2306-%E8%94%AC%E8%8F%9C%2F</url>
    <content type="text"><![CDATA[模拟费用流. 直接建图,每新增一天就跑一次增广费用流,大概可以获得 $60$ 分的好成绩. 注意如果用了若干天获得了 $s$ 的收益,但其中只有 $p$ 天卖了菜,那么只用前 $p$ 天卖菜,也能获得 $s$ 的收益. 这意味着,我们新增一天对应的节点时,是不需要考虑退流的,于是用数据结构直接模拟费用流的增广过程即可.]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 3282 治疗计划]]></title>
    <url>%2F2020%2F07%2F15%2FLoj-3282-%E6%B2%BB%E7%96%97%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[Dijkstra + 线段树. 两个方案 $[l_i,r_i],[l_j,r_j]​$ 执行后能合并成一个健康区间的条件为 $R_i-L_j+1\ge |T_i-T_j|​$ ,最后要合并成 $[1,n]​$ .可以看成从所有 $L_i=1$ 的区间出发,若区间 $i,j$ 能合并,则有边 $i\to j$ ,边权为 $C_j$ ,求到 $R_i=n$ 的区间的最短路. 考虑 $i$ 能向哪些 $j$ 连边,若 $T_j\le T_i$ ,则需要满足 $R_i-T_i+1\ge L_j-T_j$ ,否则需要满足 $R_i+T_i+1\ge L_j+T_j$ .开两棵线段树,都以 $T$ 为下标,在 Dijkstra 过程中需要找 $i​$ 的所有出边,在两棵线段树上分别找即可. 每个点的入边的边权是相同的,所以每个 $j$ 只会被 $dis$ 最小的 $i$ 更新,之后可以将其删去,时间复杂度 $O(n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(ll x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(ll x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int N = 1e5 + 10, inf = 0x7fffffff;int n, m;struct info&#123; int t, l, r, c; bool operator &lt; (const info &amp;rhs) const &#123; return t &lt; rhs.t; &#125;&#125; p[N];vector&lt;int&gt; E;struct Segtree&#123; int mi[N &lt;&lt; 2]; void pushup(int x) &#123; mi[x] = min(mi[x &lt;&lt; 1], mi[x &lt;&lt; 1 | 1]); &#125; void BuildTree(int x, int l, int r, int sgn) &#123; if (l == r) &#123; mi[x] = p[l].l + p[l].t * sgn; return; &#125; int mid = (l + r) &gt;&gt; 1; BuildTree(x &lt;&lt; 1, l, mid, sgn); BuildTree(x &lt;&lt; 1 | 1, mid + 1, r, sgn); pushup(x); &#125; void erase(int x, int l, int r, int pos) &#123; if (l == r) &#123; mi[x] = inf; return; &#125; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) erase(x &lt;&lt; 1, l, mid, pos); else erase(x &lt;&lt; 1 | 1, mid + 1, r, pos); pushup(x); &#125; void query(int x, int l, int r, int L, int R, int bound) &#123; if (mi[x] &gt; bound) return; if (l == r) &#123; E.push_back(l); return; &#125; int mid = (l + r) &gt;&gt; 1; if (L &lt;= mid) query(x &lt;&lt; 1, l, mid, L, R, bound); if (R &gt; mid) query(x &lt;&lt; 1 | 1, mid + 1, r, L, R, bound); &#125;&#125; T1, T2;ll dis[N];priority_queue&lt;pair&lt;ll, int&gt; &gt; q;ll Dijkstra()&#123; for (int i = 1; i &lt;= m; ++i) if (p[i].l == 1) &#123; dis[i] = p[i].c; q.push(make_pair(-dis[i], i)); T1.erase(1, 1, m, i); T2.erase(1, 1, m, i); &#125; while (!q.empty()) &#123; int u = (q.top()).second; q.pop(); if (p[u].r == n) return dis[u]; E.clear(); if (u &gt; 1) T1.query(1, 1, m, 1, u - 1, p[u].r - p[u].t + 1); if (u &lt; m) T2.query(1, 1, m, u + 1, m, p[u].r + p[u].t + 1); for (int v : E) &#123; dis[v] = dis[u] + p[v].c, q.push(make_pair(-dis[v], v)); T1.erase(1, 1, m, v); T2.erase(1, 1, m, v); &#125; &#125; return -1;&#125;int main()&#123; n = read(), m = read(); for (int i = 1; i &lt;= m; ++i) &#123; p[i].t = read(); p[i].l = read(), p[i].r = read(); p[i].c = read(); &#125; sort(p + 1, p + 1 + m); T1.BuildTree(1, 1, m, -1); T2.BuildTree(1, 1, m, 1); cout &lt;&lt; Dijkstra() &lt;&lt; '\n'; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6698 一键挖矿]]></title>
    <url>%2F2020%2F07%2F15%2FLoj-6698-%E4%B8%80%E9%94%AE%E6%8C%96%E7%9F%BF%2F</url>
    <content type="text"><![CDATA[线段树. 一维时是经典问题,但我们常用的单调栈 + 线段树做法并不能比较方便的搬到二维上,需要考虑另外一种条件转化. 加入权值在区间 $[l,r]$ 内的格子,令它们的颜色为黑色,其它的格子颜色为白色. 考虑所有的 $(n+1)\times (m+1)$ 个 $2\times 2$ 的小正方形(超出边界也算),则所有黑色格子形成一个矩形,当且仅当恰好有 $4$ 个小正方形内部有 $1$ 个黑色格子,并且没有任何一个小正方形内部有 $3$ 个黑色格子. 必要性是显然的,任何一个由黑色格子组成的矩形都满足以上条件.充分性可以这样考虑,初始时一定是有 $4$ 个黑色格子,要求恰好有 $4$ 个小正方形内部有 $1$ 个黑色格子,就必须用黑色格子将它们连起来,形成矩形的边界,而此时角的地方会出现包含 $3$ 个黑色格子的小正方形,只有将内部全部填满后才会消失,于是可以得出这个条件是充分必要的. 有了这个结论,再来考虑如何计算答案.我们从小到大枚举 $r$ ,并对每个 $l\le r$ 维护 $f(l)$ ,表示将权值在 $[l,r]$ 内的格子染黑后,有多少个小正方形内部有 $1$ 个或 $3$ 个黑色格子.不难发现 $f(l)\ge 4,f(r)=4$ 是恒成立的,根据上面的结论,我们只需要求有多少个 $f(l)=4$ ,即最小值的个数. 用线段树维护 $f$ 以及最小值个数,每次 $r$ 增加 $1$ 时,会影响到周边的 $4$ 个 $2\times 2$ 的小正方形,在线段树上区间加即可. 时间复杂度 $O(nm\log nm)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int N = 2e5 + 10;int n, m, mx;vector&lt;int&gt; w[N];int tag[N &lt;&lt; 2];struct info&#123; int mi, cnt;&#125; tree[N &lt;&lt; 2];info operator + (const info &amp;A, const info &amp;B)&#123; if (A.mi == B.mi) return (info)&#123;A.mi, A.cnt + B.cnt&#125;; else if (A.mi &lt; B.mi) return A; return B;&#125;void pushup(int x)&#123; tree[x] = tree[x &lt;&lt; 1] + tree[x &lt;&lt; 1 | 1];&#125; void BuildTree(int x, int l, int r)&#123; if (l == r) &#123; tree[x] = (info)&#123;0, 1&#125;; return; &#125; int mid = (l + r) &gt;&gt; 1; BuildTree(x &lt;&lt; 1, l, mid); BuildTree(x &lt;&lt; 1 | 1, mid + 1, r); pushup(x);&#125;void modify(int x, int c)&#123; tree[x].mi += c; tag[x] += c;&#125;void pushdown(int x)&#123; if (tag[x]) &#123; modify(x &lt;&lt; 1, tag[x]); modify(x &lt;&lt; 1 | 1, tag[x]); tag[x] = 0; &#125;&#125;void upd(int x, int l, int r, int L, int R, int c)&#123; if (L &gt; R) return; if (L &lt;= l &amp;&amp; r &lt;= R) return modify(x, c); int mid = (l + r) &gt;&gt; 1; pushdown(x); if (L &lt;= mid) upd(x &lt;&lt; 1, l, mid, L, R, c); if (R &gt; mid) upd(x &lt;&lt; 1 | 1, mid + 1, r, L, R, c); pushup(x);&#125;void query(info &amp;res, int x, int l, int r, int L, int R)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; res = res + tree[x]; return; &#125; int mid = (l + r) &gt;&gt; 1; if (L &lt;= mid) query(res, x &lt;&lt; 1, l, mid, L, R); if (R &gt; mid) query(res, x &lt;&lt; 1 | 1, mid + 1, r, L, R);&#125;int f(int x)&#123; return x == 1 || x == 3;&#125;void solve(int x, int x0, int x1, int x2)&#123; int a[5] = &#123;0, x, x0, x1, x2&#125;; sort(a + 1, a + 1 + 4); int p = lower_bound(a + 1, a + 1 + 4, x) - a; for (int i = 1; i &lt;= p; ++i) &#123; int t = f(p - i + 1) - f(p - i); upd(1, 1, mx, a[i - 1] + 1, a[i], t); &#125;&#125;int px[N], py[N];int main()&#123; n = read(), m = read(), mx = n * m; BuildTree(1, 1, mx); for (int i = 0; i &lt;= n + 1; ++i) &#123; w[i].resize(m + 2); w[i][0] = w[i][m + 1] = mx + 1; for (int j = 1; j &lt;= m; ++j) if (i == 0 || i == n + 1) w[i][j] = mx + 1; else &#123; w[i][j] = read(); px[w[i][j]] = i, py[w[i][j]] = j; &#125; &#125; ll ans = 0; for (int r = 1; r &lt;= mx; ++r) &#123; int x = px[r], y = py[r]; solve(w[x][y], w[x - 1][y], w[x][y - 1], w[x - 1][y - 1]); solve(w[x][y], w[x - 1][y], w[x][y + 1], w[x - 1][y + 1]); solve(w[x][y], w[x + 1][y], w[x][y - 1], w[x + 1][y - 1]); solve(w[x][y], w[x + 1][y], w[x][y + 1], w[x + 1][y + 1]); info tmp&#123;4, 0&#125;; query(tmp, 1, 1, mx, 1, r); ans += tmp.cnt; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6541 圣杯战争]]></title>
    <url>%2F2020%2F07%2F15%2FLoj-6541-%E5%9C%A3%E6%9D%AF%E6%88%98%E4%BA%89%2F</url>
    <content type="text"><![CDATA[动态开点线段树 + 可删堆. 首先由于边权都是 $&gt;0$ 的,易知答案一定是最小生成树上的一条边,用反证法不难证明. 先做出一棵最小生成树,并钦定一个点为根,对每个点 $x$ 维护一个 ${\rm res}(x)$ ,表示 $x$ 的所有异色儿子与 $x$ 的最短距离,没有异色儿子则视为 $\inf$ ,那么答案就是 $\min_x \lbrace{\rm res}(x)\rbrace$ . 每次修改 $x$ 的颜色时,会影响到 ${\rm res}(x),{\rm res}(fa(x))$ ,我们用一个可删小根堆维护所有的 ${\rm res}(x)$ ,修改时将 ${\rm res}(x),{\rm res}(fa(x))$ 从堆中删掉,计算出新的 ${\rm res}(x),{\rm res}(fa(x))$ 后再将它们加入到堆中,查询堆顶即为答案. 对每个 $x$ 开一棵以颜色为下标的线段树,为每个叶子节点开一个可删小根堆,对于 $x$ 的每个儿子 $y$ ,将 $(x,y)$ 的边权加入到 $col(y)$ 对应的堆中,计算 ${\rm res}(x)$ 时只需查询 $[1,col(x)),(col(x),K]$ 这两个区间内叶子节点堆顶的最小值. 修改 $x$ 的颜色时需要对 $fa(x)$的线段树修改,将原来颜色的贡献删掉,将新的颜色的贡献加入. 叶子节点不会超过 $n+q$ 个,可删堆就只需要开这么多个,如果开 $O((n+q)\log (n+q))$ 个可能会 RE 或 CE. 时间复杂度 $O(m\log m+(n+q)\log (n+q))$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int N = 4e5 + 10, inf = 1e9;struct Heap&#123; priority_queue&lt;int&gt; q1, q2; void insert(int x) &#123; q1.push(-x); &#125; void erase(int x) &#123; q2.push(-x); &#125; int mi() &#123; while (!q2.empty() &amp;&amp; q1.top() == q2.top()) q1.pop(), q2.pop(); if (q1.empty()) return inf; return -q1.top(); &#125;&#125; ans;int n, m, q, col[N], res[N], opt_x[N], opt_k[N], val[N], tot = 0;struct Edge&#123; int u, v, w; bool operator &lt; (const Edge &amp;rhs) const &#123; return w &lt; rhs.w; &#125;&#125; E[N];vector&lt;pair&lt;int, int&gt; &gt; G[N];int Fa[N], fa[N], tofa[N];int Find(int x)&#123; return x == Fa[x] ? x : Fa[x] = Find(Fa[x]);&#125;int idx = 0, mi[N * 2] = &#123;inf&#125;, ls[N * 2], rs[N * 2], id[N * 2], t = 0, rt[N];Heap leaf[N];void upd(int &amp;x, int l, int r, int pos, int c, int sgn)&#123; if (!x) x = ++idx; if (l == r) &#123; if (!id[x]) id[x] = ++t; if (sgn == 1) leaf[id[x]].insert(c); else leaf[id[x]].erase(c); mi[x] = leaf[id[x]].mi(); return; &#125; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) upd(ls[x], l, mid, pos, c, sgn); else upd(rs[x], mid + 1, r, pos, c, sgn); mi[x] = min(mi[ls[x]], mi[rs[x]]);&#125;void query(int &amp;s, int x, int l, int r, int L, int R)&#123; if (!x || L &gt; R) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; s = min(s, mi[x]); return; &#125; int mid = (l + r) &gt;&gt; 1; if (L &lt;= mid) query(s, ls[x], l, mid, L, R); if (R &gt; mid) query(s, rs[x], mid + 1, r, L, R);&#125;void dfs(int x, int F)&#123; fa[x] = F, res[x] = inf; for (auto p : G[x]) &#123; int y = p.first, w = p.second; if (y == F) continue; if (col[y] != col[x]) res[x] = min(res[x], w); upd(rt[x], 1, tot, col[y], w, 1); tofa[y] = w; dfs(y, x); &#125; ans.insert(res[x]);&#125;int main()&#123; n = read(), m = read(), read(), q = read(); for (int i = 1; i &lt;= m; ++i) E[i].u = read(), E[i].v = read(), E[i].w = read(); sort(E + 1, E + 1 + m); iota(Fa + 1, Fa + 1 + n, 1); for (int i = 1; i &lt;= m; ++i) &#123; int u = Find(E[i].u), v = Find(E[i].v); if (u != v) &#123; Fa[u] = v; G[E[i].u].push_back(make_pair(E[i].v, E[i].w)); G[E[i].v].push_back(make_pair(E[i].u, E[i].w)); &#125; &#125; for (int i = 1; i &lt;= n; ++i) val[++tot] = col[i] = read(); for (int i = 1; i &lt;= q; ++i) &#123; opt_x[i] = read(); val[++tot] = opt_k[i] = read(); &#125; sort(val + 1, val + 1 + tot); tot = unique(val + 1, val + 1 + tot) - val - 1; for (int i = 1; i &lt;= n; ++i) col[i] = lower_bound(val + 1, val + 1 + tot, col[i]) - val; dfs(1, 0); for (int i = 1; i &lt;= q; ++i) &#123; int x = opt_x[i], c = lower_bound(val + 1, val + 1 + tot, opt_k[i]) - val; ans.erase(res[x]); res[x] = inf; query(res[x], rt[x], 1, tot, 1, c - 1); query(res[x], rt[x], 1, tot, c + 1, tot); ans.insert(res[x]); if (x != 1) &#123; ans.erase(res[fa[x]]); upd(rt[fa[x]], 1, tot, col[x], tofa[x], -1); upd(rt[fa[x]], 1, tot, c, tofa[x], 1); res[fa[x]] = inf; query(res[fa[x]], rt[fa[x]], 1, tot, 1, col[fa[x]] - 1); query(res[fa[x]], rt[fa[x]], 1, tot, col[fa[x]] + 1, tot); ans.insert(res[fa[x]]); &#125; col[x] = c; write(ans.mi(), '\n'); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个恒等式的组合意义证明]]></title>
    <url>%2F2020%2F07%2F06%2F%E4%B8%80%E4%B8%AA%E6%81%92%E7%AD%89%E5%BC%8F%E7%9A%84%E7%BB%84%E5%90%88%E6%84%8F%E4%B9%89%E8%AF%81%E6%98%8E%2F</url>
    <content type="text"><![CDATA[$$\sum_{i=0}^n A^i\binom{n-i}{k}=\sum_{i=0}^n(A-1)^i\binom{n+1}{i+k+1}$$ 其中 $A,n,k$ 均为正整数,特别地,当 $A=1$ 时,等式右端 $(A-1)^0$ 应视作 $1$ . 证明有 $n$ 个球,先确定一个 $i$ ,将前 $i$ 个球拿出,这 $i$ 个球每个球可以放入 $A$ 个盒子中的任意一个,再从剩下的 $n-i$ 个球中选出 $k$ 个球,这 $k$ 个球每个球只能放入一个盒子中,求方案数. 显然左式是上面这个问题的答案,接下来我们用另外一个办法来选球,以证明右式也是这个问题的答案. 记前 $i$ 个球为第一类球,选出的 $k$ 个球为第二类球. 枚举共有 $j$ 个第一类球放入了前 $A-1$ 个盒子,并讨论最后一个第一类球是否放入了前 $A-1$ 个盒子. 若最后一个第一类球放入了前 $A-1$ 个盒子,那么我们选出 $i+k$ 个球,其中前 $i$ 个球表示放入前 $A-1$ 个盒子的球,后 $k$ 个球表示第二类球,贡献为 $\sum(A-1)^i \binom{n}{i+k}$. 若最后一个第一类球放入了最后一个盒子,那么我们选出 $i+1+k$ 个球,其中前 $i$ 个球表示放入前 $A-1$ 个盒子的球,第 $i+1$ 个球表示最后一个第一类球,后 $k$ 个球表示第二类球,贡献为 $\sum(A-1)^i \binom{n}{i+1+k}$ . 第一类球需要形成一个前缀,此时前缀中空出的位置一定是放入最后一个盒子的第一类球. 将两类贡献求和即可得到右式 $\sum_{i=0}^n(A-1)^i\binom{n+1}{i+k+1}$ ,从而证明了右式也是问题的答案,得出左式和右式相等. 运用当 $n$ 很大, $k$ 较小时,直接用左式计算,时间复杂度是 $O(n-k)$ 的. 而右式可以通过简单处理变成二项式定理的形式,可以用总和减掉另外 $k$ 项的贡献求得答案,时间复杂度 $O(k)$ .]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Global Round 9]]></title>
    <url>%2F2020%2F07%2F05%2FCodeforces-Global-Round-9%2F</url>
    <content type="text"><![CDATA[本来要打这场的,但由于某种原因鸽了. vp 一看题发现全是神必构造,一道都不会,跑路了.题目一道都改不来,感觉要完蛋了. A - Sign Flipping让奇数位置上的 $a_i\ge 0$ ,偶数位置上的 $a_i\le 0$ 即可. 也可以脑瘫地去 dp, 设 $dp(i,j,0/1)$ 表示考虑了前 $i$ 个数,有 $j$ 个差分是 $\ge 0$ 的,第 $i$ 个数为 $a_i/-a_i$ 时是否合法.若两个数相同,则既可以转移到 $j$ ,也可以转移到 $j+1$ ,最后让 $\ge 0$ 的差分数目恰好为 $\frac{n-1}{2}$ ,转移时要记录方案. code B - Neighbor Grid角上填 $2$ , 边上填 $3$ ,中间填 $4$ ,再判一下是否合法即可. code C - Element Extermination手玩一下,不难发现有解的充要条件是 $a_n&gt;a_1$ . code D - Replace by MEX为了方便,规定序列下标从 $0$ 开始. 若当前的 ${\rm mex}=n$ ,则随便找一个 $a_i\neq i$ 的位置进行操作,若找不到,说明已经符合要求,不用再进行操作.若当前的 ${\rm mex}\neq n$ ,则对 $\rm mex$ 这个位置进行操作. 可以发现,这两种操作是交替进行的,且执行完两次操作后, $a_i\neq i$ 的位置数目会恰好减少 $1$ .于是 $2n$ 次操作内一定可以让序列每个位置都满足 $a_i=i​$ . code E - Inversion Swapsort从前往后考虑每个位置 $i$ ,将所有 $j&gt;i$ 的 $(i,j)$ 交换操作全部执行,需要给这些 $j$ 确定操作的顺序. 记原序列,即未进行任何操作的序列 $a$ ,为序列 $b$ ,不难发现将这些 $j$ 按照 $b_j$ 为第一关键字, $j$ 为第二关键字从大到小排序,依次执行这些 $(i,j)$ 操作即可,最后一定能得到单调不上升的 $a$ 序列. code F - Integer Game结论是先手有三步必杀策略. 记 $k=10^9$ .第一轮先手令 $y=k$ ,后手操作后变为 $a+k,b,c$ .第二轮先手令 $y=2k+2a-b-c$ ,后手操作后变为 $a+k,2k+2a-c,c$ 或者 $a+k,b,2k+2a-b$ .此时三个数从小到大形成了等差数列,并且上一次后手操作的一定是最大的数,第三轮先手令 $y​$ 为公差即可取胜. code G - Tree Ｍodification将树看作二分图,黑白染色,考虑一次操作 $(a,b,c)$ ,我们只反转 $a$ 的颜色,其他点的颜色就可以维持不变. 每次操作能让某种颜色点数 $-1$ ,且只要该颜色的点数 $\ge 2$ ,就一定能找到合适的 $(a,b,c)$ 使得它的点数 $-1$ .最后要形成菊花图,即某种颜色只有一个点,于是答案就是初始时黑白点数目较小者 $-1​$ . code H - Set Merging I - Cubic Lattice]]></content>
      <tags>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于位运算的一个 O(n)-O(1) RMQ 做法]]></title>
    <url>%2F2020%2F07%2F03%2F%E5%9F%BA%E4%BA%8E%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E4%B8%80%E4%B8%AA-O-n-O-1-RMQ%20%E5%81%9A%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一个比较好写的小常数 $O(n)-O(1)$ RMQ 做法,巧妙运用了分块与位运算函数. source RMQ 问题:给出一个长度为 $n$ 的整数数列 $a$ ,有 $m$ 次询问,每次询问一个区间 $[l,r]$ 内 $a_i$ 的最小值. 一些常见的做法: 线段树, $O(n)-O(\log n)$ . 朴素的 ST 表, $O(n\log n)-O(1)$ . RMQ 转 LCA, 离线后用 tarjan 算法求 LCA, $O(n\alpha(n))-O(1)$ . RMQ 转 LCA, 然后用 $\pm1$ RMQ 做法解决, $O(n)-O(1)$ . 这里介绍另外一种基于位运算的 $O(n)-O(1)$ 做法,相比上面的最后一种做法更为好写,且常数较小.下面的做法需要先保证机器字节长 $w\ge \log n$ ,这在我们平常遇到的问题中绝大多数时候都是成立的. 考虑将序列分块,每块大小为 $\Theta(\log n)$ ,预处理整块部分的 ST 表,这里对 $O(\frac n {\log n})$ 个数建 ST 表,时间复杂度 $O(n)$ . 实现时候可以取块大小为 $\frac 3 2\log n$ ,常数较为优秀. 若询问的端点 $l,r​$ 来自两个不同的块,整块可以在 ST 表上询问,边角是块的前缀 / 后缀最小值,这可以 $O(n)​$ 预处理. 难点是 $l,r​$ 位于同一个块中的情况,我们在预处理时,对每个块从左到右维护一个单调栈,满足元素从栈底到栈顶单调上升,那么 $[l,r]​$ 的最小值所在的位置,就是加入 $r​$ 后单调栈中从底部到顶部第一个 $\ge l​$ 的位置. 每加入一个元素时,我们就将当前栈的形态给存储下来,由于每块大小是 $O (\log n)$ 的,而 $w\ge\log n$ ,所以栈的形态可以压缩到一个二进制数中,假定块的左端点为 $S$ ,则这个数的第 $i$ 个二进制位表示了 $S+i$ 这个位置是否在单调栈中. 那么查询单调栈中从底部到顶部第一个 $\ge l$ 的位置,就可以转化为问这个二进制数从第 $l$ 位往前第一个为 $1$ 的位置.我们可以利用 __builtin_ctz 函数 $O(1)$ 计算,记所询问的单调栈转化为二进制数表示为 $x$ .调用__builtin_ctz(x) 会返回 $x$ 二进制下末尾 $0​$ 的个数 ,那么显然 l + __builtin_ctz(x &gt;&gt; l) 即为所求. 这份代码 实现了上述做法 ,目前在 Loj 和 Luogu 上都是效率 rk1 ,RMQ 部分的代码只有不到 2k .]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>单调栈</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Grand Contest 046]]></title>
    <url>%2F2020%2F07%2F02%2FAtcoder-Grand-Contest-046%2F</url>
    <content type="text"><![CDATA[dp 专项练习场. A - Takahashikun, The Strider为了方便,可以先规定初始方向是 $x$ 正半轴,那么第 $i$ 步的移动的向量就是 $(\sin ix,\cos ix)$ .那么就是要求方程 $\sum_{i=0}^{k-1} (\sin ix,\cos ix)=(0,0)$ 的最小正整数解 $k$ . 可以把式子化简后求解,也可以直接猜结论,甚至还可以 MMA 求解 . code B - Extension设 $dp(i,j)$ 表示有多少种不同的 $i$ 行 $j$ 列的矩阵,直接转移有 $dp(i,j)=dp(i,j-1)\cdot i+dp(i-1,j)\cdot j$ .这样转移,若某种情况能被 $(i,j-1),(i-1,j)$ 同时拓展出来,就会被重复计算,需要将这部分减掉. 不难发现它们必须满足第 $i$ 行恰有一个黑的,且第 $j$ 列恰有一个黑的,因为每次黑色是新增的,所以交点处不能为黑.于是这些情况数就是 $dp(i-1,j-1)\cdot (i-1)\cdot (j-1)$ ,将它们减去即可.code C - Shift老套路了,每次把一个 $1$ 放到一个 $0$ 前面去,可以看成是 $0$ 将 $1$ 分成了若干段,数列可以用每段的长度来表示,每次操作就是让后面某段长度减 $1$ ,让前面某段长度加 $1$ . $k$ 那么大显然是唬人的,最多 $|S|$ 次操作就足够了. 记所有的 $0$ 将串分为了 $m$ 个由 $1$ 构成的连续段,第 $i$ 段的长度为 $a_i$ ,此处开头结尾也算,长度为 $0$ 的也算. 记 $n=|S|$ ,设 $dp(i,j,k)$ 表示考虑了第 $i$ 到第 $m$ 个段,操作了 $j$ 次,留出了 $k$ 个 $1$ 可以加给前面的段的方案数. 转移时枚举当前这一段增加的长度或减少的长度,注意不能又用后面留出的 $1$ ,又往前面送 $1$ ,这样是亏操作数目的. 长度增加时可以用类似前缀和的做法优化,即每次只增加一个,这样转移是 $O(1)$ 的,这部分时间复杂度为 $O(n^3)$ ,而长度减少时显然最多减少 $a_i$ 个,这部分时间复杂度也为 $O(\sum a_i\cdot n^2)=O(n^3)$ . code D - Secret Passage先考虑给定一个字符串 $T$ ,如何判断它能否被串 $S$ 经过若干次得到. 若它们的最后一个字符相同,则可以同时删掉最后一个字符,判断前面的能否操作出来,若最后一个字符不同,则必须要在某次操作中,在这个位置插入一个对应的字符. 设 $dp(i,j,k)$ 表示当前 $T$ 的长度为 $i$ ,需要插入 $j$ 个 $0$ , $k$ 个 $1$ 的方案数,转移时讨论最后一个字符能否匹配即可. 需要注意,最后求出的状态 $(i,j,k)​$ 并非全部合法,即并不是每个状态都对应着能生成出来的串 $T​$ ,需要满足仅对串 $S​$ 的前 $|S|-(i-j-k)​$ 位进行操作的情况下,能向后插入 $j​$ 个 $0​$ , $k​$ 个 $1​$ . 我们每次对 $S$ 操作时,可以将其中一个字符插到后面,也可以插到前 $|S|-(i-j-k)$ 位中,设 $f(i,j,k)$ 表示仅对 $S$ 的前 $i$ 个字符进行操作,向后插入了 $j$ 个 $0$ , $k$ 个 $1$ 时,最多还可以向前 $|S|-(i-j-k)$ 位插入的字符数.转移就讨论是否用新插进来的字符,插入的字符是 $0$ 还是 $1​$ ,插入到前面还是后面,这样就可以判断状态是否合法了. 时间复杂度 $O(|S|^3)$ . code E - Permutation Cover明天再说. F - Forbidden Tournament明天再说.]]></content>
      <tags>
        <tag>Atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 4532 湫秋系列故事——安排座位]]></title>
    <url>%2F2020%2F07%2F01%2FHdu-4532-%E6%B9%AB%E7%A7%8B%E7%B3%BB%E5%88%97%E6%95%85%E4%BA%8B%E2%80%94%E2%80%94%E5%AE%89%E6%8E%92%E5%BA%A7%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[容斥原理 + 多项式卷积. 经典模型,有 $n$ 种颜色的球,每种球有 $a_i$ 个,要将它们排成一行,使得相邻两个球颜色不同,求方案数. 下面认为同种颜色的球是没有区别的,若有区别,最后将答案乘上 $\prod (a_i!)$ 即可. 用容斥原理计算,若恰有 $k$ 个位置是相邻两个球颜色相同的,方案数为 $t(k)$ ,则对答案贡献为 $(-1)^k t(k)$ . 考虑每种颜色的小球贡献,若第 $i$ 种球在最后有 $j$ 个位置是相邻的,那么实际对可重排列长度的贡献个数为 $a_i-j$ ,那么可重排列的分子的贡献放在最后计算,分母的贡献和容斥系数拆到每种球上,将每种球的多项式卷起来就可以了. 具体地,对于第 $i$ 种球,我们构造一个多项式$$f(i)=\sum_{j=0}^{a_i-1} (-1)^j\binom {a_i-1}j \frac{1}{(a_i-j)!}x^{a_i-j}$$其中 $\binom{a_i-1}{j}$ 表示选择哪 $j​$ 个位置合并在一起. 记 $F=\prod f(i), m=\sum a_i$ ,答案即为 $\sum_{i=n}^{m} i!\cdot [x^i]F​$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int P = 1e9 + 7;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a, int b)&#123; int res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res;&#125;const int N = 500 + 10;int fac[N], invfac[N], binom[N][N];void init(int mx)&#123; fac[0] = invfac[0] = binom[0][0] = 1; for (int i = 1; i &lt;= mx; ++i) &#123; binom[i][0] = 1; for (int j = 1; j &lt;= i; ++j) binom[i][j] = add(binom[i - 1][j - 1], binom[i - 1][j]); fac[i] = mul(fac[i - 1], i); invfac[i] = fpow(fac[i], P - 2); &#125;&#125;int n, m, a, poly[N], coef[N];int solve()&#123; int ans = 0, prod = 1; n = read(), m = 0; poly[0] = 1; for (int t = 1; t &lt;= n; ++t) &#123; int a = read(); for (int j = 0; j &lt; a; ++j) &#123; coef[a - j] = mul(binom[a - 1][j], invfac[a - j]); if (j &amp; 1) coef[a - j] = add(P, -coef[a - j]); &#125; m += a, prod = mul(prod, fac[a]); for (int i = m; i &gt;= 0; --i) &#123; poly[i] = 0; for (int j = 1; j &lt;= a &amp;&amp; j &lt;= i; ++j) inc(poly[i], mul(coef[j], poly[i - j])); &#125; &#125; for (int i = n; i &lt;= m; ++i) inc(ans, mul(fac[i], poly[i])); ans = mul(ans, prod); for (int i = 0; i &lt;= m; ++i) poly[i] = 0; return ans;&#125;int main()&#123; init(500); int cases = read(); for (int i = 1; i &lt;= cases; ++i) &#123; int ans = solve(); printf("Case %d: %d\n", i, ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>容斥原理</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各省省选题目乱做]]></title>
    <url>%2F2020%2F06%2F18%2F%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89%E9%A2%98%E7%9B%AE%E4%B9%B1%E5%81%9A%2F</url>
    <content type="text"><![CDATA[2020 省选题目乱做. OJ 上有的就不写题面了. BJOI 1v1 大战. 封印对 $t$ 建出后缀自动机,将 $s$ 放上去匹配,对于 $s$ 的每个前缀能处理出它最长的是 $t$ 的子串的后缀.这些后缀可以表示成 $n$ 个区间 $[l_i,r_i]$ ,对于每次询问 $[L,R]$ ,显然只需要考虑这 $n$ 个区间的贡献. 考虑所有 $l_i\le L$ 的区间,它们对答案的贡献是 $\min(\max(r_i,L-1),R)-L+1$ ,预处理前缀最大的 $r_i$ 即可.记 $p=\max_{l_i\le L}\lbrace\min(\max(r_i,L-1),R)\rbrace$ ,考虑 $p&lt;r_i\le R$ 的区间,贡献是 $r_i-l_1+1$ ,预处理 ST 表即可.对于 $r_i&gt;R$ 的区间,它们的贡献会在 $r_i=R$ 处算上,对于 $l_i&gt;L,r_i\le p$ 的区间,都没有从 $L$ 到 $p$ 长,就不用考虑.code 联合省选 A 卷冰火战士首先可以将权值全部离散化,考虑有两个函数 $f(x),g(x)$ 表示当温度为 $x$ 时,冰,火能参战的人的总能量.那么当温度为 $x$ 时,显然消耗总能量为 $2\times\min(f(x),g(x))$ . 而 $f$ 是不降的, $g$ 是不增的,只需要找到 $f$ 第一次比 $g$ 大的位置和 $f$ 最后一个比 $g$ 小的位置,二者中必有最优解.考虑如何找出这些位置,用线段树维护这两个函数在每个位置的值,在线段树上二分,每次看一下往哪边走即可. 由于要输出最高的最优温度,所以最后还需要在线段树上向右拓展一下,找到最高的最优温度.时间复杂度 $O(n\log n)$ .code 组合数问题给的多项式 $f(k)$ 可以直接拆成 $m+1$ 个单项式做,每个单项式只需要算下面这个东西:$$\sum_{k=0}^n x^k\binom n k\cdot k^m$$直接用第二类斯特林数将自然数幂展开成组合数.$$\begin{aligned}ans&amp;=\sum_{k=0}^nx^k\binom n k\sum_{i=0}^m {m\brace i}i!\binom k i \\&amp;=\sum_{i=0}^m{m\brace i}i!\sum_{k=0}^n x^k\binom n k\binom k i\\&amp;=\sum_{i=0}^m{m\brace i}i!\binom n i\sum_{k=0}^n x^k\binom{n-i}{k-i} \\&amp;=\sum_{i=0}^m{m\brace i}n^{\underline i} x^i\sum_{k=i}^{n-i}x^{k-i}\binom{n-i}{k-i}\\&amp;=\sum_{i=0}^m{m\brace i}n^{\underline i} x^i(x+1)^{n-i}\end{aligned}$$对于每个单项式可以 $O(m)$ 求其贡献,时间复杂度 $O(m^2)$ .code (代码偷懒写的 $O(m^2\log P)$) 魔法商店 2018 年集训队论文 - 浅谈保序回归问题. 首先可以注意到求出权值最大/最小的合法集合是一个带权拟阵求最大/最小权值极大独立组的问题. 若集合 $A$ 外的元素 $x$ 能替换 $A$ 内的元素 $y$ ,则必须满足调整后的权值 $v_x\ge v_y$ .若集合 $B$ 外的元素 $x$ 能替换 $B$ 内的元素 $y$ ,则必须满足调整后的权值 $v_x\le v_y$ . 于是就形成了若干个偏序关系,转化成了保序回归 $L_2$ 问题,具体解法可以参考相关论文.代码先鸽着. 信号传递考虑状压 dp ,从小到大依次确定每个信号站在 $S$ 序列中的编号,记录哪些编号已经被确定. 两个相邻的数会产生贡献,这个贡献可以拆到每个位置上分别计算,预处理一下贡献的系数即可.自己不会与自己产生贡献,贡献系数只会有 $m\times 2^{m-1}$ 种,空间就能开下了,时间复杂度 $O(m2^m)$ .code 树 AGC044C 再放送. 用 01 Trie 树维护子树 $x$ 内所有的 $v_i+d(i,x)$ .需要实现插入一个数,合并两棵 Trie ,给插入的数整体 $+1$ , 询问插入的数异或和这些操作. 整体 $+1$ 有一个 trick, 将 Trie 树反着建,即先走低位,再走高位,修改时先对 $1$ 的方向递归修改,然后交换左右儿子.合并就直接像线段树那样合并就行了,全局异或和可以在修改和合并的时候顺便维护一下,时间复杂度 $O(n\log n)$ . 注意因为有 $+1$ 操作, Trie 树中实际可能出现的最大值是 $v+n-1$ ,而不是 $v$ .code 作业题先枚举一个因子,只保留权值是它倍数的边计算贡献,最后把答案反演出来.于是瓶颈在于算所有生成树边权之和. 考虑每条边被计算了多少次,这可以用矩阵树定理转换为求一个余子式的值.要求每条边的贡献,做一次矩阵求逆搞出伴随矩阵就行了.具体一点的描述可以看 这里 ,把图当成有向图,强制让 $n$ 作为根,求生成内向树数目,也就是原图的生成树数目. 也可以将每条边的权值看作 $1+wx$ ,在 $\bmod x^2$ 意义下求行列式,最后一次项的系数就是所有生成树边权之和. 复杂度是 $O(n^4\max \sigma_0(w_i)$ ,可以剪下枝,如果保留某些边后图不连通,就不用计算了.code 联合省选 B 卷 和 A 卷相同的题就不再写了. 卡牌游戏显然从第二个位置开始,选取那些前缀和 $&gt;0$ 的位置,将它们的前缀和加入答案即可.code 信息传递把询问离线下来挂在每个点上,做一次点分治即可统计出答案.如果强制在线,则可以考虑在每个分治中心把信息存下来, 询问时在点分树上跳即可,空间复杂度会多一个 $\log​$ .code 幸运数字显然每种优惠都可以拆到不超过 $2​$ 个区间上进行贡献,端点离散化后打上差分标记,最后扫一遍统计答案即可.由于还要输出要求的最优位置,还要额外处理一些细节.code 丁香之路枚举 $t$ ,考虑第 $t$ 个人的答案. 假定已经确定了每条边要走多少次,那么这个方案合法当且仅当它们能构成 $s\to t$ 的欧拉路.问题可以归纳为,已经加了 $m$ 条给定边,此时 $s,t$ 以及其他有度数的点形成集合 $S$ ,还要加若干条边(每条边可以被加多次),使得每个点度数满足各自的奇偶性要求,且 $S$ 内所有点连通,最小化加入的所有边权值总和. 不难发现,我们新加的边中只会用到 $(x,x+1)$ 的边,其他边可以被组合出来,于是只用再考虑这 $n-1$ 条边.此时还需要连奇数条边的点显然有偶数个,我们将它们按顺序两两串起来,就满足了度数的限制.此时 $S$ 集合中的点仍可能不连通,需要将各个连通块用边连起来,并且为了满足度数限制,选到的边都要走两次. 由于可能会用到 $S$ 外的点来使 $S$ 连通,直接做是斯坦纳树问题,不是 MST 问题,需要进一步观察图的性质.若 $x$ 不在集合 $S$ 中,则 $(x-1,x),(x,x+1)$ 这两条边一定是同时被选或同时不被选,可以缩在一起,缩完之后的边一定都是连接 $S$ 连通块之间的边,用这些边做一次 MST 即可,由于权值不会达到 $n$ ,对它们的排序可以用计数排序. 时间复杂度 $O(n^2\alpha(n))$ .code SCOI游戏 给定二维平面上的两个点 $S,T​$ ,以及其他 $n​$ 个点 $p_1,p_2,\dots,p_n​$ ,询问有多少组 $i&lt;j​$ 满足 $T​$ 在三角形 $SP_iP_j​$ 的外接圆内部(不包含边界).$n\le 10^5​$ ,保证没有点重合,没有三点共线的情况,点的坐标可以认为是在 $[-10^9,10^9]​$ 内随机的. 记圆心为 $O​$ ,需要满足 $|OS|&gt;|OT|​$ ,连接 $ST​$ ,做其中垂线,划分出两个半平面,圆心必须在靠近 $T​$ 的那个半平面内.外心是两条边的中垂线交点,记线段 $SP_i​$ 的中垂线为 $L_i​$ ,变为询问这 $n​$ 条直线之间有多少个交点在给定的半平面内. 因为坐标随机,所以可以有精度很垃圾的做法,先通过平移,旋转,把 $S$ 搞到原点, $T$ 搞到 $x$ 轴正半轴上某个位置.于是只需要求 $x&gt;k$ 的交点 $(x,y)$ 个数,假定两条直线分别是 $y=ax+b,y=cx+d$ ,则要求 $x=\frac{d-b}{a-c}&gt;t​$ . 把所有直线拿来按照斜率从小到大排序,枚举 $y=ax+b$ ,考虑 $c&lt;a$ 的所有直线 $y=cx+d$ ,此时 $a-c&gt;0$ ,要求变为 $d-b&gt;ta-tc$ ,即 $tc+d&gt;ta+b$ ,不难发现就是个关于 $a,ta+b​$ 的二维数点,随便搞一搞即可. 行走 在三维空间中随机游走.初始在 $(0,0,0)$ ,每一步会从 $ (x,y,z)$ 等概率走到$$(x+1,y+1,z+1),(x+1,y,z),(x,y+1,z),(x,y,z+1),\\(x-1,y,z),(x,y-1,z),(x,y,z-1),(x-1,y-1,z-1)$$这八个点中的一个.有 $m$ 次询问,每次询问走了 $t$ 步后,在 $(a,b,c)$ 的概率.$a,b,c$ 可能是通配符, 表示并不关心这一维的坐标,保证 $a,b,c$ 不会同时是通配符 .答案对 $998244353$ 取模, $1\le m\le 2\times 10^5,0\le t,|a|,|b|,|c|\le 2\times 10^5$ ,恰好有一个通配符的询问不超过 $50$ 个. Case 1: 恰好有 2 个通配符可以先将通配符换到 $b,c​$ 上,答案为$$\begin{aligned}ans&amp;=2^{-t}[x^a] (x+2+x^{-1})^t \\&amp;=2^{-t}[x^{a+t}] (x^2+2x+1)^t \\&amp;=2^{-t}[x^{a+t}] (x+1)^{2t} \\&amp;=2^{-t}\binom{2t}{a+t}\end{aligned}$$单次询问时间复杂度 $O(1)$ . Case 2: 恰好有 1 个通配符可以先将通配符换到 $c$ 上,答案为$$\begin{aligned}ans&amp;=8^{-t}[x^ay^b] (xy+x+y+1+x^{-1}+y^{-1}+1+x^{-1}y^{-1})^t\\&amp;=8^{-t}[x^ay^b] ((x+1)(y+1)+(x^{-1}+1)(y^{-1}+1))^t\\&amp;=8^{-t}[x^ay^b]\sum_{i=0}^t \binom t i(x+1)^i(x^{-1}+1)^{t-i}(y+1)^i(y^{-1}+i)^{t-i}\\&amp;=8^{-t}\sum_{i=0}^t\binom t i[x^{a+t-i}] (x+1)^t\cdot[y^{b+t-i}] (y+1)^t\\&amp;=8^{-t}\sum_{i=0}^t\binom t i\binom{t}{a+t-i}\binom{t}{b+t-i}\end{aligned}$$单次询问时间复杂度 $O(t)$ . Case 3: 没有通配符答案为$$\begin{aligned}ans&amp;=8^{-t}[x^ay^bz^c] (xyz+x+y+z+x^{-1}+y^{-1}+z^{-1}+x^{-1}y^{-1}z^{-1})^t\\&amp;=8^{-t}[x^{a+t}y^{b+t}z^{c+t}] (x^2y^2z^2+x^2yz+xy^2z+xyz^2+yz+xz+xy+1)^t \\&amp;=8^{-t}[x^{a+t}y^{b+t}z^{c+t}] (xy+1)^t(xz+1)^t(yz+1)^t\end{aligned}$$若 $xy,xz,yz​$ 分别选了 $k_1,k_2,k_3​$ 个,则有 $k_1+k_2=a+t,k_1+k_3=b+t,k_2+k_3=c+t​$ ,可以直接解出 $k_1,k_2,k_3​$ 的值,根据二项式定理,答案即为 $8^{-t}\binom t {k_1}\binom t {k_2}\binom t {k_3}​$ .单次询问时间复杂度 $O(1)​$ . FG 有 $n​$ 个数,初始都是 $0​$ ,有 $m​$ 种操作,每个操作有 4 个参数 $l,r,v,c​$ ,表示这个操作可以给 $[l,r]​$ 内所有数异或上 $[1,v]​$ 内的一个任意一个数,代价为 $c​$ .每个操作可以执行多次,一个操作序列的代价是使用过的操作代价最大值,每个操作序列会得到若干种终止状态,每种终止状态的贡献是能得到它的操作序列中代价的最小值,询问所有可能被得到的终止状态的贡献总和.答案对 $10^9+7​$ 取模, $1\le n,m\le 10^5,1\le l\le r\le n, 1\le c\le 10^9,1\le v\le 2^{16\times 2^{16}}​$ , $v​$ 会通过给定的随机数生成器来读入. 首先容易发现可以直接把 $v$ 换成最大的满足 $2^k\le v$ 的 $2^k$ ,因为每次都只修改一个二进制位,就能凑出 $\le 2^k$ 的数. 若用 $c\le x$ 的操作能得到 $f(x)$ 种终止状态,则答案为 $\sum_x x\cdot (f(x)-f(x-1))$ . 将所有操作按照 $c$ 从小到大排序,依次加入每个操作,并维护当前的 $f(x)$ .可以对每个二进制位分开考虑, $f(x)$ 是每个二进制位终止状态数量的乘积.对这 $n$ 个数做异或意义下的差分,则每个操作相当于可以给两个数异或上 $1$ ,对每个二进制位维护一个线性基, $f(x)$ 即为 $2^t$ ,其中 $t$ 表示所有二进制位的线性基大小之和. 由于加入的数都是只有两个位置上是 $1​$ ,可以看成是在 $l,r+1​$ 之间连了一条边,不难发现,若加入一条边时两端点未连通,则线性基大小会增加一,于是可以用并查集来维护每个线性基,就得到了一个 $O(n\cdot \alpha(n)\cdot \log v)​$ 的做法. 注意到若加入边时,端点已连通,那么可以用新加的边去替换环上的某条边,显然将 $v​$ 更小的替换掉,就能保证不变劣.用 LCT 对 $n+1​$ 个点维护一个关于边权 $v_i​$ 的最大生成树即可,时间复杂度 $O(n\log n)​$ .]]></content>
  </entry>
  <entry>
    <title><![CDATA[Loj 6402 yww 与校门外的树]]></title>
    <url>%2F2020%2F06%2F17%2FLoj-6402-yww-%E4%B8%8E%E6%A0%A1%E9%97%A8%E5%A4%96%E7%9A%84%E6%A0%91%2F</url>
    <content type="text"><![CDATA[多项式求逆. 首先这个随机过程可以等价于随机出了一个 $1\sim n$ 的排列,需要对每个排列的答案求和. 不难发现,各个连通块是一段连续的区间,且两个相邻的连通块之间一定是左侧的最小值大于右侧的最大值. 设 $F(x)$ 表示长度为 $i$ 的排列形成一个连通块的 OGF, 若干个这样的结构会组合成一个排列,且合并时顺序固定. 那么设 $P(x)=\sum i!x^i​$ ,则有 $\frac{1}{1-F}=P​$ ,得出 $F=1-\frac{1}{P}​$ . 考虑如何计算答案,只需要把贡献放入 $F​$ 的每一项中,再用若干个结构卷起来组合成排列即可. 设 $G=\sum [x^i]F\cdot i\cdot x^i$ ,则 $[x^n]\frac{1}{1-G}$ 即为所求. 需要实现多项式乘法及求逆,时间复杂度 $O(n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int P = 998244353, G = 3;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a, int b)&#123; int res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res;&#125;const int N = 1 &lt;&lt; 20 | 10;int curn = 0, rev[N], omega[N], inv[N];void init(int n)&#123; if (n == curn) return; for (int i = 0; i &lt; n; ++i) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) * (n &gt;&gt; 1)); for (int l = 2; l &lt;= n; l &lt;&lt;= 1) &#123; omega[l] = fpow(G, (P - 1) / l); inv[l] = fpow(omega[l], P - 2); &#125; curn = n;&#125;void DFT(int *a, int n, bool invflag)&#123; init(n); for (int i = 0; i &lt; n; ++i) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (int l = 2; l &lt;= n; l &lt;&lt;= 1) &#123; int gi = omega[l], m = l &gt;&gt; 1; if (invflag) gi = inv[l]; for (int *p = a; p != a + n; p += l) &#123; int g = 1; for (int i = 0; i &lt; m; ++i) &#123; int t = mul(g, p[i + m]); p[i + m] = add(p[i], P - t); p[i] = add(p[i], t); g = mul(g, gi); &#125; &#125; &#125; if (invflag) &#123; int invn = fpow(n, P - 2); for (int i = 0; i &lt; n; ++i) a[i] = mul(a[i], invn); &#125;&#125;void NTT(int *A, int *B, int *C, int lenA, int lenB)&#123; int lenC = lenA + lenB - 1, n = 1; while (n &lt; lenC) n &lt;&lt;= 1; static int a[N], b[N]; for (int i = 0; i &lt; lenA; ++i) a[i] = A[i]; for (int i = lenA; i &lt; n; ++i) a[i] = 0; for (int i = 0; i &lt; lenB; ++i) b[i] = B[i]; for (int i = lenB; i &lt; n; ++i) b[i] = 0; DFT(a, n, false); DFT(b, n, false); for (int i = 0; i &lt; n; ++i) C[i] = mul(a[i], b[i]); DFT(C, n, true);&#125;void Inverse(int *A, int *B, int len)&#123; int n = 1; while (n &lt; len) n &lt;&lt;= 1; static int res[N], tmp[N]; res[0] = fpow(A[0], P - 2); for (int i = 2; i &lt;= n; i &lt;&lt;= 1) &#123; NTT(A, res, tmp, i, i); for (int j = 0; j &lt; i; ++j) tmp[j] = add(0, P - tmp[j]); inc(tmp[0], 2); NTT(res, tmp, res, i, i); &#125; for (int i = 0; i &lt; len; ++i) B[i] = res[i];&#125;int n, F[N];int main()&#123; n = read(); int fac = 1; for (int i = 0; i &lt;= n; ++i) &#123; F[i] = fac; fac = mul(fac, i + 1); &#125; Inverse(F, F, n + 1); for (int i = 0; i &lt;= n; ++i) F[i] = add(0, P - F[i]); inc(F[0], 1); for (int i = 0; i &lt;= n; ++i) F[i] = add(0, P - mul(i, F[i])); inc(F[0], 1); Inverse(F, F, n + 1); write(F[n], '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 试题乱做]]></title>
    <url>%2F2020%2F06%2F16%2FCF-%E8%AF%95%E9%A2%98%E4%B9%B1%E5%81%9A%2F</url>
    <content type="text"><![CDATA[记录最近乱做的一些 CF 题目. 1361B Johnny and Grandmaster 给定 $n,p$ ,以及 $n$ 个数,第 $i$ 个数是 $p^{k_i}$ ,你需要将它们划分入两个集合,使得两个集合内的数总和之差最小.$1\le n,p\le 10^6, 0\le k_i\le 10^6$ ,答案对 $10^9+7​$ 取模. 可以看成是对每个数确定贡献是 $p^{k_i}​$ 还是 $-p^{k_i}​$ ,最小化总贡献的绝对值.将所有数按照 $k_i​$ 从大到小排序,依次考虑,维护一个当前贡献 $s​$ ,若 $s&gt;0​$ ,则减掉当前数,否则加上当前数.简单的想法是用 $p​$ 进制高精度去模拟这个过程,但 $n,k​$ 都很大,这样实现会超时.注意到当 $v=\frac{s}{p^{k_i}}&gt;n​$ 时,后面考虑的数一定都是被减掉的,于是只用维护这个 $v​$ 的值即可.需要特判 $p=1​$ 的情况.时间复杂度 $O(n\log n+n\log k)​$ .code 1361C Johnny and Megan’s Necklace 有 $2n$ 个点,其中 $2i-1$ 与 $2i$ 已经有边,你需要再连出一些边让这个图成为一个环.每个点有权值 $a_i$ ,连接 $i$ 与 $j$ 的收益是 $\log_2({\rm lowbit}(a_i\operatorname {xor} a_j))$ ,特别地,若 $a_i=a_j$ ,则收益为 $20$ .一个方案的总收益是所有你连接的边中收益的最小值.需要求出最大的总收益,并给出一个合法的连边方案.$1\le n\le 5\times 10^5,0\le a_i&lt;2^{20}$ . 首先可以二分答案 $k$ ,那么就只有后 $k$ 位相同的点之间可以连边,要连出一个大环.将原有的每条边,以及 $2^k$ 种权值看作新的点,原有的每个点看作新的边,连接它后 $k$ 位的权值以及原来与它相邻的边.于是在转化后的图上找出一条欧拉回路,就等价于在原图中连出了一个大环.时间复杂度 $O(\log \log a\cdot n+a)$ .code 508D Tanya and Password 一个长度为 $n+2$ 的字符串有 $n$ 个长度为 $3$ 的子串,现在给你 $n$ 个长度为 $3$ 的串,问能否还原出一个合法原串.若能还原出原串,还需要输出任意一个合法的方案. $1\le n\le 2\times 10^5​$ . 若两个节点满足 “某个结构相同” 时有边,要找哈密尔顿路径,通常可以将节点当做连接结构之间的边,找欧拉路径.其实和上面那道题很像.若一个串的前两位和另个串的后两位相同,则可以接在它的后面.将每种长度为 $2$ 的串当作点,每个给出的串从它前两位的点向后两位的点连边,求此有向图的欧拉路径即可.时间复杂度 $O(n)$ . code 342E Xenia and Tree 给定一棵 $n$ 个点的树,每个点是红色或者蓝色,初始时只有 $1$ 为红色.有 $m$ 次操作,可能是修改或询问.修改:将蓝点 $x$ 变成红点.询问:询问 $x$ 到所有红点中最小的距离.$n,m\le 10^5$ . 显然直接写个动态点分治上去就完了,不过这题只有加点操作,而没有删点操作,所以还可以定期重构来做.对于每 $\sqrt m$ 个操作一起处理,先 bfs 预处理出每个点的答案,加入红点时将它记录下来,询问时考虑记录的红点贡献.预处理 ST 表实现 $O(1)$ 查询 LCA ,时间复杂度 $O(n\log n+(n+m)\sqrt m)$ .code 512D Fox And Travelling 给定一个 $n$ 个点, $m$ 条边的无重边自环的无向图,每次可以删掉一个度数 $\le 1$ 的点以及它连出的所有边.对于每个 $k\in [0,n]$ ,需要求出有序地删掉 $k$ 个点的方案数.$n\le 100$ ,答案对 $10^9+9$ 取模. 首先可以剥叶子预处理出哪些点可能被删掉,哪些点不可能被删掉.若仅保留可能被删掉的点,则图变成了一个森林,对于每棵树考虑其方案数,最后卷在一起得到答案.对于一棵树,若某个点与不可能被删掉的点有边,则它在这棵树中一定是最后被删掉的,以它为根做一个树形 dp.设 $dp(i,j)$ 表示在子树 $i$ 中有序删掉 $j$ 个点的方案数,转移时就是将两个子树的 dp 值卷起来.若一棵树中不存在这样的点,就以每个点为根做一次 dp, 此时若 $i$ 个点删了 $j$ 个点,会被算 $i-j$ 次,需要除掉.时间复杂度 $O(n^3)​$ .code 449D Jzzhu and Numbers 给出一个大小为 $n$ 的可重集合,需要从中选出一个非空子集,使得子集中的数按位与的结果为 $0$ ,求方案数.$1\le n\le 10^6$ ,元素大小 $0\le a_i\le 10^6$ ,答案对 $10^9+7$ 取模. 考虑容斥,枚举某些位,钦定这些位置按位与起来是 $1$ ,这等价于子集中每个数都是某个数 $S$ 的超集.高维前缀和预处理有几个数是 $S$ 的超集即可,时间复杂度 $O(n+a\log a)​$ .code 55D Beautiful Numbers 给定 $l,r​$ ,问区间 $[l,r]​$ 内有多少个数满足它能被自己的每一个非零数位整除, $1\le l\le r\le 9\times 10^{18}​$ . 考虑数位 dp, 需要记录每种数位是否出现过,若再把模每种数位的余数都记下来,状态数就太大了.优化一下, 只需要将模 $7,8,9$ 的余数分别记录下来即可, $5$ 可以在最后一位判,其余可以用模 $8,9$ 的余数算出来.时间复杂度大概是 $O(\log r\cdot 2^8\times 7\times 8\times 9)$ ,可以进一步优化,记录出现过的数位 LCM 即可,种类到不了 $2^8$ .code 449C Jzzhu and Apples 给定 $n$ ,从 $1$ 到 $n$ 的整数中选出尽可能多的数对,使得每对的 $\gcd &gt;1$ ,需要输出一种最优方案. 考虑所有满足 $p&gt;2$ 且 $2p\le n$ 的素数 $p$ ,将它能筛到的所有数拿来匹配,若有奇数个,则将 $2p$ 留下.最后将所有 $2$ 的幂次的数以及留下的 $2p$ 两两匹配即可,时间复杂度 $O(n\log n)$ ,魔改线性筛应该可以 $O(n)$ .code 1368E Ski Accident 给定一张 $n$ 个点, $m$ 条边的有向图,每个点只会向编号比它大的点连边,且每个点的出度不超过 $2$ .你需要删掉某些点以及和它们相关的所有边,使得剩下的图中不存在长度为 $2$ 的路径.删掉的点的数目不能超过 $\frac 4 7n​$ ,需要构造一个合法的方案. 按照编号顺序从小到大依次考虑每个点,若某个点此时必须被删掉,则删掉它,否则考虑下一个点.即,对于每个点 $x$ 维护有几个点到 $x$ 距离为 $2$ ,考虑到 $x$ 时,若集合非空,则删掉 $x$ ,然后暴力更新信息.图是一个 $3$ 层的满二叉树时显然操作次数最劣,此时 $7$ 个点中需要删掉 $4$ 个,于是删点次数不会超过 $\frac 4 7 n$ .时间复杂度 $O(n + m)​$.code 10D LCIS 给定两个长度分别为 $n,m$ 的整数数列 $a,b$ ,求它们的最长公共上升子序列,需要输出一种合法方案, $n\le 500$ . 设 $f(i,j)$ 表示只考虑 $a$ 的前 $i$ 个数,以 $b_j$ 结尾的 LCIS 长度.考虑转移,若 $a_i\neq b_j$ ,则只能继承 $f(i-1,j)$ 的信息.否则,转移有 $f(i,j)=\max_{1\le k&lt;j,b_k&lt;a_i} \lbrace f(i-1,k) +1\rbrace$ .直接转移是 $O(n^3)$ 的.注意到对于同个 $i$ ,随着 $j$ 增大,合法的 $k$ 形成的集合只会不断加入数,不会删除数,直接维护出最优的 $k$ 即可.由于要输出方案,所以还需要记录一下每个状态是从哪个位置转移来的.时间复杂度 $O(n^2)​$ .code 986C AND Graph 给定一张有 $m$ 个点的无向图和参数 $n$ ,每个点有权值 $0\le a_i&lt;2^n$ ,两个点有边当且仅当两者权值按位与为 $0$ .求这张图的连通块数目, $0\le n&lt;22, 1\le m\le 2^n$ . 暴力将所有边连出来,边数是 $O(3^n)$ 的,比较爆炸,考虑优化建图.为了方便,下面直接用权值代替它的编号.若 $x,y$ 有边,说明 $x$ 的补集应当是 $y$ 的超集,我们新建 $2^n$ 个辅助节点,记为 $0’,1’,2’\dots,(2^n-1)’$ .那么从 $x$ 向 $x’$ 连边, $(\sim x)’$ 向 $x$ 连边,若 $a$ 是 $b$ 的超集,则 $b’$ 向 $a’$ 连边.这样从 $x$ 出发 dfs 就能走到所有在原图中与它相连的点了.每个 $b’$ 需要向所有超集连边,边数还是 $O(3^n)$ 的,优化一下,只向恰好比它大一个的超集连边,其他边可以传递得到.时间复杂度 $O(n\cdot 2^n)$ ,若把边存下来,空间复杂度 $O(n\cdot 2^n)$ ,开不下,在 dfs 时直接枚举相连的点,就不用存边了.code 1325E Ehab’s REAL Number Theory Problem 给定一个长度为 $n$ 的整数序列 $a$ ,满足每个元素的因子个数不超过 $7$ .你需要选出一个最短的非空子序列,使得子序列内元素乘积是平方数,输出这个长度,或判断无解.$1\le n\le 10^5,1\le a_i\le 10^6$ . 由 $\sigma_0(a_i)\le 7$ 可以推出 $\omega(a_i)\le 2$ .将 $a_i$ 质因数分解,次数是偶数的质因子没有贡献,可以直接忽略.若还剩两个质因子 $x,y$ ,则在 $x,y$ 之间连边,若还剩 $1$ 个质因子 $x$ ,则在 $1,x$ 之间连边,若没有剩下,说明答案为 $1$ .那么就得到了一张由 $1$ 和所有质数为结点的无向图,这张图上每一个环都对应了一个合法方案,只需要找出最小环.枚举 $s$ 作为环的起点进行 bfs, 若某条边 $(x,y)$ 满足 $x,y$ 都被访问过,就有个长度为 $dis(x)+dis(y)+1$ 的环.再优化一下,不难发现一个环一定包含了 $\le \sqrt {\max a_i}$ 的数,只枚举它们作为起点 bfs 即可.时间复杂度 $O(n\sqrt {\max a_i})$ .code 1043F Make It One 给定 $n$ 个正整数 $a_1,a_2,\dots,a_n$ ,需要选出一个非空子集,使得集合内的数 $\gcd$ 为 $1$ ,输出最少选多少个数.$1\le n,a_i\le 3\times 10^5$ . 记 $t(x)$ 表示有几个数是 $x$ 的倍数,记 $dp(i,j)$ 表示选 $i$ 个数使得它们的 $\gcd$ 为 $j$ 的方案数,转移有 $$dp(i,j)=\binom{t(j)}{i}-\sum_{k\ge 2} dp(i,j\cdot k)$$ 对于每个 $i$ ,计算出所有 $dp(i,j)$ 需要 $O(n\log n)$ 的时间,但特判掉无解的情况后,答案显然不会太大.考虑集合中开始只有一个数,加入新的数时,一定要让 $\gcd$ 的某个质因子次数减到 $0$ 才有用,否则可以不加入它.于是可以得出当有解时,答案不会超过 $\omega(a)+1$ ,只用在这个范围内枚举 $i$ 即可,时间复杂度 $O(\omega(a)\cdot n\log n)$ .code 367E Sereja and Intervals 给定 $n,m,x$ ,要构造出一个长度为 $n$ 的序列,每个元素是一个 $1\le l\le r\le m$ 的区间,需要满足没有区间完全包含另一个区间,且至少有一个区间的左端点为 $x$ ,求合法方案数,答案对 $10^9+7$ 取模, $1\le n\times m\le 10^5$ . 区间之间不能相互包含,则肯定没有两个区间是完全相同的,可以先不考虑顺序,求出方案数后乘上 $n!$ .依次考虑 $1$ 到 $m$ 的每个数,每个数显然最多作为一次左端点,最多作为一次右端点,设 $dp(i,j,k)$ 表示考虑了前 $i$ 个数,还有 $j$ 个左端点未被匹配,已经匹配了 $k$ 个区间,转移时枚举这个数是否作为左右端点,是否和之前的端点匹配,因为区间不能有包含关系,所以若与之前剩下的端点匹配,方案是唯一的.当考虑到 $x$ 时,强制让它作为左端点即可.时间复杂度 $O(n^2m)$ ,当 $n&gt;m$ 时显然无解,所以复杂度为 $O(nm\sqrt {nm})​$ ,可以通过.code 710F String Set Queries 维护一个字符串集合 $S$ ,支持加入一个未加入过的串,删除一个已加入过的串,每次查询给出一个串 $s$ ,问集合 $S$ 中的串在串 $s$ 中出现了多少次,一个串在多个位置出现则计算多次,强制在线.操作总数 $m\le 3\times 10^5$ ,修改,询问的字符串总长不超过 $3\times 10^5$ . 贡献是有可减性的,我们分别算加入的字符串贡献与删除的字符串贡献,将两者相减即可,只需要支持插入和询问.如果可以离线,可以用 cdq 分治.每次考虑左边插入对右边询问的贡献,对左边插入的串建出 AC 自动机,将右边的串放上去匹配.现在强制在线,可以考虑二进制分组,维护 $O(\log m)$ 个 AC 自动机,插入串时新建一个自动机,并不断将最后的两个自动机合并,直到最后的两个自动机大小不同,询问时就在所有的 AC 自动机上都问一遍就可以了.code 364D Ghd 给出一个大小为 $n$ 的可重集合 $S$ ,定义它的某个非空子集 $T$ 的权值为 $T$ 内所有元素的 $\gcd$ ,需要求出大小不小于 $n$ 的一半的所有子集的最大权值. $1\le n\le 10^6$ ,元素大小 $1\le a_i\le 10^{12}​$ . 考虑每次随机一个数 $a_x$ ,计算包含它的,大小为 $\frac n 2$ 的集合最大的 $\gcd$ 是多少,那么做一次能得到正确答案的概率至少为 $\frac 1 2$ ,随机 $k$ 次,错误率就只有 $2^{-k}$ 了.把所有 $a_i$ 与 $x$ 取 $\gcd$ 得到 $b_i=\gcd(a_i,x)$ ,那么枚举 $d$ 作为答案,如果 $d$ 的所有约数在 $b_i$ 中出现次数达到了 $\frac n 2$ ,就说明 $d$ 合法.实现时可以将所有 $b_i$ 存在一个 map 中,枚举 map 中的元素 $d,d’$ ,若 $d|d’$ ,就将 $d’$ 出现次数统计上.时间复杂度 $O(k\cdot \sigma_0^2(a))​$ ,可以适当进行剪枝.code 1270G Subset with Zero Sum 给出一个长度为 $n$ 的序列 $a$ ,每个元素都满足 $i-n\le a_i\le i-1$ ,需要选出一个非空子序列,满足子序列中所有元素之和为 $0$ ,输出任意一种方案即可, $1\le n\le 10^6$ . 移项得到 $1\le i-a_i\le n$ ,每个点 $i$ 向 $i-a_i$ 连一条边,在图中随便找一个环,环上的点权值之和显然为 $0$ .每个点都有出度,不可能是 DAG ,于是一定能找到一个环.code 739E Gosha is hunting 有 $n$ 个小精灵,你有 $a$ 个普通球和 $b$ 个超级球,用普通球抓住第 $i$ 只小精灵的概率为 $A_i$，用超级球抓住第 $i$ 只小精灵的概率为 $B_i$ .需要一开始就决定向哪些精灵投掷哪些精灵球,同种的球只能对一个精灵用一次,可以对一只精灵投掷两种球,如果两次中有一次抓到则视为抓到.询问当采用最优的方案时,最终抓到小精灵的期望个数是多少.要求相对误差或绝对误差不超过 $10^{-4}$, $n\le 2000$ . 朴素的 dp 是设 $dp(i,j,k)$ 表示考虑了前 $i$ 个精灵,用了 $j$ 个普通球, $k$ 个超级球能获得的最大收益,是 $O(n^3)$ 的.不难发现这个 dp 关于 $j,k$ 都是凸的,因为多用一个同种的球增加的收益肯定是递减的.可以 WQS 二分,若只对其中一维进行二分,时间复杂度 $O(n^2\log \epsilon)$ ,对两维都二分可以做到 $O(n\log^2 \epsilon)​$ .code 526F Pudding Monsters 给定 $n$ 以及一个 $n\times n$ 的矩阵,每行每列恰好有一个位置是 $1$ ,其余地方是 $0$ ,只读入 $n$ 个 $1$ 的位置.要从这个矩阵中找出一个 $k\times k$ 的子矩阵 ( $k$ 自选) ,满足子矩阵中 $1$ 的个数恰好是 $k$ ,求合法的方案数.$n\le 3\times 10^5$ . 记第 $i$ 行的 $1$ 出现在第 $p_i$ 列,不难发现所有 $p_i$ 形成了一个排列,且方案数就是值域连续的区间的数目.考虑枚举合法区间的右端点 $r$ ,合法的左端点需要满足 $\max[l,r]-\min[l,r]=r-l$ .其中 $\max[l,r],\min[l,r]$ 分别表示区间 $[l,r]$ 内 $p_i$ 的最小值和最大值.用线段树维护每个 $l$ 的 $\max[l,r]-\min[l,r]+l$ ,当右端点移动时,通过单调栈可以求出 $\max,\min$ 被修改的若干段区间,给这些区间各自整体加上改变量.由于 $p$ 是排列,所以有 $\max[l,r]-\min[l,r]\ge r-l$ ,即 $\max[l,r]-\min[l,r]+l\ge r$ ,只需要在线段树上维护区间最小值以及最小值数目,就可以求得满足 $\max[l,r]-\min[l,r]+l=r$ 的 $l$ 的数目.时间复杂度 $O(n\log n)​$ .code 338D GCD Table 给出 $n,m$ ,表示有一个 $n\times m$ 的矩阵,其中第 $i$ 行第 $j$ 列的元素是 $\gcd(i,j)$ ,读入一个长度为 $k$ 的序列 $a$ ,判断这个序列是否在这个矩阵中作为某一行的一个连续段出现过, $1\le n,m\le 10^{12},1\le k\le 10^4$ . 经典题,假定序列 $a$ 是在第 $x$ 行第 $y$ 列开始出现的,那么 $x$ 必须是所有 $a_i$ 的倍数,即, $x$ 是所有 $a_i$ 的 $\rm lcm$ 的倍数.记 $M={\rm lcm}(a_1,a_2,a_3,\dots,a_n),x=k\times M$ ,那么 $a_i=\gcd(k\times M, y+i-1)$ ,要求 $\frac {(y+i-1)}{a_i}\perp \frac M {a_i}\cdot k$ .那么显然直接取 $k=1$ 是最优的,这样更有可能找到合法的 $y$ .注意到 $a_i=\gcd(k\times M, y+i-1)$ ,说明 $a_i|y+i-1$ ,化成同余方程可以得到 $y\equiv 1-i\pmod {a_i}$ .用 excrt 算法合并这些同余方程,得到一个 $y$ 的最小正整数解 $y_0$ ,那么 $y$ 一定是 $p\cdot M+y_0$ 的形式,由于对于每个 $i$ 都要满足 $\frac {(y+i-1)}{a_i}\perp \frac M {a_i}\cdot k$ ,直接让 $y=y_0$ 就是最优的,验证一下是否都成立即可,时间复杂度 $O(k\log n)$ .code 839E Mother of Dragons 给出一张 $n$ 个点的无重边无自环无向图和一个正整数 $k$ ,你需要为每个点分配一个非负实数权值 $a_i$ ,满足 $k=\sum a_i$ .图中每条边 $(u,v)$ 会产生一个收益 $a_u\cdot a_v$ ,求总收益的最大值. $1\le n\le 40,1\le k\le 1000$ ,要求相对误差或绝对误差在 $10^{-6}$ 以内. 首先通过大胆猜想等办法可以搞出一个高论:找出一个最大团,把权值平均分在这些点上是最优的.证明大概可以考虑改变分配方式后一定不会变优,严格一点的证明过程可以参考 官方题解 .于是只用求最大团的大小,可以用 $O(3^{\frac n 3})​$ 的 BronKerbosch 算法,也可以 meet in the middle $O(n\cdot 2^{\frac n 2})​$ 来做.还有一个随机做法,每次随机一个排列 $p​$ ,对每个点依次判断能否加入当前团中,若能,就贪心将其加入,多做几次.code 960G Bandit Blues 给定 $n,A,B$ ,求有多少个长度为 $n$ 的排列,满足其前缀最大值恰有 $A$ 个,后缀最大值恰有 $B$ 个.$1\le n\le 10^5,0\le A,B\le n$ ,答案对 $998244353$ 取模. 网上大多都是用第一类斯特林数求解的题解,这里分享另外一种思路比较简洁的做法.考虑将 $[1,n]$ 内的数从大到小插入到当前排列中,第一个数比较特殊,它同时是前后缀的 $\max$ .而对于后面插入的数,若之前排列中已有 $i$ 个数,那么让它成为前缀 $\max$ 和后缀 $\max$ 的方案都是 $1$ 种,其余 $i-1$ 种方案既不是前缀 $\max$ ,也不是后缀 $\max$ .于是将第一个数的贡献单独计算,不难得出答案为 $[x^{A-1}y^{B-1}]\prod_{i=1}^{n-1}(x+y+i-1)$ .可以把 $\prod_{i=1}^{n-1}(x+y+i-1)$ 看作一个关于 $x+y$ 的多项式,求出其各项系数后用二项式定理简单计算答案即可.用分治 NTT ,时间复杂度 $O(n\log^2 n)$ ,若用 倍增 NTT ,可以做到与第一类斯特林数做法相同的复杂度 $O(n\log n)$ . 其实第一类斯特林数做法的式子展开后和这个东西是一样的,只不过感觉这个做法推起来比较直接. code 1285F Classical? 给出一个长度为 $n$ 的正整数数列 $a$ ,求出 $\max_{i\neq j} {\rm lcm}(a_i,a_j)$ , $2\le n\le 10^5,1\le a_i\le 10^5$ . 将每个 $a_i$ 的因子 $d$ 也都加入数列 $a$ 中,于是问题变为在数列 $a$ 中求两个互质的数的最大乘积.将所有 $a$ 从大到小排序,依次枚举 $x=a_i$ ,若存在 $y&gt;x,y\perp x$ ,那么区间 $(x,y)$ 内的数与 $x$ 就没有贡献了.维护一个栈来存储所有可能与 $x$ 产生贡献的 $y$ ,那么枚举到 $x$ 时,就不断弹栈并计算贡献,直到栈内没有与 $x$ 互质的数.对每个 $x$ 维护栈内有多少个数与 $x$ 互质,可以维护 $f(d)=\sum_{d|y} cnt(y)$ ,则与 $x$ 互质的数个数为 $\sum_{d|x}\mu(d)f(d)$ .实现时可以直接用计数排序,时间复杂度 $O(n+a\log a)$ .code 1295F Good Contest 有一个长度为 $n​$ 的序列 $a​$ ,其中 $a_i​$ 是区间 $[l_i,r_i]​$ 内等概率随机选取的整数,问序列 $a​$ 单调不升的概率.答案对 $998244353​$ 取模, $1\le n\le 50,0\le l_i\le r_i&lt;998244353​$ . 直接划艇即可.先对所有端点离散化并排序,设 $dp(i,j)​$ 表示考虑了前 $i​$ 个数,第 $i​$ 个数在最后 $ j​$ 个区间中的方案数.转移时考虑枚举 $k​$ ,表示第 $i-k+1​$ 到第 $i​$ 个数都在第 $j​$ 个区间中,前面的数都不在第 $j​$ 个区间中.$$dp(i,j)=dp(i,j-1)+\sum_{k=1}^{i} dp(i-k,j-1)\cdot\binom{len_j+k-1}{k}$$其中 $len_j​$ 表示从后往前第 $j​$ 个区间的长度,时间复杂度 $O(n^3)​$ .code 961G Partitions 给出一个长度为 $n$ 的序列 $w$ 以及一个正整数 $k$ ,需要将 $1$ 到 $n$ 这 $n$ 个整数划分成恰好 $k$ 个集合,定义一个集合 $S$ 的权值为 $|S|\cdot \sum_{i\in S}w_i$ ,一个划分的权值为分出的所有集合权值之和,求所有合法划分的权值总和.$1\le k\le n\le 2\times 10^5$ ,答案对 $10^9+7$ 取模. 一个划分的权值可以这样考虑,若 $u,v$ 被划分到了同一个集合中,则对划分的权值产生 $w_u+w_v$ 的贡献, $u=v$ 也算. 那么计算所有划分的权值之和时,直接考虑每对 $u,v$ 的贡献即可. $$ans=(\sum w_i)\cdot{n\brace k}+\sum_{u\neq v} (w_u+w_v)\cdot {n-1\brace k}\\ans=(\sum w_i)\cdot ({n\brace k}+(n-1){n-1\brace k})$$ 这里只用算两个第二类斯特林数,直接展开暴力算即可,时间复杂度 $O(n+k\log n)$ .code 722E Research Rover 有一个 $n\times m$ 的网格图,初始在左上角 $(1,1)$ ,随机沿着一条最短路径走到右下角 $(n,m)$ ,初始有个权值 $s$ ,图上有 $k$ 个关键点,每经过一个关键点,当前的权值 $x$ 就会变成 $\lceil \frac x 2\rceil$ ,询问到终点时权值的期望.$1\le n,m,s\le 10^5,0\le k\le 2000$ ,答案对 $10^9+7$ 取模. 将 $(1,1), (n,m)$ 也视作关键点,最后对答案简单处理即可.设 $dp(i,j)$ 表示走到了第 $i$ 个关键点,经过了至少 $j$ 个关键点的方案数.显然第二维只用开到 $\log s$ .转移时考虑枚举经过了 $j-1$ 个关键点时走到了 $k$ ,有 $dp(i,j)=\sum (dp(k,j-1)-dp(k,j))\cdot |{\rm Path}(k\to i)|$ .其中 $|{\rm Path}(k\to i)|$ 表示从第 $k$ 个关键点到第 $i$ 个关键点的方案数,时间复杂度 $O(n+m+k^2\log s)​$ .code 995F Cowmpany Cowmpensation 给出一个 $n$ 个点的有根树,为每个点分配一个 $[1,D]$ 内的正整数作为权值,需要满足每个点的权值不大于其父亲的权值,求合法的方案数, $1\le n\le 3000,1\le D\le 10^9$ ,答案对 $10^9+7$ 取模. 答案是关于 $D$ 的 $n$ 次多项式,可以考虑归纳证明.当 $n=1$ 时显然成立,否则我们记各个子树大小分别为 $a_1,a_2\dots a_k$ , 枚举根的权值为 $i$ ,得到方案数为$$\sum_{i=1}^D\prod_{j=1}^k f(a_j,i)$$根据我们的归纳假设,可知 $f(a,x)$ 是一个关于 $x$ 的 $a$ 次多项式,因为 $\sum a_j=n-1$ ,那么每个 $\prod_{j=1}^k f(a_j,i)$ 都是关于 $i$ 的 $n-1$ 次多项式,于是方案数可以写成 $\sum_{k=0}^{n-1}c_k \sum_{i=1}^D i^k$ 的形式,这显然是关于 $D$ 的 $n$ 次多项式.于是只需要暴力 dp 出 $D=1,2,\dots,n-1$ 时的答案,然后做拉格朗日插值即可,时间复杂度 $O(n^2)​$ .code 283E Cow Tennis Tournament 有一张 $n$ 个点的竞赛图,初始时每条边都由编号较大的指向编号较小的,有 $k$ 次操作,每次操作给出 $[l,r]$ ,表示对于所有 $u,v\in[l,r],u\neq v$ ,翻转边 $(u,v)$ 的方向.问所有操作结束后图中三元环的数目. $3\le n\le 10^5,1\le k\le 10^5$ . 竞赛图的三元环个数是经典问题了,补集转化可知答案为 $\binom n 3-\sum_{i=1}^n \binom{outdeg_i}{2}$ ,其中 $outdeg_i$ 表示 $i$ 的出度.于是只需要求出最后每个点的出度,考虑将所有操作按照 $l$ 排序,从左往右依次计算每个位置 $i$ 的答案,先将 $l\le i$ 的翻转操作全部执行,将 $r=i-1$ 的翻转操作全部撤销,然后询问 $&lt;i$ 的位置有多少个数被翻转了偶数次, $&gt;i$ 的位置有多少个数翻转了奇数次,相加即为 $i$ 的出度,不难发现修改和询问可以用线段树支持,时间复杂度 $O(n\log n)​$ .code]]></content>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 3266 Equilateral Triangles]]></title>
    <url>%2F2020%2F06%2F14%2FLoj-3266-Equilateral-Triangles%2F</url>
    <content type="text"><![CDATA[曼哈顿距离与切比雪夫距离的转化. 将坐标系旋转 $\frac \pi 4$ ,每个点的坐标 $(x,y)$ 就变成了 $(x+y,x-y)$ . 此时原来的曼哈顿距离变成了切比雪夫距离 $\max(|x_1-x_2|,|y_1-y_2|)$ ,三个点形成正三角形需要满足$$\max(|x_1-x_2|,|y_1-y_2|)=\max(|x_1-x_3|,|y_1-y_3|)=\max(|x_2-x_3|,|y_2-y_3|)$$通过一定的观察可以发现,这三个点中存在两个点的 $x$ 相同,或存在两个点的 $y$ 相同. 证明:若 $x$ 均不相同,可以假定有 $x_1&gt;x_2&gt;x_3$ . 则 $x_1-x_3&gt;x_1-x_2,x_1-x_3&gt;x_2-x_3$ .可知 $|y_1-y_2|=|y_2-y_3|$ . 若 $y$ 也均不相同,则 $|y_1-y_3|&gt;|y_1-y_2|$ ,而 $|x_1-x_3|&gt;|x_1-x_2|$ ,对应 $\max$ 不可能相等. 先枚举两个 $x$ 相同的点 $(a,b),(a,c)$ ,满足 $b&lt;c$ ,考虑计算有多少个点能和它们形成正三角形. 此时 $3$ 个 $\max$ 的值都是 $c-b$ ,可以得出另外一个点只可能是在 $x$ 距离差上取得 $\max$ . 即,统计满足 $x=a\pm(c-b),b\le y\le c$ 的 $(x,y)$ 的数目即可. 再枚举两个 $y$ 相同的点 $(b,a),(c,a)$ ,满足 $b&lt;c$ ,同理计算贡献. 为了不与枚举 $x$ 时贡献重复,统计 $b&lt;x&lt;c,y=a\pm (c-b)$ 的 $(x,y)$ 的数目即可. 时间复杂度 $O(n^3)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(ll x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(ll x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int N = 600 + 10;int n, p[N][N], t[N][N], row[N][N], col[N][N];char buf[N];int main()&#123; n = read(); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%s", buf + 1); for (int j = 1; j &lt;= n; ++j) if (buf[j] == '*') t[i + j][i - j + n] = 1; &#125; n &lt;&lt;= 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; row[i][j] = row[i][j - 1] + t[i][j]; col[i][j] = col[i][j - 1] + t[j][i]; &#125; ll ans = 0; for (int a = 1; a &lt;= n; ++a) for (int b = 1; b &lt;= n; ++b) if (t[a][b]) for (int c = b + 1; c &lt;= n; ++c) if (t[a][c]) &#123; int d = a + (c - b); if (d &lt;= n) ans += row[d][c] - row[d][b - 1]; d = a - (c - b); if (d &gt;= 1) ans += row[d][c] - row[d][b - 1]; &#125; for (int a = 1; a &lt;= n; ++a) for (int b = 1; b &lt;= n; ++b) if (t[b][a]) for (int c = b + 1; c &lt;= n; ++c) if (t[c][a]) &#123; int d = a + (c - b); if (d &lt;= n) ans += col[d][c - 1] - col[d][b]; d = a - (c - b); if (d &gt;= 1) ans += col[d][c - 1] - col[d][b]; &#125; write(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 3265 Delegation]]></title>
    <url>%2F2020%2F06%2F13%2FLoj-3265-Delegation%2F</url>
    <content type="text"><![CDATA[[NOIP 2018] 赛道修建 再放送. 虽说是再放送,但是在处理细节上还是有一点区别的. 二分答案,考虑检查每条路径长度都 $\ge k$ 是否可行. 在点 $x$ 的时候,需要合并从每个儿子传上来的每条路径,并且传最多一条路径上去. 在保证其余路径能被合法合并的前提下,传上去的路径长度应当尽可能大,二分这个值,检查其余路径能否匹配即可. 注意在根节点处不能再传路径上去,即只能检查传上去的路径长度为 $0$ 是否合法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int N = 1e5 + 10;int n;vector&lt;int&gt; G[N], a[N];int t[N], b[N];int solve1(int x, int m, int k)&#123; for (int i = 1; i &lt;= m; ++i) t[i] = a[x][i]; if (m &amp; 1) t[++m] = 0; sort(t + 1, t + 1 + m); for (int i = 1; i &lt; m + 1 - i; ++i) if (t[i] + t[m + 1 - i] &lt; k) return -1; return 0;&#125;int solve2(int x, int m, int k)&#123; for (int i = 1; i &lt;= m; ++i) t[i] = a[x][i]; if (!(m &amp; 1)) t[++m] = 0; sort(t + 1, t + 1 + m); int L = 1, R = m, s = -1; while (L &lt;= R) &#123; int mid = (L + R) &gt;&gt; 1, f = 1; for (int i = 1; i &lt;= m; ++i) if (i &lt; mid) b[i] = t[i]; else if (i &gt; mid) b[i - 1] = t[i]; for (int i = 1; i &lt; m - i &amp;&amp; f; ++i) if (b[i] + b[m - i] &lt; k) f = 0; if (f) s = t[mid], L = mid + 1; else R = mid - 1; &#125; return s;&#125;int dfs(int x, int F, int k)&#123; int m = 0; a[x].clear(), a[x].push_back(0); for (int y : G[x]) if (y != F) &#123; ++m; int len = dfs(y, x, k); if (len == -1) return -1; a[x].push_back(len + 1); &#125; if (x != 1) &#123; int p = solve2(x, m, k); if (p != -1) return p; &#125; return solve1(x, m, k);&#125;int main()&#123; n = read(); for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(); G[u].push_back(v); G[v].push_back(u); &#125; int L = 1, R = n - 1, ans = 0; while (L &lt;= R) &#123; int mid = (L + R) &gt;&gt; 1; if (dfs(1, 0, mid) != -1) ans = mid, L = mid + 1; else R = mid - 1; &#125; write(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JOI 2020 Final]]></title>
    <url>%2F2020%2F06%2F12%2FJOI-2020-Final%2F</url>
    <content type="text"><![CDATA[JOI 2020 Final 选做. 長いだけのネクタイ / Just Long Neckties / 只不过是长的领带先将 $A,B$ 分别从小到大排序. 在去掉一个 $A_i$ 之后,显然最优的方案是将剩下的每个位置依次匹配. 不难发现此时 $[1,i-1]$ 内的 $B_x$ 匹配的都是 $A_x$ ,而 $[i,n]$ 内的 $B_x$ 匹配的都是 $A_{x+1}$ . 分别预处理前后缀奇怪度的 $\max$ 即可. code JJOOII 2在原串中选出一个合法的子序列做为最后保留的部分,需要最小化这个子序列首尾距离. 预处理每个字符向后能找到的第一个相同字符,以及连续选 $k$ 次相同字符后在什么位置,枚举子序列起点即可. code スタンプラリー 3 / Collecting Stamps 3 / 集邮比赛在任意时刻,已经到达过的点一定是在环上包含起点的某个区间. 设 $dp(i,j,v,0/1)$ 表示已经到了前 $i$ 个点和后 $j$ 个点,收益为 $v$ ,停留在第 $i$ 个点 / 第 $n-j+1$ 个点的最早时间. code オリンピックバス / Olympic Bus / 奥运公交建出 $1$ 为源, $1$ 为汇, $n$ 为源, $n$ 为汇的最短路树. 翻转一条边的方向时,若它不在最短路树上,则只可能经过它反向后的边,或走原最短路. 若它在最短路树上,就暴力重新计算 $1\to n,n\to 1$ 的最短路. 最短路树上的边数是 $O(n)$ 的,由于点数小,边数大,每次重新计算最短路时 $O(n^2+m)$ 暴力 Dijkstra. 时间复杂度 $O(n^3+nm)$ . code 火事 / Fire / 火灾二维数点好题. 若一个位置的权值由 $a$ 变为 $b$ ,本质不同的 $a\to b$ 最多只会有 $n$ 种,因为每个位置只会被左边第一个更大的覆盖掉. 为了方便,我们统一规定若相邻两个位置权值相同,仍然认为前面的数较大,即可以完成覆盖. 单调栈求出 $L_i,R_i$ 分别表示 $i$ 左边,右边第一个比 $i$ 大的位置,那么所有的 $a\to b$ 本质都是 $S_{i}\to S_{L_i}$ 的形式. 考虑 $S_i\to S_{L_i}$ 发生的时间,不难发现对于 $j\in[i,R_i)$ 的每个 $j$ ,这个过程会在 $j-L_i$ 时刻发生. 这会使得 $p\in[i,R_i),t\ge p-L_i$ 的 $S_p(t)$ 的值加上 $S_{L_i}-S_i$ . 把 $p,t$ 看作平面上的两个维度,则每个 $i$ 的贡献是给一个直角梯形内所有点的权值加上某个数. 假定 $p$ 是沿着横的方向, $t$ 是沿着纵的方向,则询问时会询问某一行的区间和(前缀和). 可以先把直角梯形容斥成两个直角三角形. 考虑 $\sum b_i\min(a_i,c)$ 这个式子,它表示了有 $i$ 次操作,每次给 $[1,a_i]$ 加上 $b_i$ ,最后询问 $c$ 的前缀和的答案. 不难发现直角三角形对某一行前缀和的贡献也可以表示成 $\sum b_i\min (a_i,c)$ 的形式,用线段树维护前缀和即可. code]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>线段树</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 3246 Cave Paintings]]></title>
    <url>%2F2020%2F06%2F10%2FLoj-3246-Cave-Paintings%2F</url>
    <content type="text"><![CDATA[树形 dp. 一个直接的想法是,若 $x$ 的水能流到 $y$ ,就连边 $x\to y$ ,若某个点有水,则它的全部后继也都有水. 直接建图的边数很爆炸,且只是一张普通的有向图,没有足够优秀的性质支持我们统计方案数,考虑对建图进行优化. 首先可以把同一行中,能通过本行及下方的点四连通的点缩在一起,它们的方案一定是一样的. 缩点后,连边时可以只连相邻两行之间的边,不难发现原来的所有限制可以通过传递得到,方案数不变. 此时图变成了一个有向森林,做简单的树形 dp 即可统计方案数,可以不显式建树,用并查集维护即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int P = 1e9 + 7;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;const int N = 1e3 + 10, M = 1e6 + 10;int n, m, cnt = 0, id[N][N], dp[M], fa[M], ans = 1;int Find(int x)&#123; return x == fa[x] ? x : fa[x] = Find(fa[x]);&#125;char buf[N][N];int main()&#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) scanf("%s", buf[i] + 1); for (int i = n - 1; i &gt;= 2; --i) &#123; int lst = cnt; for (int j = 2; j &lt;= m - 1; ++j) if (buf[i][j] == '.') &#123; if (buf[i][j - 1] == '#') dp[++cnt] = 1, fa[cnt] = cnt; id[i][j] = cnt; if (buf[i + 1][j] == '.') &#123; int tmp = Find(id[i + 1][j]); if (tmp != cnt) &#123; dp[cnt] = mul(dp[cnt], dp[tmp]); fa[tmp] = cnt; &#125; &#125; &#125; for (int j = lst + 1; j &lt;= cnt; ++j) if (Find(j) == j) inc(dp[j], 1); &#125; for (int i = 1; i &lt;= cnt; ++i) if (Find(i) == i) ans = mul(ans, dp[i]); write(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF891E Lust]]></title>
    <url>%2F2020%2F06%2F09%2FCF891E-Lust%2F</url>
    <content type="text"><![CDATA[指数型生成函数. 给定 $n$ 个数 $a_1,a_2,\dots ,a_n$ 和一个初值为 $0$ 的计数器 $cnt$ ,执行以下操作 $k$ 次:在 $1,2,\dots,n$ 中等概率随机选择一个数 $i$ ,令 $cnt$ 加上 $\prod_{j\neq i}a_j$，然后把 $a_i$ 减 $1$ .求 $k$ 次操作后计数器 $cnt$ 的值的期望模 $10^9+7$ .$n\le 5\times 10^3, k\le 10^9$ . 考虑每次的贡献是 $\prod_{j\neq i} a_j$ ,然后将 $a_i$ 减掉 $1$ ,这可以看成是 $\prod_j a_j-\prod_j a_j’​$ ,即减掉前后所有数乘积之差. $k$ 次操作的贡献会抵消成 $\prod a_i-\prod (a_i-b_i)$, 其中 $b_i$ 表示 $a_i$ 这个数被在 $k$ 次操作中一共被减了多少次. 前面的乘积是确定的,只用算后面那个乘积的期望,可以写出这个问题的 EGF, $$F_a(x)=\sum \frac{a-i}{i!}x^i=e^x(a-x)\\G(x)=\prod_{i=1}^n F_{a_i}(x)=e^{nx}\prod_{i=1}^n(a_i-x)$$所求即为 $\frac{k!}{n^k}[x^k]G(x)$ , 可以暴力求出 $\prod_{i=1}^n(a_i-x)$ 每项系数,再考虑每一项与 $e^{nx}$ 卷积对答案贡献即可. 时间复杂度 $O(n^2)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int P = 1e9 + 7;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a, int b)&#123; int res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res;&#125;const int N = 5e3 + 10;int n, k, prod[N], ans = 1;int main()&#123; n = read(), k = read(); prod[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; int a = read(); ans = mul(ans, a); for (int j = i - 1; j &gt;= 0; --j) &#123; inc(prod[j + 1], P - prod[j]); prod[j] = mul(prod[j], a); &#125; &#125; int t = 1, inv = fpow(n, P - 2), pw = 1; for (int i = 0; i &lt;= n &amp;&amp; i &lt;= k; ++i) &#123; inc(ans, P - mul(mul(t, pw), prod[i])); t = mul(t, k - i); pw = mul(pw, inv); &#125; write(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF736D Permutations]]></title>
    <url>%2F2020%2F06%2F09%2FCF736D-Permutations%2F</url>
    <content type="text"><![CDATA[利用伴随矩阵求代数余子式. 给定一张两侧各 $n$ 个点,共 $m$ 条边的二分图,保证其完美匹配个数为奇数 对于二分图的每一条边,询问将这条边删去后,剩下的二分图的完美匹配数是否仍为奇数. $n\le 2000,m\le \min(n^2,5\times 10^5)$ . 定义一个矩阵 $A$ , 若左侧的 $i$ 与右侧的 $j$ 有边,则 $A_{i,j}=1$ ,否则 $A_{i,j}=0$ . 那么这张二分图完美匹配数为奇数等价于 $\sum_p \prod_{i=1}^n a_{i,p_i}\equiv 1\pmod 2$ . 而 $-1$ 在模 $2$ 意义下也是 $1$ ,所以给每一项乘个 $-1$ 的 $p$ 的逆序对数次方,值不变,这个东西就是 $\det(A)$ . 即,这张二分图完美匹配数为奇数等价于 $\det(A)\equiv 1\pmod 2​$ . 现在要算去掉某条边后完美匹配数的奇偶性,容斥一下,变成算必须包含它的完美匹配数的奇偶性. 不难发现必须包含它的数目就是 $A_{i,j}$ 的余子式,可以乘上 $(-1)^{i+j}$ 变成代数余子式. 于是我们需要对 $A$ 的每个元素求出代数余子式. 保证了 $\det(A)\equiv 1\pmod 2$ ,求出 $A​$ 的伴随矩阵 $$A^{*}=\det(A)A^{-1}$$ 即可求出 $A_{i,j}$ 的代数余子式 $(-1)^{i+j}M_{i,j}=A^{*}_{j,i}$ . 瓶颈在于求出 $A^{-1}$ ,而运算是在模 $2$ 意义下进行的,可以用 bitset 优化,时间复杂度 $O(\frac{n^3}{w})$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int N = 2e3 + 10, M = 5e5 + 10;bitset&lt;N&gt; A[N], B[N];int n, m, st[M], ed[M];void Guass()&#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = i; j &lt; n; ++j) if (A[j][i]) &#123; if (i != j) &#123; swap(A[i], A[j]); swap(B[i], B[j]); &#125; break; &#125; for (int j = 0; j &lt; n; ++j) if (i != j &amp;&amp; A[j][i]) A[j] ^= A[i], B[j] ^= B[i]; &#125;&#125;int main()&#123; n = read(), m = read(); for (int i = 0; i &lt; m; ++i) &#123; int u = read() - 1, v = read() - 1; A[u][v] = 1; st[i] = u, ed[i] = v; &#125; for (int i = 0; i &lt; n; ++i) B[i][i] = 1; Guass(); for (int i = 0; i &lt; m; ++i) if (B[ed[i]][st[i]]) puts("NO"); else puts("YES"); return 0;&#125;]]></content>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 3235 Przedszkole]]></title>
    <url>%2F2020%2F06%2F09%2FLoj-3235-Przedszkole%2F</url>
    <content type="text"><![CDATA[容斥原理 + 子集卷积 + 拉格朗日插值 + 色多项式. 对三种子任务分别设计算法. $m\le 24$考虑容斥,暴力枚举哪些边连接的两个点颜色是相同的,用并查集维护相同颜色的点形成的连通块. 若钦定了 $p​$ 条边连接的两个点颜色相同,形成了 $s​$ 个连通块,贡献应为 $(-1)^p k^s​$ . 由于每加一条边最多减少 $1​$ 个连通块,所以 $s​$ 与 $n​$ 的差不会超过 $m​$ ,维护出这个关于 $k​$ 的多项式各项系数即可. 时间复杂度 $O(2^mm+qm)$ ,但可以剪枝,若搜到某条边时,两个端点同色,选它和不选它的贡献会恰好抵消掉. $n\le 15$从 $m\le 24$ 的做法可以注意到答案是关于 $k$ 的 $n$ 次多项式. 于是只需要代 $k=1,2,3\dots,n+1$ 求出答案,就可以插值得出这个多项式. 考虑对于一个 $k$ 如何求出答案. 染色可以看成依次为每种颜色确定点集,每种颜色的点集必须是独立集,不同颜色的点集不能相交. 记集合幂级数 $F(x)=\sum_{S\in I} x^S$ ,其中 $I$ 表示所有独立集的集合,则 $F$ 子集卷积意义下 $k$ 次幂全集的系数即为所求. 时间复杂度 $O(2^nn^3+qn)$ ,为了实现方便也可以写成 $O(2^nn^3+qn^2)$ 之类的,插值不是复杂度瓶颈. 每个点度数为 $2$此时的图一定是由若干个互不相交的环构成的,考虑一个长度为 $l$ 的环,它的色多项式为 $(k-1)^l+(-1)^l(k-1)$ . 注意长度相同的环是没有本质差别的,可以合并起来一起算. 环长种类数是 $O(\sqrt n)$ 的,时间复杂度 $O(q\sqrt n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int P = 1e9 + 7;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a, int b)&#123; int res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res;&#125;int n, m, q;namespace sub1&#123; const int N = 1e5 + 10, M = 25; int fa[N], siz[N]; int st[M], ed[M], coef[M]; int Find(int x) &#123; return x == fa[x] ? x : Find(fa[x]); &#125; void dfs(int x, int p, int s) &#123; if (x == m) &#123; inc(coef[s], p); return; &#125; int u = Find(st[x]), v = Find(ed[x]); if (u != v) &#123; if (siz[u] &gt; siz[v]) swap(u, v); dfs(x + 1, p, s); fa[u] = v, siz[v] += siz[u]; dfs(x + 1, p == 1 ? P - 1 : 1, s + 1); fa[u] = u, siz[v] -= siz[u]; &#125; &#125; void solve() &#123; iota(fa + 1, fa + 1 + n, 1); fill(siz + 1, siz + 1 + n, 1); for (int i = 0; i &lt; m; ++i) st[i] = read(), ed[i] = read(); dfs(0, 1, 0); while (q--) &#123; int k = read(), ans = 0; int mi = max(1, n - m), pw = fpow(k, mi); for (int i = mi; i &lt;= n; ++i) &#123; inc(ans, mul(pw, coef[n - i])); pw = mul(pw, k); &#125; write(ans, '\n'); &#125; &#125;&#125;namespace sub2&#123; void FWT(int *a) &#123; for (int l = 2; l &lt;= (1 &lt;&lt; n); l &lt;&lt;= 1) &#123; int m = l &gt;&gt; 1; for (int *p = a; p != a + (1 &lt;&lt; n); p += l) for (int i = 0; i &lt; m; ++i) inc(p[i + m], p[i]); &#125; &#125; void IFWT(int *a) &#123; for (int l = 2; l &lt;= (1 &lt;&lt; n); l &lt;&lt;= 1) &#123; int m = l &gt;&gt; 1; for (int *p = a; p != a + (1 &lt;&lt; n); p += l) for (int i = 0; i &lt; m; ++i) inc(p[i + m], P - p[i]); &#125; &#125; const int N = 15; int nxt[N], popc[1 &lt;&lt; N], y[N + 1]; int a[N + 1][1 &lt;&lt; N], res[N + 1][1 &lt;&lt; N], tmp[N + 1][1 &lt;&lt; N]; void solve() &#123; for (int i = 0; i &lt; m; ++i) &#123; int u = read() - 1, v = read() - 1; nxt[u] |= 1 &lt;&lt; v, nxt[v] |= 1 &lt;&lt; u; &#125; for (int S = 0; S &lt; (1 &lt;&lt; n); ++S) &#123; popc[S] = popc[S &gt;&gt; 1] + (S &amp; 1); bool f = true; for (int i = 0; i &lt; n &amp;&amp; f; ++i) if ((S &gt;&gt; i &amp; 1) &amp;&amp; (S &amp; nxt[i])) f = false; if (f) a[popc[S]][S] = 1; &#125; res[0][0] = 1; for (int i = 0; i &lt;= n; ++i) FWT(a[i]), FWT(res[i]); int mx = (1 &lt;&lt; n) - 1; y[0] = 0; for (int k = 1; k &lt;= n; ++k) &#123; for (int i = 0; i &lt;= n; ++i) for (int S = 0; S &lt; (1 &lt;&lt; n); ++S) tmp[i][S] = 0; for (int i = 0; i &lt;= n; ++i) for (int S = 0; S &lt; (1 &lt;&lt; n); ++S) if (a[i][S]) for (int j = 0; i + j &lt;= n; ++j) inc(tmp[i + j][S], mul(a[i][S], res[j][S])); for (int i = 0; i &lt;= n; ++i) for (int S = 0; S &lt; (1 &lt;&lt; n); ++S) res[i][S] = tmp[i][S]; IFWT(tmp[popc[mx]]); y[k] = tmp[popc[mx]][mx]; &#125; while (q--) &#123; int k = read(); if (k &lt;= n) &#123; write(y[k], '\n'); continue; &#125; int ans = 0; for (int i = 0; i &lt;= n; ++i) &#123; int t = y[i]; for (int j = 0; j &lt;= n; ++j) if (i != j) &#123; t = mul(t, add(k, P - j)); t = mul(t, fpow(add(i, P - j), P - 2)); &#125; inc(ans, t); &#125; write(ans, '\n'); &#125; &#125;&#125;namespace sub3&#123; const int N = 1e5 + 10; int vis[N], tot = 0, siz[N]; int a[N], b[N], c = 0; vector&lt;int&gt; G[N]; int dfs(int x) &#123; vis[x] = 1; int s = 1; for (int y : G[x]) if (!vis[y]) s += dfs(y); return s; &#125; void solve() &#123; for (int i = 1; i &lt;= n; ++i) &#123; int u = read(), v = read(); G[u].push_back(v), G[v].push_back(u); &#125; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) siz[++tot] = dfs(i); sort(siz + 1, siz + 1 + tot); for (int l = 1, r = 1; l &lt;= tot; l = r) &#123; a[++c] = siz[l]; while (r &lt;= n &amp;&amp; siz[r] == siz[l]) ++b[c], ++r; &#125; while (q--) &#123; int k = read(), ans = 1; for (int i = 1; i &lt;= c; ++i) &#123; int t = fpow(k - 1, a[i]); if (a[i] &amp; 1) inc(t, P + 1 - k); else inc(t, k - 1); ans = mul(ans, fpow(t, b[i])); &#125; write(ans, '\n'); &#125; &#125;&#125;int main()&#123; n = read(), m = read(), q = read(); if (m &lt;= 24) sub1::solve(); else if (n &lt;= 15) sub2::solve(); else sub3::solve(); return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>容斥原理</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 3223 Trzy kule]]></title>
    <url>%2F2020%2F06%2F09%2FLoj-3223-Trzy-kule%2F</url>
    <content type="text"><![CDATA[Meet in the middle + 二维前缀和. 首先可以补集转化一下,用 $2^n$ 减掉三个不等式都不成立的方案数. 将每个 $r$ 变为 $n-1-r$ ,则我们需要求出与每个串相同的字符数都不超过对应的 $r$ 的方案数. 首先可以将这三个串都异或上第一个串,答案不变,于是一个位置只会有 $000,001,010,011$ 这四种情况. 记串 $S$ 中,这四种位置上 $0$ 的数目分别为 $c_0,c_1,c_2,c_3$ . 考虑 Meet in the middle, 先枚举 $c_0,c_1$ ,再枚举 $c_2,c_3$ ,询问能凑成合法四元组的 $c_0,c_1$ 的贡献总和. 看上去有 3 个维度的限制,但是 $c_0,c_1$ 对应的点中有 2 维是一样的,于是可以缩成 2 维,变成单点加,最后矩形求和. 由于每个维度的坐标都不会超过 $2n$ ,所以直接用二维前缀和处理即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int P = 1e9 + 7;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a, int b)&#123; int res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res;&#125;const int N = 2e4 + 10;int n, r[3], s[N][N], k[4], c[4], fac[N], invfac[N];char buf[3][N];int binom(int x, int y)&#123; return mul(fac[x], mul(invfac[y], invfac[x - y]));&#125;int main()&#123; n = read(); for (int i = 0; i &lt; 3; ++i) &#123; r[i] = n - 1 - read(); if (r[i] &lt; 0) return write(fpow(2, n), '\n'), 0; scanf("%s", buf[i] + 1); &#125; fac[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; fac[i] = mul(fac[i - 1], i); int x = buf[0][i] - '0', y = buf[1][i] - '0', z = buf[2][i] - '0'; y ^= x, z ^= x; k[y &lt;&lt; 1 | z]++; &#125; invfac[n] = fpow(fac[n], P - 2); for (int i = n - 1; i &gt;= 0; --i) invfac[i] = mul(invfac[i + 1], i + 1); int w = 0, h = 0; for (c[0] = 0; c[0] &lt;= k[0]; ++c[0]) &#123; int t = binom(k[0], c[0]); for (c[1] = 0; c[1] &lt;= k[1]; ++c[1]) &#123; int x = c[0] + c[1]; int y = k[1] + c[0] - c[1]; w = max(w, x), h = max(h, y); inc(s[x][y], mul(t, binom(k[1], c[1]))); &#125; &#125; for (int i = 0; i &lt;= w; ++i) for (int j = 0; j &lt;= h; ++j) &#123; if (i) inc(s[i][j], s[i - 1][j]); if (j) inc(s[i][j], s[i][j - 1]); if (i &amp;&amp; j) inc(s[i][j], P - s[i - 1][j - 1]); &#125; int ans = 0; for (c[2] = 0; c[2] &lt;= k[2]; ++c[2]) &#123; int t = binom(k[2], c[2]); for (c[3] = 0; c[3] &lt;= k[3]; ++c[3]) &#123; int x = min(r[0] - c[2] - c[3], r[1] + c[2] + c[3] - k[2] - k[3]); if (x &lt; 0) continue; x = min(x, w); int y = r[2] - c[2] + c[3] - k[3]; if (y &lt; 0) continue; y = min(y, h); inc(ans, mul(mul(t, binom(k[3], c[3])), s[x][y])); &#125; &#125; ans = add(fpow(2, n), P - ans); write(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>meet in the middle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 3215 Muzyka pop]]></title>
    <url>%2F2020%2F06%2F08%2FLoj-3215-Muzyka-pop%2F</url>
    <content type="text"><![CDATA[数位 dp. 假定有一棵插入了 $[0,m]$ 内所有数的 01 Trie 树,我们可以在上面做简单的 dp 求出答案. 设 $f(x,l,r)$ 表示把 $[l,r]$ 内所有的 $b$ 都分配入 $x$ 的子树中能产生的最大贡献. 转移时枚举将 $[l,k]$ 内的 $b$ 分入 $x$ 左子树中, $[k+1,r]$ 内的 $b$ 分入 $x$ 右子树中. $$f(x,l,r) =\max_{l-1\le k\le r} f(x_{lson},l,k) + f(x_{rson},k+1,r)+\sum_{i=k+1}^r a_i$$但这棵 Trie 树的节点数目是 $O(m)$ 的,直接这样 dp 不可行. 注意到除去从 $m$ 到根这条链上的点,其它点的每个子树都是完全二叉树. 于是 dp 只需要记录当前节点深度,以及是否在从 $m$ 到根的链上. 其实这东西就是个数位 dp, 深度表示考虑到了哪一位,是否在链上表示是否顶住了上界. 用 Trie 树的形式可能比较容易理解贡献的计算. 时间复杂度 $O(n^3\log m)​$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(ll x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(ll x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const ll inf = 1e18;const int K = 63, N = 200 + 10;ll m, s[N], dp[K][2][N][N];int n, k = 1;int main()&#123; n = read(), m = read(); while ((1LL &lt;&lt; k) &lt;= m) k++; for (int i = 1; i &lt;= n; ++i) s[i] = s[i - 1] + read(); for (int d = 0; d &lt; k; ++d) for (int lim = 0; lim &lt; 2; ++lim) &#123; int t = lim &amp;&amp; !(m &gt;&gt; d &amp; 1LL); for (int l = 1; l &lt;= n; ++l) for (int r = l; r &lt;= n; ++r) &#123; ll val = -inf; int mi = t ? r : l - 1; for (int k = mi; k &lt;= r; ++k) &#123; ll tmp = s[r] - s[k]; if (d) &#123; tmp += dp[d - 1][t][l][k]; tmp += dp[d - 1][lim][k + 1][r]; &#125; else if (k - l + 1 &gt; 1 || r - k &gt; 1) continue; val = max(val, tmp); &#125; dp[d][lim][l][r] = val; &#125; &#125; write(dp[k - 1][1][1][n], '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 3226 Greedy Pie Eaters]]></title>
    <url>%2F2020%2F06%2F07%2FLoj-3226-Greedy-Pie-Eaters%2F</url>
    <content type="text"><![CDATA[区间 dp. 首先可以假定每个区间都对应了一头牛,没有给出的可以将其牛的重量看作 0 . 当某头牛要吃区间 $[l,r]​$ 时,若剩下的派大于 $1​$ ,可以先让其他牛吃到还剩一个,于是每头牛都恰好吃掉一个派. 设 $f(l,r)​$ 表示把 $l,r​$ 内的派吃完能获得的最大收益,转移时枚举最后被吃的派是 $k​$ ,$$f(l,r)=\max_{l\le k\le r} f(l,k-1)+f(k+1,r)+g(l,r,k)$$其中 $g(l,r,k)=\max_{l\le x\le k\le y \le r} A_{x,y}$ ,表示用区间不超出 $[l,r]$ 的牛吃掉第 $k$ 个派能获得的最大收益. 转移时考虑 $[l,r]$ 这个区间的贡献就行了. $$g(l,r,k)=\max \lbrace A_{l,r},g(l+1,r,k),g(l,r-1,k) \rbrace$$时间复杂度 $O(n^3)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(ll x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(ll x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int N = 300 + 10;int n, m, g[N][N][N], a[N][N];ll f[N][N];int main()&#123; n = read(), m = read(); for (int i = 1; i &lt;= m; ++i) &#123; int w = read(), l = read(), r = read(); a[l][r] = w; &#125; for (int len = 1; len &lt;= n; ++len) for (int l = 1; l + len - 1 &lt;= n; ++l) &#123; int r = l + len - 1; for (int k = l; k &lt;= r; ++k) &#123; g[l][r][k] = max(a[l][r], max(g[l + 1][r][k], g[l][r - 1][k])); f[l][r] = max(f[l][r], f[l][k - 1] + f[k + 1][r] + g[l][r][k]); &#125; &#125; write(f[1][n], '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>区间dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 3247 Non-Decreasing Subsequences]]></title>
    <url>%2F2020%2F06%2F06%2FLoj-3247-Non-Decreasing-Subsequences%2F</url>
    <content type="text"><![CDATA[矩阵乘法. dp 显然可以写成转移矩阵的形式. 记 $v$ 为长度为 $K$ ,值全为 $1$ 的列向量, $w$ 为长度为 $K$ ,仅第一个值为 $1$ 的行向量, $T_i$ 表示第 $i$ 个数对应的转移矩阵. 那么询问 $[l,r]$ 的答案就是$$(w(\prod_{i=l}^r T_i)v)_{0,0}$$注意到转移矩阵 $T_i$ 有逆,且逆是容易直接求出的,于是可以考虑维护转移矩阵前缀积,以及逆矩阵的前缀积. 记 $x_i=T_1T_2T_3\cdots T_iv,y_i=wT_{i}^{-1}\cdots T_{3}^{-1}T_2^{-1}T_1^{-1}$ ,则询问的答案为 $(y_{l-1}x_r)_{0,0}$ . $T_i$ 和 $T_{i}^{-1}$ 都只有 $O(k)$ 个位置有值,于是右乘 $T_{i}$ 与左乘 $T_{i}^{-1}$ 都可以 $O(K^2)$ 完成. 时间复杂度 $O(nK^2+qK)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int P = 1e9 + 7, inv2 = (P + 1) &gt;&gt; 1;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;const int M = 20;const int N = 5e4 + 10;int n, K, Q, a[N], op;struct Matrix&#123; int v[M][M]; Matrix()&#123;memset(v, 0, sizeof v);&#125;&#125; x[N], y[N], tmp;Matrix operator * (Matrix A, Matrix B)&#123; Matrix res; if (op == 0) &#123; for (int k = 0; k &lt; K; ++k) for (int j = 0; j &lt; K; ++j) if (B.v[k][j]) for (int i = 0; i &lt; K; ++i) if (A.v[i][k]) inc(res.v[i][j], mul(A.v[i][k], B.v[k][j])); &#125; else &#123; for (int i = 0; i &lt; K; ++i) for (int k = 0; k &lt; K; ++k) if (A.v[i][k]) for (int j = 0; j &lt; K; ++j) if (B.v[k][j]) inc(res.v[i][j], mul(A.v[i][k], B.v[k][j])); &#125; return res;&#125;int main()&#123; n = read(), K = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read() - 1; op = 0; for (int i = 0; i &lt; K; ++i) x[0].v[i][i] = y[0].v[i][i] = 1; for (int i = 1; i &lt;= n; ++i) &#123; memset(tmp.v, 0, sizeof tmp.v); for (int j = 0; j &lt; K; ++j) inc(tmp.v[j][j], 1); for (int j = 0; j &lt;= a[i]; ++j) inc(tmp.v[j][a[i]], 1); x[i] = x[i - 1] * tmp; &#125; memset(tmp.v, 0, sizeof tmp.v); for (int i = 0; i &lt; K; ++i) tmp.v[i][0] = 1; for (int i = 1; i &lt;= n; ++i) x[i] = x[i] * tmp; op = 1; for (int i = 1; i &lt;= n; ++i) &#123; memset(tmp.v, 0, sizeof tmp.v); for (int j = 0; j &lt; K; ++j) inc(tmp.v[j][j], 1); for (int j = 0; j &lt;= a[i]; ++j) inc(tmp.v[j][a[i]], P - inv2); y[i] = tmp * y[i - 1]; &#125; memset(tmp.v, 0, sizeof tmp.v); tmp.v[0][0] = 1; for (int i = 1; i &lt;= n; ++i) y[i] = tmp * y[i]; int Q = read(); while (Q--) &#123; int l = read(), r = read(), ans = 0; for (int k = 0; k &lt; K; ++k) inc(ans, mul(y[l - 1].v[0][k], x[r].v[k][0])); write(ans, '\n'); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 3267 Help Yourself]]></title>
    <url>%2F2020%2F06%2F06%2FLoj-3267-Help-Yourself%2F</url>
    <content type="text"><![CDATA[第二类斯特林数 + 线段树优化 dp 转移. USACO 怎么也有如此套路的题… 可以先将所有线段按照左端点从小到大排序,方便后续处理. 记一个非空集合 $T$ 的线段形成的连通块数目为 $c(T)$ ,则答案为 $\sum_T c(T)^k$ . 朴素的 dp设 $dp(i,x,p)$ 表示考虑了前 $i$ 条线段,选了的线段右端点最大值为 $x$ ,有 $p$ 个连通块的方案数. 这样做状态数为 $O(n^3)$ ,不太可行. 幂次展开为组合数注意到 $k​$ 比较小,尝试将其展开为组合数的形式,$$\begin{aligned}ans&amp;=\sum_T c(T)^k \\&amp;=\sum_T\sum_{i=0}^k {k\brace i}\cdot i!\cdot \binom{c(T)}{i}\\&amp;=\sum_{i=0}^k{k\brace i}\cdot i!\cdot \sum_{T}\binom{c(T)}{i}\end{aligned}$$ 当题目中要算 $c^k$ 的贡献, $c$ 大而 $k$ 小,尤其是 $c$ 是某种东西的数目时,可以尝试展开成组合数. 原来需要记录 $c$ 的大小,最后算贡献,现在就将贡献摊在每个 $c$ 增大的时候计算,只用记录 $k$ 的大小. 于是我们在状态中就不需要记录连通块数目,而是在新产生一个连通块时,考虑它是否被选. 设 $dp(i,x,p)$ 表示考虑了前 $i$ 条线段,选了的线段右端点最大值为 $x$ ,产生的连通块被选定了 $p$ 个的方案数. 状态数从 $O(n^3)$ 降到了 $O(n^2k)$ ,还需进一步优化. 线段树优化转移考虑转移的形式,假定当前在考虑第 $i$ 条线段,其覆盖的区间为 $[l,r]$ . 若不选这条线段,则每个 $dp(i-1,x,p)$ 转移到 $dp(i,x,p)$ . 若选了这条线段,则根据 $x​$ 的大小分情况讨论. 若 $x&lt;l​$ ,此时会产生新的一个连通块, $dp(i-1,x,p)​$ 可以转移到 $dp(i,r,p)​$ 和 $dp(i,r,p+1)​$ . 若 $l\le x\le r​$ , $dp(i-1,x,p)​$ 可以转移到 $dp(i,r,p)​$ . 若 $x&gt;r$ , $dp(i-1,x,p)$ 可以转移到 $dp(i,x,p)$ . 不难发现,我们可以开 $k+1$ 棵线段树来维护这个 dp 数组,第 $p$ 棵线段树维护了当前所有的 $dp(i,x,p)$ . 时间复杂度 $O(nk\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int P = 1e9 + 7, inv2 = (P + 1) &gt;&gt; 1;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;const int N = 2e5 + 10, K = 10 + 1;struct node&#123; int tag, sum; node()&#123;tag = 1, sum = 0;&#125;&#125;;struct Segtree&#123; node Tree[N &lt;&lt; 2];#define root Tree[x] void pushup(int x) &#123; root.sum = add(Tree[x &lt;&lt; 1].sum, Tree[x &lt;&lt; 1 | 1].sum); &#125; void modify(int x, int c) &#123; root.sum = mul(root.sum, c); root.tag = mul(root.tag, c); &#125; void pushdown(int x) &#123; if (root.tag != 1) &#123; modify(x &lt;&lt; 1, root.tag); modify(x &lt;&lt; 1 | 1, root.tag); root.tag = 1; &#125; &#125; void Mul(int x, int l, int r, int L, int R, int c) &#123; if (L &gt; R || L &gt; r || R &lt; l) return; if (L &lt;= l &amp;&amp; r &lt;= R) return modify(x, c); int mid = (l + r) &gt;&gt; 1; pushdown(x); if (L &lt;= mid) Mul(x &lt;&lt; 1, l, mid, L, R, c); if (R &gt; mid) Mul(x &lt;&lt; 1 | 1, mid + 1, r, L, R, c); pushup(x); &#125; void Add(int x, int l, int r, int pos, int c) &#123; if (l == r) &#123; inc(root.sum, c); return; &#125; int mid = (l + r) &gt;&gt; 1; pushdown(x); if (pos &lt;= mid) Add(x &lt;&lt; 1, l, mid, pos, c); else Add(x &lt;&lt; 1 | 1, mid + 1, r, pos, c); pushup(x); &#125; int query(int x, int l, int r, int L, int R) &#123; if (L &gt; R || L &gt; r || R &lt; l) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) return root.sum; int mid = (l + r) &gt;&gt; 1, res = 0; pushdown(x); if (L &lt;= mid) inc(res, query(x &lt;&lt; 1, l, mid, L, R)); if (R &gt; mid) inc(res, query(x &lt;&lt; 1 | 1, mid + 1, r, L, R)); return res; &#125;#undef root&#125; T[K];int n, m, k, S[K][K], d[K];pair&lt;int, int&gt; seg[N];int main()&#123; n = read(), k = read(), m = n &lt;&lt; 1; for (int i = 1; i &lt;= n; ++i) seg[i].first = read(), seg[i].second = read(); sort(seg + 1, seg + 1 + n); S[0][0] = 1; for (int i = 1; i &lt;= k; ++i) for (int j = 1; j &lt;= i; ++j) S[i][j] = add(S[i - 1][j - 1], mul(S[i - 1][j], j)); T[0].Add(1, 0, m, 0, 1); for (int i = 1; i &lt;= n; ++i) &#123; int l = seg[i].first, r = seg[i].second; for (int p = k; p &gt;= 0; --p) &#123; if (p &lt; k) T[p + 1].Add(1, 0, m, r, T[p].query(1, 0, m, 0, l - 1)); T[p].Add(1, 0, m, r, T[p].query(1, 0, m, 0, r)); T[p].Mul(1, 0, m, r + 1, m, 2); &#125; &#125; int ans = 0, fac = 1; for (int p = 0; p &lt;= k; ++p) &#123; int s = T[p].query(1, 0, m, 0, m); inc(ans, mul(s, mul(S[k][p], fac))); fac = mul(fac, p + 1); &#125; write(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>线段树</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2273 数列]]></title>
    <url>%2F2020%2F06%2F06%2FLoj-2273-%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[dp 计数. 不难发现,合法的选择区间会在选一个数之后不断收缩,将它作为状态记录下来 dp 即可. 设 $dp(i,l,r,k)$ 表示考虑了前 $i$ 个数,下个数合法的选择区间为 $[l,r]$ , 最后一个数的值为 $k$ 的方案数. 转移时,对于 $[l,l],[l+1,k-1],[k,k],[k+1,r-1],[r,r]$ 这几段分别转移,每一段内转移到新的 $l,r$ 是一样的. 于是修改差分就可以完成 $O(1)$ 转移,注意处理 $l,r$ 不存在等特殊情况,时间复杂度 $O(n\cdot r^3)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int P = 998244353;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;const int N = 150 + 10;int n, m = 0, dp[2][N][N][N], t[N];void trans(int id, int l, int r, int L, int R, int v)&#123; if (L &gt; R) return; inc(dp[id ^ 1][l][r][L], v); inc(dp[id ^ 1][l][r][R + 1], P - v);&#125;int main()&#123; n = read(); for (int i = 1; i &lt;= n; ++i) m = max(m, t[i] = read()); int id = 0, bound = t[1], L, R; dp[id][0][m + 1][1] = 1, dp[id][0][m + 1][bound + 1] = P - 1; for (int i = 2; i &lt;= n; ++i) &#123; for (int l = 0; l &lt;= m + 1; ++l) for (int r = l; r &lt;= m + 1; ++r) for (int k = l; k &lt;= r; ++k) inc(dp[id][l][r][k], dp[id][l][r][k - 1]); bound = t[i]; for (int l = 0; l &lt;= m + 1; ++l) for (int r = l; r &lt;= m + 1; ++r) for (int k = l; k &lt;= r; ++k) dp[id ^ 1][l][r][k] = 0; for (int l = 0; l &lt;= m + 1; ++l) for (int r = l; r &lt;= m + 1; ++r) for (int k = l; k &lt;= r; ++k) if (dp[id][l][r][k]) &#123; L = max(l, 1), R = min(l, bound); trans(id, l, l, L, R, dp[id][l][r][k]); L = max(l + 1, 1), R = min(k - 1, bound); trans(id, l, k, L, R, dp[id][l][r][k]); if (k &gt; l) &#123; L = max(k, 1), R = min(k, bound); trans(id, k, k, L, R, dp[id][l][r][k]); &#125; L = max(k + 1, 1), R = min(r - 1, bound); trans(id, k, r, L, R, dp[id][l][r][k]); if (r &gt; k) &#123; L = max(r, 1), R = min(r, bound); trans(id, r, r, L, R, dp[id][l][r][k]); &#125; &#125; id ^= 1; &#125; int ans = 0; for (int l = 0; l &lt;= m + 1; ++l) for (int r = l; r &lt;= m + 1; ++r) for (int k = l; k &lt;= r; ++k) &#123; inc(dp[id][l][r][k], dp[id][l][r][k - 1]); inc(ans, dp[id][l][r][k]); &#125; write(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 3213 树的重心]]></title>
    <url>%2F2020%2F06%2F05%2FLoj-3213-%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83%2F</url>
    <content type="text"><![CDATA[二维数点. 考虑每个点 $x$ 会在删掉哪些边后成为重心,把它的贡献加到那些边上去. 考虑 $x$ 的所有子树(包括父亲方向的),分删掉的边是否在最大子树中进行讨论. $x$ 要成为新的重心,最大子树大小不能超过全局的一半,可以简单得出断掉的部分节点数应当在某个区间 $[l,r]$ 中. 若断掉的边是在 $x$ 某个儿子的子树内,那么断掉的节点数就是那条边下方的子树大小. 这等价于对于 dfs 序在某个区间内,且下方子树大小在某个区间的边的答案加上了 $x$ ,是个二维数点问题. 若断掉的边是在 $x$ 父亲方向的子树上,当它不在 $x$ 到根的路径上时,断掉的节点数也是下方子树大小. 当它在 $x$ 到根的路径上时,断掉的节点数是 $n$ 减去下方子树大小. 可以先把断掉的节点数都当成是下方子树大小,再对每条边考虑子树中的每次操作,将对应的贡献修改过来. 用主席树维护这个二维数点即可,时间复杂度 $O(n\log n)​$ .]]></content>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2391 港口设施]]></title>
    <url>%2F2020%2F06%2F05%2FLoj-2391-%E6%B8%AF%E5%8F%A3%E8%AE%BE%E6%96%BD%2F</url>
    <content type="text"><![CDATA[并查集 + 二分图染色. 把每个物品的进出时间看成一条线段,则被分在同一个栈中的两条线段不能相交,只能包含或相离. 把相交的物品之间连上边,方案数就等价于合法的二分图染色方案数. 若直接连边,边数是 $O(n^2)$ 的,考虑优化建图. 将所有点按照左端点从小到大排序,按照右端点从小到大依次考虑. 它能连的点应当是左端点在区间 $[1,l)$ 内,且还没有被考虑过的所有点. 注意到若两个点分别向 $[a,b],[c,d]$ 连边,且有 $a&lt;c&lt;b&lt;d$ ,那么连边时可以将 $[c,d]$ 直接换成 $[b,d]$ . 因为 $[a,b],[c,d]$ 里面的点一定都是同色的,连 $[a,b]$ 时已经保证了 $[c,b]$ 内同色,只需要对 $[b,d]$ 连边即可. 用一个并查集维护每个点通过同色的点向右最大能拓展到的位置,直接从那个点开始连边即可. 时间复杂度 $O(n\log n)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int P = 1e9 + 7;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;const int N = 2e6 + 10;int n, p[N], fa[N], nxt[N], vis[N], cnt = 0, col[N];int Find(int x)&#123; return x == fa[x] ? x : fa[x] = Find(fa[x]);&#125;vector&lt;int&gt; G[N];bool dfs(int x)&#123; for (int y : G[x]) if (col[y] &amp;&amp; col[x] + col[y] != 3) return false; else if (!col[y]) &#123; col[y] = 3 - col[x]; bool f = dfs(y); if (!f) return false; &#125; return true;&#125;int main()&#123; n = read(); for (int i = 1; i &lt;= n; ++i) &#123; int l = read(), r = read(); p[l] = p[r] = i; &#125; iota(fa + 1, fa + 2 + n, 1); iota(nxt + 1, nxt + 2 + n, 1); for (int i = 1; i &lt;= 2 * n; ++i) if (!vis[p[i]]) // left endpoint, do counting sort vis[p[i]] = ++cnt; else // right endpoint, add edges &#123; int id = vis[p[i]]; fa[id] = Find(id + 1); for (int j = fa[id], t; j &lt;= cnt; j = t) &#123; G[id].push_back(j); G[j].push_back(id); t = Find(nxt[j] + 1); nxt[j] = cnt; &#125; &#125; int ans = 1; for (int i = 1; i &lt;= n &amp;&amp; ans; ++i) if (!col[i]) &#123; col[i] = 1; bool f = dfs(i); if (f) ans = mul(ans, 2); else ans = 0; &#125; write(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2276 新型城市化]]></title>
    <url>%2F2020%2F06%2F03%2FLoj-2276-%E6%96%B0%E5%9E%8B%E5%9F%8E%E5%B8%82%E5%8C%96%2F</url>
    <content type="text"><![CDATA[二分图最大匹配的必须边. 首先可以在反图上考虑这个问题(即将边集替换为其补集). 问题变为给出一张二分图,询问删掉哪些边后最大匹配会减少,即哪些边是最大匹配的必须边. 首先用最大流跑出一个最大匹配,仅保留未满流的边做 tarjan,将每个点所属的 SCC 求出. 边 $(u,v)$ 是最大匹配的可行边,当且仅当它满流,或 $u,v$ 在相同的 SCC 中. 证明:若其满流,显然是可行边,若在相同的 SCC 中,则可以替换掉原来的一条匹配边. 边 $(u,v)$ 是最大匹配的必须边,当且仅当它满流,且 $u,v$ 在不同的 SCC 中. 证明:若其不满流,显然不是必须边,若在相同的 SCC 中,则可以被其他边替换掉. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int N = 1e4 + 10, M = 3e5 + 10, inf = 1e9;int S, T, n, m, ecnt = 1, head[N], cur[N], dep[N];struct Edge&#123; int nx, to, flow;&#125; E[M];void addedge(int u, int v, int w)&#123; E[++ecnt] = (Edge)&#123;head[u], v, w&#125;; head[u] = ecnt;&#125;void ins(int u, int v, int w)&#123; addedge(u, v, w); addedge(v, u, 0);&#125;queue&lt;int&gt; q;bool bfs()&#123; for (int i = 1; i &lt;= T; ++i) dep[i] = -1, cur[i] = head[i]; dep[S] = 0, q.push(S); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; i; i = E[i].nx) &#123; int v = E[i].to; if (E[i].flow &amp;&amp; dep[v] == -1) dep[v] = dep[u] + 1, q.push(v); &#125; &#125; return dep[T] != -1;&#125;int dfs(int u, int limit)&#123; if (u == T || !limit) return limit; int flow = 0, f; for (int &amp;i = cur[u]; i; i = E[i].nx) &#123; int v = E[i].to; if (dep[v] == dep[u] + 1 &amp;&amp; E[i].flow &amp;&amp; (f = dfs(v, min(limit, E[i].flow)))) &#123; E[i ^ 1].flow += f; E[i].flow -= f; flow += f; limit -= f; if (!limit) break; &#125; &#125; return flow;&#125;vector&lt;int&gt; G[N];int col[N];void paint(int u)&#123; for (int v : G[u]) &#123; if (!col[v]) &#123; col[v] = 3 - col[u]; paint(v); &#125; &#125;&#125;void Dinic()&#123; while (bfs()) dfs(S, inf);&#125;int dfn[N], low[N], idx = 0, in[N], stk[N], tp = 0, cnt = 0, scc[N];void tarjan(int u)&#123; dfn[u] = low[u] = ++idx; in[u] = 1, stk[++tp] = u; for (int i = head[u]; i; i = E[i].nx) &#123; if (E[i].flow == 0) continue; int v = E[i].to; if (!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if (in[v]) low[u] = min(low[u], dfn[v]); &#125; if (dfn[u] == low[u]) &#123; ++cnt; int x = 0; while (x != u) &#123; x = stk[tp--]; scc[x] = cnt; in[x] = 0; &#125; &#125;&#125;vector&lt;pair&lt;int, int&gt; &gt; ans;int main()&#123; n = read(), m = read(); S = n + 1, T = n + 2; for (int i = 1; i &lt;= m; ++i) &#123; int u = read(), v = read(); G[u].push_back(v); G[v].push_back(u); &#125; for (int i = 1; i &lt;= n; ++i) if (!col[i]) &#123; col[i] = 1; paint(i); &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (col[i] == 1) ins(S, i, 1); else ins(i, T, 1); if (col[i] == 1) for (int j : G[i]) ins(i, j, 1); &#125; Dinic(); for (int i = 1; i &lt;= T; ++i) if (!dfn[i]) tarjan(i); for (int u = 1; u &lt;= n; ++u) if (col[u] == 1) for (int i = head[u]; i; i = E[i].nx) &#123; int v = E[i].to; if (v &lt;= n &amp;&amp; E[i].flow == 0 &amp;&amp; scc[u] != scc[v]) ans.push_back(make_pair(min(u, v), max(u, v))); &#125; sort(ans.begin(), ans.end()); printf("%llu\n", ans.size()); for (auto p : ans) write(p.first, ' '), write(p.second, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>tarjan</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6157 A^B problem]]></title>
    <url>%2F2020%2F06%2F03%2FLoj-6157-A%5EB-problem%2F</url>
    <content type="text"><![CDATA[带权并查集. 维护一个带权并查集, 用 $ans(x)$ 表示 $x$ 到 $x$ 的根节点路径权值异或和. 得到一个信息 $(s,t,w)$ 后,若 $s,t$ 不在同一并查集,则将两个并查集合并,并打上标记. 否则,检查 $ans(s)\oplus ans(t)$ 是否为 $t$ ,若不为 $t$ ,说明不合法. 最后若并查集数目 $&gt;1$ ,说明有多解,否则将每个点的 $ans$ 求出后即可得到答案. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int N = 5e5 + 10;int n, m, fa[N], val[N], tot, siz[N], ans[N];int Find(int st, int x)&#123; ans[st] ^= val[x]; if (x == fa[x]) return x; return Find(st, fa[x]);&#125;vector&lt;int&gt; G[N];void dfs(int x, int F, int &amp;mx, int &amp;mi)&#123; for (int y : G[x]) if (y != F) &#123; mx = max(mx, ans[x] ^ ans[y]); mi = min(mi, ans[x] ^ ans[y]); dfs(y, x, mx, mi); &#125;&#125;void solve(int id)&#123; n = read(), m = read(); tot = n; for (int i = 1; i &lt;= n; ++i) &#123; fa[i] = i, val[i] = 0, siz[i] = 1; G[i].clear(); &#125; for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(); G[u].push_back(v), G[v].push_back(u); &#125; bool valid = true; for (int i = 1; i &lt;= m; ++i) &#123; int s = read(), t = read(), w = read(); ans[s] = ans[t] = 0; int u = Find(s, s), v = Find(t, t); if (siz[u] &gt; siz[v]) swap(u, v); if (u != v) &#123; fa[u] = v; val[u] = ans[s] ^ ans[t] ^ w; --tot, siz[v] += siz[u]; &#125; else valid &amp;= (ans[s] ^ ans[t]) == w; &#125; if (!valid) puts("Impossible"); else if (tot &gt; 1) puts("No"); else &#123; int mx = 0, mi = 1 &lt;&lt; 16; int rt; for (int i = 1; i &lt;= n; ++i) ans[i] = 0, rt = Find(i, i); dfs(rt, 0, mx, mi); write(mi, ' '); write(mx, '\n'); &#125;&#125;int main()&#123; int T = read(); for (int i = 1; i &lt;= T; ++i) solve(i); return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平面最近点对]]></title>
    <url>%2F2020%2F05%2F31%2F%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[分治求平面最近点对. 给出平面上的 $n$ 个点,询问不同的两个点之间距离最小是多少. 暴力直接枚举两个点计算距离,时间复杂度 $O(n^2)$ . kd 树建出 kd 树,对每个点询问一下与它最近的距离. 适当剪枝,复杂度为玄学. 分治把所有点按照 $x$ 排序,从中间划分成左右两部分,递归计算两部分内部各自的贡献,再考虑跨过中线的贡献. 记 $d$ 表示左右两部分内部贡献的最小值,那么计算跨过中线的点对时,只需要考虑距离 $&lt;d$ 的点对. 假定中线为 $l:x=k$ ,那么只用考虑横坐标在区间 $(x-k,x+k)$ 内的点. 把这些点拿出来按照 $y$ 排序,枚举起点,向后找终点,当两者纵坐标之差达到 $k$ 时就换下一个起点. 可以证明 ,对于每个起点,有效的终点不会超过 $6$ 个. 时间复杂度 $T(n)=2T(\frac n 2) + O(n\log n)=O(n\log^2 n)$ . 模板题Hdu 1007 Quoit Design 给出平面上 $n$ 个点,需要找出一个圆,使得它恰好包含了其中的一个点,求出这个圆可能的最大半径. 以最近点对为直径的两个端点作圆,将它做微小偏移即可得到所求的圆,半径可以直接视作最近点对距离的一半. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int N = 1e5 + 10;struct v2&#123; double x, y; v2 operator - (const v2 &amp;rhs) const &#123; return (v2)&#123;x - rhs.x, y - rhs.y&#125;; &#125; double modulus() &#123; return sqrt(x * x + y * y); &#125; void in() &#123; scanf("%lf%lf", &amp;x, &amp;y); &#125;&#125; p[N], tmp[N];bool cx(const v2 &amp;A, const v2 &amp;B)&#123; return A.x &lt; B.x;&#125;bool cy(const v2 &amp;A, const v2 &amp;B)&#123; return A.y &lt; B.y;&#125;double ans;int n;void work(int l, int r)&#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1; work(l, mid); work(mid + 1, r); double k = p[mid].x; int t = 0; for (int i = l; i &lt;= r; ++i) if (fabs(k - p[i].x) &lt;= ans) tmp[++t] = p[i]; sort(tmp + 1, tmp + 1 + t, cy); for (int i = 1; i &lt;= t; ++i) for (int j = i + 1; j &lt;= t; ++j) if (tmp[j].y - tmp[i].y &lt; ans) ans = min(ans, (tmp[j] - tmp[i]).modulus()); else break;&#125;void solve()&#123; for (int i = 1; i &lt;= n; ++i) p[i].in(); sort(p + 1, p + 1 + n, cx); ans = 1e18; work(1, n); printf("%.2lf\n", ans / 2);&#125;int main()&#123; while (n = read()) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>计算几何</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6723 教科书般的亵渎]]></title>
    <url>%2F2020%2F05%2F30%2FLoj-6723-%E6%95%99%E7%A7%91%E4%B9%A6%E8%88%AC%E7%9A%84%E4%BA%B5%E6%B8%8E%2F</url>
    <content type="text"><![CDATA[整除分块 + 树状数组. 先考虑给定一个伤害值 $d$ ,如何计算施放了多少次亵渎. 将每个随从生命值 $x$ 换成需要被攻击的次数,即 $\lfloor \frac{x-1}{d}\rfloor +1$ ,就可以把 $d$ 看作 $1$ ,即每次造成 $1$ 点伤害. 那么施放的次数就是最大的 $x$ ,使得 $1,2,3,\dots, x$ 作为生命值在随从中都出现过,再加上 $1$ . 考虑对于每个 $d$ 都直接维护出答案,询问时利用树状数组查询 $[L,R]$ 内的区间和. 每加入一个数 $x$ 的时候,对它整除分块,它对一段区间 $[L,R]$ 的贡献都是加入了一个数 $k$ . 对每个 $k$ 用 set 维护它在哪些位置是作为最大的 $x$ ,将 $[L,R]$ 内 $k-1$ 作为最大的 $x$ 的位置全部更新一遍.答案. 由于只有增加数字的操作,所以对于每个位置 $d$ ,更新次数不会超过 $\frac {n}{d}$ . 时间复杂度 $O(n\log^2n+n\sqrt n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int N = 1e5 + 10;int n, m, bucket[N];struct FenwickTree&#123; int lowbit(int x) &#123; return x &amp; (-x); &#125; int bit[N]; int add(int x, int c) &#123; for (; x &lt;= n; x += lowbit(x)) bit[x] += c; &#125; int sum(int x) &#123; int s = 0; for (; x; x -= lowbit(x)) s += bit[x]; return s; &#125; int query(int l, int r) &#123; return sum(r) - sum(l - 1); &#125;&#125; Buc, Ans;int ans[N];set&lt;int&gt; st[N];int solve(int d)&#123; Ans.add(d, -ans[d]); while ("WLLAKIOI") &#123; int l = d * ans[d] + 1, r = l + d - 1; l = min(l, n + 1), r = min(r, n); int cnt = Buc.query(l, r); if (cnt) ++ans[d]; else break; &#125; Ans.add(d, ans[d]); st[ans[d]].insert(d);&#125;void upd(int l, int r, int k)&#123; auto first = st[k].lower_bound(l); auto last = st[k].upper_bound(r); for (auto it = first; it != last; it = st[k].erase(it)) solve(*it);&#125;int main()&#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) st[0].insert(i); while (m--) &#123; int op = read(); if (op == 1) &#123; int x = read() - 1; if (bucket[x]) continue; bucket[x] = 1; Buc.add(x + 1, 1); for (int l = 1, r; l &lt;= x; l = r + 1) &#123; int k = x / l; r = x / k; upd(l, r, k); &#125; upd(x + 1, n, 0); &#125; else &#123; int L = read(), R = read(); write(Ans.query(L, R) + R - L + 1, '\n'); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2407 气氛/Luft]]></title>
    <url>%2F2020%2F05%2F30%2FLoj-2407-%E6%B0%94%E6%B0%9B-Luft%2F</url>
    <content type="text"><![CDATA[高维多面体的体积计算 + 高斯消元的一个 trick. 如果只有 $n$ 个 $n-1​$ 维的点,那么凸包其实就是它们围成的高维多面体. 它的体积就是选一个起点, 将 $n-1$ 个 $n-1$ 维向量形成的矩阵的行列式绝对值除掉 $(n-1)!​$ . 现在有 $n+1$ 个点,求它们形成的凸包体积. 有一个通用的结论,这 $n+1$ 个 $n-1$ 维点的凸包体积等于任选出 $n$ 个点的高维多面体体积之和 $/2​$ . 枚举哪一个点没选,用高斯消元求出其余 $n​$ 个点形成的高维多面体体积即可. 注意不能直接在模意义下计算,否则只能算出行列式在模意义下的值,但无法判定符号,得出绝对值. 所以必须要用真实值消元,为了避免 double 的精度误差,可以将真实值和模意义下的值分别维护. 最后根据真实值的符号决定是否对模意义下的值取相反数. 时间复杂度 $O(t\cdot n^4)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int P = 1e9 + 7;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a, int b)&#123; int res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res;&#125;const int N = 40;int n, p[N][N], b[N][N];long double a[N][N];int Guass()&#123; long double res = 1; int prod = 1, sgn = 1; for (int i = 1; i &lt; n; ++i) &#123; for (int j = i; j &lt; n; ++j) if (b[j][i]) &#123; if (j != i) &#123; sgn *= -1, res *= -1; swap(b[i], b[j]); swap(a[i], a[j]); &#125; break; &#125; if (!b[i][i]) return 0; res *= a[i][i], prod = mul(prod, b[i][i]); int inv = fpow(b[i][i], P - 2); for (int j = i + 1; j &lt; n; ++j) &#123; long double t = -a[j][i] / a[i][i]; int r = mul(P - b[j][i], inv); for (int k = 1; k &lt; n; ++k) a[j][k] += t * a[i][k], inc(b[j][k], mul(r, b[i][k])); &#125; &#125; if (sgn == -1) prod = add(0, P - prod); if (res &lt; 0) return add(0, P - prod); return prod;&#125;void solve()&#123; n = read(); for (int i = 1; i &lt;= n + 1; ++i) for (int j = 1; j &lt; n; ++j) p[i][j] = read(); int ans = 0; for (int ban = 1; ban &lt;= n + 1; ++ban) &#123; int x = ban == 1 ? 2 : 1; int t = 0; for (int i = 1; i &lt;= n + 1; ++i) if (i != ban &amp;&amp; i != x) &#123; ++t; for (int j = 1; j &lt; n; ++j) &#123; a[t][j] = p[i][j] - p[x][j]; b[t][j] = add(p[i][j], P - p[x][j]); &#125; &#125; inc(ans, Guass()); &#125; ans = mul(ans, (P + 1) &gt;&gt; 1); write(ans, '\n');&#125;int main()&#123; int T = read(); while (T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>计算几何</tag>
        <tag>线性代数</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 5279 YJC plays Minecraft]]></title>
    <url>%2F2020%2F05%2F29%2FHdu-5279-YJC-plays-Minecraft%2F</url>
    <content type="text"><![CDATA[多项式 $\exp$ . 规定每一块内部不能有环.连接块与块的边随便选. 这样只会多算一种情况,就是块与块的边都被选,并且每块的第一个点和最后一个点都连通. 把这种情况减掉即可,答案为$$ans=2^n\prod_{i=1}^n (g_{a_i})-\prod_{i=1}^n (g_{a_i}-h_{a_i})$$ 其中 $g_n,h_n$ 分别表示 $n$ 个点的完全图生成森林的数目, $n$ 个点的完全图, $n$ 与 $n$ 不连通的生成森林数目. 记 $f_n=n^{n-2}$ 表示 $n$ 个点的完全图生成树的数目, $F,G,H$ 分别为三者的 EGF. 易知 $G=\exp F$ ,只需要考虑如何计算 $H$ . 考虑 $h_n$ 如何计算,枚举 $1​$ 所在的生成树大小即可.$$h_n=\sum_{i=1}^{n-1}\binom{n-2}{i-1} f_i\cdot g_{n-i} \\\frac{h_n}{(n-2)!}=\sum_{i=1}^{n-1} \frac{f_i}{(i-1)!}\cdot \frac{g_{n-i}}{(n-i-1)!}$$做一次卷积即可求出所有 $h$ ,时间复杂度 $O(n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int P = 998244353, G = 3;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a, ll b)&#123; int res = 1; while (b) &#123; if (b &amp; 1LL) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res;&#125;const int N = 1 &lt;&lt; 18 | 10;int rev[N], omega[N], inv[N], curn = 0;void init(int n)&#123; if (curn == n) return; for (int i = 0; i &lt; n; ++i) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) * (n &gt;&gt; 1)); for (int l = 2; l &lt;= n; l &lt;&lt;= 1) &#123; omega[l] = fpow(G, (P - 1) / l); inv[l] = fpow(omega[l], P - 2); &#125; curn = n;&#125;void DFT(int *a, int n, bool invflag)&#123; init(n); for (int i = 0; i &lt; n; ++i) if(i &lt; rev[i]) swap(a[i], a[rev[i]]); for (int l = 2; l &lt;= n; l &lt;&lt;= 1) &#123; int m = l &gt;&gt; 1; int gi = omega[l]; if (invflag) gi = inv[l]; for (int *p = a; p != a + n; p += l) &#123; int g = 1; for (int i = 0; i &lt; m; ++i) &#123; int t = mul(g, p[i + m]); p[i + m] = add(p[i], P - t); p[i] = add(p[i], t); g = mul(g, gi); &#125; &#125; &#125; if(invflag) &#123; int invn = fpow(n, P - 2); for (int i = 0; i &lt; n; ++i) a[i] = mul(a[i], invn); &#125;&#125;void NTT(int *A, int *B, int *C, int lenA, int lenB)&#123; int lenC = lenA + lenB - 1, n = 1; while (n &lt; lenC) n &lt;&lt;= 1; static int a[N], b[N]; copy(A, A + lenA, a); fill(a + lenA, a + n, 0); copy(B, B + lenB, b); fill(b + lenB, b + n, 0); DFT(a, n, false); DFT(b, n, false); for (int i = 0; i &lt; n; ++i) C[i] = mul(a[i], b[i]); DFT(C, n, true);&#125;void Inverse(int *A, int *B, int n)&#123; int len = 1; while (len &lt; n) len &lt;&lt;= 1; static int res[N], tmp[N]; res[0] = fpow(A[0], P - 2); for (int i = 2; i &lt;= len; i &lt;&lt;= 1) &#123; NTT(A, res, tmp, i, i); NTT(tmp, res, tmp, i, i); for (int j = 0; j &lt; i; ++j) res[j] = add(mul(2, res[j]), P - tmp[j]); &#125; copy(res, res + n, B);&#125;void Diff(int *A, int n)&#123; for (int i = 0; i &lt; n - 1; ++i) A[i] = mul(i + 1, A[i + 1]); A[n - 1] = 0;&#125;int Inv[N];void Inte(int *A, int n)&#123; for (int i = n + 1; i &gt;= 1; --i) A[i] = mul(Inv[i], A[i - 1]); A[0] = 0;&#125;void Log(int *A, int *B, int n)&#123; static int invA[N], tmp[N]; Inverse(A, invA, n); copy(A, A + n, tmp); Diff(tmp, n); NTT(tmp, invA, tmp, n, n); Inte(tmp, n); copy(tmp, tmp + n, B);&#125;void Exp(int *A, int *B, int n)&#123; int len = 1; while (len &lt; n) len &lt;&lt;= 1; static int res[N], tmp[N]; res[0] = 1; for (int i = 2; i &lt;= len; i &lt;&lt;= 1) &#123; Log(res, tmp, i); for (int j = 0; j &lt; i; ++j) tmp[j] = add(A[j], P - tmp[j]); inc(tmp[0], 1); NTT(tmp, res, res, i, i); &#125; copy(res, res + n, B);&#125;int bin[N], fac[N], invfac[N], f[N], g[N], tf[N], tg[N], h[N];int a[N];void solve()&#123; int n = read(), ans = 0, prod = bin[n]; for (int i = 1; i &lt;= n; ++i) a[i] = read(), prod = mul(prod, g[a[i]]); ans = prod; prod = 1; for (int i = 1; i &lt;= n; ++i) prod = mul(prod, add(g[a[i]], P - h[a[i]])); inc(ans, P - prod); write(ans, '\n');&#125;int main()&#123; int n = 100000 + 1; bin[0] = fac[0] = fac[1] = invfac[0] = invfac[1] = Inv[1] = 1; bin[1] = 2; for (int i = 2; i &lt; n; ++i) &#123; bin[i] = add(bin[i - 1], bin[i - 1]); fac[i] = mul(fac[i - 1], i); Inv[i] = mul(P - P / i, Inv[P % i]); invfac[i] = mul(invfac[i - 1], Inv[i]); &#125; f[0] = 0, f[1] = 1; for (int i = 2; i &lt; n; ++i) f[i] = mul(fpow(i, i - 2), invfac[i]); Exp(f, g, n); g[0] = 0; for (int i = 1; i &lt; n; ++i) &#123; tf[i] = mul(f[i], i); tg[i] = mul(g[i], i); f[i] = mul(f[i], fac[i]); g[i] = mul(g[i], fac[i]); &#125; NTT(tf, tg, h, n, n); h[0] = h[1] = 0; for (int i = 2; i &lt; n; ++i) h[i] = mul(h[i], fac[i - 2]); int T = read(); while (T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 3094 删数]]></title>
    <url>%2F2020%2F05%2F29%2FLoj-3094-%E5%88%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[线段树. 考虑对于给定的数列,如何计算最小修改次数. 若当前数列长度为 $x$ ,则操作一次后会转移到 $x-cnt(x)$ ,其中 $cnt(x)$ 表示数列中有几个 $x$ . 想让数列长度变为 $0​$ ,这相当于每个长度都要被删去一次,而 $x​$ 可以让 $[x-cnt(x)+1,x]​$ 这些长度都被删一次. 于是 $[1,n]$ 内每种数字 $x$ 可以覆盖一段区间 $[x-cnt(x)+1,x]$ ,询问 $[1,n]$ 内有几个位置没被覆盖即为答案. 可以用线段树维护每个位置被覆盖的次数,询问最小值以及最小值出现的次数即可得到答案. 现在考虑如何支持修改,单点修改可以直接删掉原来的线段,加上新的线段. 整体 $+1,-1$ 可以直接对全局维护偏移量标记 $\Delta$ ,询问 $[1,n]$ 时改为询问 $[1-\Delta,n-\Delta]$ 即可. 注意整体 $+1,-1$ 时,可能会导致 $n$ 与 $n+1$ 交换,此时需要修改它们的贡献. 时间复杂度 $O(n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int N = 4.5e5 + 10, inf = 1e9;int n, m, mx, a[N], cnt[N], delta;int calc(int x)&#123; return x - delta + m;&#125;struct node&#123; int mi, cnt, tag;&#125; Tree[N &lt;&lt; 2];#define root Tree[x]#define lson Tree[x &lt;&lt; 1]#define rson Tree[x &lt;&lt; 1 | 1]void BuildTree(int x, int l, int r)&#123; root.mi = root.tag = 0, root.cnt = r - l + 1; if (l == r) return; int mid = (l + r) &gt;&gt; 1; BuildTree(x &lt;&lt; 1, l, mid); BuildTree(x &lt;&lt; 1 | 1, mid + 1, r);&#125;void pushup(int x)&#123; root.mi = min(lson.mi, rson.mi), root.cnt = 0; if (lson.mi == root.mi) root.cnt += lson.cnt; if (rson.mi == root.mi) root.cnt += rson.cnt;&#125;void modify(int x, int c)&#123; root.mi += c; root.tag += c;&#125;void pushdown(int x)&#123; if (root.tag) &#123; modify(x &lt;&lt; 1, root.tag); modify(x &lt;&lt; 1 | 1, root.tag); root.tag = 0; &#125;&#125;void upd(int x, int l, int r, int L, int R, int c)&#123; if (l &gt; R || L &gt; r) return; if (L &lt;= l &amp;&amp; r &lt;= R) return modify(x, c); int mid = (l + r) &gt;&gt; 1; pushdown(x); if (L &lt;= mid) upd(x &lt;&lt; 1, l, mid, L, R, c); if (R &gt; mid) upd(x &lt;&lt; 1 | 1, mid + 1, r, L, R, c); pushup(x);&#125;void query(int &amp;mi, int &amp;cnt, int x, int l, int r, int L, int R)&#123; if (root.mi &gt; mi) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; if (root.mi &lt; mi) mi = root.mi, cnt = root.cnt; else if (root.mi == mi) cnt += root.cnt; return; &#125; int mid = (l + r) &gt;&gt; 1; pushdown(x); if (L &lt;= mid) query(mi, cnt, x &lt;&lt; 1, l, mid, L, R); if (R &gt; mid) query(mi, cnt, x &lt;&lt; 1 | 1, mid + 1, r, L, R);&#125;void Modify(int p, int x)&#123; if (x == 1) &#123; if (cnt[calc(n)]) upd(1, 1, mx, calc(n) - cnt[calc(n)] + 1, calc(n), -1); &#125; else &#123; if (cnt[calc(n + 1)]) upd(1, 1, mx, calc(n + 1) - cnt[calc(n + 1)] + 1, calc(n + 1), 1); &#125; delta += x;&#125;void Add(int p, int x)&#123; if (a[p] &lt;= calc(n)) upd(1, 1, mx, a[p] - cnt[a[p]] + 1, a[p] - cnt[a[p]] + 1, -1); cnt[a[p]]--; a[p] = x - delta + m; cnt[a[p]]++; if (a[p] &lt;= calc(n)) upd(1, 1, mx, a[p] - cnt[a[p]] + 1, a[p] - cnt[a[p]] + 1, 1);&#125;int main()&#123; n = read(), m = read(); mx = n + 2 * m; BuildTree(1, 1, mx); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read() + m; upd(1, 1, mx, a[i] - cnt[a[i]], a[i] - cnt[a[i]], 1); ++cnt[a[i]]; &#125; for (int i = 1; i &lt;= m; ++i) &#123; int p = read(), x = read(); if (p == 0) Modify(p, x); else Add(p, x); int mi = 1, cnt = 0; query(mi, cnt, 1, 1, mx, calc(1), calc(n)); write(mi ? 0 : cnt, '\n'); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6169 相似序列]]></title>
    <url>%2F2020%2F05%2F28%2FLoj-6169-%E7%9B%B8%E4%BC%BC%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[Hash + 主席树. 给每种元素随机分配一个大权值,若两个区间内权值和相等,就可以认为它们在排序后是一样的. 现在可以允许排序后有一个位置不同. 以权值为下标建出主席树,二分出第一个不能匹配的权值 $x$ ,最后一个不能被匹配的权值 $y$ . 若 $x,y$ 是来自两个不同的子串,且 $[x,y]$ 内没有其它权值,说明排序后它们位置能对应上,两个子串就相似了. 可以记录一下每种权值的个数,方便判断. 时间复杂度 $O(n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;typedef unsigned long long ull;ull gen()&#123; ull a = rand(), b = rand(), c = rand(), d = rand(); return a | (b &lt;&lt; 15) | (c &lt;&lt; 30) | (d &lt;&lt; 45);&#125;const int N = 1e5 + 10;int n, m = 100000, q, idx, a[N], ls[N * 20], rs[N * 20], cnt[N * 20], rt[N];ull val[N], b[N], sum[N * 20];void upd(int &amp;x, int lst, int l, int r, int pos, ull c)&#123; x = ++idx; ls[x] = ls[lst], rs[x] = rs[lst], cnt[x] = cnt[lst], sum[x] = sum[lst]; ++cnt[x], sum[x] += c; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) upd(ls[x], ls[lst], l, mid, pos, c); else upd(rs[x], rs[lst], mid + 1, r, pos, c);&#125;int tx, ty;int query_first(int A, int B, int C, int D, int l, int r)&#123; if (l == r) &#123; if (sum[B] - sum[A] == sum[D] - sum[C]) return -1; tx = cnt[B] - cnt[A] - (cnt[D] - cnt[C]); return l; &#125; int mid = (l + r) &gt;&gt; 1; if (sum[ls[B]] - sum[ls[A]] != sum[ls[D]] - sum[ls[C]]) return query_first(ls[A], ls[B], ls[C], ls[D], l, mid); else return query_first(rs[A], rs[B], rs[C], rs[D], mid + 1, r);&#125;int query_last(int A, int B, int C, int D, int l, int r)&#123; if (l == r) &#123; if (sum[B] - sum[A] == sum[D] - sum[C]) return -1; ty = cnt[B] - cnt[A] - (cnt[D] - cnt[C]); return l; &#125; int mid = (l + r) &gt;&gt; 1; if (sum[rs[B]] - sum[rs[A]] != sum[rs[D]] - sum[rs[C]]) return query_last(rs[A], rs[B], rs[C], rs[D], mid + 1, r); else return query_last(ls[A], ls[B], ls[C], ls[D], l, mid);&#125;int query_cnt(int A, int B, int C, int D, int l, int r, int L, int R)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) return cnt[B] - cnt[A] + cnt[D] - cnt[C]; int res = 0, mid = (l + r) &gt;&gt; 1; if (L &lt;= mid) res += query_cnt(ls[A], ls[B], ls[C], ls[D], l, mid, L, R); if (!res &amp;&amp; R &gt; mid) res += query_cnt(rs[A], rs[B], rs[C], rs[D], mid + 1, r, L, R); return res;&#125;bool check(int A, int B, int C, int D)&#123; if (B - A != D - C) return false; int x = query_first(rt[A - 1], rt[B], rt[C - 1], rt[D], 1, m); if (x == -1) return true; int y = query_last(rt[A - 1], rt[B], rt[C - 1], rt[D], 1, m); if (x == y) return true; if ((tx &gt; 0) == (ty &gt; 0)) return false; if (abs(tx) &gt; 1 || abs(ty) &gt; 1) return false; if (x + 1 &gt; y - 1) return true; return query_cnt(rt[A - 1], rt[B], rt[C - 1], rt[D] ,1, m, x + 1, y - 1) == 0;&#125;void solve()&#123; for (int i = 1; i &lt;= idx; ++i) ls[i] = rs[i] = cnt[i] = sum[i] = 0; idx = 0; for (int i = 1; i &lt;= m; ++i) val[i] = gen(); n = read(), q = read(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); b[i] = val[a[i]]; upd(rt[i], rt[i - 1], 1, m, a[i], b[i]); &#125; for (int t = 1; t &lt;= q; ++t) &#123; int A = read(), B = read(), C = read(), D = read(); puts(check(A, B, C, D) ? "YES" : "NO"); &#125;&#125;int main()&#123; srand(time(0)); int T = read(); while (T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3145 Str]]></title>
    <url>%2F2020%2F05%2F28%2Fbzoj-3145-Str%2F</url>
    <content type="text"><![CDATA[SAM + dsu on tree. 枚举串 $A$ 和串 $B$ 模糊匹配的位置分别为 $i,j$ ,用 ${\rm LCS}(i-1,j-1)+{\rm LCP}(i+1,j+1)+1$ 更新答案. 直接这样做是 $O(n^2)​$ 的. 可以在后缀树上枚举节点 $x​$ 作为 $i-1,j-1​$ 在后缀树上的 LCA, 需要最大化 ${\rm LCP} (i+1,j+1)​$ . 将子树 $x​$ 内的点用 dsu on tree 加进来,每加入一个点时,用在前缀树上 dfs 序与它相邻的点更新答案. 于是做 dsu on tree 时,将点按照在前缀树上的 dfs 序作为权值插入到 set 中即可. 时间复杂度 $O(n\log^2n)$ .]]></content>
      <tags>
        <tag>SAM</tag>
        <tag>dsu on tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4340 隐身术]]></title>
    <url>%2F2020%2F05%2F27%2Fbzoj-4340-%E9%9A%90%E8%BA%AB%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[SAM + dfs 爆搜. 枚举 B 的子串左端点 $t$ ,即考虑所有是以 $t$ 开头的后缀的前缀. $k$ 较小,可爆搜之,只要保证每次 $k$ 都在减少, dfs 的层数就是 $O(k)$ 的. 具体地,设状态 $(x,y,z)$ 表示串 $A$ 匹配到了位置 $x$ , 串 $B$ 匹配到了位置 $y$ ,还剩 $z$ 次修改机会. 若 $A_x=B_y$ ,则我们需要先跳过一段连续的可以匹配的段,这样接下来就一定会消耗一次修改机会. 在 SAM 上询问这两个位置的 LCP ,将其跳过即可. 若 $A_x\neq B_y$ ,则必须使用修改操作,可以将 $B_y$ 删掉,或在 $B$ 中加入一个 $A_x$ ,或将 $B_y$ 改成 $A_x$ . 这三种操作分别转移到 $(x,y+1,z-1),(x+1,y,z-1),(x+1,y+1,z-1)$ . 当某一个串匹配完成时,由于可能还剩下了若干修改操作,合法的前缀是一段区间,差分打上标记即可. 时间复杂度 $O(n\log n+n\cdot k^3)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int N = 2e5 + 10, K = 18, S = 27;int n, m, k, Log[N * 2];char A[N], B[N];namespace SAM&#123; int idx = 1, lst = 1, fa[N], len[N], ch[N][S], pos[N]; void Extend(int x, int c) &#123; int p = lst, np = ++idx; lst = np, len[np] = len[p] + 1; while (p &amp;&amp; ch[p][c] == 0) ch[p][c] = np, p = fa[p]; if (!p) fa[np] = 1; else &#123; int q = ch[p][c]; if (len[q] == len[p] + 1) fa[np] = q; else &#123; int nq = ++idx; len[nq] = len[p] + 1; fa[nq] = fa[q], fa[q] = fa[np] = nq; memcpy(ch[nq], ch[q], sizeof ch[nq]); while (p &amp;&amp; ch[p][c] == q) ch[p][c] = nq, p = fa[p]; &#125; &#125; pos[x] = np; &#125; vector&lt;int&gt; G[N]; int tot = 0, ps[N], st[N * 2][K]; void dfs(int x) &#123; st[++tot][0] = len[x], ps[x] = tot; for (int i = 0; i &lt; G[x].size(); ++i) &#123; dfs(G[x][i]); st[++tot][0] = len[x]; &#125; &#125; void init() &#123; for (int i = 2; i &lt;= idx; ++i) G[fa[i]].push_back(i); dfs(1); for (int j = 1; (1 &lt;&lt; j) &lt;= tot; ++j) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= tot; ++i) st[i][j] = min(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]); Log[1] = 0; for (int i = 2; i &lt;= tot; ++i) Log[i] = Log[i &gt;&gt; 1] + 1; &#125; int query(int x, int y) // LCP of A[x], B[y] &#123; if (x &gt; n || y &gt; m) return 0; x = n + 1 - x, x += m + 1; y = m + 1 - y; int l = ps[pos[x]], r = ps[pos[y]]; if (l &gt; r) swap(l, r); int k = Log[r - l + 1]; return min(st[l][k], st[r - (1 &lt;&lt; k) + 1][k]); &#125;&#125;using namespace SAM;int ans = 0, diff[N], t;void dfs(int x, int y, int z)&#123; int lcp = query(x, y); x += lcp, y += lcp; if (x &gt; n || y &gt; m) &#123; int d = z - (n + 1 - x); if (d &lt; 0) return; int l = max(1, y - d - t), r = min(m + 1 - t, y + d - t); ++diff[l], --diff[r + 1]; return; &#125; else if (z) &#123; dfs(x + 1, y, z - 1); dfs(x, y + 1, z - 1); dfs(x + 1, y + 1, z - 1); &#125;&#125;int main()&#123; k = read(); scanf("%s", A + 1), n = strlen(A + 1); scanf("%s", B + 1), m = strlen(B + 1); int cur = 0; for (int i = m; i &gt;= 1; --i) Extend(++cur, B[i] - 'A'); Extend(++cur, 26); for (int i = n; i &gt;= 1; --i) Extend(++cur, A[i] - 'A'); init(); int L = max(1, n - k), R = min(m, n + k); for (t = 1; t &lt;= m; ++t) &#123; dfs(1, t, k); for (int i = L; i &lt;= R; ++i) diff[i] += diff[i - 1]; for (int i = L; i &lt;= R; ++i) if (diff[i]) ++ans, diff[i] = 0; &#125; write(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4180 字符串计数]]></title>
    <url>%2F2020%2F05%2F27%2Fbzoj-4180-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[SAM + 矩阵快速幂 floyd. 考虑如果给出了串 $S$ ,如何算最小操作次数,将 $S$ 放到 $T$ 的 SAM 上去匹配,若没有出边则返回 $1$ ,且操作次数 $+1$ . 可以二分答案 $mid$ ,尝试检查用 $mid$ 次操作能构造出的串最小长度,若 $\le n$ ,说明答案 $\ge mid$ . 考虑如何求出用 $mid$ 次操作能构造的串的最小长度,其实转移只会出现在根节点的出边指向的点中. bfs 预处理出它们之间的距离,即要加入多少个字符,对转移矩阵求 $mid​$ 次幂即可得到用 $mid​$ 次操作的最短距离. 时间复杂度 $O(|\sum|\cdot |T|+|\sum|^3\log^2 n)$ ,其中 $|\sum|$ 代表字符集大小. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(ll x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(ll x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int N = 2e5 + 10, S = 4, inf = 1e9;const ll INF = 4e18;int n, idx = 1, lst = 1, len[N], fa[N], ch[N][S];char buf[N];void Extend(int c)&#123; int p = lst, np = ++idx; lst = np; len[np] = len[p] + 1; while (p &amp;&amp; ch[p][c] == 0) ch[p][c] = np, p = fa[p]; if (!p) fa[np] = 1; else &#123; int q = ch[p][c]; if (len[q] == len[p] + 1) fa[np] = q; else &#123; int nq = ++idx; len[nq] = len[p] + 1; fa[nq] = fa[q], fa[q] = fa[np] = nq; memcpy(ch[nq], ch[q], sizeof ch[nq]); while (p &amp;&amp; ch[p][c] == q) ch[p][c] = nq, p = fa[p]; &#125; &#125;&#125;struct Martix&#123; ll v[S][S]; Martix() &#123; for (int i = 0; i &lt; S; ++i) for (int j = 0; j &lt; S; ++j) v[i][j] = INF; &#125; Martix operator * (const Martix &amp;rhs) const &#123; Martix res; for (int i = 0; i &lt; S; ++i) for (int k = 0; k &lt; S; ++k) if (v[i][k] &lt; INF) for (int j = 0; j &lt; S; ++j) if (rhs.v[k][j] &lt; INF) res.v[i][j] = min(res.v[i][j], v[i][k] + rhs.v[k][j]); return res; &#125;&#125; A, tmp;Martix fpow(Martix a, ll b)&#123; Martix res; for (int i = 0; i &lt; S; ++i) res.v[i][i] = 0; while (b) &#123; if (b &amp; 1LL) res = res * a; a = a * a; b &gt;&gt;= 1; &#125; return res;&#125;int dis[N], vis[N];queue&lt;int&gt; q;void bfs(int id, int st)&#123; for (int i = 1; i &lt;= idx; ++i) vis[i] = 0, dis[i] = inf; vis[S] = 1, dis[st] = 0, q.push(st); while (!q.empty()) &#123; int x = q.front(); q.pop(); for (int i = 0; i &lt; S; ++i) if (!vis[ch[x][i]]) &#123; if (!ch[x][i]) A.v[id][i] = min(A.v[id][i], 1LL * dis[x] + 1); else &#123; vis[ch[x][i]] = 1; dis[ch[x][i]] = dis[x] + 1; q.push(ch[x][i]); &#125; &#125; &#125;&#125;ll solve(ll k)&#123; tmp = fpow(A, k); ll mi = INF; for (int i = 0; i &lt; S; ++i) for (int j = 0; j &lt; S; ++j) mi = min(mi, tmp.v[i][j]); return mi;&#125;int main()&#123; ll len = read(); scanf("%s", buf + 1); n = strlen(buf + 1); for (int i = 1; i &lt;= n; ++i) Extend(buf[i] - 'A'); for (int i = 0; i &lt; S; ++i) bfs(i, ch[1][i]); ll L = 1, R = len, ans; while (L &lt;= R) &#123; ll mid = (L + R) &gt;&gt; 1; if (solve(mid) &lt;= len) ans = mid, L = mid + 1; else R = mid - 1; &#125; if (solve(ans) &lt; len) ++ans; write(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>矩阵加速</tag>
        <tag>SAM</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2255 炸弹]]></title>
    <url>%2F2020%2F05%2F26%2FLoj-2255-%E7%82%B8%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[tarjan 求 SCC. 若 $i$ 能炸到 $j$ ,就从 $i$ 向 $j$ 连一条边,那么 $i$ 的答案就是从 $i$ 出发能到的点的数目 直接做传递闭包的时间复杂度为 $O(\frac{n^3}{w})$ . 注意到一个点能炸到的点一定是一段连续区间,可以用 $l_i,r_i$ 表示. 用 tarjan 求出每个 SCC,缩点之后变成一张 DAG, 在 DAG 上按照拓扑序逆序 dp 更新 $l,r$ 即可. 如果直接暴力连边,边数是 $O(n^2)$ 的,可以用线段树优化到 $O(n\log n)$ . 进一步优化,注意到对于炸弹 $i$ ,从左边连向它的边中,只需要保留距离它最近的点连来的边,右边也是一样. 因为更左边的点若能炸到 $i$ ,那么也一定能炸到左边最近能炸到 $i​$ 的点,就可以传递过来了. 时间复杂度 $O(n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int P = 1e9 + 7;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;const int N = 5e5 + 10;int n, stk[N], tp = 0, lb[N], rb[N], dfn[N], low[N], in[N], bel[N];int idx = 0, tot = 0;ll X[N], R[N];vector&lt;int&gt; G[N], scc_G[N];void tarjan(int u)&#123; dfn[u] = low[u] = ++idx; stk[++tp] = u, in[u] = 1; for (int v : G[u]) &#123; if (!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if (in[v]) low[u] = min(low[u], dfn[v]); &#125; if (dfn[u] == low[u]) &#123; ++tot; int x = 0; while (x != u) &#123; x = stk[tp--]; bel[x] = tot; lb[tot] = min(lb[tot], x), rb[tot] = max(rb[tot], x); in[x] = 0; &#125; &#125;&#125;int vis[N];void calc(int x)&#123; vis[x] = 1; for (int y : scc_G[x]) &#123; if (!vis[y]) calc(y); lb[x] = min(lb[x], lb[y]); rb[x] = max(rb[x], rb[y]); &#125;&#125;int main()&#123; n = read(); for (int i = 1; i &lt;= n; ++i) X[i] = read(), R[i] = read(); tp = 0; for (int i = 1; i &lt;= n; ++i) &#123; while (tp &amp;&amp; X[stk[tp]] + R[stk[tp]] &lt; X[i]) --tp; if (tp) G[stk[tp]].push_back(i); while (tp &amp;&amp; X[stk[tp]] + R[stk[tp]] &lt;= X[i] + R[i]) --tp; stk[++tp] = i; &#125; tp = 0; for (int i = n; i &gt;= 1; --i) &#123; while (tp &amp;&amp; X[stk[tp]] - R[stk[tp]] &gt; X[i]) --tp; if (tp) G[stk[tp]].push_back(i); while (tp &amp;&amp; X[stk[tp]] - R[stk[tp]] &gt;= X[i] - R[i]) --tp; stk[++tp] = i; &#125; for (int i = 1; i &lt;= n; ++i) lb[i] = n + 1, rb[i] = 0; tp = 0; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= n; ++i) for (int j : G[i]) scc_G[bel[i]].push_back(bel[j]); for (int i = 1; i &lt;= tot; ++i) if (!vis[i]) calc(i); int ans = 0; for (int i = 1; i &lt;= n; ++i) inc(ans, mul(i, rb[bel[i]] - lb[bel[i]] + 1)); write(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[倍增FFT]]></title>
    <url>%2F2020%2F05%2F26%2F%E5%80%8D%E5%A2%9EFFT%2F</url>
    <content type="text"><![CDATA[已知关于 $x​$ 的多项式 $\prod_{i=1}^k (x+i)​$ 的各项系数,欲求 $\prod_{i=k+1}^{2k} (x+i)​$ 的各项系数. 做法记 $F(x)=\prod_{i=1}^k (x+i)=\sum_{i=0}^k c_i\cdot x^i, G(x)=\prod_{i=k+1}^{2k} (x+i)$ ,则$$\begin{aligned}G(x)&amp;=F(x+k) \\&amp;=\sum_{i=0}^k c_i\cdot (x+k)^i \\&amp;=\sum_{i=0}^k c_i\cdot \sum_{j=0}^i \binom i j k^{i-j}x^j \\&amp;=\sum_{j=0}^k \frac {k^{-j}} {j!}\cdot x^j\cdot \sum_{i=j}^k (c_i\cdot k^i\cdot i!)\cdot \frac 1 {(i-j)!}\end{aligned}$$对着系数稍微构造一下向量 $a,b$ 就可以得到$$G(x)=\sum_{j=0}^k \frac {k^{-j}} {j!}\cdot x^j\cdot \sum_{i=0}^{2k} a_i\cdot b_{j+k-i}$$于是对 $a,b$ 做一次卷积即可算出 $G(x)$ 的各项系数,时间复杂度 $O(k\log k)$ . 应用求多项式 $F(x)=\prod_{i=1}^n (x+i)$ 的各项系数. 若直接用分治 FFT 求解, 时间复杂度 $O(n\log^2 n)$ . 考虑像快速幂那样倍增去做,记 $m=\lfloor \frac{n}{2}\rfloor$ . 先求出 $\prod_{i=1}^m (x+i)​$ 的各项系数,用上面的做法 $O(m\log m)​$ 推出 $\prod_{i=m+1}^{2m} (x+i)​$ 的各项系数. $O(m\log m)$ 将它们乘起来得到 $\prod_{i=1}^{2m} (x+i)$ 的各项系数,若 $n$ 为奇数,再暴力乘上 $(x+n)$ 这个单项式. 时间复杂度 $T(n)=T(\frac n 2)+O(n\log n) = O(n\log n)$ .]]></content>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2552 假面]]></title>
    <url>%2F2020%2F05%2F24%2FLoj-2552-%E5%81%87%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[背包. 考虑对每个人 $i$ ,维护 $p(i,j)$ 表示他剩余了 $j$ 点生命值的概率. 对于一次锁定操作,更新对应的 $p(i)$ 即可. 对于一次结界操作,考虑 $i$ 被命中的概率,需要算出除 $i$ 之外还有 $x$ 个人存活的概率 $q(i,x)$ 来统计答案. 先算出 $q(0,x)$ 表示有 $x$ 个人存活的概率,相当于做了一个背包,要算 $q(i)$ 时,将 $i$ 的贡献从 $q(0)$ 中撤掉即可. 初始生命值 $m_i$ 可以看做与 $n$ 同阶,时间复杂度 $O(qn+n^2C)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int P = 998244353;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a, int b)&#123; int res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res;&#125;const int N = 200 + 10;int n, Q, mx[N], p[N][N], q[N], tmp[N], inv[N];void modify()&#123; int x = read(), up = read(), down = read(); int Pr = mul(up, fpow(down, P - 2)); // pr of get attacked for (int i = 0; i &lt;= mx[x]; ++i) &#123; if (i == 0) p[x][i] = add(mul(Pr, p[x][i + 1]), p[x][i]); else p[x][i] = add(mul(Pr, p[x][i + 1]), mul(add(1, P - Pr), p[x][i])); &#125;&#125;int t[N];void query()&#123; for (int i = 1; i &lt;= n; ++i) q[i] = 0; q[0] = 1; int k = read(); for (int i = 1; i &lt;= k; ++i) t[i] = read(); for (int i = 1; i &lt;= k; ++i) &#123; int Pr = add(1, P - p[t[i]][0]); // pr of alive if (!Pr) continue; for (int j = n; j &gt;= 0; --j) &#123; inc(q[j + 1], mul(q[j], Pr)); q[j] = mul(q[j], add(1, P - Pr)); &#125; &#125; for (int i = 0; i &lt;= n; ++i) tmp[i] = q[i]; for (int i = 1; i &lt;= k; ++i) &#123; int Pr = add(1, P - p[t[i]][0]); if (!Pr) &#123; write(0, ' '); continue; &#125; if (Pr == 1) &#123; for (int j = 0; j &lt;= n; ++j) q[j] = q[j + 1]; &#125; else &#123; int inv_iPr = fpow(add(1, P - Pr), P - 2); for (int j = 0; j &lt;= n; ++j) &#123; q[j] = mul(q[j], inv_iPr); inc(q[j + 1], P - mul(q[j], Pr)); &#125; &#125; int ans = 0; for (int x = 0; x &lt; n; ++x) inc(ans, mul(Pr, mul(q[x], inv[x + 1]))); write(ans, ' '); for (int j = 0; j &lt;= n; ++j) q[j] = tmp[j]; &#125; puts("");&#125;int main()&#123; n = read(); for (int i = 1; i &lt;= n; ++i) &#123; p[i][mx[i] = read()] = 1; inv[i] = i &gt; 1 ? mul(P - P / i, inv[P % i]) : 1; &#125; int Q = read(); while (Q--) &#123; int op = read(); if (op == 0) modify(); else query(); &#125; for (int i = 1; i &lt;= n; ++i) &#123; int s = 0; for (int j = 0; j &lt;= mx[i]; ++j) inc(s, mul(p[i][j], j)); write(s, ' '); &#125; puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>概率/期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2589 Count on a tree II]]></title>
    <url>%2F2020%2F05%2F22%2Fbzoj-2589-Count-on-a-tree-II%2F</url>
    <content type="text"><![CDATA[树上分块. 只查询树上路径信息时,可以在树上随机撒 $O(\sqrt n)$ 个关键点,复杂度是对的. 查询路径 $(x,y)$ 时,先从 $x,y$ 向上跳到两个最近的关键点,用预处理的这两个点之间的信息加上其余部分得到信息. 先预处理出任意两个关键点路径上的颜色数目. 对于零散部分,需要检查每种颜色是否在两个关键点路径上出现过,若未出现,则需要将它加入贡献. 为了支持查询,需要维护一个可持久化数组,修改有 $O(n)$ 次,查询有 $O(n\sqrt n)$ 次. 可以直接上一个主席树,时间复杂度 $O(n\sqrt n \log n)$ . 由于查询次数较多,可以考虑根号平衡,用可持久化分块做到修改 $O(\sqrt n)$ ,查询 $O(1)$ ,时间复杂度 $O(n\sqrt n)$ .]]></content>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2494 寻宝游戏]]></title>
    <url>%2F2020%2F05%2F22%2FLoj-2494-%E5%AF%BB%E5%AE%9D%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[巧妙的构造. 若第 $i$ 个数之前的运算符号是 or ,就将这个位置记作 0, 否则记作 1. 依次连接可以得到一个二进制数 $x$ ,规定第 $n$ 个运算符号对应的数为最高位. 对于第 $i$ 列的所有数,也可以顺次连接得到一个二进制数 $b_i$ ,规定第 $n$ 行的那个数为最高位. 于是可以发现运算结果第 $i$ 位为 1, 当且仅当 $b_i&lt;x$ . 先将所有 $b_i$ 排个序,得到它们的大小关系. 对于每个询问,找出 1 的那些位上最小的 $b_i$ ,找出 0 那些位上最大的 $b_i$ ,即可算出方案数. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int P = 1e9 + 7;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;const int N = 1e3 + 10, M = 5e3 + 10;int n, m, q, a[N][M], rnk[M];struct info&#123; int id, val; int b[N]; bool operator &lt; (const info &amp;rhs) const &#123; for (int i = 1; i &lt;= n; ++i) if (b[i] != rhs.b[i]) return b[i] &lt; rhs.b[i]; return false; &#125;&#125; p[M];char buf[M];int main()&#123; n = read(), m = read(), q = read(); int mx = 1; for (int i = 1; i &lt;= n; ++i) &#123; inc(mx, mx); scanf("%s", buf + 1); for (int j = 1; j &lt;= m; ++j) a[i][j] = buf[j] - '0'; &#125; for (int j = 1; j &lt;= m; ++j) &#123; p[j].id = j, p[j].val = 0; for (int i = n; i &gt;= 1; --i) &#123; p[j].b[n + 1 - i] = a[i][j]; inc(p[j].val, p[j].val); inc(p[j].val, a[i][j]); &#125; &#125; sort(p + 1, p + 1 + m); for (int i = 1; i &lt;= m; ++i) rnk[p[i].id] = i; while (q--) &#123; scanf("%s", buf + 1); int L = 0, R = mx, pos0 = 0, pos1 = m + 1; for (int i = 1; i &lt;= m; ++i) if (buf[i] == '0') pos0 = max(pos0, rnk[i]); else pos1 = min(pos1, rnk[i]); if (pos0 &gt; pos1) write(0, '\n'); else &#123; if (pos0 != 0) L = p[pos0].val; if (pos1 != m + 1) R = p[pos1].val; write(add(R, P - L), '\n'); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2540 随机算法]]></title>
    <url>%2F2020%2F05%2F21%2FLoj-2540-%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[状压 dp. 由于图的点数比较少,所以可以先 $O(2^n)$ 把真实的最大独立集大小给算出来,然后算有几个集合使得答案等于它. 设 $dp(S,i)$ 表示当前排列中已经加入的元素集合为 $S$ ,算出的独立集大小为 $i$ 的方案数. 转移时,考虑将一个点 $x$ 加入独立集中,记 $x$ 以及它所有邻居构成的集合为 $T$ . 那么 $x$ 必须是 $T-S$ 中第一个出现的元素,转移有$$dp(S\cup T,i+1)\leftarrow dp(S,i)\cdot A_{n-|S|}^{|T-S|}\cdot \frac{1}{|T-S|}$$ $T-S$ 表示 $S$ 在 $T$ 中的相对补集,即在集合 $T$ 中,但不在集合 $S$ 中的所有元素构成的集合. 时间复杂度 $O(m+2^n\cdot n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; if (x &lt; 0) putchar('-'), x = -x; print(x); putchar(c);&#125;const int P = 998244353;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a, int b)&#123; int res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res % P;&#125;const int N = 20;int n, m, popc[1 &lt;&lt; N], dp[1 &lt;&lt; N][N + 1], nxt[N], mx;int fac[N + 1], invfac[N + 1];int A(int x, int y)&#123; return mul(fac[x], invfac[x - y]);&#125;int main()&#123; n = read(), m = read(); fac[0] = 1; for (int i = 1; i &lt;= n; ++i) fac[i] = mul(fac[i - 1], i); invfac[n] = fpow(fac[n], P - 2); for (int i = n - 1; i &gt;= 0; --i) invfac[i] = mul(invfac[i + 1], i + 1); for (int i = 1; i &lt;= m; ++i) &#123; int u = read() - 1, v = read() - 1; nxt[u] |= 1 &lt;&lt; v; nxt[v] |= 1 &lt;&lt; u; &#125; for (int i = 0; i &lt; n; ++i) nxt[i] |= 1 &lt;&lt; i; for (int S = 1; S &lt; (1 &lt;&lt; n); ++S) &#123; popc[S] = popc[S &gt;&gt; 1] + (S &amp; 1); bool f = true; for (int i = 0; i &lt; n &amp;&amp; f; ++i) if (S &gt;&gt; i &amp; 1) f &amp;= (popc[S &amp; nxt[i]] == 1); if (f) mx = max(mx, popc[S]); &#125; dp[0][0] = 1; for (int S = 0; S &lt; (1 &lt;&lt; n); ++S) for (int i = 0; i &lt; mx; ++i) if (dp[S][i]) for (int x = 0; x &lt; n; ++x) if (!(S &gt;&gt; x &amp; 1)) &#123; int T = nxt[x]; int c = A(n - popc[S] - 1, popc[T] - popc[T &amp; S] - 1); inc(dp[S | T][i + 1], mul(dp[S][i], c)); &#125; int ans = mul(dp[(1 &lt;&lt; n) - 1][mx], invfac[n]); write(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2538 Slay the Spire]]></title>
    <url>%2F2020%2F05%2F21%2FLoj-2538-Slay-the-Spire%2F</url>
    <content type="text"><![CDATA[贪心 + dp 计数. 首先,对于给定 $m$ 张牌,由于强化牌的值都 $&gt;1$ ,所以我们可以贪心制定以下打牌策略: 若没有攻击牌,则无论怎么打,伤害值都是 $0$ . 若强化牌 $&lt;k$ 张,则先打出所有强化牌,再从大到小打出攻击牌,直到一共打出 $k$ 张. 若强化牌 $\ge k$ 张,则先从大到小打出 $k-1$ 张强化牌,再打出一张最大的攻击牌. 设 $F(i,j)$ 表示抽了 $i$ 张强化牌,按最优策略打出 $j$ 张时每种方案权值乘积之和. 设 $G(i,j)$ 表示抽了 $i$ 张攻击牌,按最优策略打出 $j$ 张时每种方案权值总和之和. 强化牌 $&lt;k$ 张的情况贡献就是 $\sum F(i,i)\cdot G(m-i,k-i)$ . 强化牌 $\ge k$ 张的情况贡献就是 $\sum F(i,k-1)\cdot G(m-i,1)$ . 只需要考虑 $F,G$ 怎么求. 设 $f(i,j)$ 表示打了 $i$ 张强化牌,权值最小的强化牌是第 $j$ 张的贡献总和,即可求出 $F$ , $G$ 的求法同理. 时间复杂度 $O(n^2)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; print(x); putchar(c);&#125;const int P = 998244353;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a, int b)&#123; int res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res;&#125;const int N = 3e3 + 10;int n, m, k, fac[N], invfac[N], sup[N], atk[N];int binom(int x, int y)&#123; if (x &lt; y || y &lt; 0) return 0; return mul(fac[x], mul(invfac[y], invfac[x - y]));&#125;int f[N][N], g[N][N], sum[N];int F(int x, int y) // choose x, use y&#123; if (!y) return binom(n, x); int res = 0; for (int i = x - y + 1; i &lt;= n - y + 1; ++i) // i used first inc(res, mul(f[y][i], binom(i - 1, x - y))); return res;&#125;int G(int x, int y) // choose x, use y&#123; int res = 0; for (int i = x - y + 1; i &lt;= n - y + 1; ++i) // i used first inc(res, mul(g[y][i], binom(i - 1, x - y))); return res;&#125;void solve()&#123; n = read(), m = read(), k = read(); for (int i = 1; i &lt;= n; ++i) sup[i] = read(); for (int i = 1; i &lt;= n; ++i) atk[i] = read(); sort(sup + 1, sup + 1 + n); sort(atk + 1, atk + 1 + n); for (int i = 1; i &lt;= n; ++i) &#123; f[1][i] = sup[i]; sum[i] = add(sum[i - 1], f[1][i]); &#125; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n - i + 1; ++j) f[i][j] = mul(sup[j], add(sum[n], P - sum[j])); for (int j = 1; j &lt;= n; ++j) &#123; if (j &lt;= n - i + 1) sum[j] = add(sum[j - 1], f[i][j]); else sum[j] = sum[j - 1]; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; g[1][i] = atk[i]; sum[i] = add(sum[i - 1], g[1][i]); &#125; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n - i + 1; ++j) g[i][j] = add(mul(atk[j], binom(n - j, i - 1)), add(sum[n], P - sum[j])); for (int j = 1; j &lt;= n; ++j) &#123; if (j &lt;= n - i + 1) sum[j] = add(sum[j - 1], g[i][j]); else sum[j] = sum[j - 1]; &#125; &#125; int ans = 0; for (int i = 0; i &lt; m; ++i) if (i &lt; k) inc(ans, mul(F(i, i), G(m - i, k - i))); else inc(ans, mul(F(i, k - 1), G(m - i, 1))); write(ans, '\n');&#125;int main()&#123; fac[0] = 1; for (int i = 1; i &lt;= 3000; ++i) fac[i] = mul(fac[i - 1], i); invfac[3000] = fpow(fac[3000], P - 2); for (int i = 3000 - 1; i &gt;= 0; --i) invfac[i] = mul(invfac[i + 1], i + 1); int T = read(); while (T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个恒等式的两种证明]]></title>
    <url>%2F2020%2F05%2F20%2F%E4%B8%80%E4%B8%AA%E6%81%92%E7%AD%89%E5%BC%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%AF%81%E6%98%8E%2F</url>
    <content type="text"><![CDATA[$$\sum_{i=1}^n \frac{\binom n i(-1)^{i-1}}i=\sum_{i=1}^n \frac{1}{i}$$ min-max 反演考虑这样一个问题: 有一个可重集合,初始为空,每次从 $[1,n]$ 中等概率选择一个整数加入集合. 问期望操作多少次能使得 $[1,n]$ 中每个整数都在集合中. 设 $E(i)$ 表示集合中已经有 $i$ 种不同的整数,期望操作多少次能加入一个新的整数,易知 $E(i)=\frac {n} {n-i}$ . 这个问题的答案就是$$ans=\sum_{i=0}^{n-1} E(i)=n\cdot \sum_{i=1}^n \frac{1}{i}$$考虑用另一种方法求解这个问题,根据 min-max 反演可知$$ans=\sum_{i=1}^{n}\binom n i(-1)^{i-1}\cdot \frac{n}{i}$$于是可得$$\sum_{i=1}^n \frac{\binom n i(-1)^{i-1}}i=\sum_{i=1}^n \frac{1}{i}$$ 积分构造一个函数$$f(x)=\frac{1-(1-x)^n}{x}$$考虑 $f(x)$ 在区间 $[0,1]$ 上的定积分 $s$ ,$$s=\int_0^1 \frac{1-(1-x)^n}{x} {\rm d}x$$用第一类换元法,令 $t=1-x$ ,可得$$\begin{aligned}s&amp;=\int_0^1\frac{1-t^n}{1-t} {\rm d}t \\&amp;=\int_0^1(\sum_{i=0}^{n-1}t^i){\rm d}t \\&amp;=\sum_{i=1}^n\frac 1 i\end{aligned}$$若利用二项式定理直接进行积分,$$\begin{aligned}s&amp;=\int_0^1 \frac{1-(1-x)^n}{x} {\rm d}x \\&amp;=\int_0^1 \frac{1-\sum_{i=0}^n\binom n i(-1)^ix^i}{x} {\rm d}x\\&amp;=\int_0^1{\sum_{i=1}^n\binom n i (-1)^{i-1}x^{i-1}} {\rm d}x\\&amp;=\sum_{i=1}^n \frac{\binom n i(-1)^{i-1}}i\end{aligned}$$于是可知$$\sum_{i=1}^n \frac{\binom n i(-1)^{i-1}}i=\sum_{i=1}^n \frac{1}{i}$$]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4381 Odwiedziny]]></title>
    <url>%2F2020%2F05%2F19%2Fbzoj-4381-Odwiedziny%2F</url>
    <content type="text"><![CDATA[根号分治. 先预处理倍增数组用于支持查询 LCA, 预处理和查询 LCA 的时间复杂度为 $O(n\log n + m\log n)$ . $k\le \sqrt n$预处理出 $nxt(x,i)$ 表示从 $x$ 向上跳 $i$ 步走到的点, $sum(x,i)$ 表示从 $x$ 向上每次跳 $i$ 步经过的点权和. 于是询问时就可以做到 $O(1)$ 回答. 这部分的时间复杂度为 $O(m\sqrt n)$ . $k&gt; \sqrt n$对于 $k&gt;\sqrt n$ 的询问,显然跳的步数不会超过 $\sqrt n$ ,每次用倍增找出要跳到的下一个点,更新答案即可. 这部分的时间复杂度为 $O(m\sqrt n\log n)$ . 适当调整可以发现,若我们对 $k\le b,k&gt;b$ 分别执行以上两种算法,两部分总时间复杂度为 $O(mb+m\frac n b\cdot \log n)$ . 取 $b=\sqrt {n\log n}​$ 即可做到 $O(m\sqrt{n\log n})​$ ,再算上求 LCA 部分,复杂度为 $O(m\sqrt {n\log n}+(m+n)\log n)​$ . 然而这只是理论复杂度,实现时由于常数等原因需要自己调节参数以取得更好的效果… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; print(x); putchar(c);&#125;const int N = 5e4 + 10, K = 16, S = 200 + 10;int n, m, B, a[N], b[N], c[N], fa[N][K], dep[N], ans[N];vector&lt;int&gt; G[N];int nxt[N][S], sum[N][S];void dfs(int u, int F)&#123; fa[u][0] = F; for (int i = 1; (1 &lt;&lt; i) &lt;= dep[u]; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1]; nxt[u][1] = F, sum[u][1] = sum[F][1] + a[u]; for (int i = 2; i &lt;= B; ++i) &#123; nxt[u][i] = nxt[F][i - 1]; sum[u][i] = sum[nxt[u][i]][i] + a[u]; &#125; for (int v : G[u]) if (v != F) &#123; dep[v] = dep[u] + 1; dfs(v, u); &#125;&#125;int jump(int x, int k)&#123; for (int i = K - 1; i &gt;= 0; --i) if ((1 &lt;&lt; i) &lt;= k) x = fa[x][i], k -= 1 &lt;&lt; i; return x;&#125;struct info&#123; int x, y, k, id; bool operator &lt; (const info &amp;rhs) const &#123; return k &lt; rhs.k; &#125;&#125; q[N];int LCA(int x, int y)&#123; if (dep[x] &lt; dep[y]) swap(x, y); for (int i = K - 1; i &gt;= 0; --i) if ((1 &lt;&lt; i) &lt;= dep[x] - dep[y]) x = fa[x][i]; if (x == y) return x; for (int i = K - 1; i &gt;= 0; --i) if ((1 &lt;&lt; i) &lt;= dep[x] &amp;&amp; fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i]; return fa[x][0];&#125;int bf(int x, int y, int k)&#123; if (x == y) return a[x]; int s = a[x], lca = LCA(x, y); while (dep[x] - dep[lca] &gt; k) &#123; x = jump(x, k); s += a[x]; &#125; int p = dep[x] + dep[y] - 2 * dep[lca]; if (p &lt;= k) return s + a[y]; p -= k; while (1) &#123; if (p &lt;= 0) return s + a[y]; s += a[jump(y, p)]; p -= k; &#125; return s;&#125;int query(int x, int y, int k)&#123; int s = 0, lca = LCA(x, y); int d = dep[x] - dep[lca]; if (d &gt;= k) &#123; d -= d % k; s += sum[x][k]; x = jump(x, d); s -= sum[nxt[x][k]][k]; &#125; else s += a[x]; if (lca == y) return s; int p = dep[x] + dep[y] - 2 * dep[lca]; if (p &lt;= k) return s + a[y]; int z = jump(y, (p - 1) % k + 1); int w = jump(y, p - k); s += a[y]; s += sum[z][k], s -= sum[nxt[w][k]][k]; return s;&#125;int main()&#123; n = read(); B = sqrt(n / 4); for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1, 0); for (int i = 1; i &lt;= n; ++i) b[i] = read(); for (int i = 1; i &lt;= n - 1; ++i) &#123; c[i] = read(); if (c[i] &lt;= B) write(query(b[i], b[i + 1], c[i]), '\n'); else write(bf(b[i], b[i + 1], c[i]), '\n'); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>根号分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4320 ShangHai2006 Homework]]></title>
    <url>%2F2020%2F05%2F19%2Fbzoj-4320-ShangHai2006-Homework%2F</url>
    <content type="text"><![CDATA[根号分治 + 根号平衡. 记 $K=3\times 10^5$ ,对于 $\le \sqrt K$ 的模数 $Y$ ,每次加入一个 $X$ 的时候都暴力更新一下它们的答案,就可以 $O(1)$ 回答. 这部分的时间复杂度是 $O(n\sqrt K)$ . 对于 $&gt;\sqrt K$ 的模数 $Y$ ,可知 $\lfloor \frac X Y\rfloor \le \sqrt K$ ,而 $X\bmod Y=X-\lfloor \frac X Y\rfloor\cdot Y$ . 于是每次询问时,可以枚举 $\lfloor \frac X Y\rfloor$ 的值,询问在某段区间 $[L,R]$ 中出现过的最小的 $X$ . 归纳一下,我们需要维护一个集合,要插入 $O(n)$ 个数,查询 $O(n\sqrt K)$ 次某个数的后继. 直接用 set 维护会多一个 log, 考虑根号平衡,实现 $O(\sqrt K)$ 插入, $O(1)$ 询问后继. 对值域分块,对每个位置维护块内的后继,对每个块维护该块右端点的后继即可. 于是这部分的时间复杂度也是 $O(n\sqrt K)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;void print(int x)&#123; if (x &gt;= 10) print(x / 10); putchar('0' + x % 10);&#125;void write(int x, char c)&#123; print(x); putchar(c);&#125;const int N = 3e5 + 10, S = 550;int n, m, B, bel[N], lp[S], rp[S], suc[S], inner_suc[N], ans[S];void upd(int x)&#123; for (int y = 1; y &lt;= B; ++y) ans[y] = min(ans[y], x % y); for (int i = 1; i &lt; bel[x]; ++i) suc[i] = min(suc[i], x); for (int i = lp[bel[x]]; i &lt;= x; ++i) inner_suc[i] = min(inner_suc[i], x);&#125;int query(int y)&#123; if (y &lt;= B) return ans[y]; int res = n + 1; for (int k = 0; y * k &lt;= n; ++k) &#123; int L = y * k, R = y * (k + 1) - 1; L = max(L, 1); R = min(R, n); int x = min(suc[bel[L]], inner_suc[L]); if (x &lt;= R) res = min(res, x % y); &#125; return res;&#125;int main()&#123; n = 300000, m = read(); B = sqrt(n); for (int i = 1; i &lt;= n; ++i) &#123; bel[i] = (i - 1) / B + 1; lp[bel[i]] = (bel[i] - 1) * B + 1; rp[bel[i]] = bel[i] * B; suc[bel[i]] = n + 1; inner_suc[i] = n + 1; &#125; rp[bel[n]] = n; for (int i = 1; i &lt;= B; ++i) ans[i] = n + 1; for (int i = 1; i &lt;= m; ++i) &#123; char buf[10]; scanf("%s", buf); if (buf[0] == 'A') upd(read()); else write(query(read()), '\n'); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JOI 2019 Final]]></title>
    <url>%2F2020%2F05%2F19%2FJOI-2019-Final%2F</url>
    <content type="text"><![CDATA[JOI 2019 Final 选做. 「JOI 2019 Final」勇者比太郎枚举 $(i,j)$ ,合法的 $k,l$ 的数目用预处理的后缀和算一下就行了,时间复杂度 $O(n^2)$ . code 「JOI 2019 Final」画展容易发现,若最多有 $k$ 幅画展出,那么一定存在一组解,满足使用的画框是大小前 $k$ 大的. 将画框按大小从大到小排序,画按照美观度为第一关键字,大小为第二关键字从大到小排序. 贪心匹配即可,若当前画能放入未被使用的最大画框中,就将其放入,时间复杂度 $O(n\log n)$ . code 「JOI 2019 Final」有趣的家庭菜园 3对最后的序列 dp ,设 $dp(i,j,k,lst)$ 表示红,绿,黄分别已经用了 $i,j,k$ 个,上一个元素的颜色是 $lst$ 时的最小花费. 显然将原序列移动到最终序列后,同一种颜色的叶子相对顺序不会改变,于是可以 $O(1)$ 计算出每次转移的花费. 时间复杂度 $O(n^3)$ . code 「JOI 2019 Final」硬币收藏首先可以把每个硬币都移动到最近的在矩形中的点,再考虑通过移动使得每个位置恰有 $1$ 个硬币. 记 $d$ 表示各个位置还需要多少硬币,从左往右考虑每一列,若该列的两个 $d$ 一正一负,就移动到其中一者为 $0$ . 然后将多余的 $d$ 分给下一列即可,时间复杂度 $O(n)$ . code 「JOI 2019 Final」独特的城市记树的某条直径为 $S-T$ ,则对于一个点 $x$ ,能对它造成贡献的点,一定都在 $x$ 到 $S,T$ 中较远的那个点的路径上. 否则,若还有其他点能对 $x$ 造成贡献,那么它到 $x$ 的距离一定大于 $x$ 到 $S,T$ 的距离,可以构造出更长的直径. 以 $S$ 为根做一次 dfs ,对每个 $x$ ,统计一下 $S\to x$ 路径上有几个点能对 $x$ 造成贡献,再以 $T$ 为根做一次同样的 dfs . 对于同一个 $x$ 的两次 dfs ,假设 $x$ 到 $S$ 更远,那么 $T$ 那一次的 dfs 计入贡献的点就是 $S$ 那一次计入贡献的点的子集. 那么把两次的答案取 $\max$ 就是实际的答案. dfs 时,用一个栈维护根到当前节点路径中,能造成贡献的点,开一个桶记录每种权值出现次数. 往栈中加点或者删点的时候,更新桶,并且更新当前答案,类似于莫队增加或删除端点时的操作. 假设当前已经处理了 $x$ 的答案,需要继续向下 dfs . 为了保证栈中点都是有贡献的,要先把栈中与 $x$ 距离小于等于 $x$ 到其它子树中最深的点的所有点删掉. 先往最深点的方向走,再往其它儿子走,删除操作就不用被撤销掉了. 每个点只会对它的父亲贡献 $O(1)$ 次进出栈操作,时间复杂度 $O(n)​$ . code]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1355]]></title>
    <url>%2F2020%2F05%2F18%2FCF1355%2F</url>
    <content type="text"><![CDATA[$Div.2$ ,被炸鱼了. A Sequence with Digits直接按照题意暴力做,当某一位为 $0$ 时,后面操作都没用了,退出即可. 操作次数显然不会太多. B Young Explorers显然尽量先用 $e_i$ 比较小的人,记录一下剩了几个人,和后面的人一起用即可. C Count Triangles枚举 $z$ ,计算有多少对 $x+y&gt;z$ ,分类讨论一下计算贡献即可. 也可以直接 FFT, 把 $x,y$ 对应的生成函数给卷起来计算 $x+y&gt;z$ 的有多少对. D Game With Array当 $S\ge 2N$ 时,可以构造出所有数都 $\ge 2$ 的方案,然后令 $K=1$ 即可. 否则显然无解. E Restorer Distance记最后所有数都变成了 $x$ ,那么答案关于 $x$ 显然是一个先降后升的单峰函数. 三分,对于某个 $x$ ,算一下需要执行多少次 $+1$ ,多少次 $-1$ . 若 $M&lt;A+B$ ,就用 $M$ 操作先尽可能抵消,剩下的用 $A,B$ 操作完成即可. F Guess Divisors Count如果能求出 $X​$ 各个质因子的次数,就能得到答案了,但 $10^9​$ 内质数太多,无法准确询问出每一个质因子的次数. 考虑只确定 $\le p$ 的质数是否在 $X$ 中出现,记这部分质数乘积为 $X_1$ ,那么 $&gt; p$ 的出现过的质数乘积 $X_2\le \frac{10^9}{X_1}$ . 当 $X_1\cdot p^3\ge 10^9$ 时,可以确定 $X_2$ 中含有的质因子个数不会超过 $2$ ,否则 $X_1\cdot X_2&gt; X_1\cdot p^3\ge 10^9$ ,不合法. 那么 $X_2$ 部分的贡献不会超过 $4$ ,求出 $X_1$ 部分贡献后乘上 $2$ ,即可保证相对误差在 $2$ 倍内. 分类讨论一下,若 $X_1\le 3$ ,直接令 $X_1$ 部分贡献为 $4$ ,可以利用绝对误差 $\le 7$ 的标准通过测试. 若 $X_1&gt; 3$ ,取 $p=630$ 有 $X_1\cdot p^3\ge 10^9$ ,如果对 $630$ 内所有质数都确定是否出现,需要 $19$ 次询问. 如果得到的 $X_1$ 只有不超过 $2$ 个质因数,我们用 $1$ 次询问即可确定它们具体的次数. 否则, $X_1$ 至少为 $2\times 3\times 5$ ,此时 $p\le 330$ , $11$ 次询问即可确定出现情况,再用 $\omega(X)\le 9$ 次询问确定具体次数. 这两种情况的询问次数都不会超过 $20$ . 最坏情况是 $X_1=1$ ,此时需要对 $\le 1001$ 内每个质数确定是否出现,经验算恰好需要 $22$ 次询问.]]></content>
      <tags>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>codeforces</tag>
        <tag>非传统题</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2743 摩天大楼]]></title>
    <url>%2F2020%2F05%2F15%2FLoj-2743-%E6%91%A9%E5%A4%A9%E5%A4%A7%E6%A5%BC%2F</url>
    <content type="text"><![CDATA[dp 计数问题. 考虑将所有 $A_i$ 从小到大排序,依次插入到序列中,并对合法的方案数计数. 设 $dp(i,j,k,h)$ 表示插入了前 $i$ 个数,分成了 $j$ 段,已确定的元素差值之和为 $k$ ,即下图中 $y=A_i$ 直线下方部分长度,已经钦定了 $h$ 个左右边界 $(0\le h\le 2)$ 的方案数. 转移加入 $A_{i+1}$ 时,除了边界外,每段的两端都会多出 $(A_{i+1}-A_i)$ 的长度,即 $k$ 的增量为 $(A_{i+1}-A_i)\cdot (2j-h)$ . 再讨论一下 $A_{i+1}$ 插入到两端还是某段中,是否会新建一段,是否钦定为边界这些情况转移,时间复杂度 $O(n^2L)$ . 可以把第一维滚动掉来优化空间. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;const int P = 1e9 + 7;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;const int N = 100 + 10, M = 1000 + 10;int n, L, a[N], dp[2][N][M][3];void trans(int i, int id, int j, int k, int h)&#123; int val = dp[id ^ 1][j][k][h]; int w = k + (a[i] - a[i - 1]) * (2 * j - h); if (w &gt; L) return; inc(dp[id][j + 1][w][h], mul(j + 1 - h, val)); if (j) inc(dp[id][j - 1][w][h], mul(j - 1, val)); inc(dp[id][j][w][h], mul(j * 2 - h, val)); if (h &lt; 2) &#123; if (j) inc(dp[id][j][w][h + 1], mul(2 - h, val)); inc(dp[id][j + 1][w][h + 1], mul(2 - h, val)); &#125;&#125;int main()&#123; n = read(), L = read(); if (n == 1) return puts("1"), 0; for (int i = 1; i &lt;= n; ++i) a[i] = read(); sort(a + 1, a + 1 + n); int id = 0; dp[id][0][0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; id ^= 1; memset(dp[id], 0, sizeof dp[id]); for (int j = 0; j &lt;= i; ++j) for (int k = 0; k &lt;= L; ++k) for (int h = 0; h &lt;= 2; ++h) if (dp[id ^ 1][j][k][h]) trans(i, id, j, k, h); &#125; int ans = 0; for (int k = 0; k &lt;= L; ++k) inc(ans, dp[id][1][k][2]); printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[括号序列问题]]></title>
    <url>%2F2020%2F05%2F11%2F%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[组合数学计数. 求有多少个长度为 $n$ 的括号序列,满足其最长合法括号子序列长度恰好为 $k$ ,答案对 $10^9+7$ 取模. $2\le k\le n\le 2\times 10^5$ ,数据组数 $T\le 2\times 10^5$ . 先考虑对于一个给定的括号序列,如何计算其最长合法括号子序列长度. 把左括号权值设为 $1​$ ,右括号权值设为 $-1​$ ,记 $s​$ 表示这个序列权值的前缀和,则最长合法长度为 $n-s_n+2\min s_i​$ . 简要证明,考虑 $\min s_i$ 对应的位置 $x$ ,之前有 $-s_x$ 个右括号无法匹配,剩下括号都能互相匹配,否则有更小的 $s_i$ . 同理, $x$ 之后有 $s_n-s_x$ 个左括号无法匹配,剩下都能互相匹配,用 $n$ 将两部分不合法的减掉,剩下的就是答案. 再考虑如何统计最长合法长度恰好为 $k$ 的序列长度,我们枚举左右括号分别有多少个, $s_n$ 和 $\min s_i$ 就都确定了. 于是记 $t=\frac{k-n+s_n}{2}$ ,只需要统计 $\min s_i=t$ 的方案数,可以用 $\min s_i\ge t$ 的方案数减掉 $\min s_i\ge t+1$ 的方案数. 限制了 $\min s_i\ge t$ ,相当于从 $(0,0)$ 走到 $(\frac{n-s_n}{2},\frac{n+s_n}{2})$ ,每次向上或向右一步,且不越过直线 $y=x+t$ 的方案数. 这可以容斥成两个组合数,即 $\binom n {(n+s_n)/2}-\binom{n}{n-t+1}$ ,再减掉 $\min s_i \ge t+1$ 的方案数 $\binom n {(n+s_n)/2}-\binom{n}{n-t}$ . 简单整理可以得到贡献为 $\binom{n}{ k /2}-\binom{n}{ k /2 -1}$ ,与我们枚举的 $s_n$ 无关,那么答案就是 $(n-k+1)\cdot (\binom{n}{ k/ 2}-\binom{n}{ k/ 2 -1})$ .]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF932E Team Work]]></title>
    <url>%2F2020%2F05%2F11%2FCF932E-Team-Work%2F</url>
    <content type="text"><![CDATA[第二类斯特林数. 给定 $n\le 10^9,k\le 5000$ ,求 $\sum_{i=0}^n \binom n i i^k$ ,答案对 $10^9+7$ 取模. 把后面的 $i^k$ 用第二类斯特林数展开成组合数的形式.$$\begin{aligned}ans&amp;=\sum_{i=0}^n \binom n i i^k \\&amp;=\sum_{i=0}^n \binom n i \sum_{j=1}^k {k\brace j} i^{\underline j} \\&amp;=\sum_{i=0}^n \binom n i \sum_{j=1}^k {k\brace j} \binom i j\cdot j! \\&amp;=\sum_{j=1}^k {k\brace j}\cdot j!\sum_{i=0}^n \binom n i\binom i j\end{aligned}$$需要对 $\binom n i \binom i j$ 求和,考虑组合意义,可以看成每次从 $n$ 个数中选出若干个数,一共选了 $2$ 次, $2$ 次都被选中的有 $j$ 个. 那么我们可以先找出哪 $j$ 个数 $2$ 次都被选,其他数可以被选 $0$ 次,也可以被选 $1$ 次,得到 $\sum \binom n i \binom i j=2^{n-j}\binom n j$ . 代入得到$$ans=\sum_{j=1}^k {k\brace j}\cdot j!\cdot 2^{n-j}\binom n j$$$O(k^2)$ 预处理出所有的 $k\brace j$ 即可算出答案. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;const int P = 1e9 + 7;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a, int b)&#123; int res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res;&#125;const int N = 5e3 + 10;int n, k, fac[N], s[N][N];int main()&#123; n = read(), k = read(); s[0][0] = 1; for (int i = 1; i &lt;= k; ++i) for (int j = 1; j &lt;= i; ++j) s[i][j] = add(s[i - 1][j - 1], mul(j, s[i - 1][j])); fac[0] = 1; for (int i = 1; i &lt;= k; ++i) fac[i] = mul(fac[i - 1], i); int ans = 0, binom = n; for (int i = 1; i &lt;= k &amp;&amp; i &lt;= n; ++i) &#123; int tmp = mul(s[k][i], fac[i]); tmp = mul(tmp, mul(fpow(2, n - i), binom)); inc(ans, tmp); binom = mul(binom, fpow(i + 1, P - 2)); binom = mul(binom, n - i); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6187 Odd]]></title>
    <url>%2F2020%2F05%2F10%2FLoj-6187-Odd%2F</url>
    <content type="text"><![CDATA[随机化 + 分块维护 hash 表. 每个数出现奇数次有一个比较常用的处理方法,就给每个数随机分配一个较大的权值. 若区间内所有数权值异或和等于区间内所有出现过的数权值异或和,则说明每个数都出现了奇数次. 考虑枚举右端点 $r$ ,统计有几个左端点 $l$ 满足要求. 记 $p(x)$ 表示 $[x,r]$ 所有出现过的数权值异或和,在加入 $r$ 时给 $[lst(a_r)+1,r]$ 内的 $p$ 异或上 $a_r​$ 的权值. 记前缀和 $s(x)$ 表示 $[1,x]$ 内所有数的异或和,在加入 $r$ 时只用计算出 $s(r)$ ,对前面的 $r$ 无影响. 若区间 $[l,r]$ 合法,则有 $p(l)=s(r)\oplus s(l-1)$ ,即 $p(l)\oplus s(l-1)=s(r)$ . 给每个 $l$ 维护出 $val(l)=p(l)\oplus s(l-1)$ ,修改时会给某个区间异或上一个 $v$ ,询问时询问内区间有几个 $v$ . 用分块 + hash 表维护,修改时整块打标记,边角暴力重构,询问时整块直接询问 hash 表,边角暴力重构后再询问. 时间复杂度 $O(n\sqrt n)$ . 有一个很有用的剪枝,询问时,若边角块没有标记,就可以不用重构. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;typedef unsigned long long ull;mt19937 Generator(19260817);ull gen()&#123; return Generator() | ((ull)(Generator()) &lt;&lt; 32);&#125;const int N = 2e5 + 10, M = 1e6 + 10, B = 300, S = (N / B) + 10, P = 20007;struct HashTable&#123; int tot, head[P], nx[S], cnt[S]; ull t[S]; void ins(ull x) &#123; int pos = x % P; for (int i = head[pos]; i; i = nx[i]) if (t[i] == x) &#123; ++cnt[i]; return; &#125; t[++tot] = x, cnt[tot] = 1, nx[tot] = head[pos], head[pos] = tot; &#125; int Find(ull x) &#123; int pos = x % P; for (int i = head[pos]; i; i = nx[i]) if (t[i] == x) return cnt[i]; return 0; &#125; void reset() &#123; for (int i = 1; i &lt;= tot; ++i) head[t[i] % P] = 0, cnt[i] = 0; tot = 0; &#125;&#125; Hash[S];int n, bel[N], lp[S], rp[S], a[N], lst[M];ull val[N], b[M], tag[S], sum = 0;void ReBuild(int x)&#123; Hash[x].reset(); for (int i = lp[x]; i &lt;= rp[x]; ++i) &#123; val[i] ^= tag[x]; Hash[x].ins(val[i]); &#125; tag[x] = 0;&#125;void pushdown(int x)&#123; if (tag[x]) ReBuild(x);&#125;void upd(int L, int R, ull x)&#123; if (bel[L] == bel[R]) &#123; for (int i = L; i &lt;= R; ++i) val[i] ^= x; ReBuild(bel[L]); &#125; else &#123; for (int i = L; i &lt;= rp[bel[L]]; ++i) val[i] ^= x; ReBuild(bel[L]); for (int i = bel[L] + 1; i &lt;= bel[R] - 1; ++i) tag[i] ^= x; for (int i = lp[bel[R]]; i &lt;= R; ++i) val[i] ^= x; ReBuild(bel[R]); &#125;&#125;int query(int L, int R, ull x)&#123; int s = 0; if (bel[L] == bel[R]) &#123; pushdown(bel[L]); for (int i = L; i &lt;= R; ++i) s += (val[i] == x); &#125; else &#123; pushdown(bel[L]); for (int i = L; i &lt;= rp[bel[L]]; ++i) s += (val[i] == x); for (int i = bel[L] + 1; i &lt;= bel[R] - 1; ++i) s += Hash[i].Find(x ^ tag[i]); pushdown(bel[R]); for (int i = lp[bel[R]]; i &lt;= R; ++i) s += (val[i] == x); &#125; return s;&#125;int main()&#123; n = read(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); b[a[i]] = gen(); &#125; for (int i = 1; i &lt;= n; ++i) &#123; bel[i] = (i - 1) / B + 1; lp[bel[i]] = (bel[i] - 1) * B + 1; rp[bel[i]] = bel[i] * B; &#125; rp[bel[n]] = n; for (int i = 1; i &lt;= n; ++i) &#123; val[i] = sum; sum ^= b[a[i]]; &#125; for (int i = 1; i &lt;= bel[n]; ++i) ReBuild(i); sum = 0; ll ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; sum ^= b[a[i]]; upd(lst[a[i]] + 1, i, b[a[i]]); ans += query(1, i, sum); lst[a[i]] = i; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>随机化</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2264 吉夫特]]></title>
    <url>%2F2020%2F05%2F09%2FLoj-2264-%E5%90%89%E5%A4%AB%E7%89%B9%2F</url>
    <content type="text"><![CDATA[子集 dp 的一个 trick. 根据 Lucas 定理,显然就是要求对于子序列 $p$ 中相邻两个数,满足 $p_{i}$ 是 $p_{i-1}$ 的子集. 设 $f(i)$ 表示以 $i$ 结尾的子序列数目,依次计算每个 $f(a_i)$ ,转移时大力枚举 $a_i$ 的超集. 记 $k=\log \max a_i$ ,由于保证了 $a_i$ 互不相同,时间复杂度 $O(3^k)$ ,然而这样就可以直接干过去,可以算作事故了. 考虑进一步优化,将前 $\frac k 2$ 个数位和后 $\frac k 2$ 个数位分开考虑. 设 $s(x)​$ 表示 $\sum f(y)​$ ,其中 $y​$ 满足 $y​$ 的前 $\frac k 2​$ 位和 $x​$ 的前 $\frac k 2​$ 位相同, $y​$ 的后 $\frac k 2​$ 位是 $x​$ 的后 $\frac k 2​$ 位的超集. 转移时,只需要枚举 $a_i​$ 前 $\frac k 2​$ 位的超集即可算出 $f(a_i)​$ ,然后枚举 $a_i​$ 后 $\frac k 2​$ 位的子集去更新 $s​$ . 保证了 $a_i$ 互不相同,所以对于每种前面的 $\frac k 2$ 位,只会枚举 $2^{\frac k 2}$ 次超集,后面枚举子集的分析是同理的. 时间复杂度 $O(6^{\frac k 2})$ . 如果不保证元素互不相同,暴力做法会被卡到 $O(n\cdot 2^k)$ ,而将数位分开考虑的做法会退化到 $O(n\cdot 2^{\frac k 2})$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;const int P = 1e9 + 7;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;const int N = 18, M = 9;int n, s[1 &lt;&lt; N], ans = 0;int main()&#123; n = read(); s[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; int x = read(); int R = x &amp; ((1 &lt;&lt; M) - 1), L = (x - R) &gt;&gt; M; int S = L ^ ((1 &lt;&lt; M) - 1); int f = s[x]; for (int T = S; T; T = (T - 1) &amp; S) inc(f, s[x | (T &lt;&lt; M)]); inc(ans, f); inc(f, 1); S = R; for (int T = S; T; T = (T - 1) &amp; S) inc(s[(L &lt;&lt; M) ^ T], f); inc(s[L &lt;&lt; M], f); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF838D Airplane Arrangements]]></title>
    <url>%2F2020%2F05%2F09%2FCF838D-Airplane-Arrangements%2F</url>
    <content type="text"><![CDATA[构造 + 概率的计算. 飞机上有 $n$ 个位置,有 $m$ 个乘客入座,每个乘客有一张票 $(x\in [1,n]\cup {\mathbb N_+},dir\in \lbrace 0,1\rbrace)$ . 每个乘客依次进入飞机,先走到位置 $x$ ,若 $dir =0$ ,则向前走,直到找到一个空位并坐下. 若 $dir = 1$ ,则向后走,直到找到一个空位并坐下. 若每个乘客都能找到一个空位,则是合法的情况,问有多少种情况是合法的,答案对 $10^9+7$ 取模. $1\le m\le n\le 10^6​$ ,两种情况不同当且仅当存在一个乘客,他在两种情况中拥有的票不一样. 考虑新加入一个特殊位置 $n+1$ ,若有乘客走到这里坐下,说明不合法. 然后就可以将序列变成一个环.每个乘客在环上选一个位置和一个方向出发,直到找到空位并坐下. 可以发现如果我们允许乘客从 $n+1​$ 出发,合法方案数也不会变,但可以使得每个位置都等价. 乘客共选了 $m$ 个位置, 位置 $n+1$ 没有被选的概率为 $\frac{n+1-m}{n+1}$ ,再乘上总方案数 $(2n+2)^m$ 即为合法方案数. 123456789101112131415161718192021222324252627282930313233343536373839//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;const int P = 1e9 + 7;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a, int b)&#123; int res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res;&#125;int main()&#123; int n = read(), m = read(); printf("%d\n", mul(n + 1 - m, mul(fpow(n + 1, P - 2), fpow(2 * n + 2, m)))); return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5058 期望逆序对]]></title>
    <url>%2F2020%2F05%2F08%2Fbzoj-5058-%E6%9C%9F%E6%9C%9B%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[矩阵快速幂 + 树状数组. 考虑两个数 $a_i,a_j​$ 对答案的贡献,可以发现它们把所有位置分成了 $3​$ 种, $i,j​$ ,以及其他位置. 对于 $a_i,a_j$ 来说,它们出现在其他的每一个位置的概率都是相同的. 于是只用考虑以下这几种情况最终出现的概率, $a_i$ 在位置 $i$ , $a_j$ 在位置 $j​$ . $a_i$ 在位置 $j$ , $a_j$ 在位置 $i​$ . $a_i,a_j​$ 恰有一个在原来位置,另外一个在除掉 $i,j​$ 后的其他位置. $a_i,a_j$ 恰有一个在对方位置,另外一个在除掉 $i,j$ 后的其他位置. $a_i,a_j$ 都在除掉 $i,j$ 后的其他位置. 可以用矩阵快速幂处理出操作 $k$ 次后这几种情况各自的概率. 而 $a_i,a_j$ 对于答案的贡献是一些与 $i,j$ 有关的一次多项式. 从前往后考虑每个 $a_i$ ,树状数组维护以 $a_i$ 为下标的区间中的 $\sum1,\sum i$ 即可,时间复杂度 $O(n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;const int P = 1e9 + 7, inv2 = (P + 1) &gt;&gt; 1;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a, int b)&#123; int res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res;&#125;struct Matrix&#123; int v[5][5]; Matrix()&#123;memset(v, 0, sizeof v);&#125; Matrix operator * (const Matrix &amp;rhs) const &#123; Matrix res; for (int i = 0; i &lt; 5; ++i) for (int k = 0; k &lt; 5; ++k) if (v[i][k]) for (int j = 0; j &lt; 5; ++j) if (rhs.v[k][j]) inc(res.v[i][j], mul(v[i][k], rhs.v[k][j])); return res; &#125;&#125; st, trans, I;Matrix Fpow(Matrix a, int b)&#123; Matrix res = I; while (b) &#123; if (b &amp; 1) res = res * a; a = a * a; b &gt;&gt;= 1; &#125; return res;&#125;const int N = 5e5 + 10;int n, k, c[5];int binom(int x)&#123; return 1LL * x * (x - 1) / 2 % P;&#125;void f(int x, int y, int w)&#123; trans.v[y][x] = w;&#125;void init()&#123; for (int i = 0; i &lt; 5; ++i) I.v[i][i] = 1; st.v[0][0] = 1; f(0, 0, binom(n - 2)), f(0, 1, 1), f(0, 2, mul(2, n - 2)), f(0, 3, 0), f(0, 4, 0); f(1, 0, 1), f(1, 1, binom(n - 2)), f(1, 2, 0), f(1, 3, mul(2, n - 2)), f(1, 4, 0); f(2, 0, 1), f(2, 1, 0), f(2, 2, binom(n - 2) + n - 3), f(2, 3, 2), f(2, 4, n - 3); f(3, 0, 0), f(3, 1, 1), f(3, 2, 2), f(3, 3, binom(n - 2) + n - 3), f(3, 4, n - 3); f(4, 0, 0), f(4, 1, 0), f(4, 2, n - 2), f(4, 3, n - 2), f(4, 4, binom(n - 2) + 1); st = Fpow(trans, k) * st; for (int i = 0; i &lt; 5; ++i) c[i] = st.v[i][0];&#125;struct FenwickTree&#123; int lowbit(int x) &#123; return x &amp; (-x); &#125; int bit[N]; void upd(int x, int c) &#123; for (; x &lt;= n; x += lowbit(x)) inc(bit[x], c); &#125; int query(int x) &#123; int s = 0; for (; x; x -= lowbit(x)) inc(s, bit[x]); return s; &#125;&#125; C, S;int cnt, sum, tmp, tot;int calc(int i)&#123; int s = 0; inc(s, mul(c[1], cnt)); inc(s, mul(mul(c[2], inv2), mul(mul(cnt, n - i), tmp))); inc(s, mul(mul(c[2], inv2), mul(add(sum, P - cnt), tmp))); inc(s, mul(mul(c[3], inv2), mul(add(mul(cnt, n - 1), P - sum), tmp))); inc(s, mul(mul(c[3], inv2), mul(add(mul(cnt, i), P - mul(cnt, 2)), tmp))); inc(s, mul(mul(c[4], inv2), cnt)); return s;&#125;int a[N];int main()&#123; n = read(), k = read(); tmp = fpow(n - 2, P - 2); tot = fpow(binom(n), k); if (n == 1) return puts("0"), 0; if (n == 2) &#123; int a = read(), b = read(); if ((a &lt; b) == (k &amp; 1)) printf("%d\n", tot); else puts("0"); return 0; &#125; init(); int ans = 0, s = 0; for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); int x = a[i]; cnt = sum = 0; if (x &gt; 1) &#123; cnt = C.query(x - 1); sum = S.query(x - 1); if (cnt || sum) inc(ans, calc(i)); &#125; if (x &lt; n) &#123; cnt = add(i - 1, P - cnt); sum = add(s, P - sum); if (cnt || sum) inc(ans, add(mul(tot, cnt), P - calc(i))); &#125; C.upd(x, 1); S.upd(x, i); inc(s, i); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 3051 皮配]]></title>
    <url>%2F2020%2F05%2F06%2FLoj-3051-%E7%9A%AE%E9%85%8D%2F</url>
    <content type="text"><![CDATA[背包 dp . 如果直接裸上一个背包计数,那么阵营和派系两种限制的状态都要记录. 即,设 $f(i,x,y)$ 表示考虑了前 $i$ 个城市的所有学校,加入蓝阵营的有 $x$ 人,加入鸭派系的有 $y$ 人的方案数. 时间复杂度 $O(nm^2)​$ ,无法通过. 注意到有限制的学校数目 $k$ 比较小,可以将有限制的学校和没有限制的学校分开处理. 设 $f(i,x,y)$ 表示考虑了前 $i$ 个包含某个有限制学校的城市,加入蓝阵营的有 $x$ 人,加入鸭派系的有 $y$ 人的方案数. 而对于没有限制的学校,可以发现学校选择的派系是不影响城市选择的阵营的,可以分开 dp ,最后将方案数相乘. 设 $g(i,x)$ 表示考虑了前 $i$ 个没有限制学校的城市,加入蓝阵营的有 $x$ 人的方案数. 设 $h(i,y)$ 表示考虑了前 $i$ 个没有限制的学校,加入鸭派系的有 $y$ 人的方案数. 最后统计答案时,每个 $f(x,y)$ 对应的合法的 $g,h$ 都是一段区间,处理出前缀和后即可统计贡献. 时间复杂度 $O(10\cdot k^2m+nm)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;const int P = 998244353;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;const int N = 2500 + 10;void cl(int *a, int n)&#123; for (int i = 0; i &lt;= n; ++i) a[i] = 0;&#125;void cl(int a[N][N], int n, int m)&#123; for (int i = 0; i &lt;= n; ++i) for (int j = 0; j &lt;= m; ++j) a[i][j] = 0;&#125;int n, m, k, tot, pt, C0, C1, D0, D1;int vis[N], siz[N], bel[N], hate[N];vector&lt;int&gt; vec[N];int g[N][N], h[N][N], f[2][N][N], id, cnt, ht, ts[N];void dp_g()&#123; cl(g[0], C0); g[0][0] = 1; for (int c = 1, i = 0; c &lt;= m; ++c) if (!vis[c] &amp;&amp; !vec[c].empty()) &#123; cnt = ++i; cl(g[i], C0); int s = 0; for (int x : vec[c]) s += siz[x]; for (int j = 0; j &lt;= C0; ++j) if (g[i - 1][j]) &#123; if (j + s &lt;= C0) inc(g[i][j + s], g[i - 1][j]); inc(g[i][j], g[i - 1][j]); &#125; &#125; for (int i = 1; i &lt;= C0; ++i) inc(g[cnt][i], g[cnt][i - 1]);&#125;int th[2][N][N];void dp_h()&#123; cl(h[0], D0); h[0][0] = 1; for (int x = 1, i = 0; x &lt;= n; ++x) if (hate[x] == -1) &#123; ht = ++i; cl(h[i], D0); int s = siz[x]; for (int j = 0; j &lt;= D0; ++j) if (h[i - 1][j]) &#123; if (j + s &lt;= D0) inc(h[i][j + s], h[i - 1][j]); inc(h[i][j], h[i - 1][j]); &#125; &#125; for (int i = 1; i &lt;= D0; ++i) inc(h[ht][i], h[ht][i - 1]);&#125;void dp_f()&#123; id = 0; cl(f[id], C0, D0); f[id][0][0] = 1; for (int c = 1; c &lt;= m; ++c) if (vis[c]) &#123; id ^= 1; cl(f[id], C0, D0); int td = 0; for (int i = 0; i &lt;= C0; ++i) for (int j = 0; j &lt;= D0 &amp;&amp; j &lt;= pt; ++j) th[0][i][j] = f[id ^ 1][i][j]; int tp = pt; int s = ts[c]; // Blue for (int x : vec[c]) if (hate[x] != -1) &#123; td ^= 1; cl(th[td], C0, D0); for (int i = 0; i + s &lt;= C0; ++i) for (int j = 0; j &lt;= D0 &amp;&amp; j &lt;= pt; ++j) if (th[td ^ 1][i][j]) &#123; if (hate[x] != 0 &amp;&amp; j + siz[x] &lt;= D0) inc(th[td][i][j + siz[x]], th[td ^ 1][i][j]); if (hate[x] != 1) inc(th[td][i][j], th[td ^ 1][i][j]); &#125; pt += siz[x]; &#125; for (int i = 0; i + s &lt;= C0; ++i) for (int j = 0; j &lt;= D0 &amp;&amp; j &lt;= pt; ++j) inc(f[id][i + s][j], th[td][i][j]); // Red pt = tp; td = 0; for (int i = 0; i &lt;= C0; ++i) for (int j = 0; j &lt;= D0 &amp;&amp; j &lt;= pt; ++j) th[0][i][j] = f[id ^ 1][i][j]; for (int x : vec[c]) if (hate[x] != -1) &#123; td ^= 1; cl(th[td], C0, D0); for (int i = 0; i &lt;= C0; ++i) for (int j = 0; j &lt;= D0 &amp;&amp; j &lt;= pt; ++j) if (th[td ^ 1][i][j]) &#123; if (hate[x] != 2 &amp;&amp; j + siz[x] &lt;= D0) inc(th[td][i][j + siz[x]], th[td ^ 1][i][j]); if (hate[x] != 3) inc(th[td][i][j], th[td ^ 1][i][j]); &#125; pt += siz[x]; &#125; for (int i = 0; i &lt;= C0; ++i) for (int j = 0; j &lt;= D0 &amp;&amp; j &lt;= pt; ++j) inc(f[id][i][j], th[td][i][j]); &#125;&#125;void solve()&#123; n = read(), m = read(); tot = cnt = ht = 0; for (int i = 1; i &lt;= m; ++i) vec[i].clear(), vis[i] = ts[i] = 0; C0 = read(), C1 = read(), D0 = read(), D1 = read(); for (int i = 1; i &lt;= n; ++i) &#123; bel[i] = read(), siz[i] = read(), hate[i] = -1; tot += siz[i]; vec[bel[i]].push_back(i); ts[bel[i]] += siz[i]; &#125; k = read(); pt = 0; for (int i = 1; i &lt;= k; ++i) &#123; int x = read(); hate[x] = read(); vis[bel[x]] = 1; &#125; dp_g(); dp_h(); dp_f(); int ans = 0; for (int x = 0; x &lt;= C0; ++x) if (pt - x &lt;= C1) for (int y = 0; y &lt;= D0 &amp;&amp; y &lt;= pt; ++y) if (pt - y &lt;= D1 &amp;&amp; f[id][x][y]) &#123; int tmp = f[id][x][y], L, R; L = max(0, tot - C1 - x), R = min(tot - pt, C0 - x); if (L &lt;= R) tmp = mul(tmp, add(g[cnt][R], P - (L ? g[cnt][L - 1] : 0))); else tmp = 0; L = max(0, tot - D1 - y), R = min(tot - pt, D0 - y); if (L &lt;= R) tmp = mul(tmp, add(h[ht][R], P - (L ? h[ht][L - 1] : 0))); else tmp = 0; inc(ans, tmp); &#125; printf("%d\n", ans);&#125;int main()&#123; int T = read(); while (T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暴力多项式操作]]></title>
    <url>%2F2020%2F05%2F06%2F%E6%9A%B4%E5%8A%9B%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[暴力技巧. 有时候需要做多项式求逆, $\exp,\ln$ ,模数不是 NTT 模数,但多项式长度比较小,就不用写 MTT ,可以用暴力代替. 暴力 $\exp$已知多项式 $A​$ ,需要求出 $B=\exp(A)​$ .$$B=\exp(A) \\B’=\exp(A)\cdot A’\\B’=B\cdot A’ \\B=\int B\cdot A’$$ 求出 $B$ 的第 $i$ 项系数后,可以暴力卷积求出 $\int B\cdot A’$ 的第 $i$ 项系数,也就算出了 $B$ 的第 $i+1$ 项系数. 时间复杂度 $O(n^2)$ . 暴力多项式求逆已知多项式 $A$ ,需要求出 $B=A^{-1}$ . 因为 $A\cdot B=1$ ,所以根据 $A$ 的系数和 $B$ 的前 $i-1$ 项系数可以直接解出 $B$ 的第 $i$ 项系数. 时间复杂度 $O(n^2)$ . 暴力 $\ln$已知多项式 $A$ ,需要求出 $B=\ln A$ .$$B=\ln A\\B’=\frac{A’}{A} \\B=\int \frac{A’}{A}$$用暴力多项式求逆算出 $A^{-1}$ 即可,时间复杂度 $O(n^2)$ .]]></content>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4849 Mole Tunnels]]></title>
    <url>%2F2020%2F05%2F04%2Fbzoj-4849-Mole-Tunnels%2F</url>
    <content type="text"><![CDATA[模拟费用流. 模拟费用流是怎么回事呢?模拟相信大家都很熟悉,但是模拟费用流是怎么回事呢,下面就让小编带大家一起了解吧. 模拟费用流,其实就是模拟费用流的过程,大家可能会很惊讶,模拟怎么会费用流呢? 但事实就是这样,小编也感到非常惊讶. 这就是关于模拟费用流的事情了,大家有什么想法呢,欢迎在评论区告诉小编一起讨论哦! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;const int N = 1e5 + 10, inf = 1e9;int n, m, c[N], ans = 0, idx = 0, st[N], ed[N], rnk[N], dep[N];void dfs(int x)&#123; st[x] = ++idx, rnk[idx] = x; if (2 * x &lt;= n) &#123; dep[2 * x] = dep[x] + 1; dfs(2 * x); &#125; if (2 * x + 1 &lt;= n) &#123; dep[2 * x + 1] = dep[x] + 1; dfs(2 * x + 1); &#125; ed[x] = idx;&#125;struct node&#123; int mi, mi_real, tag, pos;&#125; Tree[N &lt;&lt; 2];#define root Tree[o]#define lson Tree[o &lt;&lt; 1]#define rson Tree[o &lt;&lt; 1 | 1]void pushup(int o)&#123; root.mi = min(lson.mi, rson.mi); root.mi_real = min(lson.mi_real, rson.mi_real); if (lson.mi &lt; rson.mi) root.pos = lson.pos; else root.pos = rson.pos;&#125;void BuildTree(int o, int l, int r)&#123; if (l == r) &#123; root.mi = c[rnk[l]] ? dep[rnk[l]] : inf; root.mi_real = dep[rnk[l]]; root.pos = rnk[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; BuildTree(o &lt;&lt; 1, l, mid); BuildTree(o &lt;&lt; 1 | 1, mid + 1, r); pushup(o);&#125;void modify(int o, int c)&#123; root.mi += c; if (c &lt; inf) root.mi_real += c; root.tag += c;&#125;void pushdown(int o)&#123; if (root.tag) &#123; modify(o &lt;&lt; 1, root.tag); modify(o &lt;&lt; 1 | 1, root.tag); root.tag = 0; &#125;&#125;void upd(int o, int l, int r, int L, int R, int c)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) return modify(o, c); int mid = (l + r) &gt;&gt; 1; pushdown(o); if (L &lt;= mid) upd(o &lt;&lt; 1, l, mid, L, R, c); if (R &gt; mid) upd(o &lt;&lt; 1 | 1, mid + 1, r, L, R, c); pushup(o);&#125;void query(int &amp;pos, int &amp;mi, int o, int l, int r, int L, int R)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; if (root.mi &lt; mi) mi = root.mi, pos = root.pos; return; &#125; pushdown(o); int mid = (l + r) &gt;&gt; 1; if (L &lt;= mid) query(pos, mi, o &lt;&lt; 1, l, mid, L, R); if (R &gt; mid) query(pos, mi, o &lt;&lt; 1 | 1, mid + 1, r, L, R);&#125;int query_real(int o, int l, int r, int pos)&#123; if (l == r) return root.mi_real; pushdown(o); int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) return query_real(o &lt;&lt; 1, l, mid, pos); else return query_real(o &lt;&lt; 1 | 1, mid + 1, r, pos);&#125;int up[N], down[N]; // available flow of inverse edgeint main()&#123; n = read(), m = read(); dfs(1); for (int i = 1; i &lt;= n; ++i) c[i] = read(); BuildTree(1, 1, n); while (m--) &#123; int x = read(), lca = x, mi, tmp, d = 0, dis = inf, y, p; while (lca) &#123; mi = inf; query(tmp, mi, 1, 1, n, st[lca], ed[lca]); if (mi &lt; inf) &#123; int k = d + mi - query_real(1, 1, n, st[lca]); if (k &lt; dis) dis = k, y = tmp, p = lca; &#125; d += up[lca] ? -1 : 1; lca &gt;&gt;= 1; &#125; ans += dis; printf("%d ", ans); --c[y]; if (!c[y]) upd(1, 1, n, st[y], st[y], inf); lca = p; // x -&gt; lca p = x; while (p != lca) &#123; if (up[p]) // used inverse edge --up[p]; else // not &#123; ++down[p]; if (down[p] == 1) // cost : 1 -&gt; -1 upd(1, 1, n, st[p], ed[p], -2); &#125; p &gt;&gt;= 1; &#125; // lca -&gt; y p = y; while (p != lca) &#123; if (down[p]) // used inverse edge &#123; --down[p]; if (down[p] == 0) // cost : -1 -&gt; 1 upd(1, 1, n, st[p], ed[p], 2); &#125; else // not ++up[p]; p &gt;&gt;= 1; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>模拟费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6044 共]]></title>
    <url>%2F2020%2F04%2F29%2FLoj-6044-%E5%85%B1%2F</url>
    <content type="text"><![CDATA[求完全二分图的生成树个数. 确定 $1$ 为根,钦定 $k$ 个节点的深度为奇数的方案数为 $\binom{n-1}{k-1}$ ,接下来只需要考虑合法连边的方案数. 显然树边只会出现在深度为奇与深度为偶的节点之间,方案数等价于完全二分图 $K_{k,n-k}$ 的生成树个数. 可以用 prufer 序列计算,或者用矩阵树定理,写出基尔霍夫矩阵后 手动爆算行列式 . 可以得到结论, $K_{n,m}$ 的生成树个数为 $n^{m-1}\cdot m^{n-1}​$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;int P;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a, int b)&#123; int res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res;&#125;const int N = 5e5 + 10;int fac[N], invfac[N];int binom(int n, int m)&#123; return mul(fac[n], mul(invfac[m], invfac[n - m]));&#125;int calc(int n, int m)&#123; return mul(fpow(n, m - 1), fpow(m, n - 1));&#125;int n, k;int main()&#123; n = read(), k = read(), P = read(); fac[0] = 1; for (int i = 1; i &lt;= n; ++i) fac[i] = mul(fac[i - 1], i); invfac[n] = fpow(fac[n], P - 2); for (int i = n - 1; i &gt;= 0; --i) invfac[i] = mul(invfac[i + 1], i + 1); int ans = mul(binom(n - 1, k - 1), calc(k, n - k)); printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6041 事情的相似度]]></title>
    <url>%2F2020%2F04%2F26%2FLoj-6041-%E4%BA%8B%E6%83%85%E7%9A%84%E7%9B%B8%E4%BC%BC%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[SAM + dsu on tree + 线段树. 把后缀树建出来,每个前缀对应了后缀树上某个节点,询问 $[l,r]$ 的答案就是问 $[l,r]$ 内两两 LCA 中的最大 $\rm maxlen$ . 把询问离线下来,在后缀树上枚举 LCA,对它的子树做一个 dsu on tree,用 set 维护子树中所有前缀(按长度排序). 某个前缀与 set 中其他前缀的 LCA 都是我们枚举的点,只需要考虑长度是它的前驱后继的两个前缀的贡献就足够了. 于是我们可以得到若干个三元组 $(x,y,d)$ 表示前缀 $x$ 与前缀 $y$ ( $x&lt;y$ ) 的 LCS 是 $d$ . 将三元组按 $y$ 从小到大排序,从小到大枚举 $r$ ,用线段树维护每个 $l$ 的答案即可. 时间复杂度 $O(n\log^2 n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;const int N = 2e5 + 10;int n, m;int idx = 1, lst = 1, ch[N][2], fa[N], len[N], siz[N], pos[N], mxson[N];vector&lt;int&gt; G[N];void Extend(int c, int x)&#123; int np = ++idx, p = lst; lst = np; len[np] = len[p] + 1; while (p &amp;&amp; !ch[p][c]) ch[p][c] = np, p = fa[p]; if (!p) fa[np] = 1; else &#123; int q = ch[p][c]; if (len[q] == len[p] + 1) fa[np] = q; else &#123; int nq = ++idx; len[nq] = len[p] + 1; fa[nq] = fa[q]; fa[q] = fa[np] = nq; memcpy(ch[nq], ch[q], sizeof ch[nq]); while (p &amp;&amp; ch[p][c] == q) ch[p][c] = nq, p = fa[p]; &#125; &#125; pos[np] = x;&#125;char buf[N];set&lt;int&gt; s;int dep[N];void init(int u)&#123; siz[u] = 1; for (int v : G[u]) &#123; dep[v] = dep[u] + 1; init(v); if (!mxson[u] || siz[v] &gt; siz[mxson[u]]) mxson[u] = v; siz[u] += siz[v]; &#125;&#125;struct info&#123; int x, y, d; bool operator &lt; (const info &amp;rhs) const &#123; return y == rhs.y ? d &gt; rhs.d : y &lt; rhs.y; &#125;&#125; q[N * 30], p[N];int tot = 0;void calc(int x, int d)&#123; if (!x || s.empty() || !d) return; auto it = s.lower_bound(x); if (it != s.end()) q[++tot] = (info)&#123;x, *it, d&#125;; if (it != s.begin()) q[++tot] = (info)&#123;*(--it), x, d&#125;;&#125;void Calc(int u, int d)&#123; calc(pos[u], d); for (int v : G[u]) Calc(v, d);&#125;void add(int x)&#123; if (x) s.insert(x);&#125;void Add(int u)&#123; add(pos[u]); for (int v : G[u]) Add(v);&#125;void dfs(int u, bool flag)&#123; for (int v : G[u]) if (v != mxson[u]) dfs(v, false); if (mxson[u]) dfs(mxson[u], true); calc(pos[u], len[u]); add(pos[u]); for (int v : G[u]) if (v != mxson[u]) &#123; Calc(v, len[u]); Add(v); &#125; if (!flag) s.clear();&#125;int ans[N], mx[N &lt;&lt; 1];void upd(int o, int l, int r, int L, int R, int c)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; mx[o] = max(mx[o], c); return; &#125; int mid = (l + r) &gt;&gt; 1; if (L &lt;= mid) upd(o &lt;&lt; 1, l, mid, L, R, c); if (R &gt; mid) upd(o &lt;&lt; 1 | 1, mid + 1, r, L, R, c);&#125;void query(int &amp;res, int o, int l, int r, int pos)&#123; res = max(res, mx[o]); if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) query(res, o &lt;&lt; 1, l, mid, pos); else query(res, o &lt;&lt; 1 | 1, mid + 1, r, pos);&#125;int main()&#123; n = read(), m = read(); scanf("%s", buf + 1); for (int i = 1; i &lt;= n; ++i) Extend(buf[i] - '0', i); for (int i = 2; i &lt;= idx; ++i) G[fa[i]].push_back(i); init(1); dfs(1, true); for (int i = 1; i &lt;= m; ++i) &#123; int l = read(), r = read(); p[i] = (info)&#123;l, r, i&#125;; &#125; sort(q + 1, q + 1 + tot); sort(p + 1, p + 1 + m); for (int r = 1, i = 1, j = 1; r &lt;= n; ++r) &#123; while (i &lt;= tot &amp;&amp; q[i].y == r) upd(1, 1, n, 1, q[i].x, q[i].d), ++i; while (j &lt;= m &amp;&amp; p[j].y == r) query(ans[p[j].d], 1, 1, n, p[j].x), ++j; &#125; for (int i = 1; i &lt;= m; ++i) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>离线</tag>
        <tag>SAM</tag>
        <tag>dsu on tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Grand Contest 043]]></title>
    <url>%2F2020%2F04%2F26%2FAtcoder-Grand-Contest-043%2F</url>
    <content type="text"><![CDATA[AGC A Range Flip Find Route设 $dp(i,j)$ 表示使得从 $(1,1)$ 能走到 $(i,j)$ 所需的最少操作数目. $dp(i,j)$ 可以由 $dp(i-1,j),dp(i,j-1)$ 转移来. 若 $(i,j)$ 初始是 . ,则不需要额外花费. 若上个位置和 $(i,j)$ 初始都是 # ,就不需要额外的花费,可以将覆盖上个位置的矩形拓展,不会影响接下来的路径. 若上个位置初始是 . ,但 $(i,j)$ 初始是 # ,就需要操作一次将它变为 . . code B 123 Triangle为了方便,假定所有 $a_i$ 从 $0$ 开始标号,可以先将所有 $a_i$ 减去 $1$ ,因为 $n&gt;1$ ,所以不会影响答案. 先考虑判断答案是否为 $1$ ,可以把 $2$ 也看作 $0$ ,做差取绝对值改为两者异或,若最后剩下 $1$ ,说明原答案也是 $1$ . 异或的性质就比较好了,有结合律和交换律,根据帕斯卡三角可知, $a_i$ 对最后剩下的数产生贡献的次数为 $\binom {n-1} i$ . 用 Lucas 定理判断哪些 $a_i$ 对最后剩下的数对贡献次数为奇数,即可判断答案是否为 $1$ . 当答案不为 $1$ 时,我们还要区分答案是 $0$ 还是 $2$ . 注意到若初始数列中有至少一个 $1$ ,答案就不可能为 $2$ . 因为若全部都是 $1$ ,操作一次后会变成全部为 $0$ ,否则某个 $1$ 会与 $0$ 或 $2$ 相邻,操作一次后至少还有一个 $1$ . 当初始数列中没有 $1$ 时,判掉全部是 $0$ 的情况,其余情况可以将所有数 $/2$ ,变成只有 $0,1$ ,算出答案后 $\times 2$ 即可. code C Giant Graph观察一个点对答案的贡献形式,不难发现我们应该贪心拿编号之和 $i+j+k$ 最大的点. 即按照 $i+j+k$ 从大到小枚举三元组,若它能被加入独立集,就贪心将其加入,时间复杂度是 $O((n+m)^3)$ 的. 考虑转化模型,假定在三张图上各有一个棋子,A 与 B 轮流操作,每一步选一个棋子,把它沿边移动到编号更大的点上. 若某人操作时,不能做出任何移动,就输了. 不难发现三元组 $(i,j,k)$ 在独立集中,当且仅当三个棋子分别在 $(i,j,k)$ 时,先手必败. 即 $SG(X,i)\oplus SG(Y,j)\oplus SG(Z,k)=0$ ,把 $SG$ 值预处理出来,枚举 $SG(X,i),SG(Y,j)$ 即可统计答案. $SG$ 值的上界是 $O(\sqrt m)$ 的,于是时间复杂度为 $O(n+m)$ . code]]></content>
      <tags>
        <tag>Atcoder</tag>
        <tag>构造</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6039 珠宝]]></title>
    <url>%2F2020%2F04%2F26%2FLoj-6039-%E7%8F%A0%E5%AE%9D%2F</url>
    <content type="text"><![CDATA[决策单调性优化 dp. 题意就是要求解一个 01 背包,但通常的 $O(nm)$ 的 dp 会超时. 注意到每种物品的体积不会超过 $300$ ,可以考虑设计与它相关的状态进行 dp . 设 $val(i,j)$ 表示选 $j$ 件体积为 $i$ 的物品能获得的最大收益. 设 $f(i,j)$ 表示考虑了所有体积 $\le i$ 的物品,花费了 $j$ 万元能获得的最大收益. 转移时枚举体积为 $i$ 的物品选了 $k$ 个,$$f(i,j)=\max_{k} \lbrace f(i-1,j-i\times k)+val(i,k) \rbrace$$注意到 $val(i,j)-val(i,j-1)$ 就是体积为 $i$ 的物品中,第 $j$ 大的收益,所以这个差值是不增的,即 $val(i)$ 是凸的. 于是我们把所有 $j$ 按照模 $i$ 分类,每一类内部具有决策单调性,可以用分治优化. 时间复杂度 $O(n\log n+\max C\cdot m\log m)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;const int K = 300 + 10, N = 5e4 + 10;vector&lt;ll&gt; val[K];int n, m, siz[K];ll f[2][N], g[2][N];void solve(int id, int i, int l, int r, int kl, int kr)&#123; int mid = (l + r) &gt;&gt; 1, pk = kl; ll res = 0; for (int k = kl; k &lt;= mid &amp;&amp; k &lt;= kr; ++k) &#123; ll tmp = g[id ^ 1][k] + val[i][min(mid - k, siz[i] - 1)]; if (tmp &gt; res) res = tmp, pk = k; &#125; g[id][mid] = res; if (l &lt;= mid - 1) solve(id, i, l, mid - 1, kl, pk); if (mid + 1 &lt;= r) solve(id, i, mid + 1, r, pk, kr);&#125;int main()&#123; n = read(), m = read(); int mx = 0; for (int i = 1; i &lt;= n; ++i) &#123; int c = read(), v = read(); val[c].push_back(v); mx = max(mx, c); &#125; for (int i = 1; i &lt;= mx; ++i) &#123; sort(val[i].begin(), val[i].end()); val[i].push_back(0); reverse(val[i].begin(), val[i].end()); siz[i] = val[i].size(); for (int j = 1; j &lt; siz[i]; ++j) val[i][j] += val[i][j - 1]; &#125; int id = 0; for (int i = 1; i &lt;= mx; ++i) if (siz[i] != 1) &#123; id ^= 1; for (int j = 0, u = 0; j &lt; i; ++j, u = 0) &#123; for (int v = j; v &lt;= m; ++u, v += i) g[id ^ 1][u] = f[id ^ 1][v]; solve(id, i, 0, u - 1, 0, u - 1); u = 0; for (int v = j; v &lt;= m; ++u, v += i) f[id][v] = g[id][u]; &#125; &#125; for (int i = 1; i &lt;= m; ++i) printf("%lld ", f[id][i]); puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>决策单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIOL Round 2]]></title>
    <url>%2F2020%2F04%2F25%2FNOIOL-Round-2%2F</url>
    <content type="text"><![CDATA[套路场. 涂色游戏CF1260 C Infinite Fence 假设 $p_1\le p_2$ ,显然特判掉 $k=1$ 的情况后,只需要判断是否有 $\lfloor \frac {p_2-\gcd(p_1,p_2)-1}{p_1}\rfloor+1&lt;k$ . 子序列问题考虑组合意义,若 $[l,r]$ 内某两个数都是第一次出现的,那么这个数对就会对 $(f(l,r))^2$ 造成 $2$ 的贡献. 若某个数是 $[l,r]$ 内第一次出现的,这个数会对 $(f(l,r))^2$ 造成 $1$ 的贡献. 预处理出 $pre(i)$ 表示 $a_i$ 上一次出现的位置,枚举后面的数,考虑每个前面的数与它能对多少个区间造成贡献即可. 游戏树形 dp 求出钦定选了 $k$ 组有祖先后代关系的匹配的方案数,二项式反演即可得到恰好选了 $k$ 组的答案. 设 $dp(x,i)$ 表示在子树 $x$ 中选了 $i$ 组有祖先后代关系的匹配的方案数,转移时就是一个树形背包.]]></content>
      <tags>
        <tag>树形dp</tag>
        <tag>贪心</tag>
        <tag>线段树</tag>
        <tag>数学</tag>
        <tag>test</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hitachi Programming Contest 2020]]></title>
    <url>%2F2020%2F04%2F22%2FHitachi-Programming-Contest-2020%2F</url>
    <content type="text"><![CDATA[C 和 D 比较有意思. A Hitachi String人口普查. code B Nice Shopping人口普查. code C ThREE先把能填的数字都对 $3$ 取模,记 $1\sim n$ 的整数对 $3$ 取模后,有 $k_0$ 个 $0$ , $k_1$ 个 $1$ , $k_2$ 个 $2$ . 首先容易发现对于两个距离为 $3$ 的点 $x,y$ ,它们深度的奇偶性必定不同. 不妨假定深度为偶数的点有 $t_0$ 个,深度为奇数的点有 $t_1$ 个,并且 $t_0\le t_1$ ,否则只需交换 $t_0$ 和 $t_1$ . 若 $t_0\le k_0$ ,就可以给深度为偶数的点全部赋值为 $0$ ,这样奇偶性不同的点权值乘积必定为 $0$ . 若 $k_0&lt;t_0,k_1\le t_0\le k_0+k_1$ ,可以将所有的 $1$ 都填给深度为偶数的点,剩下的深度为偶数的点填 $0$ ,这样对于奇偶性不同的点,只可能是 $(0,0),(0,2),(1,0),(1,2)$ 这几种权值组合,积与和中至少有一者为 $0$ . 因为 $k_0 +1\ge k_1$ ,所以不会出现 $k_0&lt;t_0&lt;k_1$ 的情况. 因为 $k_1\ge k_2,t_0\le t_1$ ,所以不会出现 $t_0&gt;k_0+k_1$ 的情况. 于是就证明出了只会存在上述两种情况,那么我们总能通过对应方法构造出一组合法解. code D Manga Market考虑如果在时刻 $t$ 在商店 $i$ 购买物品,结束后立即去商店 $j$ 购买物品 . 那么 $j​$ 会因为在 $i​$ 处等候而额外花费 $(a_i\cdot t +b_i+1)\cdot a_j​$ 的时间. 如果我们将二者交换顺序,在时刻 $t​$ 在 $j​$ 购买,结束后立即去 $i​$ 购买, $i​$ 会额外花费 $(a_j\cdot t +b_j+1)\cdot a_i​$ 的时间. 若先去 $i​$ 比先去 $j​$ 更优,就需要满足$$(a_i\cdot t +b_i+1)\cdot a_j\le (a_j\cdot t +b_j+1)\cdot a_i \\(b_i+1)\cdot a_j \le (b_j+1)\cdot a_i$$可以发现 $i$ 是否比 $j$ 优与当前时刻 $t$ 无关. 于是可以先对所有商店排序,得到序列 $p$ ,那么我们实际去的商店按照时间先后形成的序列一定是 $p$ 的一个子序列. 考虑 dp, 设 $dp(i,j)$ 表示考虑了序列 $p$ 的前 $i$ 家商店,去了 $j$ 家商店最少用时,转移时枚举去不去第 $i$ 家商店. 这个 dp 的状态数是 $O(n^2)$ 的,无法直接通过,需要一些优化. 注意到如果没有 $a_i=0$ 的商店,花费的时间是随去的商店数目指数级增长的,即有效的 $j$ 只会有前 $O(\log T)$ 个. 而根据我们的排序方式, $a_i=0$ 的商店一定是排在 $a_i&gt;0$ 的商店后面的. 于是可以对 $a_i&gt;0$ 的所有商店做一次 dp ,就只会有 $O(n\log T)$ 个状态需要计算,设这样的商店共有 $k$ 个, 然后对于每个状态 $(j,dp(k,j))​$ ,贪心地将 $a_i=0​$ 的商店按照 $b_i​$ 从小到大依次去一遍,直到全部取完或时间超出 $T​$ . 只会有 $O(\log T)$ 个状态 $(j,dp(k,j))$ ,这部分的时间复杂度也是 $O(n\log T)$ . 再加上给 $n$ 个商店排序的复杂度,总时间复杂度为 $O(n\log n+n\log T)$ . code 这份代码为了偷懒,用了 map 存储 dp 值, 复杂度多了一个 $O(\log \log T)$ . 要去掉也很简单,转移时记录最大的有效的 $j$ ,每次枚举 $j$ 时只枚举到当前上限就可以了. E Odd Sum Rectangles假定 $n\le m$ . 先考虑 $n=m​$ 的情况,在构造 $(2^{n}-1)\times (2^n-1)​$ 的矩阵时,先构造出 $(2^{n-1}-1)\times (2^{n-1}-1)​$ 的矩阵. 把 $(2^{n-1}-1)\times (2^{n-1}-1)​$ 的矩阵在 $(2^{n}-1)\times (2^n-1)​$ 的矩阵的左上角,右上角,左下角,右下角各放一个. 这样就只剩下第 $2^{n-1}$ 行和第 $2^{n-1}$ 列没有填,在 $(2^{n-1},2^{n-1})$ 这个位置填 $1$ ,其他位置填 $0$ . 用归纳法可以证明这样构造的正确性,思路是证明每一次矩阵的权值都达到了 $4^{n-1}+2^{n-1}\cdot (2^n-1)$ 这个上界. 若 $n&gt; m​$ ,就先构造一个 $(2^{n}-1)\times (2^n-1)​$ 的矩阵,然后只保留前 $2^{m}-1​$ 列就可以了. code]]></content>
      <tags>
        <tag>Atcoder</tag>
        <tag>构造</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20200421]]></title>
    <url>%2F2020%2F04%2F21%2Ftest20200421%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+xg3xBuEotwApRM8tvgkVZL3lI01b1W4jKB8ibzFG3P6G+HjRr+OL7onCF7hmMs9yvGNYPVDSrkN1O3rxy0yV/sjls/JJPWsWi+Yw1oCC476iCJfAqjB1J9SjIkCjuRkkdDuZ4EIhOw/KV4FI/cw2nlf6MTgSO1K3uD49ZmRwTLUEFGikbFCkXBn8MMI5dDwHLp3qFzmi2MnKPCv0eLDN0yhkkXGuIs8pgJP3Xzq5nQYrwHw8RqmB6yYgsZVHgqI4uSPrhFlgs8/0iiuFQlUIe0KWD5KVWTIIWD/lX8n/o/SqzWLIfbYSrrQSU25N/1zofGjNy5LfR0CqGWcFkvv5wqIuDwYNoC8IZJNEIVF8hObDqjoZRKaec+5yvzf8Hs3B0lS3exnW8y+DiX9zd326PXga5W3UBHnDx/pJguHO3/+r08e4Thx9X89ptOw6I1RXkhJPmFaU/V+uSfjQRynoG6mNbh9/zEEUkyYTycZUGxHz4HDRwBeNlwmE5VxsoUH9wEf1xUNnronut+qMToVDi/LN3Ph3hhvpgCX7gS5ZqRDH0PXZsXpoxfr97LZ+Cvrt/Enf0XFeftGk3B5NdLvDP4vAhv0oJXL5Va/LmQlPjZCgOrZBjMI1Sznx9P8zZbDClDiOOJKhkprfEvSmJLMUKAg/nseIM8zh2ck/BkSbvKxGMNLiJozyTvPByQZkLl9m6Cy5LvLwnFGp/o2J5lt9taG/JzemeIdwcQG2Fpyi7mCSo1fggSCUl4Km8Qx7v4j/NKDbhEBAdOIsfLb1h1+PKLNNDwXZ89XWoBllf20Ot98rogJpi1kORJ2Etsw2r6OOb1FNXFBRX5/sFT6amWAE6495omEEAmLUttDGrSi1PXFdjoDhNimnadFj/tIbErCxz/gGh5P+WK6X+GRdRplRJFm8NJtQRd2L25naiboqqXZTwBkwwDufuvddy1onB05bbcHuK5N4lXYqPeC8MD70gTWPODiJ1zba3F71QWeNYuBoi5dlJcJexvBAMuv/HQI7I3FAPGrhgkVKFAQhooVuqxhA+fwTXWnh8afPlqAvGF7kJV5UuQQ+rg1tz8TWqbB2lTngPStkBLpoteFPeSNjWhMIFmeSlpaVFJ+RnsZYZBCMjswybUQEO7AmNyDSt6JrbdHOzjiaVYRmt42D+IiQYnvo6P8qlc0xXZn5+RiFXAD8EsYktg3USbSUN/qRcIitk97z8/opCistE9i+I9QBafQXjbtOC1SlXQpKHvgd+PjLs6ZwikGQ2qIXnF+P8QFs6LntYgR9juONyOo3IiwgxZ/EJlPHIq+IT8Z/fWNJxbQ0AeUEq7zWiusmakNK1mpzXhB9KA2uo9tlIhpjifXI0t7U4PJUUDkcB+xBmhDl7sevoFoRvirfyedCOEFggF182WDLk/zXa7TgFfdJ9lL3WYjxbNFylZTTeBrou8Tfgj5YhSEIs3ae1oWHZ7P02odAgr2LUdIEKXMxubO8ec1XZk+Xi1+RapeDwHA1qyGQ/KWpvzsOGguQBvq/jL0TJb/toGroeE1LRlGP5KzlGwNeMC925wLbZNG3kw8wEY3eQrVsSLLm4xgeh0CfVc7c/WgPPR62Hni/r9sIH6WQlnqMkiqqvNKqTkBTpUtDtfVcVSx+U90ce9vIs4LmeD6vsXfbaMiySRXnigzjs71HreOUQa//XByL9wYKXs8lJdp0P8h8FqZmwN2JdPaXffHNF4F8XbObws/7LcDWpyLjF+jdtoAH6eN6FT/8oH4cMACH8a9TbccdXfaTt4p5i/qkNpYJxYpg3XuS8itjj9PgdVXSGXS42OfFBTbYUKN/clXfZcQVLVTjRdNngLT35eTEoQ7Tl0qH+SPrO6PWsoHaog5Tp2fZeb9Tvr7qSyim+oErJ1ldGExnrOKkn3l/x0iBujkFGsHlOsRRLLkHyaW/Nn6EhdvWb0uO2fQrivnEfY7q2u4hpsPbBLH7LodDPhCj/x11rYjZC4e4KMNLsIPfyS4hY7NbdoMaUbA6zge3TZk+axaIy9C3Am3qBHC8KPQcZjSLCCMD8VHDoP8peBtrDGJpU61XPdYoQBwDvSdw4J0dby6a4FGuptctocAg4mAjj1SVqef+dIEX4xjnAIh0C1EgMH47NdZffNs1Gx8bL3C6Zei7bw1uht42V6d1SFK4Nw1zuKWQlKikGoPOAf8uOl7iwOySO4uTb+zM6q4X4U31/zijCEyW8lItm3w3Q0q6H8eE7sIGM7OhwmetqPxfgjqdjL9rQZA9sb4F9PBziFrk3lDaJzt3M5LRqy/JlSkfjOHWUjWllzpg6Jc4bqRfrkd/Sdthr0fnf0B6hjKoOXuBFDWgxzsAiGsdwk14IOyb9AIujs/zxuxXQeqDaeemHpEP1lHKscfZHXytfLwSuHj0HHShChxUyqaUX2E6SQeIc8gnRuKJnIVTguumUjMkce3gbR2ITBucweje7lOVlQXzIOJZCZsNrkgTIBLVQQEa4Ns/u2fmB4n0/AlHI+hMQDb3GYqB0TWfTQ9xHS5eZR1hj/XgR3NjQrbZ4kVoGviRH1K+oydj8XHsiw4x6ZQd4TciReAKvrzXyF0heUH2EVseGZOrv6eZuPHVWt/Bz7zVldFc0TJcI67/KbDbnaa/VmvFxFG1JaEZ4HngcjW6CIZK9NFQfu1I9H9jPveypr2qmcs0n98fg9zCBM9UqUTa3zhsCpnVCSgyCWSCU1io5W6tIqipx5Ae+x9Ig5Ji5QV8/PJIsa5OnuDnH6QPuOGryhYIcuOC1brDdK0lXPr90tv+ghEoKg+CvyB4j24LT8Qle348l83jmXkcmN5ZA1RuHYvOrVPPTkneEzc/DLkJGUlGNpj7P4rbWoR9+FUNk+VnzBQR3S5ea75hbkH6g/7+FDuxCfHalZOZMs+YSxst5hCvWjfULWjvfPvGRpXQg+ENZmoVipJDZrvmZT8cTJq/F+WehnL98pdnEH0Sd0v+nBgv6IhiW5xqG5/hIcyaU6nb7jWTKvWnpBpMQ10SZitWada9qG4oxFkupfg2895OKwSMdyngfDOAIRzW7fa8Zlwgj148SRUYpJAl8wWrNsthzGPtjWWbhwQ3tfViiHlYclC6BfUbx54fYj0kZNQtlXM7InlLBgesq6sJQPFGjk7DyH12Xd7fbClH6lqol241RlZ6FMhKom0qsEEyQ7pNfXwgLlCDgA52Ifxyhzks6RVo78aFsMeu66pt1lWS8L3eHhsPMQoic9ODkjnNEHPyl76FPB+yO3SuMZmw9TM/KnzYVHkKQ8LX5PMb0b+4+WYphWT56JmabPwLNj2gjnE40SyW6CZ7mkx4+QAkM8b4ELNqhf9siQtdIcF3g0ROs8lcbSVhlf8jvgspEbbVIe/z0Y/3BCtz7pHKDzGjJrM+Ym9nRIN0Kzu2+FXUrtQpiZfFqILwewKHzOwZXDKVGSSV+rkCkuuKdfSzamhk7oQ== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>树形dp</tag>
        <tag>状压dp</tag>
        <tag>SAM</tag>
        <tag>dsu on tree</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 572 Misaka Network 与求和]]></title>
    <url>%2F2020%2F04%2F19%2FLoj-572-Misaka-Network-%E4%B8%8E%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[杜教筛 + 魔改 min_25 筛. 为了方便,记 $f(i)$ 就表示次大质因子的 $k​$ 次幂. $$\begin{aligned}ans&amp;=\sum_{i=1}^n\sum_{j=1}^n f(\gcd(i,j)) \\&amp;=\sum_{d=1}^n f(d) \sum_{i=1}^{\lfloor\frac n d\rfloor}\sum_{j=1}^{^{\lfloor\frac n d\rfloor}} [\gcd(i,j)=1] \\&amp;=\sum_{d=1}^n \lfloor\frac{n}{d}\rfloor^2\sum_{t|d}\mu(t)f(\frac{d}{t})\\&amp;=\sum_{d=1}^n \lfloor\frac{n}{d}\rfloor^2\cdot (f*\mu)(d)\end{aligned}$$ 对 $d$ 整除分块,就需要多次询问 $f* \mu$ 的前缀和. 记 $h(n)=\sum_{i=1}^n (f* \mu)(i)$ . 用杜教筛的套路,可以得出 $$\sum_{i=1}^n f(n) = \sum_{i=1}^n (f \times \mu \times I) (i) = \sum_{i=1}^n h(\lfloor \frac n i \rfloor) \\h(n)=\sum_{i=1}^n f(i)-\sum_{i=2}^n h(\lfloor \frac n i \rfloor)$$ Latex 渲染有点问题,就用 $\times$ 代替 $*$ 作为狄利克雷卷积的符号了. 计算 $h$ 时整除分块,递归下去计算. 每次还会询问 $f$ 的前缀和,可以把 min_25 筛魔改一下,在提出因子时,如果它是次大因子,才计入贡献. 此外,还要把 $\le n$ 的每个质数贡献的 $1$ 加入 $h(n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned int uint;inline uint read()&#123; uint out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;uint fpow(uint a, int b)&#123; uint res = 1; while (b) &#123; if (b &amp; 1) res = res * a; a = a * a; b &gt;&gt;= 1; &#125; return res;&#125;const int N = 2e5 + 10;int n, k, sqr, w[N], tot = 0, id1[N], id2[N];int cnt = 0, ism[N], prime[N]; uint pk[N], g[N], _h[N];int vis_h[N];int id(int x)&#123; if (x &lt;= sqr) return id1[x]; return id2[n / x];&#125;void init()&#123; ism[1] = 1, pk[1] = 1; for (int i = 2; i &lt;= sqr; ++i) &#123; if (!ism[i]) prime[++cnt] = i, pk[i] = fpow(i, k); for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= sqr; ++j) &#123; ism[i * prime[j]] = 1; if (i % prime[j] == 0) break; pk[i * prime[j]] = pk[i] * pk[prime[j]]; &#125; &#125; for (int l = 1, r; l &lt;= n; l = r + 1) &#123; r = n / (n / l); w[++tot] = n / l; if (n / l &lt;= sqr) id1[n / l] = tot; else id2[n / (n / l)] = tot; &#125; for (int i = 1; i &lt;= tot; ++i) g[i] = w[i] - 1; for (int j = 1; j &lt;= cnt; ++j) for (int i = 1; i &lt;= tot &amp;&amp; prime[j] * prime[j] &lt;= w[i]; ++i) &#123; int k = id(w[i] / prime[j]); g[i] -= g[k] - j + 1; &#125;&#125;uint S(int x, int j)&#123; if (x &lt;= 1 || prime[j] &gt; x) return 0; uint res = 0; for (int i = j; i &lt;= cnt &amp;&amp; prime[i] * prime[i] &lt;= x; ++i) for (ll pw = prime[i]; pw * prime[i] &lt;= x; pw *= prime[i]) res += S(x / pw, i + 1) + (g[id(x / pw)] - i + 1) * pk[prime[i]]; return res;&#125;uint h(int x)&#123; int pos = id(x); if (vis_h[pos]) return _h[pos]; vis_h[pos] = 1; uint res = S(x, 1) + g[pos]; for (int l = 2, r; l &lt;= x; l = r + 1) &#123; r = x / (x / l); res -= h(x / l) * (uint)(r - l + 1); &#125; return _h[pos] = res; &#125;int main()&#123; n = read(), k = read(); sqr = ceil(sqrt(n)); init(); uint ans = 0, lst = 0, cur; for (int l = 1, r; l &lt;= n; l = r + 1) &#123; r = n / (n / l); cur = h(r); ans += (cur - lst) * (uint)(n / l) * (uint)(n / l); lst = cur; &#125; printf("%u\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6682 梦中的数论]]></title>
    <url>%2F2020%2F04%2F19%2FLoj-6682-%E6%A2%A6%E4%B8%AD%E7%9A%84%E6%95%B0%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[min_25 筛. 先枚举 $i$ ,答案就变成了$$ans=\sum_{i=1}^n \binom{\sigma_0(i)}{2}\\=\frac {\sum_{i=1}^n \sigma_0^2(i)-\sum_{i=1}^n \sigma_0(i)} 2 \\=\frac {\sum_{i=1}^n \sigma_0^2(i)-\sum_{i=1}^n \lfloor\frac{n}{i}\rfloor} 2$$后面那个 $\sum$ 可以直接整除分块 $O(\sqrt n)$ 求出. 对于前面那个 $\sum$ ,注意到 $\sigma_0^2(x)$ 也是积性函数,且当 $p$ 为质数时, $\sigma_0^2(p^k)=(k+1)^2$ ,容易计算. 于是可以考虑用 min_25 筛求出其前缀和,时间复杂度 $O(\frac{n^{\frac 3 4}}{\log n})$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;const int P = 998244353;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;const int N = 2e5 + 10;ll n, w[N];int sqr, prime[N], ism[N], cnt = 0, g[N], id1[N], id2[N], tot = 0, ans = 0;int id(ll x)&#123; if (x &lt;= sqr) return id1[x]; return id2[n / x];&#125;void init()&#123; ism[1] = 1; for (int i = 2; i &lt;= sqr; ++i) &#123; if (!ism[i]) prime[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; prime[j] &lt;= sqr / i; ++j) &#123; ism[i * prime[j]] = 1; if (i % prime[j] == 0) break; &#125; &#125; for (ll l = 1, r; l &lt;= n; l = r + 1) &#123; r = n / (n / l); inc(ans, P - mul(n / l % P, (r - l + 1) % P)); w[++tot] = n / l; if (n / l &lt;= sqr) id1[n / l] = tot; else id2[n / (n / l)] = tot; &#125; for (int i = 1; i &lt;= tot; ++i) g[i] = (w[i] - 1) % P; for (int j = 1; j &lt;= cnt; ++j) for (int i = 1; i &lt;= tot &amp;&amp; prime[j] &lt;= w[i] / prime[j]; ++i) &#123; int k = id(w[i] / prime[j]); inc(g[i], P - add(g[k], add(1, P - j))); &#125; for (int i = 1; i &lt;= tot; ++i) g[i] = mul(g[i], 4);&#125;int S(ll x, int j)&#123; if (x &lt;= 1 || prime[j] &gt; x) return 0; int s = add(g[id(x)], P - mul(4, j - 1)); for (int k = j; k &lt;= cnt &amp;&amp; prime[k] &lt;= x / prime[k]; ++k) &#123; ll pw = prime[k], t = 1LL * prime[k] * prime[k]; for (int e = 1; t &lt;= x; ++e) &#123; inc(s, mul((e + 1) * (e + 1), S(x / pw, k + 1))); inc(s, (e + 2) * (e + 2)); pw *= prime[k], t *= prime[k]; &#125; &#125; return s;&#125;int main()&#123; n = read(), sqr = ceil(sqrt(n)); init(); inc(ans, 1); inc(ans, S(n, 1)); ans = mul(ans, (P + 1) &gt;&gt; 1); printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6181 某个套路求和题]]></title>
    <url>%2F2020%2F04%2F19%2FLoj-6181-%E6%9F%90%E4%B8%AA%E5%A5%97%E8%B7%AF%E6%B1%82%E5%92%8C%E9%A2%98%2F</url>
    <content type="text"><![CDATA[复习了一下 min_25 筛. 考虑化简 $f(n)=\prod_{d|n} \mu(d)$ . 当 $n$ 有平方因子时, $f(n) = 0$ ,否则我们考虑有几个 $\mu(d)=-1$ ,就可以算出 $\mu(n)$ . 记 $n$ 有 $\omega(n)$ 种不同的质因子,由于 $n$ 没有平方因子,所以各个质因子的次数都是 $1$ . $d$ 是 $n$ 的约数可以看做从 $\omega(n)$ 个质因子中选出一些乘起来组成的,而 $\mu(d)=-1$ 等价于选了奇数个. 那么显然有 $2^{\omega(n)-1}$ 种选法,只有当 $n$ 为质数时有奇数个 $\mu(d)=-1$ ,其他情况都有偶数个. 于是可以得出$$ans=\sum_{i=1}^n\mu^2(i) -\sum_{i=1}^n 2\times [i\in Prime]$$后者是 $1$ 到 $n$ 中质数个数的 $2$ 倍,可以用 min_25 筛求出. 考虑如何求 $\sum \mu^2(i)$ ,记 $p(n)=\max_{d^2|n} \lbrace d\rbrace$ 表示 $n$ 的最大平方因子,则$$\sum_{i=1}^n \mu^2(i) \\=\sum_{i=1}^n [p(i)=1] \\=\sum_{d=1}^n \mu(d) \sum_{d|p(i)}1 \\=\sum_{d=1}^n\mu(d) \sum_{d^2|i} 1\\=\sum_{d=1}^n \mu(d) \lfloor \frac n {d^2} \rfloor$$于是筛出 $\sqrt n$ 以内的 $\mu$ ,就可以在 $O(\sqrt n)$ 内计算出 $\sum \mu^2(i)$ 了. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;const int N = 1e5 + 10, P = 998244353;ll w[N * 2], g[N * 2], n;int sqr, mu[N], prime[N], cnt = 0, ism[N], id1[N], id2[N], tot = 0;void init()&#123; ism[1] = 1, mu[1] = 1; for (int i = 2; i &lt;= sqr; ++i) &#123; if (!ism[i]) prime[++cnt] = i, mu[i] = -1; for (int j = 1; i * prime[j] &lt;= sqr &amp;&amp; j &lt;= cnt; ++j) &#123; ism[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; for (ll l = 1, r; l &lt;= n; l = r + 1) &#123; r = n / (n / l); w[++tot] = n / l; if (n / l &lt;= sqr) id1[n / l] = tot; else id2[n / (n / l)] = tot; &#125; for (int i = 1; i &lt;= tot; ++i) g[i] = w[i] - 1; for (int j = 1; j &lt;= cnt; ++j) for (int i = 1; i &lt;= tot &amp;&amp; prime[j] &lt;= w[i] / prime[j]; ++i) &#123; ll k = w[i] / prime[j]; if (k &lt;= sqr) k = id1[k]; else k = id2[n / k]; g[i] -= g[k] - j + 1; &#125;&#125;int main()&#123; n = read(), sqr = ceil(sqrt(n)); init(); ll ans = 0; for (int i = 1; i &lt;= n / i; ++i) ans += 1LL * mu[i] * (n / i / i); ans -= 2 * g[1]; printf("%lld\n", (ans % P + P) % P); return 0;&#125;]]></content>
      <tags>
        <tag>min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20200418]]></title>
    <url>%2F2020%2F04%2F18%2Ftest20200418%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>Burnside/Polya</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20200417]]></title>
    <url>%2F2020%2F04%2F17%2Ftest20200417%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>贪心</tag>
        <tag>树状数组</tag>
        <tag>李超线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6031 字符串]]></title>
    <url>%2F2020%2F04%2F16%2FLoj-6031-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[SAM + 根号分治. 每次询问的 $k$ 都是一样的,可以记一个常数 $p=kq$ ,考虑根号分治,对 $k\le q$ 和 $k&gt;q$ 两种情况讨论. $k\le q$每次询问的串长不会超过 $\sqrt p$ ,可以直接枚举 $w$ 的每个子串 $w[l,r]$ . 算出这个子串在 $s$ 中出现的次数,再乘上 $[l,r]$ 这个区间在第 $a$ 到第 $b$ 个区间出现的次数,就是这个子串对询问贡献. 前者可以在串 $s$ 的 SAM 上找出 $w[l,r]$ 对应的状态,其 right 集合大小即为出现次数. 后者可以将 $[l,r]$ 在 $m$ 个区间中出现的所有位置存在 vector 中,二分找出 $a,b$ 的位置,做差即为所求. 时间复杂度 $O(qk^2\log m)=O(p\sqrt p \log m)$ . $k&gt; q$询问的次数不超过 $\sqrt p$ ,对于每次询问,我们都将第 $a$ 个区间到第 $b$ 个区间拿出来,考虑每个区间 $[l,r]$ 的贡献. $w[l,r]$ 在串 $s$ 中出现的次数等价于 $s$ 有多少个前缀与 $w[1,r]$ 的 LCS 长度不小于 $r-l+1$ . 将 $w[1,r]$ 在 SAM 上对应的位置找出,倍增查找出其深度最浅的满足 $maxlen\ge r-l+1$ 的祖先. 其 right 集合大小即为所求. 注意在给 $w[1,r]$ 定位时,若沿着失配边往回跳,有效的后缀长度就会改变. 时间复杂度 $O(q(k+m\log n))=O(p+m\sqrt p\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;const int N = 2e5 + 10, S = 26, K = 320;int fa[N], len[N], siz[N], ch[N][S], idx = 1, lst = 1;void Extend(int c)&#123; int p = lst, np = ++idx; lst = np; len[np] = len[p] + 1, siz[np] = 1; while (p &amp;&amp; !ch[p][c]) ch[p][c] = np, p = fa[p]; if (!p) fa[np] = 1; else &#123; int q = ch[p][c]; if (len[q] == len[p] + 1) fa[np] = q; else &#123; int nq = ++idx; len[nq] = len[p] + 1; fa[nq] = fa[q]; fa[q] = fa[np] = nq; memcpy(ch[nq], ch[q], sizeof ch[nq]); while (p &amp;&amp; ch[p][c] == q) ch[p][c] = nq, p = fa[p]; &#125; &#125;&#125;int A[N], t[N];void toposort()&#123; for (int i = 1; i &lt;= idx; ++i) ++t[len[i]]; for (int i = 1; i &lt;= idx; ++i) t[i] += t[i - 1]; for (int i = 1; i &lt;= idx; ++i) A[t[len[i]]--] = i;&#125;char s[N], w[N];int n, m, q, k, L[N], R[N];namespace Case1&#123; vector&lt;int&gt; vc[K][K]; int calc(int a, int b, int l, int r) &#123; int x = lower_bound(vc[l][r].begin(), vc[l][r].end(), a) - vc[l][r].begin(); int y = upper_bound(vc[l][r].begin(), vc[l][r].end(), b) - vc[l][r].begin() - 1; return y - x + 1; &#125; void solve() &#123; for (int i = 1; i &lt;= m; ++i) if (1 &lt;= L[i] &amp;&amp; L[i] &lt;= R[i] &amp;&amp; R[i] &lt;= k) vc[L[i]][R[i]].push_back(i); while (q--) &#123; scanf("%s", w + 1); int a = read() + 1, b = read() + 1; ll ans = 0; for (int l = 1; l &lt;= k; ++l) &#123; int x = 1; for (int r = l; r &lt;= k; ++r) &#123; x = ch[x][w[r] - 'a']; if (!siz[x]) break; if (vc[l][r].empty()) continue; if (vc[l][r].back() &lt; a || vc[l][r].front() &gt; b) continue; ans += 1LL * siz[x] * calc(a, b, l, r); &#125; &#125; printf("%lld\n", ans); &#125; &#125;&#125;namespace Case2&#123; const int D = 18; int Fa[N][D], dep[N]; vector&lt;int&gt; tmp[N]; int query(int x, int bound) &#123; if (len[x] &lt; bound) return 0; for (int i = D - 1; i &gt;= 0; --i) if ((1 &lt;&lt; i) &lt;= dep[x] &amp;&amp; len[Fa[x][i]] &gt;= bound) x = Fa[x][i]; return siz[x]; &#125; int tot[N]; void solve() &#123; for (int i = 2; i &lt;= idx; ++i) &#123; int x = A[i]; dep[x] = dep[fa[x]] + 1, Fa[x][0] = fa[x]; for (int j = 1; (1 &lt;&lt; j) &lt;= dep[x]; ++j) Fa[x][j] = Fa[Fa[x][j - 1]][j - 1]; &#125; while (q--) &#123; scanf("%s", w + 1); int a = read() + 1, b = read() + 1; for (int i = a; i &lt;= b; ++i) tmp[R[i]].push_back(L[i]); ll ans = 0; int x = 1, cnt = 0; for (int r = 1; r &lt;= k; ++r) &#123; int c = w[r] - 'a'; if (ch[x][c]) &#123; x = ch[x][c]; ++cnt; &#125; else &#123; while (x &amp;&amp; !ch[x][c]) x = fa[x]; if (!x) x = 1, cnt = 0; else cnt = len[x] + 1, x = ch[x][c]; &#125; for (int l : tmp[r]) if (cnt &gt;= r - l + 1) ans += query(x, r - l + 1); &#125; printf("%lld\n", ans); for (int i = a; i &lt;= b; ++i) tmp[R[i]].clear(); &#125; &#125;&#125;int main()&#123; n = read(), m = read(), q = read(), k = read(); scanf("%s", s + 1); for (int i = 1; i &lt;= n; ++i) Extend(s[i] - 'a'); toposort(); for (int i = idx; i &gt;= 2; --i) siz[fa[A[i]]] += siz[A[i]]; for (int i = 1; i &lt;= m; ++i) L[i] = read() + 1, R[i] = read() + 1; if (k &lt;= q) Case1::solve(); else Case2::solve(); return 0;&#125;]]></content>
      <tags>
        <tag>倍增</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20200415]]></title>
    <url>%2F2020%2F04%2F15%2Ftest20200415%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>博弈论</tag>
        <tag>dsu on tree</tag>
        <tag>test</tag>
        <tag>点分治</tag>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2564 原题识别]]></title>
    <url>%2F2020%2F04%2F14%2FLoj-2564-%E5%8E%9F%E9%A2%98%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[比较麻烦的二维数点. 随机生成数据带来的性质首先需要注意数据的生成方式是给出的,表面上是减少输入量,实际上蕴含了这棵树的一些有用的性质. 前 $p$ 个点形成一条主链,后面的点随机向前面的点连边,那么每个点到主链的距离期望是 $O(\log n)$ 的. 于是对于树上任意两个点 $x,y$ 和它们的最近公共祖先 $l$ , $\min(dis(x,l),dis(y,l))$ 的期望也是 $O(\log n)$ 的. 此外,由于每个点颜色是在 $[1,n]$ 中随机的,所以在期望意义下,每种颜色只会有 $O(1)$ 个点. 第一问先考虑第一问怎么做,求区间内颜色数目通常可以找出 $p_i$ 表示上一个和 $i$ 颜色相同的点,然后二维数点. 现在是在树上,就令 $p_i$ 表示 $i$ 的所有真祖先中,颜色与 $i​$ 相同且深度最大的点. 不妨令 $dis(x,l) &lt;dis(y,l)$ ,我们可以先求出 $[l, y]$ 这条链上的颜色数目,这可以用主席树二维数点 $O(\log n)$ 求出. 再枚举 $(l,x]​$ 链上的每个点 $i​$ ,若 $i​$ 的颜色是 $c​$ ,就找出所有颜色是 $c​$ 的点,如果都没有在 $[l,y]​$ 上出现, $i​$ 就有贡献 $1​$. 检查某个点是否在 $[l,y]$ 这条链上可以直接用欧拉序判断. $(l,x]​$ 这条链上期望只会有 $O(\log n)​$ 个点,而每个点期望只会有 $O(1)​$ 个点和它颜色相同,每次判断也是 $O(1)​$ 的. 于是单次第一种询问的时间复杂度为 $O(\log n)​$ . 第二问仍然令 $dis(x,l) &lt;dis(y,l)$ ,可以讨论 $a,b$ 所在的位置,拆成三个子问题. Case 1$a\in [1,l), b\in [1,y]$ .这等价于在一条链上询问,点 $i$ 能产生贡献,当且仅当 $L\in[p_i+1,i], R\ge i$ . 于是可以对 $i​$ 分段,将贡献大力拆开,用主席树维护一下区间的 $\sum 1, \sum i,\sum p_i,\sum i\cdot p_i​$ 就可以支持询问. Case 2$a\in [l,x],b\in[1,l)$ .我们把 $a\in [1,x],b\in[1,l) $ 的贡献算出来,再减去 $a\in [1,l),b\in[1,l) $ 的贡献. 这两种贡献和 Case 1 的形式是一样的. Case 3$a\in [l,x],b\in[l,y]$ .先计算 $[l,y]$ 上的点的贡献,此时不考虑 $[l,x]$ 内的点的颜色,贡献拆开后就是一个二维数点. 再考虑 $[l,x]$ 上的每个点 $i$ ,它有贡献当且仅当 $p_i&lt;l$ 且 $[l,b]$ 内没有和它颜色相同的点. 找出 $q_i$ 表示 $[l,y]$ 中第一个和 $i$ 颜色相同的点(没有就记作 $y+1$ ). 当 $p_i&lt;l$ 时,就有贡献 $(x-i+1)(q_i-l)$ ,仍然可以用二维数点计算. 每种情况都可以在 $O(\log n)$ 的时间内求出贡献,总复杂度 $O(n \log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline unsigned int read()&#123; unsigned int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;unsigned int SA, SB, SC;unsigned int rng61()&#123; SA ^= SA &lt;&lt; 16; SA ^= SA &gt;&gt; 5; SA ^= SA &lt;&lt; 1; unsigned int t = SA; SA = SB; SB = SC; SC ^= t ^ SA; return SC;&#125;const int N = 4e5 + 10, K = 19;int n, m, len, ecnt, head[N], to[N], nx[N], col[N], fa[N];void addedge(int u, int v)&#123; ++ecnt; to[ecnt] = v; nx[ecnt] = head[u]; head[u] = ecnt;&#125;void gen()&#123; for (int i = 2; i &lt;= n; ++i) &#123; if (i &lt;= len) fa[i] = i - 1; else fa[i] = rng61() % (i - 1) + 1; addedge(fa[i], i); &#125; for (int i = 1; i &lt;= n; ++i) col[i] = rng61() % n + 1;&#125;vector&lt;int&gt; vec[N];int dfn[N], ed[N], Log[N], st[N][K], dep[N], app[N], ptot, tot;ll pre2[N], pre3[N];struct info&#123; ll sum1, sum2, sum3, sum4; info(ll sum1 = 0, ll sum2 = 0, ll sum3 = 0, ll sum4 = 0) : sum1(sum1), sum2(sum2), sum3(sum3), sum4(sum4) &#123;&#125; info&amp; operator += (const info &amp;rhs) &#123; sum1 += rhs.sum1, sum2 += rhs.sum2; sum3 += rhs.sum3, sum4 += rhs.sum4; return *this; &#125; info&amp; operator -= (const info &amp;rhs) &#123; sum1 -= rhs.sum1, sum2 -= rhs.sum2; sum3 -= rhs.sum3, sum4 -= rhs.sum4; return *this; &#125;&#125; tree[N * 20];int ls[N * 20], rs[N * 20];void upd(int &amp;o, int lst, int l, int r, int x, int y)&#123; o = ++ptot; tree[o] = tree[lst], ls[o] = ls[lst], rs[o] = rs[lst]; ++tree[o].sum1, tree[o].sum2 += y; tree[o].sum3 += x, tree[o].sum4 += 1LL * x * y; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (y &lt;= mid) upd(ls[o], ls[lst], l, mid, x, y); else upd(rs[o], rs[lst], mid + 1, r, x, y);&#125;void query(info &amp;res, int tl, int tr, int l, int r, int L, int R)&#123; if (tl == tr || l &gt; R || r &lt; L) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; res += tree[tr]; res -= tree[tl]; return; &#125; int mid = (l + r) &gt;&gt; 1; if (L &lt;= mid) query(res, ls[tl], ls[tr], l, mid, L, R); if (R &gt; mid) query(res, rs[tl], rs[tr], mid + 1, r, L, R);&#125;int lst[N], rt[N];void dfs(int u, int Fa)&#123; st[dfn[u] = ++tot][0] = u, dep[u] = dep[Fa] + 1; vec[col[u]].push_back(u), lst[u] = app[col[u]]; int t = app[col[u]]; app[col[u]] = u; pre2[u] = pre2[Fa] + dep[u] - dep[lst[u]]; pre3[u] = pre3[Fa] + 1LL * (dep[u] - dep[lst[u]]) * dep[u]; upd(rt[u], rt[Fa], 0, n, dep[u], dep[lst[u]]); for (int i = head[u]; i; i = nx[i]) &#123; int v = to[i]; dfs(v, u); st[++tot][0] = u; &#125; app[col[u]] = t, ed[u] = tot;&#125;int LCA(int x, int y)&#123; x = dfn[x], y = dfn[y]; if (x &gt; y) swap(x, y); int k = Log[y - x + 1]; if (dep[st[x][k]] &lt; dep[st[y - (1 &lt;&lt; k) + 1][k]]) return st[x][k]; else return st[y - (1 &lt;&lt; k) + 1][k];&#125;int vis[N];bool onlink(int x, int y, int p)&#123; return dfn[x] &lt;= dfn[p] &amp;&amp; dfn[p] &lt;= ed[x] &amp;&amp; dfn[p] &lt;= dfn[y] &amp;&amp; dfn[y] &lt;= ed[p];&#125;ll calc1(int x, int y)&#123; ++tot; int la = LCA(x, len), lb = LCA(y, len); if (la &gt; lb) swap(x, y); int l = LCA(x, y); info tmp = info(0, 0, 0, 0); query(tmp, rt[fa[l]], rt[y], 0, n, 0, dep[l] - 1); int res = tmp.sum1; for (int i = x; i != l; i = fa[i]) if (vis[col[i]] != tot) &#123; vis[col[i]] = tot; int fl = 1, sz = vec[col[i]].size(); for (int j = 0; j &lt; sz &amp;&amp; fl; ++j) if (onlink(l, y, vec[col[i]][j])) fl = 0; res += fl; &#125; return res;&#125;ll calc(int x, int y, info res)&#123; int a = dep[x], b = dep[y]; ll s = (res.sum1 * a - res.sum2) * (b + 1) - res.sum3 * a + res.sum4; return s + 1LL * (a + b + 2) * pre2[x] - 2 * pre3[x] - a; &#125;ll calc2(int x, int y)&#123; ++tot; int la = LCA(x, len), lb = LCA(y, len); if (la &gt; lb) swap(x, y); int l = LCA(x, y), pl = fa[l], dl = dep[l]; info t1 = info(0, 0, 0, 0), t2 = t1; query(t1, rt[pl], rt[y], 0, n, 0, dl - 1); query(t2, rt[pl], rt[x], 0, n, 0, dl - 1); ll res = calc(pl, y, t1) + calc(pl, x, t2); res -= 2 * (1LL * dl * pre2[pl] - pre3[pl]) + dl - 1; res += (1LL * (dep[y] + 1) * t1.sum1 - t1.sum3) * (dep[x] - dl + 1); int tp = 0; for (int i = x; i != l; i = fa[i]) app[++tp] = i; app[++tp] = l; while (tp &gt; 0) &#123; int i = app[tp--]; if (vis[col[i]] != tot) &#123; vis[col[i]] = tot; int mn = dep[y] + 1, sz = vec[col[i]].size(); for (int j = 0; j &lt; sz; ++j) if (onlink(l, y, vec[col[i]][j]) &amp;&amp; mn &gt; dep[vec[col[i]][j]]) mn = dep[vec[col[i]][j]]; res += 1LL * (mn - dl) * (dep[x] - dep[i] + 1); &#125; &#125; return res;&#125;void solve()&#123; dfs(1, 0); Log[1] = 0; for (int i = 2; i &lt;= tot; ++i) Log[i] = Log[i &gt;&gt; 1] + 1; for (int j = 1; j &lt; K; ++j) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= tot; ++i) if (dep[st[i][j - 1]] &lt; dep[st[i + (1 &lt;&lt; j &gt;&gt; 1)][j - 1]]) st[i][j] = st[i][j - 1]; else st[i][j] = st[i + (1 &lt;&lt; j &gt;&gt; 1)][j - 1]; tot = 0; m = read(); for (int i = 1; i &lt;= m; ++i) &#123; int op = read(), x = read(), y = read(); if (op == 1) printf("%lld\n", calc1(x, y)); else printf("%lld\n", calc2(x, y)); &#125;&#125;void reset()&#123; ecnt = ptot = tot = 0; for (int i = 1; i &lt;= n; ++i) &#123; rt[i] = head[i] = vis[i] = app[i] = 0; vec[i].clear(); &#125; &#125;int main()&#123; int T = read(); while (T--) &#123; n = read(), len = read(); SA = read(), SB = read(), SC = read(); gen(); solve(); reset(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2052 矿区]]></title>
    <url>%2F2020%2F04%2F14%2FLoj-2052-%E7%9F%BF%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[平面图转对偶图. 先把平面图转成对偶图. 方法是把每条无向边拆成两条有向边,规定每个面都在围成它的有向边的左侧,这样每条有向边就只会被用一次. 对于每个边,按照极角序找它转动后下一条边,这样会形成一个置换. 分解后得到的每个环就对应了每个面,即对偶图中的每个点,再在有公共边的面之间连边即可. 找出面的时候用叉积顺便算一下面积,面积为负数的就是外面无穷大的面. 然后以最外面无穷大的面为根,做一棵生成树出来,询问时按照最外围边对子树和容斥一下即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;ll Abs(ll x)&#123; return x &gt; 0 ? x : -x;&#125;const double eps = 1e-10;const int N = 4e6 + 10;int n, m, q, rt, cnt, tid[N];ll sum[N][2];struct v2&#123; int x, y; v2(int x = 0, int y = 0) : x(x), y(y) &#123;&#125; v2 operator - (const v2 &amp;rhs) const &#123; return v2(x - rhs.x, y - rhs.y); &#125; ll operator * (const v2 &amp;rhs) const &#123; return 1LL * x * rhs.y - 1LL * y * rhs.x; &#125; double angle() &#123; return atan2(y, x); &#125;&#125; p[N];double calc(int u, int v)&#123; return (p[v] - p[u]).angle();&#125;struct Edge&#123; int u, v, id; double slop; Edge(int u = 0, int v = 0, int id = 0, double slop = 0) : u(u), v(v), id(id), slop(slop) &#123;&#125; friend bool operator &lt; (Edge A, Edge B) &#123; if (fabs(A.slop - B.slop) &gt; eps) return A.slop &lt; B.slop; return A.v &lt; B.v; &#125;&#125; E[N];typedef vector&lt;Edge&gt;::iterator vit;vector&lt;Edge&gt; vec[N];namespace DualGraph&#123; int ecnt = 1, head[N], to[N], nx[N]; void addedge(int u, int v) &#123; ++ecnt; to[ecnt] = v; nx[ecnt] = head[u]; head[u] = ecnt; &#125; int fa[N], vis[N], ontree[N]; void dfs(int u, int F) &#123; fa[u] = F, vis[u] = 1; for (int i = head[u]; i; i = nx[i]) &#123; int v = to[i]; if (vis[v]) continue; ontree[i] = ontree[i ^ 1] = 1; dfs(v, u); sum[u][0] += sum[v][0], sum[u][1] += sum[v][1]; &#125; &#125; int np[N]; void solve() &#123; dfs(rt, 0); ll num = 0, deno = 0; for (int i = 1; i &lt;= q; ++i) &#123; ll c = (read() + num) % n + 1; for (int j = 1; j &lt;= c; ++j) &#123; ll x = (read() + num) % n + 1; np[j] = x; &#125; np[c + 1] = np[1]; num = deno = 0; for (int j = 1; j &lt;= c; ++j) &#123; int x = np[j], y = np[j + 1]; Edge tmp = Edge(x, y, 0, calc(x, y)); vit it = lower_bound(vec[x].begin(), vec[x].end(), tmp); int a = (*it).id, b = a ^ 1; if (!ontree[a]) continue; a = tid[a], b = tid[b]; if (fa[a] == b) &#123; deno += sum[a][0]; num += sum[a][1]; &#125; else if (fa[b] == a) &#123; deno -= sum[b][0]; num -= sum[b][1]; &#125; &#125; num = Abs(num), deno = Abs(deno); ll g = __gcd(num, deno); num /= g, deno /= g; printf("%lld %lld\n", num, deno); &#125; &#125;&#125;namespace PlanGraph&#123; int ecnt = 1, nx[N]; void addedge(int u, int v) &#123; ++ecnt; E[ecnt] = Edge(u, v, ecnt, calc(u, v)); vec[u].push_back(E[ecnt]); &#125; void Init() &#123; n = read(), m = read(), q = read(); for (int i = 1; i &lt;= n; ++i) p[i].x = read(), p[i].y = read(); for (int i = 1; i &lt;= m; ++i) &#123; int u = read(), v = read(); addedge(u, v); addedge(v, u); &#125; for (int i = 1; i &lt;= n; ++i) sort(vec[i].begin(), vec[i].end()); for (int i = 2; i &lt;= ecnt; ++i) &#123; int v = E[i].v; vit it = lower_bound(vec[v].begin(), vec[v].end(), E[i ^ 1]); if (it == vec[v].begin()) it = vec[v].end(); --it; nx[i] = (*it).id; &#125; for (int i = 2; i &lt;= ecnt; ++i) if (!tid[i]) &#123; tid[i] = ++cnt; ll Area = 0; v2 st = p[E[i].u]; for (int x = nx[i]; x != i; x = nx[x]) &#123; tid[x] = cnt; v2 a = p[E[x].u], b = p[E[x].v]; Area += (a - st) * (b - st); &#125; if (Area &lt; 0) rt = cnt; else &#123; sum[cnt][0] = Area * 2; sum[cnt][1] = Area * Area; &#125; &#125; for (int i = 2; i &lt;= ecnt; ++i) DualGraph::addedge(tid[i], tid[i ^ 1]); &#125;&#125;int main()&#123; PlanGraph::Init(); DualGraph::solve(); return 0;&#125;]]></content>
      <tags>
        <tag>对偶图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2882 两个人的星座]]></title>
    <url>%2F2020%2F04%2F13%2FLoj-2882-%E4%B8%A4%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%98%9F%E5%BA%A7%2F</url>
    <content type="text"><![CDATA[极角排序. 两个三角形如果相离,则一定可以用公切线分开. 枚举两个点的连线作为公切线,统计两个半平面中各类颜色点的数目,时间复杂度 $O(n^3)$ . 优化一下,先枚举一个点作为原点,对其他点极角排序. 再枚举另一个点,用前缀和询问两个半平面中各类颜色点的数目. 由于两个相离的三角形通过顶点相连可以产生 $4$ 根公切线,所以最后还需要将答案除掉 $4$ . 时间复杂度 $O(n^2\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;const int N = 3e3 + 10;int sgn(int x)&#123; return x &gt;= 0;&#125;struct v2&#123; int x, y, col; v2(int x = 0, int y = 0, int col = 0) : x(x), y(y), col(col) &#123;&#125; v2 operator + (const v2 &amp;rhs) const &#123; return v2(x + rhs.x, y + rhs.y, col); &#125; v2 operator - (const v2 &amp;rhs) const &#123; return v2(x - rhs.x, y - rhs.y, col); &#125; ll operator * (const v2 &amp;rhs) const &#123; return 1LL * x * rhs.y - 1LL * y * rhs.x; &#125; friend bool operator &lt; (v2 A, v2 B) &#123; if (sgn(A.y) != sgn(B.y)) return sgn(A.y) &gt; sgn(B.y); return A * B &gt; 0; &#125;&#125; p[N], a[N];int n, sum[N][3], pos[N], t[2][3];int query(int l, int r, int col)&#123; if (l &gt; r) return 0; return sum[r][col] - sum[l - 1][col];&#125;ll calc()&#123; for (int i = 2; i &lt;= n; ++i) a[i - 1] = p[i] - p[1]; sort(a + 1, a + n); for (int i = 1; i &lt; n; ++i) &#123; for (int j = 0; j &lt; 3; ++j) sum[i][j] = sum[i - 1][j]; ++sum[i][a[i].col]; &#125; ll s = 0; for (int i = 1; i &lt; n; ++i) &#123; v2 iv = v2(0, 0, 0) - a[i]; int l = i, r = lower_bound(a + 1, a + n, iv) - a; memset(t, 0, sizeof t); for (int j = 0; j &lt; 3; ++j) &#123; t[0][j] += query(r, n - 1, j); t[0][j] += query(1, l - 1, j); t[1][j] += query(l + 1, r - 1, j); &#125; int c = p[1].col, d = a[i].col; for (int id = 0; id &lt; 2; ++id) &#123; ll prod = 1; for (int j = 0; j &lt; 3; ++j) &#123; if (c != j) prod *= t[id][j]; if (d != j) prod *= t[id ^ 1][j]; &#125; s += prod; &#125; &#125; return s;&#125;int main()&#123; n = read(); for (int i = 1; i &lt;= n; ++i) &#123; p[i].x = read(), p[i].y = read(); p[i].col = read(); &#125; ll ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; swap(p[1], p[i]); ans += calc(); swap(p[1], p[i]); &#125; ans /= 2; printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>极角排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6358 前夕]]></title>
    <url>%2F2020%2F04%2F13%2FLoj-6358-%E5%89%8D%E5%A4%95%2F</url>
    <content type="text"><![CDATA[二项式定理 + 单位根反演. 在 $n$ 个元素组成的 $2^n$ 个集合中选出若干集合,使得它们交集大小为 $4$ 的倍数,求方案数. $n\le 10^7$ . 考虑容斥,钦定交集中包含了 $k$ 个元素的总方案数为$$g(k)=\binom n k (2^{2^{n-k}}-1)$$考虑构造出容斥系数 $f$ ,使得$$ans =\sum_{i=0}^n f(k)g(k)$$对于交集大小为 $x$ 的某种方案,对答案的贡献应当为 $[4|x]$ ,而按照 $ans=\sum f(k)g(k)$ 计算时,贡献为$$\sum_{i=0}^x \binom x if(i)$$于是可以得出 $[4|x]=\sum_{i=0}^x \binom x i f(i)$ . 利用二项式反演和单位根反演可以得到 $$f(x)=\sum_{i=0}^x (-1)^{x-i} \binom x i [4|i] \\=\sum_{i=0}^x(-1)^{x-i}\binom x i \frac{1}{4}\sum_{j=0}^3 (\omega_{4}^i)^j \\=\frac{1}{4} \sum_{j=0}^3 \sum_{i=0}^x\binom x i(-1)^{x-i}\ (\omega_{4}^j)^i \\=\frac{1}{4} \sum_{j=0}^3(\omega_4^j-1)^x$$注意选择一个技能都没有的集合和一个集合都不选择是不同的方案. 而上述分析只考虑了前者的贡献,最后答案还要加上 $1$ ,表示一个集合都不选. 时间复杂度 $O(n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;const int P = 998244353, G = 3;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a, int b)&#123; int res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res;&#125;const int N = 1e7 + 10;int omega, n, f[N], g[N], invfac, fac = 1, ans = 0;int main()&#123; omega = fpow(G, (P - 1) / 4); n = read(); int k = 2, c, pw; for (int i = n; i &gt;= 0; --i) &#123; g[i] = add(k, P - 1); k = mul(k, k); &#125; for (int i = 2; i &lt;= n; ++i) fac = mul(fac, i); invfac = fpow(fac, P - 2); for (int i = n; i &gt;= 0; --i) &#123; g[i] = mul(g[i], invfac); g[n - i] = mul(g[n - i], invfac); invfac = mul(invfac, i); &#125; k = 1; for (int j = 0; j &lt; 4; ++j) &#123; c = add(k, P - 1), pw = 1; for (int i = 0; i &lt;= n; ++i) &#123; inc(f[i], pw); pw = mul(pw, c); &#125; k = mul(k, omega); &#125; for (int i = 0; i &lt;= n; ++i) inc(ans, mul(f[i], g[i])); ans = mul(ans, fpow(4, P - 2)); ans = mul(ans, fac); inc(ans, 1); printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>容斥原理</tag>
        <tag>单位根反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6360 复燃「恋之埋火」]]></title>
    <url>%2F2020%2F04%2F13%2FLoj-6360-%E5%A4%8D%E7%87%83%E3%80%8C%E6%81%8B%E4%B9%8B%E5%9F%8B%E7%81%AB%E3%80%8D%2F</url>
    <content type="text"><![CDATA[高维空间的最小圆覆盖. 题意就是要求 $m$ 维空间内 $n$ 个点的最小圆覆盖. 把二维的随机增量算法直接拓展到高维,不难发现复杂度的分析是类似的. 当我们已经加入 $k$ 个点时,需要在这 $k$ 个点所在的 $k-1$ 维平面上找一个圆心,使得它到这 $k$ 个点距离相等. 从这 $k$ 个点中选一个点作为原点,它到另外 $k-1$ 个点的 $k-1$ 个向量显然就是这个平面的一组基底. 只需要求出这些向量各自的系数即可确定圆心. 根据圆心到原点和到其他任意一个点的距离相同,可以列出 $k-1$ 个方程,高斯消元求出系数,进而确定圆心位置. 时间复杂度 $O(nm^3)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;const double eps = 1e-8;double sq(double x)&#123; return x * x;&#125;const int N = 2e4 + 10, M = 10;int n, m;typedef vector&lt;double&gt; vm;vm operator + (vm A, vm B)&#123; vm C(m); for (int i = 0; i &lt; m; ++i) C[i] = A[i] + B[i]; return C;&#125;vm operator - (vm A, vm B)&#123; vm C(m); for (int i = 0; i &lt; m; ++i) C[i] = A[i] - B[i]; return C;&#125;vm operator * (vm A, double lambda)&#123; vm B(m); for (int i = 0; i &lt; m; ++i) B[i] = A[i] * lambda; return B;&#125;double dist(vm A, vm B)&#123; double s = 0; for (int i = 0; i &lt; m; ++i) s += sq(A[i] - B[i]); return s;&#125;int id[M], k = 0;vm p[N], centre, vec[M];double radius, a[M][M];void Gauss()&#123; for (int i = 1; i &lt; k; ++i) &#123; int pos = i; for (int j = i + 1; j &lt; k; ++j) if (fabs(a[j][i]) &gt; fabs(a[pos][i])) pos = j; if (pos != i) swap(a[i], a[pos]); for (int j = 1; j &lt; k; ++j) if (i != j) &#123; double t = a[j][i] / a[i][i]; if (fabs(t) &lt;= eps) continue; for (int l = 1; l &lt;= k; ++l) a[j][l] -= a[i][l] * t; &#125; &#125;&#125;void pr(vm x)&#123; for (int i = 0; i &lt; m; ++i) printf("%.6lf,", x[i]); puts("");&#125;void find_centre()&#123; for (int i = 0; i &lt;= k; ++i) for (int j = 0; j &lt;= k; ++j) a[i][j] = 0; for (int i = 1; i &lt; k; ++i) vec[i] = p[id[i]] - p[id[0]]; for (int i = 1; i &lt; k; ++i) for (int j = 0; j &lt; m; ++j) &#123; a[i][k] += sq(vec[i][j]); for (int l = 1; l &lt; k; ++l) a[i][l] += vec[i][j] * 2 * vec[l][j]; &#125; Gauss(); for (int i = 0; i &lt; m; ++i) centre[i] = 0; for (int i = 1; i &lt; k; ++i) centre = centre + vec[i] * (a[i][k] / a[i][i]); centre = centre + p[id[0]];&#125;void dfs(int x, int bound)&#123; if (x &gt; m) return; for (int i = 0; i &lt; bound; ++i) &#123; if (dist(centre, p[i]) - radius &gt; eps) &#123; id[k++] = i; find_centre(); radius = dist(centre, p[i]); dfs(x + 1, i); k--; &#125; &#125;&#125;int main()&#123; srand(1919810); n = read(), m = read(); for (int i = 0; i &lt; n; ++i) &#123; p[i].resize(m); for (int j = 0; j &lt; m; ++j) scanf("%lf", &amp;p[i][j]); &#125; random_shuffle(p, p + n); centre = p[0], radius = -1; dfs(0, n); for (int i = 0; i &lt; m; ++i) printf("%.6lf ", centre[i]); puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>计算几何</tag>
        <tag>高斯消元</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自然数幂和学习笔记]]></title>
    <url>%2F2020%2F04%2F11%2F%E8%87%AA%E7%84%B6%E6%95%B0%E5%B9%82%E5%92%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[介绍了自然数幂和的几种常见求法. 自然数幂和定义 $S(n,k)=\sum_{i=0}^{n-1} i^k$ . 拉格朗日插值法$S(n,k)$ 是一个关于 $n$ 的 $k+1​$ 次多项式. 于是可以用拉格朗日插值在 $O(k^2)$ 内求出这个多项式,或者在 $O(k+\log P)$ 内求出某一个 $S(n,k)​$ 的值. 计算过程中需要利用逆元,所以要求模数为质数. 第二类斯特林数法自然数幂的求和不是很直接,但是下降幂求和的形式是十分简单的.$$\begin{aligned}\sum_{i=0}^{n-1} i^{\underline k} &amp;= \frac{1}{k+1}\sum_{i=0}^{n-1}(i+1)^{\underline {k+1}}-i^{\underline {k+1}} \\&amp;=\frac{n^{\underline {k+1}}}{k+1}\end{aligned}$$于是我们可以考虑用第二类斯特林数将自然数幂展开成下降幂进行求和.$$\begin{aligned}S(n,k)&amp;=\sum_{i=0}^{n-1}i^k \\&amp;=\sum_{i=0}^{n-1}\sum_{j=0}^k {k\brace j} i^{\underline j} \\&amp;=\sum_{j=0}^k {k\brace j}\sum_{i=0}^{n-1}i^{\underline j} \\&amp;=\sum_{j=0}^k {k\brace j} \frac{n^{\underline {j+1}}}{j + 1}\end{aligned}$$若多次询问的 $k$ 不同,我们可以 $O(k^2)$ 预处理第二类斯特林数, 然后 $O(k)​$ 回答每个询问. 若多次询问的 $k$ 都相同,根据$${n\brace m} = \frac{1}{m!}\sum_{i=0}^m (-1)^i \binom m i (m-i)^n$$ 可以用 NTT 优化卷积, 以 $O(k\log k)$ 的复杂度求出一行的第二类斯特林数,然后 $O(k)$ 回答每个询问. 若模数不是质数,逆元不一定存在,这个方法仍然可以计算 $S(n,k)$ ,不过复杂度只能做到 $O(k^2)$ . 考虑 $S(n,k)=\sum_{j=0}^k {k\brace j} \frac{n^{\underline {j+1}}}{j + 1}$ ,我们先 $O(k^2)​$ 预处理出第二类斯特林数. 计算时, $n^{\underline {j+1}}$ 是 $j+1$ 个连续自然数乘积,其中一定有 $j+1$ 的倍数,找出来后将它除掉 $j+1$ 即可. 如果把剩下的数暴力乘起来,单次询问的时间复杂度仍然为 $O(k^2)$ . 用线段树维护出 $n,n-1,n-2\dots,n-j$ 这个序列的前缀积,后缀积,就可以做到单次询问 $O(k\log k)$ . 伯努利数法定义伯努利数为对于任意非负整数 $n$ 满足以下等式$$[n=0]=\sum_{i=0}^n\binom{n + 1}{i} B_i$$的唯一实数列. 可以证明,伯努利数的 EGF 为 $$B(x)=\sum_{i\ge 0} \frac{B_i}{i!}=\frac{x}{e^x-1}$$ 并且满足$$S(n,k)=\frac{1}{k+1}\sum_{i=0}^k \binom{k+1}{i} B_i \cdot n^{k+1-i}$$于是可以先用多项式求逆求出前 $k+1$ 个 $B_i$ ,再用 NTT 对于某个固定的 $n$ ,对 $1$ 到 $k$ 内所有的 $i$ 求出 $S(n,i)$ . 一般适用于 $n$ 固定,而 $k$ 的询问有多个的情况,时间复杂度 $O(k\log k)$ .]]></content>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2462 完美的集合]]></title>
    <url>%2F2020%2F04%2F10%2FLoj-2462-%E5%AE%8C%E7%BE%8E%E7%9A%84%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[树上连通块的 dp 技巧 + 奇怪的组合数取模. “点数减边数”对于树上满足某种性质 $P$ 的连通块计数,有一个巧妙的转化 “点数减边数” . 枚举树上的每个点 $x$ ,计算出包含 $x$ ,且满足性质 $P$ 的连通块数目,对所有 $x$ 求和得到 $a$ . 再枚举树上每条边 $(x,y)$ ,计算出同时包含 $x,y$ ,且满足性质 $P$ 的连通块数目,对所有 $(x,y)$ 求和得到 $b$ . 每个连通块对 $a$ 贡献是点数,对 $b$ 贡献是边数,而树上的连通块也是一棵树,点数 = 边数 + 1. 于是可以得出满足性质 $P$ 的连通块数目就是 $a-b$ . 这种转化常用于求若干连通块的交,因为这样转化就变成了每个连通块都包含枚举的点/边,连通块之间就独立了. 计算完美集合数目这道题就可以使用上面这个转化,计算选出能被 $x​$ 测试的完美集合方案,减去能被 $x,y​$ 同时测试的完美集合方案. 集合内肯定不能包含 $dist*v&gt;Max$ 的点,可以将它们去掉,对剩下的点做一个背包,维护最优解和最优解的数目. 树上背包可以按照 dfs 序转移,若选了 $i$ ,则考虑其子树,转移到 $f_{dfn(i)+1}$ ,否则跳过其子树,转移到 $f_{dfn(i)+siz(i)}$ . 于是我们可以在 $O(nm)$ 的时间复杂度内求出能被某一个点或某两个点同时测试的完美集合数目. 计算模意义下组合数如果没有再从集合中选出 $k$ 个的要求和 $5^{23}$ 这个奇怪的模数,这道题就已经优美地结束了. 出题人为了加大力度,还需要我们计算出 $\binom{s}{k}\bmod 5^{23}$ ,其中 $s$ 是计算出的集合数目,可以达到 $2^{60}$ , $k$ 可以达到 $10^9$ . 用拓展 Lucas 的思路,其实就是要设法算出 $p!$ 中含有的因子 $5$ 的个数以及 $\prod_{i\le p}[i\bmod 5\neq 0] i$ 的值. 前者可以直接 $O(\log p)​$ 计算,关键在于如何计算后者. 在拓展 Lucas 中,我们是 $O(mod)$ 暴力算出一个循环节的贡献,但这里 $mod=5^{23}$ ,显然行不通. 考虑构造多项式 $F_p(x)=\prod_{1\le i\le p} [i\bmod 5\neq 0] (x+i)$ ,要求的答案就是这个多项式展开后的常数项. 若 $p$ 不是 $10$ 的整数倍,就先将最后不超过 $9$ 个一次式的乘积暴力乘出来,就可以将 $p$ 凑成 $10k$ 的形式. 考虑 $F_{10k}(x)=F_{5k}(x)\cdot F_{5k}(x+5k)​$ ,其中 $F_{5k}​$ 的常数项可以递归下去算. 而 $F_{5k}(x+5k)​$ 在模 $5^{23}​$ 下可以表示成一个关于 $(x+5k)​$ 的多项式,形如 $\sum c_i\cdot (x+5k)^i​$ . 而我们只关心展开后不含 $x​$ 的常数项,可以发现当 $i\ge 23​$ 时, 将 $(x+5k)^i​$ 展开后常数项都为 $0​$ ,没有贡献. 那么递归求出 $F_{5k}$ 展开后的前 $23$ 项,将 $(x+5k)^i$ 代入,展开后即可求得 $F_{5k}(x+5k)$ 的前 $23$ 项. 再暴力卷积合并得到 $F_{10k}$ 的前 $23$ 项,这样只会需要求 $O(\log s)$ 个 $F_{5k}$ 的前 $23$ 项,复杂度可以接受. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;const ll P = 11920928955078125;ll add(ll a, ll b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(ll &amp;a, ll b)&#123; a = add(a, b);&#125;ll mul(ll a, ll b)&#123; ll res = a * b - (ll)((long double)a / P * b + 1e-8) * P; return res &lt; 0 ? res + P : res % P;&#125;ll fpow(ll a, ll b)&#123; ll res = 1; while (b) &#123; if (b &amp; 1LL) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res;&#125;ll Inv(ll x)&#123; return fpow(x, P / 5 * 4 - 1);&#125;typedef pair&lt;ll, ll&gt; pll;typedef vector&lt;ll&gt; poly;poly operator * (poly a, poly b)&#123; poly c(23); for (int j = 0; j &lt; 23; ++j) if (b[j]) for (int i = 0; i + j &lt; 23; ++i) if (a[i]) inc(c[i + j], mul(a[i], b[j])); return c;&#125;poly p[10000];ll pw[23], binom[23][23];void init()&#123; binom[0][0] = 1; for (int i = 1; i &lt; 23; ++i) &#123; binom[i][0] = 1; for (int j = 1; j &lt;= i; ++j) binom[i][j] = add(binom[i - 1][j], binom[i - 1][j - 1]); &#125; p[0].resize(23); p[0][0] = 1; for (int i = 1; i &lt; 10000; ++i) &#123; if (i % 5) &#123; poly tmp(23); tmp[0] = i, tmp[1] = 1; p[i] = p[i - 1] * tmp; &#125; else p[i] = p[i - 1]; &#125;&#125;poly trans(poly a, ll k)&#123; pw[0] = 1; for (int i = 1; i &lt; 23; ++i) pw[i] = mul(pw[i - 1], k); poly b(23); for (int i = 0; i &lt; 23; ++i) for (int j = 0; j &lt;= i; ++j) inc(b[j], mul(a[i], mul(pw[i - j], binom[i][j]))); return b;&#125;poly facpoly(ll n)&#123; if (n &lt; 10000) return p[n]; ll k = n / 10 * 10; poly t1 = facpoly(k &gt;&gt; 1); poly t2 = trans(t1, k &gt;&gt; 1); t1 = t1 * t2; for (ll i = k + 1; i &lt;= n; ++i) if (i % 5) &#123; poly tmp(23); tmp[0] = i % P, tmp[1] = 1; t1 = t1 * tmp; &#125; return t1;&#125;pll Fac(ll n)&#123; pll res = make_pair(facpoly(n)[0], n / 5); if (n &gt;= 5) &#123; pll tmp = Fac(n / 5); res.first = mul(res.first, tmp.first); res.second += tmp.second; &#125; return res;&#125;ll Binom(ll n, ll k)&#123; if (n &lt; k) return 0; pll f1 = Fac(n), f2 = Fac(k), f3 = Fac(n - k); f1.second -= f2.second + f3.second; f1.first = mul(f1.first, mul(Inv(f2.first), Inv(f3.first))); if (f1.second &gt;= 23) return 0; return mul(f1.first, fpow(5, f1.second));&#125;const int N = 60 + 10, M = 1e4 + 10, inf = 1e9;int n, m, k, ecnt = 0, nx[N &lt;&lt; 1], to[N &lt;&lt; 1], head[N];ll Max;void addedge(int u, int v)&#123; ++ecnt; to[ecnt] = v; nx[ecnt] = head[u]; head[u] = ecnt;&#125;int w[N], val[N], dist[N][N], valid[N], rnk[N], siz[N], _fa[N], fa[N], idx = 0;void dfs(int u, int F)&#123; _fa[u] = F, siz[u] = 1, rnk[++idx] = u; for (int i = head[u]; i; i = nx[i]) &#123; int v = to[i]; if (v == F || !valid[v]) continue; dfs(v, u); siz[u] += siz[v]; &#125;&#125;ll f[N][M], g[N][M], mx = 0;pll calc(int x, int y)&#123; idx = 0; dfs(x, 0); for (int i = 0; i &lt;= m; ++i) &#123; f[idx + 1][i] = 0; g[idx + 1][i] = 1; &#125; for (int i = idx; i &gt;= 1; --i) &#123; int u = rnk[i]; for (int j = 0; j &lt;= m; ++j) &#123; ll v1 = j &gt;= w[u] ? f[i + 1][j - w[u]] + val[u] : 0; ll v2 = f[i + siz[u]][j]; if (u == y &amp;&amp; j &lt; w[u]) f[i][j] = g[i][j] = 0; else if (u == y || (j &gt;= w[u] &amp;&amp; v1 &gt; v2)) &#123; f[i][j] = f[i + 1][j - w[u]] + val[u]; g[i][j] = g[i + 1][j - w[u]]; &#125; else if (j &lt; w[u] || v1 &lt; v2) &#123; f[i][j] = f[i + siz[u]][j]; g[i][j] = g[i + siz[u]][j]; &#125; else &#123; f[i][j] = f[i + siz[u]][j]; g[i][j] = g[i + siz[u]][j] + g[i + 1][j - w[u]]; &#125; &#125; &#125; return make_pair(f[1][m], g[1][m]);&#125;ll solve(int x, int y)&#123; for (int i = 1; i &lt;= n; ++i) if (1LL * dist[x][i] * val[i] &gt; Max || (y &amp;&amp; 1LL * dist[y][i] * val[i] &gt; Max)) valid[i] = 0; else valid[i] = 1; if (!valid[x] || (y &amp;&amp; !valid[y])) return 0; pll tmp = calc(x, y); if (tmp.first &lt; mx) return 0; return Binom(tmp.second, k);&#125;int main()&#123; n = read(), m = read(), k = read(), Max = read(); init(); for (int i = 1; i &lt;= n; ++i) w[i] = read(); for (int i = 1; i &lt;= n; ++i) val[i] = read(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) dist[i][j] = (i == j) ? 0 : inf; for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(), l = read(); addedge(u, v), addedge(v, u); dist[u][v] = dist[v][u] = l; &#125; for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) if (dist[i][k] &lt; inf) for (int j = 1; j &lt;= n; ++j) if (dist[k][j] &lt; inf) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); for (int i = 1; i &lt;= n; ++i) valid[i] = 1; for (int i = 1; i &lt;= n; ++i) mx = max(mx, calc(i, 0).first); for (int i = 1; i &lt;= n; ++i) fa[i] = _fa[i]; ll ans = 0; for (int i = 1; i &lt;= n; ++i) inc(ans, add(solve(i, 0), P - (fa[i] ? solve(i, fa[i]) : 0))); printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>树形dp</tag>
        <tag>数学</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 3058 白兔之舞]]></title>
    <url>%2F2020%2F04%2F10%2FLoj-3058-%E7%99%BD%E5%85%94%E4%B9%8B%E8%88%9E%2F</url>
    <content type="text"><![CDATA[单位根反演 + 任意长度 DFT + MTT. 考虑某个 $t$ 的答案,记作 $b_t$ ,枚举白兔实际跳了 $i$ 步,得到$$b_t=\sum_{i=0}^L [i\bmod k=t] \binom L i A^i_{x,y}\\=\sum_{i=0}^L [k|(i-t)]\binom L i (A^i)_{x,y}$$其中 $A$ 是由读入给定的 $3\times 3$ 的转移矩阵. 考虑单位根反演,继续化简, $$b_t=\sum_{i=0}^L \frac 1 k\sum_{j=0}^{k-1}\omega_k^{j(i-t)} \binom L i A^i_{x,y}\\=\frac 1 k\sum_{j=0}^{k-1} \omega_k^{-jt}\sum_{i=0}^L \omega_k^{ij} A^i_{x,y} \\=\frac 1 k\sum_{j=0}^{k-1} \omega_k^{-jt}(\omega_k^j A + I)^L_{x,y}$$ 题目保证了 $k|(p-1)$ ,所以在模 $p$ 意义下 $\omega_k =g^{\frac{p-1} k}$ ,其中 $g$ 为 $p​$ 的原根. 记 $a_j=((\omega_k^j A + I)^L)_{x,y}$ ,这可以用矩阵快速幂在 $O(n^3k\log L)$ 的时间内将 $k$ 个 $a_j$ 全部求出.$$b_t=\frac 1 k\sum_{j=0}^{k-1}(\omega_k^{-j})^t a_j$$如果 $k$ 是 $2$ 的幂次,直接用 FFT 对 $a$ 做一次长度为 $k$ 的 IDFT 即可将 $b$ 求出. 如果不保证 $k$ 是 $2$ 的幂次,就需要用到一个叫 Bluestein’s Algorithm 的算法,它可以解决任意长度的 DFT. 由组合意义知 $\binom {j+t} 2=\binom j 2 + \binom t 2 +jt$ ,于是可以把 $jt$ 拆成仅和 $j,t,j+t$ 有关的几项. 原式可以化为$$b_t=\frac 1 k\sum_{j=0}^{k-1} \omega_k^{\binom t 2} \cdot \omega_k^{\binom j 2}\cdot \omega_k^{-\binom{j+t}{2}} a_j \\b_t=\frac 1 k \omega_k^{\binom t 2}\sum_{j=0}^{k-1} \omega_k^{-\binom{j+t}{2}}(a_j\cdot \omega_k^{\binom j 2})$$ 记 $f_i=\omega_k^{-\binom i 2},g_i=a_i\cdot \omega_k^{\binom i 2}$ ,则 $$b_t=\frac 1 k \omega_k^{\binom t 2}\sum_{j=0}^{k-1} g_j\cdot f_{j+t}$$ 后面已经差不多是一个卷积了,把 $g$ 翻转一下,就能得到$$b_t=\frac 1 k \omega_k^{\binom t 2}\sum_{j=0}^{k-1} g^R_{k-1-j}\cdot f_{j+t} \\b_t=\frac 1 k \omega_k^{\binom t 2}(g^R\otimes f)_{t+k-1}$$用 MTT 求出 $g^R$ 与 $f​$ 的卷积即可. 时间复杂度 $O(n^3k\log L+k\log k)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;const double PI = acos(-1.0);const int N = (1 &lt;&lt; 18) + 10;int P;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a, int b)&#123; int res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res;&#125;struct Matrix&#123; ll v[3][3]; Matrix()&#123;memset(v, 0, sizeof v);&#125; ll *operator [](int x) &#123; return v[x]; &#125;&#125; I, A;Matrix operator * (Matrix a, Matrix b)&#123; Matrix c; for (int i = 0; i &lt; 3; ++i) for (int k = 0; k &lt; 3; ++k) if (a[i][k]) for (int j = 0; j &lt; 3; ++j) if (b[k][j]) c[i][j] += a[i][k] * b[k][j]; for (int i = 0; i &lt; 3; ++i) for (int j = 0; j &lt; 3; ++j) c[i][j] %= P; return c;&#125;Matrix operator * (Matrix a, int lambda)&#123; Matrix b; for (int i = 0; i &lt; 3; ++i) for (int j = 0; j &lt; 3; ++j) b[i][j] = a[i][j] * lambda % P; return b;&#125;Matrix operator + (Matrix a, Matrix b)&#123; Matrix c; for (int i = 0; i &lt; 3; ++i) for (int j = 0; j &lt; 3; ++j) c[i][j] = add(a[i][j], b[i][j]); return c;&#125;Matrix Fpow(Matrix a, int b)&#123; Matrix res = I; while (b) &#123; if (b &amp; 1) res = res * a; a = a * a; b &gt;&gt;= 1; &#125; return res;&#125;int getrt()&#123; vector&lt;int&gt; pr; int x = P - 1; for (int i = 2; i * i &lt;= x; ++i) if (x % i == 0) &#123; pr.push_back(i); while (x % i == 0) x /= i; &#125; for (int g = 2; ; ++g) &#123; bool f = true; for (int p : pr) if (fpow(g, (P - 1) / p) == 1) &#123; f = false; break; &#125; if (f) return g; &#125;&#125;struct cp&#123; double r, i; cp(double r = 0, double i = 0) : r(r), i(i) &#123;&#125; cp operator + (const cp &amp;rhs) const &#123; return cp(r + rhs.r, i + rhs.i); &#125; cp operator - (const cp &amp;rhs) const &#123; return cp(r - rhs.r, i - rhs.i); &#125; cp operator * (const cp &amp;rhs) const &#123; return cp(r * rhs.r - i * rhs.i, r * rhs.i + i * rhs.r); &#125; cp conj() &#123; return cp(r, -i); &#125;&#125; og[N];int rev[N];void DFT(cp *a, int n)&#123; for (int i = 0; i &lt; n; ++i) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (int l = 2; l &lt;= n; l &lt;&lt;= 1) &#123; int m = l &gt;&gt; 1; for (cp *p = a; p != a + n; p += l) for (int i = 0; i &lt; m; ++i) &#123; cp t = og[n / m * i] * p[i + m]; p[i + m] = p[i] - t; p[i] = p[i] + t; &#125; &#125;&#125;void MTT(int *a, int *b, int *c, int n)&#123; static cp s1[N], s2[N], s3[N], s4[N], s5[N], s6[N]; for (int i = 0; i &lt; n; ++i) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) * (n &gt;&gt; 1)); for (int i = 0; i &lt; n; ++i) og[i] = cp(cos(PI * i / n), sin(PI * i / n)); for (int i = 0; i &lt; n; ++i) s1[i] = cp(a[i] &amp; 32767, a[i] &gt;&gt; 15); for (int i = 0; i &lt; n; ++i) s2[i] = cp(b[i] &amp; 32767, b[i] &gt;&gt; 15); DFT(s1, n); DFT(s2, n); for (int i = 0; i &lt; n; ++i) &#123; int j = (n - i) &amp; (n - 1); cp da = (s1[i] + s1[j].conj()) * cp(0.5, 0); cp db = (s1[i] - s1[j].conj()) * cp(0, -0.5); cp dc = (s2[i] + s2[j].conj()) * cp(0.5, 0); cp dd = (s2[i] - s2[j].conj()) * cp(0, -0.5); s3[j] = da * dc; s4[j] = da * dd; s5[j] = db * dc; s6[j] = db * dd; &#125; for (int i = 0; i &lt; n; ++i) &#123; s1[i] = s3[i] + s4[i] * cp(0, 1); s2[i] = s5[i] + s6[i] * cp(0, 1); &#125; DFT(s1, n); DFT(s2, n); for (int i = 0; i &lt; n; ++i) &#123; ll da = (ll)(s1[i].r / n + 0.5) % P; ll db = (ll)(s1[i].i / n + 0.5) % P; ll dc = (ll)(s2[i].r / n + 0.5) % P; ll dd = (ll)(s2[i].i / n + 0.5) % P; ll val = da + ((db + dc) &lt;&lt; 15) + (dd &lt;&lt; 30); c[i] = val % P; if (c[i] &lt; 0) c[i] += P; &#125;&#125;int n, k, L, st, ed, omega[N], f[N], g[N], h[N], res[N];int binom(int x)&#123; return 1LL * x * (x - 1) / 2 % k;&#125;int main()&#123; n = read(), k = read(), L = read(), st = read(), ed = read(), P = read(); for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) A[i][j] = read(); for (int i = 0; i &lt; n; ++i) I[i][i] = 1; omega[0] = 1, omega[1] = fpow(getrt(), (P - 1) / k); for (int i = 2; i &lt;= k; ++i) omega[i] = mul(omega[i - 1], omega[1]); for (int i = 0; i &lt; k; ++i) g[k - 1 - i] = mul(Fpow(A * omega[i] + I, L)[st - 1][ed - 1], omega[binom(i)]); for (int i = 0; i &lt; 2 * k; ++i) f[i] = omega[k - binom(i)]; int len = 1; while (len &lt; 3 * k) len &lt;&lt;= 1; MTT(f, g, h, len); int invk = fpow(k, P - 2); for (int i = 0; i &lt; k; ++i) &#123; int res = mul(invk, mul(omega[binom(i)], h[i + k - 1])); printf("%d\n", res); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>单位根反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20200409]]></title>
    <url>%2F2020%2F04%2F09%2Ftest20200409%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>最短路</tag>
        <tag>多项式</tag>
        <tag>test</tag>
        <tag>拉格朗日反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uoj 390 百鸽笼]]></title>
    <url>%2F2020%2F04%2F08%2FUoj-390-%E7%99%BE%E9%B8%BD%E7%AC%BC%2F</url>
    <content type="text"><![CDATA[指数型生成函数. 像猎人杀那样,规定已经放满的列也可以继续被选,只是不会产生影响. 枚举 $i$ ,计算第 $i$ 列空出一个鸽笼的概率. 一个合法的操作序列需要满足 $i$ 被操作了 $a_i$ 次, 所有 $\neq i$ 的 $j$ 被操作了至少 $a_j$ 次,且最后一次操作的列为 $i$ . 若某一列被操作了 $t$ 次,就会有 $G(t)=\frac{x^t}{t!n^t}$ 的贡献. 目标函数 $F(i)​$ 就是把所有列可能产生的贡献卷在一起,若 $F(i) =\sum f_i\cdot x^i​$ ,则第 $i​$ 列的答案就是 $\sum f_i\cdot i!​$ . 具体而言,$$F(i)=\frac{G(a_i-1)}{n}\prod_{j\neq i} \sum_{t\ge a_j}G(t)$$注意到 $\sum_{t\ge 0}G(t)=e^{\frac x n}$ ,所以 $F(i)$ 可以写成$$F(i)=\frac{G(a_i-1)}{n}\prod_{j\neq i}(e^{\frac x n}-\sum_{t=0}^{a_j-1}G(t))$$把 $F(i)​$ 展开,会得到若干项形如 $c\cdot e^{\frac{mx}n}\cdot x^t​$ 的式子,将它展开,$$c\cdot e^{\frac{mx}n}\cdot x^t=c\cdot x^t\cdot\sum_{s\ge 0}(\frac m n)^s\frac{x^s}{s!}\\=c\cdot \sum_{s\ge 0}(\frac m n)^s\frac{x^{s+t}}{s!}\\$$考虑它对答案 $\sum f_i\cdot i!$ 的贡献,$$c\cdot \sum_{s\ge 0}(\frac m n)^s \frac{(s+t)!}{s!}\\=c\cdot t!\cdot\sum_{s\ge 0}(\frac m n)^s\binom{s+t}{t}$$记 $h(t)=\sum_{s\ge 0}(\frac m n)^s\binom{s+t}{t}$ ,则$$\begin{aligned}h(t) &amp;= \sum_{s\ge 0}(\frac m n)^s \binom{s+t}{t}\\&amp;=\sum_{s\ge 0}(\frac{m}{n})^s(\binom{(s-1)+t}{t}+\binom{s+(t-1)}{t-1}) \\&amp;=\frac{m}{n}\cdot h(t)+h(t-1)\\&amp;=\frac{n}{n-m}\cdot h(t-1)\end{aligned}$$边界有 $h(0)=\frac{n}{n-m}​$ ,可得 $h(t)=(\frac{n}{n-m})^{t+1}​$ . 如果把组合数展开成多项式,变成 $\sum s^k \cdot (\frac{m}{n})^s ​$ 的形式,就推不下去了. 于是可知 $c\cdot e^{\frac{mx}n}\cdot x^t$ 这一项对答案的贡献为 $c\cdot (\frac{n}{n-m})^{t+1}\cdot t!$ . 观察 $F(i)​$ 的形式$$F(i)=\frac{G(a_i-1)}{n}\prod_{j\neq i}(e^{\frac x n}-\sum_{t=0}^{a_j-1}G(t))$$可以发现只需要维护下面这个式子展开成 $c\cdot e^{\frac{mx}n}\cdot x^t$ 的形式,$$\frac{1}{n}\prod_{j=1}^n(e^{\frac x n}-\sum_{t=0}^{a_j-1}G(t))$$枚举 $i$ 时,将 $i$ 那一项的贡献撤去,再加入 $G(a_i-1)$ 的贡献就可以了. 可以看做是有两个容量维度的背包计数,撤掉某一项的贡献相当于撤掉某个物品,时间复杂度 $O(n^3\cdot (\max a_i)^2)$ . 实际上不去撤销,每次重新对 $n$ 个元素做一个背包, $O(n^4\cdot (\max a_i)^2)$ 也能跑过去.]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2549 战争]]></title>
    <url>%2F2020%2F04%2F08%2FLoj-2549-%E6%88%98%E4%BA%89%2F</url>
    <content type="text"><![CDATA[闵可夫斯基和. 对于给出的两个点集可以分别做出两个凸包 $A,B$ , 记询问给出的向量为 $w=(dx,dy)$ ,若存在向量 $a\in A,b\in B$ 满足 $a=b+w$ ,则会产生冲突. 即判断是否存在 $a\in A,b\in B$ 满足 $w=a-b$. 将 $B$ 中所有点关于原点对称得到 $-B$ ,那么 $A$ 与 $-B$ 的闵可夫斯基和就是所有 $a-b$ 的集合. 两个凸包的闵可夫斯基和仍是一个凸包,将两个凸包的边拿出来归并排序即可得到求和后的凸包. 有可能存在三点共线,所以归并排序后对点集再求一次凸包. 最后只需要判定 $w$ 是否在凸包内,将 $w$ 和凸包一起平移,使得凸包第一个点与原点重合. 先判断 $w$ 是否超出左右的边界,若在边界内,根据极角二分出凸包上相邻的两个点进行判断即可. 如图,红点和蓝点由叉积知在边界外,绿点可以用二分找出两个相邻的黄点,用叉积判断是否在凸包内. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out = 0, fh = 1; char jp = getchar(); while ((jp &gt; '9' || jp &lt; '0') &amp;&amp; jp != '-') jp = getchar(); if (jp == '-') fh = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * fh;&#125;struct v2&#123; int x, y; v2(int x = 0, int y = 0) : x(x), y(y) &#123;&#125; v2 operator + (const v2 &amp;rhs) const &#123; return v2(x + rhs.x, y + rhs.y); &#125; v2 operator - (const v2 &amp;rhs) const &#123; return v2(x - rhs.x, y - rhs.y); &#125; ll operator * (const v2 &amp;rhs) const &#123; return 1LL * x * rhs.y - 1LL * y * rhs.x; &#125; ll modulus() &#123; return 1LL * x * x + 1LL * y * y; &#125; friend bool operator &lt; (v2 A, v2 B) &#123; return A * B &gt; 0 || (A * B == 0 &amp;&amp; A.modulus() &lt; B.modulus()); &#125;&#125;;const int N = 2e5 + 10;v2 stk[N];int tp;void Convex(v2 *a, int &amp;n)&#123; tp = 0; for (int i = 2; i &lt;= n; ++i) if (a[i].y &lt; a[1].y || (a[i].y == a[1].y &amp;&amp; a[i].x &lt; a[1].x)) swap(a[i], a[1]); v2 tmp = a[1]; for (int i = 1; i &lt;= n; ++i) a[i] = a[i] - tmp; sort(a + 2, a + n + 1); for (int i = 1; i &lt;= n; ++i) &#123; while (tp &gt;= 2 &amp;&amp; (a[i] - stk[tp - 1]) * (stk[tp] - stk[tp - 1]) &gt;= 0) --tp; stk[++tp] = a[i]; &#125; n = tp; for (int i = 1; i &lt;= n; ++i) a[i] = stk[i] + tmp; a[n + 1] = a[1];&#125;bool InConvex(v2 p, v2 *a, int n)&#123; if (p * a[2] &gt; 0 || a[n] * p &gt; 0) return false; int pos = lower_bound(a + 1, a + 1 + n, p) - a - 1; return (p - a[pos]) * (a[pos + 1] - a[pos]) &lt;= 0;&#125;int n, m, q, tot = 0;v2 A[N], B[N], C[N], e1[N], e2[N];void Minkowski()&#123; for (int i = 1; i &lt;= n; ++i) e1[i] = A[i + 1] - A[i]; for (int i = 1; i &lt;= m; ++i) e2[i] = B[i + 1] - B[i]; C[tot = 1] = A[1] + B[1]; int p1 = 1, p2 = 1; while (p1 &lt;= n &amp;&amp; p2 &lt;= m) ++tot, C[tot] = C[tot - 1] + (e1[p1] * e2[p2] &gt;= 0 ? e1[p1++] : e2[p2++]); while (p1 &lt;= n) ++tot, C[tot] = C[tot - 1] + e1[p1++]; while (p2 &lt;= m) ++tot, C[tot] = C[tot - 1] + e2[p2++]; Convex(C, tot);&#125;int main()&#123; n = read(), m = read(), q = read(); for (int i = 1; i &lt;= n; ++i) A[i].x = read(), A[i].y = read(); Convex(A, n); for (int i = 1; i &lt;= m; ++i) B[i].x = -read(), B[i].y = -read(); Convex(B, m); Minkowski(); v2 tmp = C[1]; for (int i = 1; i &lt;= tot; ++i) C[i] = C[i] - tmp; for (int i = 1; i &lt;= q; ++i) &#123; v2 p; p.x = read(), p.y = read(); p = p - tmp; if (InConvex(p, C, tot)) puts("1"); else puts("0"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>计算几何</tag>
        <tag>闵可夫斯基和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学军信友队趣味网络邀请赛]]></title>
    <url>%2F2020%2F04%2F08%2F%E5%AD%A6%E5%86%9B%E4%BF%A1%E5%8F%8B%E9%98%9F%E8%B6%A3%E5%91%B3%E7%BD%91%E7%BB%9C%E9%82%80%E8%AF%B7%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[被虐了. A 核酸检测$n​$ 为偶数和奇数时可以分别进行如下的构造. code B 齐心抗疫比较粗暴的方法是将所有点按照 $a$ 从小到大排序,依次激活,对每个点求出已激活的点到它的最大距离,更新答案. 用点分树实现,时间复杂度 $O(n\log^2 n)$ ,需要优秀的卡常才能通过. 注意观察性质,要求的是 $\max_{a_x\le a_y} \lbrace a_y\cdot dis(x,y)\rbrace$ ,如果我们将 $ a_x\cdot dis(x,y)$ 也统计上,并不会影响答案. 于是可以直接忽略掉 $a_x\le a_y​$ 的限制,只需要对每个点求出其他点到它的最大距离. 先找出树的一条直径 $u\to v​$ ,根据相关性质,点 $x​$ 到所有点的最大距离即为 $\max(dis(x,u),dis(x,v))​$ . 时间复杂度 $O(n)​$ . code C 病毒研究首先可以对 $m$ 种操作做一个完全背包,得到 $dp(i)$ 表示将活性恰好降低 $i$ 点所需要的最小花费. 只能确定活性在某一个区间内,可以设 $f(l,r)$ 表示确定活性在 $[l,r]$ 内,期望代价乘上 $r-l+1$ 的值. 要求的答案即为 $f(1,a_n)$ . 转移时分几种情况讨论: 若 $l,r$ 在属于不同状态,就将 $[l,r]$ 按照所在状态分成若干小区间, $f(l,r)$ 为这些小区间 $f$ 值之和. 否则,若 $l,r$ 都在状态 $1$ ,可得 $f(l,r)=0$ . 否则,$l,r$ 在同一不为 $1$ 的状态,枚举操作,得到 $f(l,r)=\min_{1\le i&lt; l}\lbrace f(l-i,r-i)+(r-l+1)\cdot dp(i) \rbrace$ . 如果直接 dp, 状态数为 $O(a_n^2)$ ,每次转移代价为 $O(a_n)$ ,无法通过. 考虑剪枝,计算 $f(l,r)$ 时,只用 $l-i,r-i$ 不在同一状态的 $f(l-i,r-i)$ 来更新,或者 $l-i,r-i$ 都在状态 $1$. 否则,若 $l-i,r-i$ 依然在同一不为 $1$ 的状态,就需要继续进行操作,而完全背包已经考虑了合并这两次操作的方案. 经过这样一个剪枝后,我们需要计算的 $f(l,r)$ 一定满足 $[l,r]$ 是某个状态的一段前缀或后缀,状态数降到了 $O(a_n)$ . code D 抗疫斗争首先考虑对于一个给定的 $m$ ,如何计算 $h_m$ . 若 $m$ 不是 $2$ 的倍数,先手只需要取 $1$ ,这样后面双方都只能取 $1$ ,最后先手一定胜利,即,此时 $h_m=1$ . 若 $m$ 是 $2$ 的倍数,容易证明双方都不会在某一步取奇数个,否则游戏一定未结束,另一方下一步取 $1$ 即可保证必胜. 那么我们不断将 $m$ 变为 $\frac m 2$ , $h_m$ 也会变成原来的 $\frac 1 2 $ ,直到当 $m$ 为奇数时, $h_m=1$ . 于是可以得出 $h_m={\rm lowbit} (m)​$ . 那么我们要求的答案就是$$ans=\sum_{i=1}^n {\rm lowbit}(i) \lfloor \frac n i\rfloor$$可以对 $\lfloor\frac n i \rfloor​$ 整除分块,每次 $O(\log n)​$ 计算 $\rm lowbit​$ 的前缀和,时间复杂度 $O(\sqrt n\log n)​$ . 进一步优化,可以把 ${\rm lowbit}(x)$ 拆成 $1+\sum_{k\ge 1} [2^k|x]2^{k-1}$ ,就可以枚举 $k$ 来计算每个 $k$ 的贡献. 记 $g(x)=\sum_{i=1}^n \lfloor \frac x i\rfloor$ ,由于 $\lfloor \frac n {ab}\rfloor=\lfloor \frac{\lfloor\frac n a\rfloor}{b}\rfloor$ ,可以得到 $$ans=g(n)+\sum_{k\ge 1} 2^{k-1}g(\lfloor\frac{n}{2^k}\rfloor)$$计算一个 $g(x)$ 的时间复杂度为 $\sqrt x$ ,由等比数列的求和可知总时间复杂度为 $O(\sqrt n)$ . code E 名垂青史鸽了.]]></content>
      <tags>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>区间dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UR 19]]></title>
    <url>%2F2020%2F04%2F07%2FUR-19%2F</url>
    <content type="text"><![CDATA[被虐了. A 清扫银河先做一个生成森林,然后本质的环就只有非树边对应的至多 $m - n + 1$ 个,其他环都可以由异或线性组合出来. 现在只考虑操作 $1$ ,一个图能被若干个环异或得到,当且仅当所有节点度数是偶数. 而这若干个环都可以在那 $m - n + 1$ 个环形成的基底下被分解. 所以只要状态为 $1$ 的边形成的子图中,每个点度数为偶,就可以在至多 $m - n + 1$ 次 $1$ 操作内将所有边都变成 $0$ . 考虑恰当安排 $2$ 操作达到这个条件. $2$ 操作的贡献可以摊到每个点上,可以看做选出一个点集 $S$ ,若某个点被选了,就把它所连的边颜色全部翻转. 转化后可以看出,多次 $2$ 操作可以合并成一次,所以总操作不会超过 $m-n+2\le m +1$ 次. 做一个 01 高斯消元,第 $i$ 个变量表示 $i$ 有没有被选,第 $i$ 个方程是点 $i$ 的度数在异或意义下为 $0​$ . 用 bitset 优化,时间复杂度 $O(T\cdot \frac{n^3}{w})​$ . code B 通用测评号可以把猎人杀的思路借用过来. 由于每个位置没有差别,可以算出所有位置达到 $b$ 时,第一个位置达到 $a$ 的概率,乘上 $n$ 就是答案. 考虑容斥,枚举集合 $S$ 在第一个位置到达 $a$ 的时候还没有到达 $b$ ,由于所有位置相同,所以只需要枚举 $i=|S|$. 再枚举一个 $j$ ,表示第一个位置到达 $a$ 时,那 $i$ 个位置上的总和为 $j$ . 每次选位置时像猎人杀那样,若选到了已经 $=a$ 的位置就重新选,直到选到可以放的. 那么我们只会关心这 $j$ 次操作和第一个位置的前 $a-1$ 的操作的相对顺序,它的第 $a$ 次操作相对顺序一定在最后.$$ans=n\cdot (1-\sum_{i=0}^{n-1} (-1)^i \binom{n-1}{i}\sum_{j=0}^{(b-1)\cdot i}\binom{a-1+j}{a-1}\cdot \frac{f(i,j)}{(i+1)^{a+j}})$$其中 $f(i,j)$ 表示有 $i$ 个位置和 $j$ 次操作,要求每个位置被操作次数 $&lt;b$ 的方案数. 由于每次操作是有区别的,所以方案数就等于 $(\frac{x^0}{0!}+\frac{x^1}{1!}+\dots+\frac{x^{b-1}}{(b-1)!})^i​$ 这个多项式第 $j​$ 项的次数乘上 $j!​$. 用 NTT 实现多项式乘法,时间复杂度 $O(n^3\log n)$ . 常数优化: 多项式 $(\frac{x^0}{0!}+\frac{x^1}{1!}+\dots+\frac{x^{b-1}}{(b-1)!})​$ 可以只进行一次 DFT, 保存点值即可. code C 前进四将所有修改和询问分别按照下标 $x$ 从大到小排序,从大到小枚举下标. 对于每个时间 $t$ ,维护当前后缀 $x$ 的最小值,以及这个数随着 $x$ 的减小被修改的次数,后者就是需要查询的答案. 考虑将 $x$ 相同的修改操作按照时间从前往后排序,相邻两个修改操作会影响一段时间区间内的后缀 $x$ 最小值. 那么这段区间维护的最小值需要对修改的值取 $\min$ ,并且需要维护变小的次数,以及支持单点查询. 用一个 Segment tree beats 维护以上操作. 时间复杂度 $O(n\log n)$ . 常数卡不过去了. code]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>STL</tag>
        <tag>容斥原理</tag>
        <tag>多项式</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于网络流的一些小结论]]></title>
    <url>%2F2020%2F04%2F07%2F%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E6%B5%81%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%BB%93%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[记录一下一些常见的小结论. 最大权闭合子图在有向图中,每一个点都有一个权值. 选择一个权值和最大的子图,使得每个点的后继都在子图里面,这个子图就叫最大权闭合子图. 从源点 $S$ 向每个正权点连一条容量为权值的边,从每个负权点向汇点 $T$ 连一条容量为权值的绝对值的边. 有向图原来的边容量全部为无限大. 原图的最大权闭合子图的权值就等于所有正权点的权值之和减去新图的最小割. 无源汇上下界可行流一条边记做 $(u,v,mi,mx)$ ,表示这条边从 $u$ 连向 $v$ ,流量下界和上界分别为 $mi$ 和 $mx$ . 每条边强制流下界,就转化成了 $(u,v,0,mx-mi)$ . 此时会有流量不平衡的点,新建超级源点 $SS$ 与超级汇点 $TT$ . 若某个点 $x$ 流入的流量比流出的流量多 $w$ ,就新建边 $(SS,x,0,w)$ . 否则,若流出的流量比流入的流量多 $w$ ,就新建边 $(x,TT,0,w)$ . 跑一次从 $SS$ 到 $TT$ 的最大流,若 $SS$ 所有的出边都满流,则原图存在可行流. code 有源汇上下界可行流记源点为 $S$ ,汇点为 $T$ . 有源汇和无源汇的区别在于,有源汇的可行流中, $S$ 和 $T​$ 两个点可以不满足流量平衡. 我们加一条边 $(T,S,0,\inf)$ ,这样 $S$ 和 $T$ 也流量平衡了,就转化为了无源汇上下界可行流,套用即可. 若存在可行流,那么原图可行流的流量就是 $(T,S,0,\inf)$ 这条边上的流量. 有源汇上下界最大流先用有源汇上下界可行流的方法求出一个可行流. 若存在可行流,删掉 $(T,S,0,\inf)$ 这条边,在可行流的基础上求出 $S$ 到 $T$ 的最大流,即,不清空已有的流量. 答案就是可行流 + 最大流. code 有源汇上下界最小流先用有源汇上下界可行流的方法求出一个可行流. 若存在可行流,删掉 $(T,S,0,\inf)$ 这条边,在可行流的基础上求出 $T$ 到 $S$ 的最大流. 答案就是可行流 - 最大流. code]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2331 某位歌姬的故事]]></title>
    <url>%2F2020%2F04%2F07%2FLoj%202331%20%E6%9F%90%E4%BD%8D%E6%AD%8C%E5%A7%AC%E7%9A%84%E6%95%85%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[dp 计数. 首先可以对坐标离散化,记录一下离散化后的每个点代表原来数列中的几个点,方便后续计算方案数. 考虑 $\max(l,r) = h$ 的限制,等价于对于 $l\le i\le r$ 的 $i$ ,都有 $a_i\le h$ ,并且 $[l,r]$ 内至少有一个 $a_i=h$ . 可以对每个点计算出它能取到的上限 $up_i$ ,这个值其实就是所有覆盖它的区间中最小的 $h$ . 可以发现, $[l,r]$ 内至少有一个 $a_i=h$ 的限制,因为 $[l,r]$ 内一定有 $up_i\le h$ ,所以只能由 $up_i=h$ 的 $a_i$ 来满足. 对于所有 $h$ 相同的限制,我们将它们以及 $up_i=h$ 的点一起拿出来单独计算对方案数的贡献. 这需要满足每个区间中,至少有一个 $a_i$ 取到了上限 $a_i=h$ . 如果一个区间完全覆盖了另一个区间,可以直接把大区间的限制去掉,那么剩下的区间一定都是没有包含关系的. 我们把这些区间按照左端点从小到大排序. 设 $dp(i,j)$ 表示确定了前 $i$ 个点是否取到上限,前 $j$ 个区间已经满足限制,但第 $j+1$ 个区间不满足限制的方案数. 最后还要乘上没有被任何区间限制的点的贡献. 时间复杂度 $O(Tm^2)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;int read()&#123; int out = 0, sgn = 1; char jp = getchar(); while (jp != '-' &amp;&amp; (jp &lt; '0' || jp &gt; '9')) jp = getchar(); if (jp == '-') sgn = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * sgn;&#125;const int P = 998244353;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a, int b)&#123; int res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res;&#125;const int N = 2e3 + 10;int n, m, V, l[N], r[N], h[N], val[N], len, cnt[N], up[N];struct Interval&#123; int L, R, mx; bool operator &lt; (const Interval &amp;rhs) const &#123; return L ^ rhs.L ? L &lt; rhs.L : R &gt; rhs.R; &#125;&#125; p[N], tmp[N];struct node&#123; int pos, cnt; &#125; q[N];int dp[N][N];bool in(node A, Interval B)&#123; return B.L &lt;= A.pos &amp;&amp; A.pos &lt;= B.R;&#125;int calc(int _n, int _m)&#123; if (!_n) return 0; sort(tmp + 1, tmp + 1 + _m); int sl = 0, minr = n + 1; for (int i = _m; i &gt;= 1; --i) &#123; if (tmp[i].R &gt;= minr) continue; p[++sl] = tmp[i]; minr = tmp[i].R; &#125; _m = sl; reverse(p + 1, p + 1 + _m); dp[0][0] = 1; int mx = p[1].mx; for (int i = 0; i &lt; _n; ++i) &#123; for (int j = 0; j &lt;= _m; ++j) if (dp[i][j]) &#123; int c = fpow(mx - 1, q[i + 1].cnt); inc(dp[i + 1][j], mul(dp[i][j], c)); c = add(fpow(mx, q[i + 1].cnt), P - c); int pp = j; while (pp + 1 &lt;= _m &amp;&amp; in(q[i + 1], p[pp + 1])) ++pp; inc(dp[i + 1][pp], mul(dp[i][j], c)); &#125; &#125; int res = dp[_n][_m]; for (int i = 0; i &lt;= _n; ++i) for (int j = 0; j &lt;= _m; ++j) dp[i][j] = 0; return res;&#125;pair&lt;int, int&gt; t[N];void solve()&#123; len = 0; n = read(), m = read(), V = read(); if (m == 0) &#123; printf("%d\n", fpow(V, n)); return; &#125; int ans = 1; for (int i = 1; i &lt;= m; ++i) &#123; l[i] = read(), r[i] = read(), h[i] = read(); val[++len] = l[i], val[++len] = r[i]; &#125; for (int i = 1; i &lt;= m; ++i) for (int j = i + 1; j &lt;= m; ++j) if (h[i] &gt; h[j]) &#123; swap(l[i], l[j]); swap(r[i], r[j]); swap(h[i], h[j]); &#125; sort(val + 1, val + 1 + len); len = unique(val + 1, val + 1 + len) - val - 1; ans = mul(ans, fpow(V, val[1] - 1 + n - val[len])); int tl = len; for (int i = 1; i &lt;= len; ++i) &#123; cnt[i] = 1; if (i &lt; len &amp;&amp; val[i] + 1 != val[i + 1]) &#123; ++tl; val[tl] = val[i] + 1; cnt[tl] = val[i + 1] - val[i] - 1; &#125; &#125; len = tl; for (int i = 1; i &lt;= len; ++i) for (int j = i + 1; j &lt;= len; ++j) if (val[i] &gt; val[j]) &#123; swap(val[i], val[j]); swap(cnt[i], cnt[j]); &#125; for (int i = 1; i &lt;= len; ++i) up[i] = V; for (int i = 1; i &lt;= m; ++i) &#123; l[i] = lower_bound(val + 1, val + 1 + len, l[i]) - val; r[i] = lower_bound(val + 1, val + 1 + len, r[i]) - val; for (int j = l[i]; j &lt;= r[i]; ++j) up[j] = min(up[j], h[i]); &#125; for (int i = 1; i &lt;= len; ++i) t[i] = make_pair(up[i], i); sort(t + 1, t + 1 + len); int i = 1, j = 1, _n, _m; while (ans &amp;&amp; j &lt;= m) &#123; _m = 0; int pp = j, tv = h[j]; while (pp &lt;= m &amp;&amp; h[pp] == tv) tmp[++_m] = (Interval)&#123;l[pp], r[pp], h[pp]&#125;, ++pp; j = pp; _n = 0; pp = i; while (pp &lt;= len &amp;&amp; t[pp].first == tv) q[++_n] = (node)&#123;t[pp].second, cnt[t[pp].second]&#125;, ++pp; i = pp; ans = mul(ans, calc(_n, _m)); &#125; while (i &lt;= len) ans = mul(ans, fpow(V, cnt[t[i++].second])); printf("%d\n", ans);&#125;int main()&#123; int T = read(); while (T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重背包的单调队列优化]]></title>
    <url>%2F2020%2F04%2F07%2F%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E7%9A%84%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[分析了几种多重背包的常见算法. 多重背包的问题形式有 $n$ 个物品,其中第 $i$ 个物品的体积是 $v_i$ ,价值是 $w_i$ ,有 $c_i$ 个. 现在有一个容量为 $m$ 的背包,需要选出若干个物品放入背包中,满足它们体积和不超过 $m$ ,最大化价值总和. 朴素算法设 $f(i,j)$ 表示考虑了前 $i$ 种物品,选出物品总体积不超过 $j$ 时的最大价值.$$f(i,j)=\max_{k=0}^{k\cdot v_i\le j} \lbrace f(i-1,j-k\cdot v_i+k\cdot w_i) \rbrace$$枚举 $i,j,k$ 进行转移,时间复杂度 $O(nm\max c_i)$ . 二进制拆分对每个物品,从小到大枚举 $k$ ,若 $c_i\ge 2^k$ ,就从 $c_i$ 中拿出 $k$ 个形成以一个新物品,体积是 $v_i\cdot 2^k$ ,价值是 $w_i\cdot 2^k$. 若最后 $c_i$ 还有剩下的,就将这 $c_i$ 个组合成一个新物品. 用这些新物品代替原来的 $c_i$ 个物品,对所有新物品做一个 $01$ 背包,容易证明和原问题是等价的. 时间复杂度 $O(nm\log \max c_i)$ . 单调队列优化观察朴素算法的转移形式,$$f(i,j)=\max_{k=0}^{k\cdot v_i\le j} \lbrace f(i-1,j-k\cdot v_i+k\cdot w_i) \rbrace$$固定 $i$ ,可以发现一个 $f(i-1,j)$ 只会被用于更新 $f(i,j+k\cdot v_i)$ ,而 $v_i$ 是确定的. 于是我们可以将所有 $f(i-1,j)$ 按照模 $v_i$ 的结果分成若干组,每组分别去更新 $f(i)$ . 考虑 $j\bmod v_i=r$ 的这一组,它们也只能更新 $j\bmod v_i=r$ 的 $f(i.j)$ . 那么我们可以直接把 $j$ 写成 $pv_i+r$ 的形式,这组内的转移式就可以写为$$f(i,pv_i+r) = \max \lbrace f(i-1,(p-k)v_i+r)+k\cdot w_i\rbrace,k\le c_i$$那么 $p-k$ 的合法选择范围就是一个长度固定的后缀的形式,随着 $p$ 增大不断向后滑动. 这就是一个滑动窗口的最优化 dp 了,可以用单调队列进行优化. 时间复杂度 $O(nm)$ .]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类欧几里得算法学习笔记]]></title>
    <url>%2F2020%2F04%2F07%2F%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[发现自己完全不会类欧几里得算法,于是来学一学. 问题最基本的形式是求$$\sum_{x=1}^n \lfloor\frac{ax+b}{c}\rfloor$$其中 $a,b,c$ 为给定的常数, $0\le a,b,c,n\le 10^9, c\neq 0$ . 当 $a \ge c$ 时,可以把 $a$ 写成 $a=kc+a\bmod c$ 的形式,答案就变成了$$\sum_{x=1}^n \lfloor\frac{(a\bmod c)\cdot x+b}{c}\rfloor + \sum_{x=1}^n kx$$后面那个 $\sum$ 是个等差数列求和,可以 $O(1)$ 求出. 对于前面那个 $\sum$ ,它的形式和原问题是一致的,我们可以递归调用该算法求解. 当 $a&lt;c$ 时,若 $a=0$ ,则答案为 $x\cdot \lfloor\frac b c\rfloor$ ,否则,我们通过画图来观察性质: 答案应该是 $x=0,x=n,y=0,y=\frac{a}{c}x+\frac{b}{c}$ 这四条直线围成的直角梯形内 $x&gt;0,y&gt;0$ 的整点的数量. 我们过交点 $(0,\frac{b}{c})$ 向 $x=n$ 引一条垂线,将图形分为两部分. 黄色部分是一个矩形,贡献可以 $O(1)$ 求出. 对于蓝色部分的直角三角形,我们可以通过翻转与平移将它变成一个子问题,递归下去求解即可. 这样递归一次会交换 $a,c$ . 考虑每递归一次,若 $a\ge c$ ,则 $a$ 变为 $a\bmod c$ , $c$ 不变.否则,就交换 $a,c$ ,递归边界是 $a=0$ . 可以发现这就类似于欧几里得算法求 $\gcd$ 的递归过程,可以得出时间复杂度 $O(\log \max(a,c))$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int read()&#123; int out = 0, sgn = 1; char jp = getchar(); while (jp != '-' &amp;&amp; (jp &lt; '0' || jp &gt; '9')) jp = getchar(); if (jp == '-') sgn = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * sgn;&#125;const int P = 998244353;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;// ans = \sum_&#123;x=1&#125;^&#123;n&#125; \lfloor \frac&#123;ax+b&#125;&#123;c&#125; \rfloorint s1(int n)&#123; return 1LL * n * (n + 1) / 2 % P;&#125;int solve(int a, int b, int c, ll n)&#123; if (a == 0) return mul(n, b / c); int ans = 0; if (a &gt;= c || b &gt;= c) &#123; ans = solve(a % c, b % c, c, n); inc(ans, mul(a / c, s1(n % P))); inc(ans, mul(b / c, (n + 1) % P)); &#125; else &#123; ll m = (n * a + b) / c; ans = mul(n % P, m % P); inc(ans, P - solve(c, c - b - 1, a, m - 1)); &#125; return ans;&#125;int bf(int a, int b, int c, int n)&#123; int ans = 0; for (int x = 1; x &lt;= n; ++x) inc(ans, (1LL * a * x + b) / c % P); return ans;&#125;int main()&#123; int T = read(); while (T--) &#123; int n = read(), a = read(), b = read(), c = read(); int ans = solve(a, b, c, n); inc(ans, P - b / c); printf("%d\n", ans);// printf("%d\n", bf(a, b, c, n)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Miller Rabin 及 Pollard Rho 算法学习笔记]]></title>
    <url>%2F2020%2F04%2F07%2FMiller%20Rabin%20%E5%8F%8A%20Pollard%20Rho%20%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[发现自己完全不会这两个算法,于是来学一学. Miller Rabin 算法用于判定一个较大的数是否为素数. 朴素的判定方法是枚举 $\sqrt n$ 内的所有数,依次检验它们是否为 $n$ 的因子,时间复杂度 $O(\sqrt n)$ . 费马小定理对于任意素数 $p$ 以及 $1\le x\le p-1$ 的整数 $x$ ,有 $x^{p-1} \equiv 1\pmod p$. 任意 $1\le x\le p-1$ 满足 $x^{p-1} \equiv 1\pmod p$ 是 $p$ 为素数的必要条件,但不是充分条件. 一个反例是 $561=3\times 11\times 17$ ,这种数被称为卡迈克尔数. 于是我们不能直接用费马小定理来判定一个数的素性,但可以利用费马小定理先排除掉一些合数. 二次探测定理对于任意素数 $p$ ,若 $x^2 \equiv 1\pmod p$ ,则 $x \equiv 1\pmod p$ 或 $x\equiv p-1 \pmod p$ . 这个定理也可以用来排除掉一些合数. 算法流程记需要判定的数为 $n$ . 取若干个素数作为基底,依次用于检验,若 $n$ 通过了所有的检验,我们就认定 $n$ 为素数. 记当前用于判定的基底为 $b$ . 首先,用费马小定理检验一次,即检查是否有 $b^{n - 1} \equiv 1\pmod n$ ,若不满足,则 $n$ 为合数. 否则,若 $n-1$ 为偶,我们可以将上式变为 $(b^{\frac{n-1}2})^2 \equiv 1 \pmod n$ . 根据二次探测定理,需要检查是否有 $b^{\frac{n-1}2} \equiv 1\pmod n$ 或 $b^{\frac{n-1}2} \equiv n-1\pmod n$ ,若都不满足,则 $n$ 为合数. 如果 $\frac {n-1}{2}$ 也是个偶数,且 $b^{\frac{n-1}2} \equiv 1\pmod n$ ,就可以继续拆,变成 $(b^{\frac{n-1}4})^2 \equiv 1 \pmod n$ 继续检验. 当做到次数为奇数,或出现了 $b^{k}\equiv n-1\pmod n$ ,就无法继续用这个基底检验了. 此时退出,用下个基底继续检验,直到判定出 $n$ 为合数,或通过了所有基底的检验. 一个基底的错误概率约为 $\frac 1 4$ ,取前 $9$ 个质数分别作为基底可基本保证正确性. 时间复杂度为 $O(\log^2 n)$ ,瓶颈在于做了 $O(\log n)$ 次检验,每次检验需要计算一次快速幂,空间复杂度 $O(1)$ . 实现时可以去掉那次费马小定理的检验,因为第一次用二次探测定理检验时就已经包含了这次检验. Loj 143 code Pollard Rho 算法用于找出一个较大数的某个非平凡因子.假设需要被分解的数为 $n$ ,且其最小质因子为 $p\ (p\neq n)$ . 该算法可以在 $O(\sqrt p\cdot \log n)$ 的期望时间复杂度内找出 $n$ 的某个非平凡因子,空间复杂度 $O(1)$ . 若要对 $n$ 进行质因数分解,则将得到的两个因数继续调用该算法分解,直到得到质数. 算法流程设需要分解的数为 $n$ ,先用 Miller Rabin 算法判断 $n$ 是否为质数,若为质数,则直接返回. 否则,设有 $n = p\times q$ ,其中 $p$ 是 $n$ 的某个非平凡因子. 我们在模意义下生成一个近似随机的数列 ${x_n},x_1 = 2, x_i = f(x_{i-1}) \bmod n$ . 其中 $f$ 是一个伪随机函数,可取 $f(x) = x^2 + a$ ,其中 $a$ 为某个常数. 此时,另一个数列 ${x_n\bmod p}$ 也客观存在,而这两个数列显然都存在循环节. 根据生日悖论,数列 ${x_n}$ 循环节出现的位置期望为 $O(\sqrt n)$ ,数列 ${x_n\bmod p}$ 循环节出现的位置期望为 $O(\sqrt p)$ . 若存在两个位置 $i,j$ 使得 $x_i\equiv x_j \pmod p$ 且 $x_i \neq x_j$ ,就可以找到一个非平凡因子 $\gcd(x_i-x_j,n)$ 可以取 $i,2i$ 这两个位置,其中 $x_{2i}$ 的值可以通过每次迭代两步得到,类似于 floyd 消圈,而不用存储整个数列. 计算出 $t =\gcd(x_{i}-x_{2i},n)$ ,若 $t=1$ ,说明 $i,2i$ 不在任何数列的循环节对应位置,继续枚举下一个 $i$ . 若 $t = n$ ,说明 $i,2i$ 同时在两个数列的对应位置,那么再增大 $i$ 也无法找到仅在一个数列中对应的 $i$ . 此时只能退出,更换随机函数 $f(x)$ ,即取另一个常数 $a$ 执行算法. 若 $t\neq 1$ 且 $t\neq n$ ,那么我们就找到了 $t$ 作为 $n$ 的一个非平凡因子. 由于函数 $f(x)=x^2 +a$ 只会生成模 $4$ 意义下与 $a,a+1$ 同余的数,所以无法分解出 $2$ 这个因子,需要特判. 期望需要枚举 $O(\sqrt p)$ 个 $i$ 来找到一个非平凡因子,每次需要求一次 $\gcd$ ,时间复杂度 $O(\sqrt p\cdot \log n)$ . 当 $n$ 不为素数时, $n$ 的最小质因子显然不超过 $\sqrt n$ ,于是时间复杂度可以化为 $O(n^{\frac 1 4}\cdot \log n)$ . 优化注意到我们只有在 $\gcd(x_i-x_{2i},n) = 1$ 的情况下才会继续运行该算法. 我们设置一个参数 $k$ ,计算每 $k$ 个 $x_i-x_{2i}$ 的乘积对 $n$ 取模的结果 $prod$ . 若 $\gcd(prod,n) =1$ ,说明这 $k$ 个 $x_i-x_{2i}$ 与 $n$ 的 $\gcd$ 均为 $1$ ,继续考虑接下来的 $k$ 个 $x_i-x_{2i}$ . 若 $\gcd(prod,n) = n$ ,我们不知道这 $k$ 个数中是否有解,此时只能回到 $k$ 步前,运行原本的 Pollard Rho 算法. 若 $\gcd(prod,n)\neq 1$ 且 $\gcd(prod,n)\neq n$ ,那么 $\gcd(prod,n)$ 就是 $n$ 的一个非平凡因子. 此时,该算法找出一个非平凡因子的时间复杂度被优化到了 $O(n^{\frac 1 4}+\frac{n^{\frac 1 4}\log n}{k}+k\log n)$ . bzoj 3667 code]]></content>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uoj 62 怎样跑得更快]]></title>
    <url>%2F2020%2F04%2F07%2FUoj%2062%20%E6%80%8E%E6%A0%B7%E8%B7%91%E5%BE%97%E6%9B%B4%E5%BF%AB%2F</url>
    <content type="text"><![CDATA[莫比乌斯反演. 为了方便,假定我们要解的方程组的形式为$$b_i\equiv \sum_{j=1}^n \gcd(i,j)^c {\rm lcm}(i,j)^d z_j \pmod {998244353}$$变形一下,得到$$b_i\cdot i^{-d} \equiv \sum_{j=1}^n \gcd(i,j)^{c-d} (j^d\cdot z_j) \pmod {998244353}$$那么方程组可以写成$$y_i \equiv \sum_{j=1}^n \gcd(i,j)^w x_j$$这样的形式,我们只要解出了这里了 $x_j$ ,由 $j^d\cdot z_j\equiv x_j$ 就可以求得 $z_j$ 了. 先尝试推一波式子把 $\gcd$ 去掉.$$\begin{aligned}y_i &amp;= \sum_{j=1}^n \gcd(i,j)^w x_j \\&amp;=\sum_{d|i} d^w\sum_{j=1}^{\lfloor\frac n d\rfloor}x_{jd}\sum_{s|\frac{i}{d},s|j} \mu(s)\end{aligned}$$我们直接枚举 $T=ds$ ,得到$$y_i=\sum_{T|i}(\sum_{d|T}d^w\mu(\frac Td)) \sum_{j=1}^{\lfloor\frac n T \rfloor} x_{jT}$$$y_i$ 是已知的,我们用一次莫比乌斯反演即可求出每个 $T$ 的 $(\sum_{d|T}d^w\mu(\frac Td)) \sum_{j=1}^{\lfloor\frac n T \rfloor} x_{jT}$ . 前面那个式子 $\sum_{d|T}d^w\mu(\frac Td)$ 是一个关于 $T$ 的积性函数,可以线性筛预处理,也可以枚举 $d$ ,将贡献加到每个 $T$ 上. 那么两者相除就可以得出每个 $T$ 的 $\sum_{j=1}^{\lfloor\frac n T \rfloor} x_{jT}$ ,我们从大到小枚举 $T$ ,就可以得出每个 $x_i$ ,进而求出 $z_i$ . 时间复杂度 $O(n\log n)$ . 形如 $y_i=\sum_{j} f(\gcd(i,j))\cdot g(i)\cdot h(j)\cdot x_i$ 的方程组都可以类似求解. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int read()&#123; int out = 0, sgn = 1; char jp = getchar(); while (jp != '-' &amp;&amp; (jp &lt; '0' || jp &gt; '9')) jp = getchar(); if (jp == '-') sgn = -1, jp = getchar(); while (jp &gt;= '0' &amp;&amp; jp &lt;= '9') out = out * 10 + jp - '0', jp = getchar(); return out * sgn;&#125;const int P = 998244353;int add(int a, int b)&#123; return a + b &gt;= P ? a + b - P : a + b;&#125;void inc(int &amp;a, int b)&#123; a = add(a, b);&#125;int mul(int a, int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a, int b)&#123; int res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return res;&#125;const int N = 1e5 + 10;int c, d, w, f[N], g[N], h[N], pwd[N];int mu[N], prime[N], cnt = 0, ism[N];void init(int n)&#123; ism[1] = 1, mu[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!ism[i]) &#123; mu[i] = P - 1; prime[++cnt] = i; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; ism[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = add(P, -mu[i]); &#125; &#125; for (int d = 1; d &lt;= n; ++d) &#123; int pw = fpow(d, w); for (int T = d; T &lt;= n; T += d) inc(g[T], mul(pw, mu[T / d])); &#125; for (int i = 1; i &lt;= n; ++i) &#123; g[i] = fpow(g[i], P - 2); pwd[i] = fpow(i, P - 1 - d); &#125; &#125;int n, m, x[N], y[N], z[N];int main()&#123; n = read(), c = read() % (P - 1), d = read() % (P - 1), m = read(); w = c - d; if (w &lt; 0) w += P - 1; init(n); while (m--) &#123; for (int i = 1; i &lt;= n; ++i) &#123; int b = read(); y[i] = mul(b, pwd[i]); f[i] = h[i] = x[i] = 0; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = i; j &lt;= n; j += i) inc(f[j], mul(y[i], mu[j / i])); bool flag = true; for (int i = 1; i &lt;= n &amp;&amp; flag; ++i) &#123; if (!g[i]) &#123; if (!f[i]) h[i] = 0; else flag = false; &#125; else h[i] = mul(f[i], g[i]); &#125; if (!flag) &#123; puts("-1"); continue; &#125; for (int i = n; i &gt;= 1; --i) &#123; int sum = 0; for (int j = i + i; j &lt;= n; j += i) inc(sum, x[j]); x[i] = add(h[i], P - sum); &#125; for (int i = 1; i &lt;= n; ++i) z[i] = mul(x[i], pwd[i]); for (int i = 1; i &lt;= n; ++i) printf("%d ", z[i]); puts(""); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20200118]]></title>
    <url>%2F2020%2F01%2F19%2Ftest20200118%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+PQjDD0Ec1wNqqbu07kdBQDpaL/AztwX8mtwtKXkTA0ejLRFVzwNjuAIm9CQKIaqFJIyqUVpd2PJjsF7YSCGXWMcaJr3qE2AaP7sDYFcHGVPEchgyGS+7CwwkTc7vGCpwB33W6O1jY9yQWsfQWdkGi1DpXx/DQtQqqSc7Jy7D9SZSz+YyenTeA4JtMpF0Whxr/Tm60qkr49Fy3kvlwOnSxnRlDVICHmg2KRtjHGp1DtODnxIrifvOPHqDj+InQQSZFhhtIXBFX4m8B9Sp5DVdnUAc/00yoiyfTN+KbZCDNiq5RJ+fM6CtxyToVEILJ4vUL76YOilTIEWMvpfGfLMwztTvIbTmD312N79Gd2C/ID3D9IbMxDxGPbNaMqFNxaw1MowNp+ZN28rfxF9YtCeWlZ48+A1I1iDaqZNKcFUnIEZjCwmobN8eAm1bfhytmL2skakSPr0/ThQqZgTrSNB6cuhm5sMKuNR22cJktFnqd8zxCqrUXggOc+XWEZtuyXM1viA5B4LZKZlNLWAmv5en5PJdNPVrm6gC5DrX677SdNHKhIkVlzdfwNPNj8MP4mKMHOVfdvMGPV1ElWtxs00SpQ/gUQht6ywdyhMu1UkbnE2V8DGdRCjZVb2hBpLvg+ddHFuOQ0wiCKjcNn1alPgKocj772bMkL34Hk5F2YOpp6Ylh5hw9DeYTZRL2srcXpUqF5RpyJJDqeUCmOjQFYh+fMcKmpKBJFOMmoZ+hp0T6PoPDK/yHye9T+YN8s+LXS6p3gSQjwAR7GAwIL19TO0MacZke4R3+O+YTYITpbXJBneyooWReTcavejSaIHmy46ZSajLradEQPlpv0Qs+XBVoBrAHL9T3CdFOWMd7M3KqvfI0KG3yjFIsEaFYCWwwOtTUeo7PF6G1w6Kj2wBao+YHa4Bdbo/Sh5p+B7LwzOthGX0AiRLU7AfFdrC/wsDAIvg5smGZJCK7mc5wylANCmKRJKP+IGelI30jx40m8HACLiyUWQX0TczBeffqK82TTua19VUEmuu9nkCB7jo9a0KyMGYN2AahpaEszd1TYTi+FoNXYDm/PA7xC7JUm/ddkCK20w5J2AKs7Gcdq4M9PcBsb5FQqIKotVTRictMZGnp2tLXH/Vf+riLxrPrDqwSntlkuYmsgBtfqWNn4NUoOKf+AwZWJUWIOr/2wjLVXHWeyzXeT31bef0YkDb7Z3q7D2CDES3ypjlRup06J4jsWFc89aQAX51f7hAWBCtNzcLti4h1uBObJwOvMpRPP9ym9fF4g/cYeAQQuXm0WVFkPGeJRnekksPDNuda3vHL+pPPUqlOnBhfNpmL2q8FBxtOu3+CwqIeDWkrWFqdIJVHzwxGvDy86/VPqtMTrAgvOxkKX7M4nYU1xKBaq2/a+TitOXTdJfeZzsIWjx/7Z3E9hlklqWvlNDDFGlw1zpsKZLdFlWYx98HYPGnXoZznSskmUnlm7mpNRlLjqQfA9qP8YP+Kn+r5tcD4plgQQfYhvloQ3QImrn9R3KdNLwKFQJ9kP6xTkXmYidWHADz/wCt/cKJ7ztOBIFXc6frEFBYv0hWr4Cxeom7Or/KDa/7Z93h6fuC19msYfbHKnjQV59rVltitvpUSjablghv5v1pTEgxn6p0miW/K1o4A var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>线段树</tag>
        <tag>数学</tag>
        <tag>矩阵加速</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20200117-am]]></title>
    <url>%2F2020%2F01%2F17%2Ftest20200117-am%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>容斥原理</tag>
        <tag>多项式</tag>
        <tag>网络流</tag>
        <tag>数位dp</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20200116]]></title>
    <url>%2F2020%2F01%2F16%2Ftest20200116%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>概率/期望</tag>
        <tag>LCT</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20200113-pm]]></title>
    <url>%2F2020%2F01%2F13%2Ftest20200113-pm%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>多项式</tag>
        <tag>数位dp</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20200113-am]]></title>
    <url>%2F2020%2F01%2F13%2Ftest20200113-am%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>线性代数</tag>
        <tag>拉格朗日插值</tag>
        <tag>矩阵树定理</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20200112-pm]]></title>
    <url>%2F2020%2F01%2F12%2Ftest20200112-pm%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>hash</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20200112-am]]></title>
    <url>%2F2020%2F01%2F12%2Ftest20200112-am%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>构造</tag>
        <tag>meet in the middle</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小割树学习笔记]]></title>
    <url>%2F2020%2F01%2F10%2F%E6%9C%80%E5%B0%8F%E5%89%B2%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[发现自己完全不会最小割树,于是来学一学. 概念一张 $n$ 个点的图上,两点之间只存在 $n-1$ 种本质不同的最小割. 可以构造出一棵带边权的树,满足树上两点的最小割 (即两点路径上最小边权) 等于原图上两点最小割. 这样的树称为最小割树,也称 Gomory-Hu Tree . 构造方法先任意选取两个节点 $u,v​$ ,求出它们的最小割 ${\rm cut}(u,v)​$ ,跑最大流时,满流的边就对应最小割中割掉的边. 通过这组割,可以把图划分成两个部分, $u$ 所在的点集记作 $U$ , $v$ 所在的点集记作 $V$ . 对于任意 $x\in U,y\in V​$ ,有 ${\rm cut}(x,y)\le {\rm cut}(u,v)​$ . 否则用 ${\rm cut}(u,v)​$ 的花费一定无法割开 $x,y​$ ,也就割不开 $u,v​$ ,就矛盾了. 在最小割树上新建一条边 $(u,v)$ ,边权为 ${\rm cut}(u,v)$ ,然后对点集 $U,V$ 内的点分别递归执行以上算法. 最后恰好计算了 $n-1$ 次最小割,也建出了最小割树. 考虑树上路径 $x\to y$ 经过的每条边 $u\to v$ . 那么在建出 $u\to v$ 这条边时, $x,y$ 被分入了不同集合,有 ${\rm cut}(x,y)\le {\rm cut}(u,v)$ . 简单归纳就可以得到这样的构造满足了概念中的性质,即,树上两点路径上最小边权等于原图上两点最小割. 那么我们只做了 $O(n)$ 次最小割,就可以支持询问任意两点之间的最小割了.]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>网络流</tag>
        <tag>最小割树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20200110]]></title>
    <url>%2F2020%2F01%2F10%2Ftest20200110%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>多项式</tag>
        <tag>倍增</tag>
        <tag>提交答案</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 3093 光线]]></title>
    <url>%2F2020%2F01%2F09%2FLoj-3093-%E5%85%89%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[等比数列求和. 显然可以从前往后不断合并两面镜子,对于每面镜子只需要记录从前面射来的透光率和后面射来的反射率就可以了. 合并两面镜子时,推一下就能发现是个简单的等比数列求和. 时间复杂度 $O(n\log P)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; int n=read(),A=1,B=0,Inv=fpow(100,P-2); for(int i=1;i&lt;=n;++i) &#123; int a=mul(read(),Inv),b=mul(read(),Inv); int tmp=fpow(add(1,P-mul(B,b)),P-2); A=mul(A,mul(a,tmp)); B=add(b,mul(B,mul(a,mul(a,tmp)))); &#125; cout&lt;&lt;A&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20200109]]></title>
    <url>%2F2020%2F01%2F09%2Ftest20200109%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>STL</tag>
        <tag>分块</tag>
        <tag>test</tag>
        <tag>虚树</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 3089 奥术神杖]]></title>
    <url>%2F2020%2F01%2F08%2FLoj-3089-%E5%A5%A5%E6%9C%AF%E7%A5%9E%E6%9D%96%2F</url>
    <content type="text"><![CDATA[$01$ 分数规划 + AC 自动机. 先把权值取个对数,就变成了最大化算术平均数. 考虑 $01​$ 分数规划,二分答案 $k​$ ,那么每个串的权值变为了 $V_i-k​$ ,需要检验是否存在权值和 $&gt;0​$ 的方案. 注意 $=0​$ 不一定是合法的,因为实际上可能一个串也没有选. 在 AC 自动机上 dp 一下,设 $f(i,j)$ 表示匹配了前 $i$ 个字符,当前在节点 $j$ 时的最大权值, dp 的时候顺便记录方案. 时间复杂度 $O(T\cdot ns|\sum|)$ ,其中 $T$ 表示二分的次数, $|\sum|$ 表示字符集大小. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1515,S=10;char s[MAXN],buf[MAXN],ans[MAXN];bool flag=false;int n,m,idx=0,cnt[MAXN],fail[MAXN],ch[MAXN][S];double f[MAXN][MAXN],val[MAXN],inf;void ins(int v)&#123; int u=0,len=strlen(buf+1); for(int i=1;i&lt;=len;++i) &#123; int c=buf[i]-'0'; if(!ch[u][c]) ch[u][c]=++idx; u=ch[u][c]; &#125; val[u]+=log(v); cnt[u]++;&#125;queue&lt;int&gt; q;void getfail()&#123; for(int i=0;i&lt;S;++i) if(ch[0][i]) q.push(ch[0][i]); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=0;i&lt;S;++i) if(ch[u][i]) &#123; q.push(ch[u][i]); fail[ch[u][i]]=ch[fail[u]][i]; val[ch[u][i]]+=val[fail[ch[u][i]]]; cnt[ch[u][i]]+=cnt[fail[ch[u][i]]]; &#125; else ch[u][i]=ch[fail[u]][i]; &#125;&#125;int pre[MAXN][MAXN],c[MAXN][MAXN];bool check(double mid)&#123; memset(f,-0x3f,sizeof f); inf=-f[0][0],f[0][0]=0; for(int i=0;i&lt;n;++i) &#123; int l=(s[i+1]=='.')?0:s[i+1]-'0'; int r=(s[i+1]=='.')?9:s[i+1]-'0'; for(int j=0;j&lt;=idx;++j) if(f[i][j]&gt;-inf) for(int k=l;k&lt;=r;++k) &#123; int p=ch[j][k]; double tmp=f[i][j]+val[p]-mid*cnt[p]; if(tmp&gt;f[i+1][p]) &#123; f[i+1][p]=tmp; pre[i+1][p]=j; c[i+1][p]=k; &#125; &#125; &#125; double mx=-inf; int pos; for(int i=0;i&lt;=idx;++i) if(f[n][i]&gt;mx) mx=f[n][i],pos=i; if(mx&lt;=0) return false; for(int i=n;i&gt;=1;--i) &#123; ans[i]=c[i][pos]+'0'; pos=pre[i][pos]; &#125; return true;&#125;int main()&#123; n=read(),m=read(); scanf("%s",s+1); double l=0,r=0,mid; for(int i=1;i&lt;=m;++i) &#123; scanf("%s",buf+1); int v=read(); r=max(r,log(v)); ins(v); &#125; getfail(); for(int i=1;i&lt;=30;++i) &#123; mid=(l+r)/2.0; if(check(mid)) flag=true,l=mid; else r=mid; &#125; if(!flag) &#123; for(int i=1;i&lt;=n;++i) putchar(s[i]=='.'?'0':s[i]); puts(""); &#125; else &#123; for(int i=1;i&lt;=n;++i) putchar(ans[i]); puts(""); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>分数规划</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 3090 勘破神机]]></title>
    <url>%2F2020%2F01%2F08%2FLoj-3090-%E5%8B%98%E7%A0%B4%E7%A5%9E%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[特征方程求解数列通项. 先考虑 $m=2$ 的做法,设 $f(i)$ 表示用 $1\times 2$ 的骨牌填满 $2\times i$ 的网格的方案数. 显然有 $f(0)=f(1)=1,f(i)=f(i-1)+f(i-2)$ . 利用特征方程可以求出 $f(i)=c_1x^i+c_2y^i$ . 推一下式子,$$\begin{aligned}(r-l+1)\cdot ans_2&amp;=\sum_{i=l}^r F(i,k) \\&amp;=\sum_{i=l}^r \binom{f(i)}{k} \\&amp;=\sum_{i=l}^r \frac{1}{k!}\cdot f(i)^{\underline k}\end{aligned}$$把 $x^{\underline k}$ 暴力展开成 $\sum a_i\cdot x^i$ ,代回上式,$$\begin{aligned}(r-l+1)\cdot ans_2&amp;=\sum_{n=l}^r \frac{1}{k!} \sum_{j=0}^k a_j\cdot f(i)^j \\&amp;=\sum_{j=0}^k \frac{a_j}{k!} \sum_{i=l}^r (c_1x^i+c_2y_i)^j \\&amp;=\sum_{j=0}^k \frac{a_j}{k!}\sum_{p=0}^j \cdot \binom{j}{p} \cdot c_1^pc_2^{j-p} \sum_{i=l}^r (x^p y^{j-p})^i\end{aligned}$$枚举 $j,p$ 的值,最后面的那一项用等比数列求和公式计算,时间复杂度 $O(k^2\cdot \log r)$ . 当 $m=3$ 时,设 $g(n)$ 表示填满 $2\times (2n)$ 的方案数,有 $g(0)=1,g(1)=3,g(i)=4g(i-1)-g(i-2)$ . 算出此时的 $c_1,x,c_2,y$ ,其余做法和 $m=2$ 的相同. 由于解出来的 $c$ 分别含有 $\sqrt 5,\sqrt 3$ ,而 $5,3$ 在模 $998244353$ 下都不是二次剩余,所以要自己定义一个数域. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int K=1&lt;&lt;9;int binom[K][K],w;struct cp&#123; int r,i; cp(int r=0,int i=0):r(r),i(i) &#123;&#125; cp operator + (const cp &amp;rhs) const &#123; return cp(add(r,rhs.r),add(i,rhs.i)); &#125; cp operator - (const cp &amp;rhs) const &#123; return cp(add(r,P-rhs.r),add(i,P-rhs.i)); &#125; cp operator * (const cp &amp;rhs) const &#123; return cp(add(mul(r,rhs.r),mul(w,mul(i,rhs.i))),add(mul(r,rhs.i),mul(i,rhs.r))); &#125; cp operator ^ (const ll &amp;k) const &#123; ll b=k; cp a=*this,res=cp(1,0); while(b) &#123; if(b&amp;1LL) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res; &#125; cp inv() const &#123; int t=fpow(add(mul(r,r),P-mul(w,mul(i,i))),P-2); return cp(mul(r,t),mul(P-i,t)); &#125; cp operator / (const cp &amp;rhs) const &#123; return (*this)*(rhs.inv()); &#125;&#125;;cp c1,x,c2,y;void init(int m)&#123; int inv2=fpow(2,P-2),inv10=fpow(10,P-2),inv6=fpow(6,P-2); for(int i=0;i&lt;=501;++i) binom[i][0]=1; for(int i=1;i&lt;=501;++i) for(int j=1;j&lt;=i;++j) binom[i][j]=add(binom[i-1][j],binom[i-1][j-1]); if(m==2) &#123; w=5; x=cp(inv2,inv2); c1=cp(inv2,inv10); y=cp(inv2,P-inv2); c2=cp(inv2,P-inv10); &#125; else &#123; w=3; x=cp(2,1); c1=cp(inv2,inv6); y=cp(2,P-1); c2=cp(inv2,P-inv6); &#125;&#125;int a[K],b[K];int solve(ll L,ll R,int k)&#123; a[0]=1; for(int i=1;i&lt;=k;++i) a[i]=0; for(int i=0;i&lt;k;++i) // *(x-i) &#123; for(int j=0;j&lt;=i;++j) b[j+1]=a[j]; b[0]=0; for(int j=0;j&lt;=i;++j) inc(b[j],mul(a[j],P-i)); for(int j=0;j&lt;=i+1;++j) a[j]=b[j]; &#125; int invfac=1; for(int i=2;i&lt;=k;++i) invfac=mul(invfac,i); invfac=fpow(invfac,P-2); cp res=cp(0,0); for(int j=0;j&lt;=k;++j) for(int p=0;p&lt;=j;++p) &#123; int t=mul(mul(a[j],binom[j][p]),invfac); cp tmp=cp(t,0)*(c1^p)*(c2^(j-p)); cp q=(x^p)*(y^(j-p)); if(q.r==1 &amp;&amp; q.i==0) tmp=tmp*cp((R-L)%P,0); else &#123; cp pw=(cp(1,0)-(q^(R+1)))/(cp(1,0)-q); pw=pw-(cp(1,0)-(q^(L+1)))/(cp(1,0)-q); tmp=tmp*pw; &#125; res=res+tmp; &#125; return res.r;&#125;int main()&#123; int T=read(),m=read(); init(m); while(T--) &#123; ll L=read(),R=read(); int k=read(),ans=fpow((R-L+1)%P,P-2); if(m==2) ans=mul(ans,solve(L-1,R,k)); else ans=mul(ans,solve((L-1)&gt;&gt;1,R&gt;&gt;1,k)); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3996 线性代数]]></title>
    <url>%2F2020%2F01%2F08%2Fbzoj-3996-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%2F</url>
    <content type="text"><![CDATA[最小割. 考虑如果把 $A_{1,i}$ 置为 $1$ ,就把 $A\times B-C$ 加上了 $B_{i}$ 这个行向量. 最后的 $D=(A \times B-C) \times A^{T}$ ,所以最后只算那些 $A_{1,i}=1$ 的 $(A\times B-C)_{1,i}$ . 设 $S=\lbrace i | A_{1,i}=1 \rbrace $ ,则 $D=\sum_{i\in S}\sum_{j\in S} B_{i,j}-\sum_{i\in S} C_{1,i}$ . 意义是,若两个位置 $i,j$ 同时被选,会带来 $B_{i,j}$ 的收益,若 $i$ 被选,需要付出 $C_{1,i}$ 的代价. 这显然已经是最小割经典问题了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=(500*500+500)*4+10;const int inf=1e9;int n,ans=0,tot,B[512][512],C[512];struct Edge&#123; int to,nx,flow;&#125;E[MAXN];int ecnt=1,head[MAXN],cur[MAXN];void addedge(int u,int v,int flow)&#123; E[++ecnt]=(Edge)&#123;v,head[u],flow&#125;; head[u]=ecnt;&#125;void ins(int u,int v,int flow)&#123; addedge(u,v,flow); addedge(v,u,0);&#125;int dep[MAXN];queue&lt;int&gt; q;bool bfs(int S,int T)&#123; for(int i=1;i&lt;=tot;++i) dep[i]=-1,cur[i]=head[i]; dep[S]=0; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u];i;i=E[i].nx) &#123; int v=E[i].to; if(dep[v]==-1 &amp;&amp; E[i].flow&gt;0) &#123; dep[v]=dep[u]+1; q.push(v); &#125; &#125; &#125; return dep[T]!=-1;&#125;int dfs(int u,int T,int limit)&#123; if(u==T || !limit) return limit; int flow=0,f; for(int &amp;i=cur[u];i;i=E[i].nx) &#123; int v=E[i].to; if(dep[v]==dep[u]+1 &amp;&amp; E[i].flow&gt;0 &amp;&amp; (f=dfs(v,T,min(limit,E[i].flow)))) &#123; flow+=f; limit-=f; E[i].flow-=f; E[i^1].flow+=f; &#125; if(!limit) return flow; &#125; return flow;&#125;int Dinic(int S,int T)&#123; int maxflow=0; while(bfs(S,T)) maxflow+=dfs(S,T,inf); return maxflow;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) ans+=(B[i][j]=read()); for(int i=1;i&lt;=n;++i) C[i]=read(); tot=n; int S=++tot,T=++tot; for(int i=1;i&lt;=n;++i) &#123; ins(i,T,C[i]); int x=++tot; ins(S,x,B[i][i]); ins(x,i,inf); for(int j=1;j&lt;i;++j) &#123; int x=++tot; ins(S,x,B[i][j]+B[j][i]); ins(x,i,inf); ins(x,j,inf); &#125; &#125; ans-=Dinic(S,T); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 3014 独特的城市]]></title>
    <url>%2F2020%2F01%2F07%2FLoj-3014-%E7%8B%AC%E7%89%B9%E7%9A%84%E5%9F%8E%E5%B8%82%2F</url>
    <content type="text"><![CDATA[树的直径. 记树的某条直径为 $S-T$ ,则对于一个点 $x$ ,能对它造成贡献的点,一定都在 $x$ 到 $S,T$ 中较远的那个点的路径上. 否则,若还有其他点能对 $x$ 造成贡献,那么它到 $x$ 的距离一定大于 $x$ 到 $S,T$ 的距离,可以构造出更长的直径. 以 $S$ 为根做一次 dfs ,对每个 $x$ ,统计一下 $S\to x$ 路径上有几个点能对 $x$ 造成贡献,再以 $T$ 为根做一次同样的 dfs . 对于同一个 $x$ 的两次 dfs ,假设 $x$ 到 $S$ 更远,那么 $T$ 那一次的 dfs 计入贡献的点就是 $S$ 那一次计入贡献的点的子集. 那么把两次的答案取 $\max$ 就是实际的答案. dfs 时,用一个栈维护根到当前节点路径中,能造成贡献的点,开一个桶记录每种权值出现次数. 往栈中加点或者删点的时候,更新桶,并且更新当前答案,类似于莫队增加或删除端点时的操作. 假设当前已经处理了 $x$ 的答案,需要继续向下 dfs . 为了保证栈中点都是有贡献的,要先把栈中与 $x$ 距离小于等于 $x$ 到其它子树中最深的点的所有点删掉. 先往最深点的方向走,再往其它儿子走,删除操作就不用被撤销掉了. 每个点只会对它的父亲贡献 $O(1)$ 次进出栈操作,时间复杂度 $O(n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,m,ecnt=0,rt,dep[MAXN],c[MAXN];vector&lt;int&gt; G[MAXN];int bucket[MAXN],ans[MAXN],tmp=0;void ins(int x)&#123; tmp+=!(bucket[x]++);&#125;void del(int x)&#123; tmp-=!(--bucket[x]);&#125;void FindRt(int u,int fa)&#123; if(dep[u]&gt;dep[rt]) rt=u; for(int v:G[u]) if(v!=fa) dep[v]=dep[u]+1,FindRt(v,u);&#125;int mxson[MAXN],mx[MAXN],se[MAXN];void Init(int u,int fa)&#123; mxson[u]=0; mx[u]=dep[u],se[u]=-1; for(int v:G[u]) &#123; if(v==fa) continue; dep[v]=dep[u]+1; Init(v,u); if(mx[v]&gt;mx[mxson[u]]) mxson[u]=v,mx[u]=mx[v]; &#125; for(int v:G[u]) if(v!=fa &amp;&amp; v!=mxson[u]) se[u]=max(se[u],mx[v]);&#125;int stk[MAXN],tp=0;void dfs(int u,int fa)&#123; while(tp &amp;&amp; dep[u]-dep[stk[tp]]&lt;=se[u]-dep[u]) del(c[stk[tp--]]); ins(c[stk[++tp]=u]); if(mxson[u]) dfs(mxson[u],u); if(tp &amp;&amp; stk[tp]==u) del(c[stk[tp--]]); while(tp &amp;&amp; dep[u]-dep[stk[tp]]&lt;=mx[u]-dep[u]) del(c[stk[tp--]]); ans[u]=max(ans[u],tmp); for(int v:G[u]) &#123; if(v==fa || v==mxson[u]) continue; if(!tp || stk[tp]!=u) ins(c[stk[++tp]=u]); dfs(v,u); &#125; if(tp &amp;&amp; stk[tp]==u) del(c[stk[tp--]]);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); G[u].push_back(v); G[v].push_back(u); &#125; for(int i=1;i&lt;=n;++i) c[i]=read(); mx[0]=dep[0]=-1; int S,T; FindRt(1,0),S=rt,FindRt(S,0),T=rt; tp=dep[S]=0,Init(S,0),dfs(S,0); tp=dep[T]=0,Init(T,0),dfs(T,0); for(int i=1;i&lt;=n;++i) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2441 棘手的操作]]></title>
    <url>%2F2020%2F01%2F06%2FLoj-2441-%E6%A3%98%E6%89%8B%E7%9A%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[启发式合并. 对每个连通块,用一个 vector 维护块内所有点的编号,用一个可删堆维护块内所有权值,维护一个块加法标记 $tag$ . 用一个可删堆维护每个块的最大值中的最大值,维护一个全局加法标记 $Stag$ . 合并时直接用启发式合并,修改时先将对应的贡献在对应的可删堆中删掉,修改后再加回去. 时间复杂度 $O(n\log^2 n)$ ,但常数小,跑得还挺快的. 这样就可以搞到 Loj 上的代码最短了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int n,m,a[MAXN],bel[MAXN],tag[MAXN],Stag;struct Heap&#123; priority_queue&lt;int&gt; q1,q2; void insert(int x) &#123; q1.push(x); &#125; int top() &#123; while(!q2.empty() &amp;&amp; q1.top()==q2.top()) q1.pop(),q2.pop(); return q1.top(); &#125; void erase(int x) &#123; q2.push(x); &#125;&#125;s[MAXN],S;vector&lt;int&gt; id[MAXN];void U()&#123; int x=read(),y=read(); x=bel[x],y=bel[y]; if(x==y) return; if(id[x].size()&gt;id[y].size()) swap(x,y); S.erase(s[x].top()+tag[x]); S.erase(s[y].top()+tag[y]); for(int i:id[x]) &#123; id[y].push_back(i); bel[i]=y; a[i]+=tag[x]-tag[y]; s[y].insert(a[i]); &#125; S.insert(s[y].top()+tag[y]);&#125;void A1()&#123; int x=read(),v=read(); S.erase(s[bel[x]].top()+tag[bel[x]]); s[bel[x]].erase(a[x]); a[x]+=v; s[bel[x]].insert(a[x]); S.insert(s[bel[x]].top()+tag[bel[x]]);&#125;void A2()&#123; int x=read(),v=read(); S.erase(s[bel[x]].top()+tag[bel[x]]); tag[bel[x]]+=v; S.insert(s[bel[x]].top()+tag[bel[x]]);&#125;void A3()&#123; int v=read(); Stag+=v;&#125;int F1()&#123; int x=read(); return a[x]+tag[bel[x]]+Stag;&#125;int F2()&#123; int x=read(); return s[bel[x]].top()+tag[bel[x]]+Stag;&#125;int F3()&#123; return S.top()+Stag;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; bel[i]=i; a[i]=read(); id[i].push_back(i); s[i].insert(a[i]); S.insert(a[i]); &#125; m=read(); for(int i=1;i&lt;=m;++i) &#123; char buf[10]; scanf("%s",buf); if(buf[0]=='U') U(); else if(buf[0]=='A') &#123; if(buf[1]=='1') A1(); else if(buf[1]=='2') A2(); else A3(); &#125; else &#123; if(buf[1]=='1') printf("%d\n",F1()); else if(buf[1]=='2') printf("%d\n",F2()); else printf("%d\n",F3()); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2251 树状数组]]></title>
    <url>%2F2020%2F01%2F06%2FLoj-2251-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[树套树. 手玩一下可以发现,这种写法中, ${\rm Add}(x)$ 对 ${\rm Find}(y)$ 有贡献,当且仅当 $y\ge x$ . 于是 $\rm Add​$ 是单点修改, $\rm Find​$ 是查询后缀和. 记 $sum(l,r)$ 表示 $[l,r]$ 区间内所有数的异或和. 因为 $\rm Find$ 特判了 $l=0$ ,所以对于每次询问 ${\rm Query}(l,r) $ 要分情况讨论. 当 $l=1$ 时,答案正确需要满足 $sum(1,r)=sum(r,n)$ ,即 $sum(1,n)=sum(r)$ . 而 $sum(1,n)$ 已知,需要查询 $r$ 被修改次数为奇/偶的概率. 当 $l\neq 1$ 时,答案正确需要满足 $sum(l,r)=sum(l-1,n)\oplus sum(r,n)$ ,即 $sum(l-1)=sum(r)$ . 需要查询 $l-1,r$ 这两个位置修改总次数为偶数的概率. 因为每次修改时,区间内的两个位置不可能同时被修改,所以不能简单的维护每个位置被修改奇/偶次的概率. 而是需要对于每个点对 $(l,r)$ ,维护它们修改总次数为奇/偶次的概率. 每个点对是二维平面上的一个点,每次修改一个矩形内的点权,查询单点的权值,这可以用标记永久化的树套树维护. 查询 $r$ 被修改次数为奇/偶的概率可以看成是查询 $(0,r)$ 这个点对修改总次数为奇/偶的概率,就不用另外维护了. 时间复杂度 $O(n+m\log^2 n)$ ,空间复杂度 $O(n\log^2 n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=1e5+10;int n,m;int merge(int x,int y)&#123; return add(mul(x,P+1-y),mul(y,P+1-x));&#125;namespace In&#123; struct node &#123; int ls,rs,val; &#125;Tree[MAXN*200];#define root Tree[o] int idx=0; void upd(int &amp;o,int l,int r,int L,int R,int c) &#123; if(!o) o=++idx; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; root.val=merge(root.val,c); return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(root.ls,l,mid,L,R,c); if(R&gt;mid) upd(root.rs,mid+1,r,L,R,c); &#125; int query(int o,int l,int r,int y) &#123; if(!o) return 0; int res=root.val; if(l==r) return res; int mid=(l+r)&gt;&gt;1; if(y&lt;=mid) return merge(res,query(root.ls,l,mid,y)); else return merge(res,query(root.rs,mid+1,r,y)); &#125;&#125;namespace Out&#123; int rt[MAXN&lt;&lt;2]; void upd(int o,int l,int r,int Lx,int Rx,int Ly,int Ry,int c) &#123; if(Lx&lt;=l &amp;&amp; r&lt;=Rx) return In::upd(rt[o],0,n,Ly,Ry,c); int mid=(l+r)&gt;&gt;1; if(Lx&lt;=mid) upd(o&lt;&lt;1,l,mid,Lx,Rx,Ly,Ry,c); if(Rx&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,Lx,Rx,Ly,Ry,c); &#125; int query(int o,int l,int r,int x,int y) &#123; int res=In::query(rt[o],0,n,y); if(l==r) return res; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) return merge(res,query(o&lt;&lt;1,l,mid,x,y)); else return merge(res,query(o&lt;&lt;1|1,mid+1,r,x,y)); &#125;&#125;int main()&#123; n=read(),m=read(); int sum=0; for(int i=1;i&lt;=m;++i) &#123; int op=read(),l=read(),r=read(); if(op==1) &#123; int pr=fpow(r-l+1,P-2); Out::upd(1,0,n,l,r,l,r,mul(pr,2)); Out::upd(1,0,n,0,l-1,l,r,pr); if(r+1&lt;=n) Out::upd(1,0,n,l,r,r+1,n,pr); sum^=1; &#125; else &#123; if(l==1 &amp;&amp; sum==1) printf("%d\n",Out::query(1,0,n,0,r)); else printf("%d\n",add(1-Out::query(1,0,n,l-1,r),P)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>概率/期望</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2142 相逢是问候]]></title>
    <url>%2F2020%2F01%2F06%2FLoj-2142-%E7%9B%B8%E9%80%A2%E6%98%AF%E9%97%AE%E5%80%99%2F</url>
    <content type="text"><![CDATA[拓展欧拉定理 + 线段树. 拓展欧拉定理:当 $x&gt;\varphi(P)$ 时,有 $a^x\equiv a^{x\bmod \varphi(P)+\varphi(P)} \pmod P$ . 那么只需要对每个位置维护出 $a\bmod P,a\bmod \varphi(P),a\bmod \varphi(\varphi(P)),\dots$ ,就可以实现单点修改. 每次把 $P$ 变成 $\varphi(P)$ ,最多变 $O(\log P)$ 次就会变成 $1$ ,所以每个位置只用维护 $k=O(\log P)$ 个值. 当一个数被操作了 $k$ 次后,就出现了 $\bmod 1$ 的情况,由于可以依次递推出每一项的值,所以再修改,它的值也不会变. 用线段树来实现修改操作,修改一个区间时,若区间内所有数都不变时,直接返回,否则继续向下暴力递归. 每个位置最多被修改 $O(\log P)$ 次,每次修改需要修改 $O(\log P)$ 个值,每修改一个值需要 $O(\log P)$ 算一次快速幂. 所有快速幂的底数都是 $c$ ,而指数不超过 $10^8$ ,所以可以对每种模数预处理出 $c^i,c^{i\times 10^4}$ 的值,快速幂就变成 $O(1)$ 了. 时间复杂度 $O(n\log^2 P)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int add(int a,int b,int P)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b,int P)&#123; return 1LL * a * b % P;&#125;const int MAXN=5e4+10,K=30;int phi(int x)&#123; int res=x; for(int i=2;i*i&lt;=x;++i) if(x%i==0) &#123; while(x%i==0) x/=i; res/=i,res*=(i-1); &#125; if(x&gt;1) res/=x,res*=(x-1); return res;&#125;int n,m,k,c,a[MAXN],mod[K],f[MAXN][K];struct node&#123; int sum,cnt,key;&#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1]void pushup(int o)&#123; root.sum=add(lson.sum,rson.sum,mod[0]); root.key=lson.key+rson.key;&#125;void BuildTree(int o,int l,int r)&#123; if(l==r) &#123; root.sum=a[l]; root.cnt=0; root.key=1; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o);&#125;void upd(int o,int l,int r,int L,int R)&#123; if(L&lt;=l &amp;&amp; r&lt;=R &amp;&amp; !root.key) return; if(l==r) &#123; ++root.cnt; if(root.cnt==k) root.key=0; root.sum=f[l][root.cnt]; return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R); pushup(o);&#125;int query(int o,int l,int r,int L,int R)&#123; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; int mid=(l+r)&gt;&gt;1; int res=0; if(L&lt;=mid) res=add(res,query(o&lt;&lt;1,l,mid,L,R),mod[0]); if(R&gt;mid) res=add(res,query(o&lt;&lt;1|1,mid+1,r,L,R),mod[0]); return res;&#125;int pw1[MAXN][K],pw0[MAXN][K];int Pow(int x,int d)&#123; return mul(pw1[x/10000][d],pw0[x%10000][d],mod[d]);&#125;int calc(int x,int num,int d)&#123; if(!num) return x%mod[d]; int t=calc(x,num-1,d+1); if(log(1.0*mod[d+1]/x)/log(1.0*c)&lt;num) t+=mod[d+1]; return Pow(t,d);&#125;int main()&#123; n=read(),m=read(),mod[0]=read(),c=read(); k=0; while(mod[k]&gt;1) &#123; ++k; mod[k]=phi(mod[k-1]); &#125; mod[++k]=1; for(int d=0;d&lt;=k;++d) &#123; pw0[0][d]=1; for(int i=1;i&lt;=10000;++i) pw0[i][d]=mul(pw0[i-1][d],c,mod[d]); pw1[0][d]=1; int pc=pw0[10000][d]; for(int i=1;i&lt;=10000;++i) pw1[i][d]=mul(pw1[i-1][d],pc,mod[d]); &#125; for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); if(!a[i]) &#123; f[i][1]=1; for(int j=2;j&lt;=k;++j) f[i][j]=calc(1,j-1,0); &#125; else &#123; for(int j=1;j&lt;=k;++j) f[i][j]=calc(a[i],j,0); &#125; &#125; BuildTree(1,1,n); for(int i=1;i&lt;=m;++i) &#123; int op=read(),L=read(),R=read(); if(!op) upd(1,1,n,L,R); else printf("%d\n",query(1,1,n,L,R)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2116 开店]]></title>
    <url>%2F2020%2F01%2F05%2FLoj-2116-%E5%BC%80%E5%BA%97%2F</url>
    <content type="text"><![CDATA[树剖 + 主席树. 先不考虑年龄的限制,那么询问 $u$ 的答案就是$$ans=\sum_{v} dis(u,v) \\ans=\sum_v dist(u)+dist(v)-2\times dist(lca(u,v)) \\ans=n\times dist(u)+\sum_v dist(v) -2\times \sum_v dist(lca(u,v))$$其中 $dist(x)$ 表示 $x$ 到根节点的距离. 前两项容易算出,最后一项的求法是经典套路. 对每条边维护一个贡献值,对于每个 $v$ ,将 $v$ 到根路径上每条边的贡献加上它的长度. 那么 $\sum_v dist(lca(u,v))$ 就等于 $u$ 到根路径上每条边的贡献之和. 修改贡献和查询贡献可以利用差分实现,考虑年龄的限制,可以先把年龄离散化,然后用树剖 + 主席树来维护贡献. 由于要在主席树上实现区间加的操作,所以要用标记永久化. 时间复杂度 $O(n\log^2 n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1.5e5+10,M=2e7+10;int idx=0,ls[M],rs[M],tag[M],d[MAXN];ll sum[M];void upd(int lst,int &amp;x,int l,int r,int L,int R)&#123; int c=d[R]-d[L-1]; x=++idx; ls[x]=ls[lst],rs[x]=rs[lst],tag[x]=tag[lst],sum[x]=sum[lst]; if(l==L &amp;&amp; r==R) &#123; ++tag[x]; return; &#125; sum[x]+=c; int mid=(l+r)&gt;&gt;1; if(R&lt;=mid) upd(ls[lst],ls[x],l,mid,L,R); else if(L&gt;mid) upd(rs[lst],rs[x],mid+1,r,L,R); else &#123; upd(ls[lst],ls[x],l,mid,L,mid); upd(rs[lst],rs[x],mid+1,r,mid+1,R); &#125;&#125;ll query(int x,int l,int r,int L,int R)&#123; int c=d[R]-d[L-1]; ll res=1LL*c*tag[x]; if(l==L &amp;&amp; r==R) return res+sum[x]; int mid=(l+r)&gt;&gt;1; if(R&lt;=mid) res+=query(ls[x],l,mid,L,R); else if(L&gt;mid) res+=query(rs[x],mid+1,r,L,R); else &#123; res+=query(ls[x],l,mid,L,mid); res+=query(rs[x],mid+1,r,mid+1,R); &#125; return res;&#125;int n,m,A,a[MAXN],b[MAXN],len;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN&lt;&lt;1];void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;int dfnidx=0,dfn[MAXN],siz[MAXN],mxson[MAXN],top[MAXN];int fa[MAXN],dist[MAXN],dep[MAXN],sumtot[MAXN];ll sumdist[MAXN];void dfs1(int u,int F)&#123; sumdist[a[u]]+=dist[u],sumtot[a[u]]++; fa[u]=F,siz[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==F) continue; dep[v]=dep[u]+1; dist[v]=dist[u]+val[i]; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; top[u]=tp,dfn[u]=++dfnidx; d[dfn[u]]=dist[u]-dist[fa[u]]; if(mxson[u]) dfs2(mxson[u],tp); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v!=fa[u] &amp;&amp; v!=mxson[u]) dfs2(v,v); &#125;&#125;int p[MAXN],rt[MAXN];bool cmp(const int &amp;x,const int &amp;y)&#123; return a[x]&lt;a[y];&#125;int main()&#123; n=read(),m=read(),A=read(); for(int i=1;i&lt;=n;++i) a[i]=b[i]=read(); sort(b+1,b+1+n); len=unique(b+1,b+1+n)-b-1; for(int i=1;i&lt;=n;++i) a[i]=lower_bound(b+1,b+1+len,a[i])-b; for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; dfs1(1,0); dfs2(1,1); for(int i=2;i&lt;=len;++i) &#123; sumdist[i]+=sumdist[i-1]; sumtot[i]+=sumtot[i-1]; &#125; for(int i=2;i&lt;=n;++i) d[i]+=d[i-1]; for(int i=1;i&lt;=n;++i) p[i]=i; sort(p+1,p+1+n,cmp); for(int i=1,j=0;i&lt;=n;++i) &#123; int pos=a[p[i]]; rt[pos]=rt[pos-1]; while(j+1&lt;=n &amp;&amp; a[p[j+1]]==pos) &#123; ++j; int x=p[j]; while(x) &#123; int y=top[x]; upd(rt[pos],rt[pos],1,n,dfn[y],dfn[x]); x=fa[y]; &#125; &#125; i=j; &#125; ll ans=0; for(int i=1;i&lt;=m;++i) &#123; int x=read(),L=(read()+ans%A)%A,R=(read()+ans%A)%A; if(L&gt;R) swap(L,R); if(L&gt;b[len] || R&lt;b[1]) &#123; printf("%lld\n",ans=0); continue; &#125; L=lower_bound(b+1,b+1+len,L)-b; R=upper_bound(b+1,b+1+len,R)-b-1; ans=sumdist[R]-sumdist[L-1]+1LL*dist[x]*(sumtot[R]-sumtot[L-1]); ll tmp=0; while(x) &#123; int y=top[x]; tmp+=query(rt[R],1,n,dfn[y],dfn[x]); tmp-=query(rt[L-1],1,n,dfn[y],dfn[x]); x=fa[y]; &#125; printf("%lld\n",ans=ans-2*tmp); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>主席树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello 2020]]></title>
    <url>%2F2020%2F01%2F05%2FHello-2020%2F</url>
    <content type="text"><![CDATA[$Div.1+Div.2$ A New Year and Naming大概是天干地支纪年法?随便模一下就好了. code B New Year and Ascent Sequence用总数减掉不合法的,不合法的只能由两个单调不增的序列拼起来,且要求拼起来之后还是单调不增的. 记录一下单调不增的序列中,最后一个元素是 $i$ 的有多少个,求一个前缀和后再枚举前面那个序列就可以了. code C New Year and Permutation考虑一个长度为 $i$ 的值域连续段的贡献. 它可以选 $n-i+1$ 个数, $n-i+1$ 个位置,内部有 $i!$ 种排列方法,外部有 $(n-i)!$ 种排列方法,全部乘起来就好了. code D New Year and Conference考虑若两条 $a$ 的线段有交,那么为了尽可能让集合 $s$ 中的元素在 $b$ 中两两不相交,集合 $s$ 只会包含这两条线段. 即,只需要考虑大小为 $2$ 的集合 $s$ ,先处理所有在 $a$ 中有交的,检查它们在 $b$ 中是否有交,交换 $a,b$ 后再做一次. 处理在 $a$ 中有交时,将所有线段按照 $a_l$ 从小到大排序,依次加入. 加入一条线段 $i$ 时,前面所有 $a_{j,r}\ge a_{i,l}$ 的线段 $j$ 都与它在 $a$ 中相交,检查它们之中是否存在在 $b$ 中与 $i$ 不相交的. 只需要求出它们的 $\max l_b,\min r_b$ 进行判断,于是可以以 $a_{r}$ 为下标维护线段树进行修改与询问. E New Year and Castle Constructionbzoj 1914 是问覆盖住点 $p$ 的三角形数目,这道题是四边形,拿来改一改就成了. 枚举每个点 $p$ ,考虑计算 $f(p)$ ,把其他点按照 $p$ 为原点做一个极角排序,双指针扫一下即可. 比赛时用的 long double ,精度被卡了,没时间写全整数,有点难受.]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2050 树]]></title>
    <url>%2F2020%2F01%2F04%2FLoj-2050-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[主席树 + 倍增求 LCA. 显然不可能每次都老老实实栽一棵子树上去,我们每次只栽一个节点到大树中,代表这次栽的子树. 大树上每条边的边权就变成了儿子对应的根到父亲对应的根的距离,如图所示. 左边是大树的真实形态,红色的边是每次栽子树时加的边,黑色的边是模板树中原有的边. 右边是每次只栽一个节点上去得到的大树形态. 考虑如何在每次栽边后计算出右边新增加的边的权值. 记录下第 $i$ 次操作后,大树实际含有节点的总数 $s_i$ ,那么给出一个编号 $x$ 后,就可以二分出它是第几次被栽进来的. 若它是第 $i$ 次操作被栽进来的,那么 $k=x-s_{i-1}$ 就是它在第 $i$ 次被栽进来的所有点中,编号从小到大的位次. 即在模板树中,它是子树 $a_i$ 中所有节点编号的第 $k$ 小,用主席树可以查询出它在模板树中实际的编号. 对于每次操作,若栽在 $b$ 下面,就可以找出 $b$ 实际的编号,得到 $b$ 到那一次操作的 $a$ 的距离,再 $+1$ ,就是这次的边权. 询问 $(x,y)$ 时,尝试将它们跳到它们在大树上的 $lca$ ,跳的过程中累加跳过的距离. 先在右边的树上跳,若 $x,y$ 所属的代表节点没有祖先后代关系,当两者父亲相同时,说明已经被栽进了同一棵模板树. 此时将它们跳进模板树,再在模板树上询问两点的距离,加入答案. 若 $x,y$ 的代表节点有祖先后代关系,假定 $y$ 的代表是 $x$ 的代表的祖先,当 $x$ 跳到父亲是 $y$ 时,就可以跳进模板树了. 需要先预处理出父亲的倍增数组,加速跳的过程. 时间复杂度 $O(n\log n)$ . 其实这个结构与最后跳 $lca$ 的过程和圆方树有相似之处,对圆方树比较熟练的话应该不难写出. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10,K=17;int n,m,q;namespace TempTree&#123; int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1]; void addedge(int u,int v) &#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt; &#125; int dep[MAXN],fa[MAXN][K],dfnidx=0,idx,dfn[MAXN],siz[MAXN]; int rt[MAXN]; struct node &#123; int ls,rs,cnt; &#125;Tree[MAXN*20];#define root Tree[o] void upd(int &amp;o,int lst,int l,int r,int pos) &#123; o=++idx; root=Tree[lst]; ++root.cnt; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(root.ls,Tree[lst].ls,l,mid,pos); else upd(root.rs,Tree[lst].rs,mid+1,r,pos); &#125; int query(int L,int R,int l,int r,int k) &#123; if(l==r) return l; int mid=(l+r)&gt;&gt;1,tmp=Tree[Tree[R].ls].cnt-Tree[Tree[L].ls].cnt; if(tmp&gt;=k) return query(Tree[L].ls,Tree[R].ls,l,mid,k); else return query(Tree[L].rs,Tree[R].rs,mid+1,r,k-tmp); &#125; int FindNum(int x,int k) &#123; return query(rt[dfn[x]-1],rt[dfn[x]+siz[x]-1],1,n,k); &#125; int Dist(int x,int y) &#123; int res=dep[x]+dep[y]; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=K-1;i&gt;=0;--i) if((1&lt;&lt;i)&lt;=dep[x]-dep[y]) x=fa[x][i]; if(x==y) return res-2*dep[x]; for(int i=K-1;i&gt;=0;--i) if((1&lt;&lt;i)&lt;=dep[x] &amp;&amp; fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return res-2*dep[fa[x][0]]; &#125; void dfs(int u,int F) &#123; fa[u][0]=F; for(int i=1;(1&lt;&lt;i)&lt;=dep[u];++i) fa[u][i]=fa[fa[u][i-1]][i-1]; dfn[u]=++dfnidx,siz[u]=1; upd(rt[dfn[u]],rt[dfn[u]-1],1,n,u); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==F) continue; dep[v]=dep[u]+1; dfs(v,u); siz[u]+=siz[v]; &#125; &#125; void init() &#123; for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs(1,0); &#125;&#125;namespace BigTree&#123; ll s[MAXN],b[MAXN],dist[MAXN][K]; int fa[MAXN][K],dep[MAXN],a[MAXN],c[MAXN]; int FindTim(ll x,int cur) &#123; int L=1,R=cur-1,tim; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(s[mid]&gt;=x) R=mid-1,tim=mid; else L=mid+1; &#125; return tim; &#125; int FindNum(ll x,int tim) &#123; return TempTree::FindNum(a[tim],x-s[tim-1]); &#125; void Link(ll B,int x) &#123; int y=FindTim(B,x); fa[x][0]=y,dep[x]=dep[y]+1; int id=FindNum(B,y); c[x]=id; dist[x][0]=TempTree::Dist(id,a[y])+1; &#125; int jump(int x,int d) &#123; for(int i=K-1;i&gt;=0;--i) if((1&lt;&lt;i)&lt;=d) x=fa[x][i],d-=1&lt;&lt;i; return x; &#125; ll query(ll A,ll B) &#123; int x=FindTim(A,m+1),y=FindTim(B,m+1); int u=FindNum(A,x),v=FindNum(B,y); if(x==y) return TempTree::Dist(u,v); if(dep[x]&lt;dep[y]) swap(x,y),swap(A,B),swap(u,v); ll ans=0; if(jump(x,dep[x]-dep[y])==y) &#123; ans+=TempTree::Dist(a[x],u); for(int i=K-1;i&gt;=0;--i) if((1&lt;&lt;i)&lt;=dep[x]-dep[y]-1) ans+=dist[x][i],x=fa[x][i]; ans+=1; ans+=TempTree::Dist(c[x],v); return ans; &#125; ans+=TempTree::Dist(a[x],u)+TempTree::Dist(a[y],v); if(dep[x]&lt;dep[y]) swap(x,y); for(int i=K-1;i&gt;=0;--i) if((1&lt;&lt;i)&lt;=dep[x]-dep[y]) ans+=dist[x][i],x=fa[x][i]; for(int i=K-1;i&gt;=0;--i) if((1&lt;&lt;i)&lt;=dep[x] &amp;&amp; fa[x][i]!=fa[y][i]) &#123; ans+=dist[x][i],ans+=dist[y][i]; x=fa[x][i],y=fa[y][i]; &#125; ans+=2; ans+=TempTree::Dist(c[x],c[y]); return ans; &#125; void solve() &#123; ++m,s[1]=n,a[1]=1; for(int i=2;i&lt;=m;++i) &#123; a[i]=read(),b[i]=read(); s[i]=s[i-1]+TempTree::siz[a[i]]; Link(b[i],i); &#125; for(int i=1;i&lt;=K-1;++i) for(int x=1;x&lt;=m;++x) if((1&lt;&lt;i)&lt;=dep[x]) &#123; fa[x][i]=fa[fa[x][i-1]][i-1]; dist[x][i]=dist[x][i-1]+dist[fa[x][i-1]][i-1]; &#125; for(int i=1;i&lt;=q;++i) &#123; ll x=read(),y=read(); printf("%lld\n",query(x,y)); &#125; &#125;&#125;int main()&#123; n=read(),m=read(),q=read(); TempTree::init(); BigTree::solve(); return 0;&#125;]]></content>
      <tags>
        <tag>主席树</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2019 影魔]]></title>
    <url>%2F2020%2F01%2F04%2FLoj-2019-%E5%BD%B1%E9%AD%94%2F</url>
    <content type="text"><![CDATA[单调栈 + 二维数点. 对于一组端点 $(l,r)$ ,考虑将它们可能的贡献放到区间 $[l+1,r-1]$ 的最大值的那个位置去计算. 即,在每个位置 $i$ ,考虑它作为区间 $[l+1,r-1]$ 最大值时产生的 $p_1,p_2$ 的贡献. 利用单调栈求出 $i$ 左边第一个比它大的位置 $L$ ,右边第一个比它大的位置 $R$ . 由于 $i​$ 要是区间内的最大值,所以选择的左端点 $\ge L​$, 右端点 $\le R​$ . 当左右端点分别选择了 $L,R​$ 时,会造成 $p_1​$ 的贡献. 当左端点选了 $L$ ,右端点在 $[i+1,R-1]$ 中时,或左端点在 $[L+1,i-1]$ 中,右端点选了 $R$ ,都会有 $p_2$ 的贡献. 而我们的询问是限制了左右端点的取值范围,相当于在平面上询问一个矩形内贡献之和. 每个 $i$ 的贡献是一个单点 $(L,R)$ ,以及两条线段 $(L,i+1\sim R-1),(L+1\sim i-1,R)$ . 将操作全部离线下来,用线段树在平面上二维数点即可,可以分别计算横的线段和竖的线段的贡献. 最后还要加上两个端点是相邻的情况造成的若干 $p_1$ 贡献. 时间复杂度 $O(n\log n)$ . 开始判 $R\neq n+1$ 的时候写成 $R\neq n-1​$ 了,居然还过了 80 分,调了好久. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;struct SegTree&#123; struct node &#123; int len; ll tag,sum; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.sum=lson.sum+rson.sum; &#125; void BuildTree(int o,int l,int r) &#123; root.sum=root.tag=0; root.len=r-l+1; if(l==r) return; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); &#125; void modify(int o,ll c) &#123; root.tag+=c; root.sum+=c*root.len; &#125; void pushdown(int o) &#123; if(root.tag) &#123; modify(o&lt;&lt;1,root.tag); modify(o&lt;&lt;1|1,root.tag); root.tag=0; &#125; &#125; void upd(int o,int l,int r,int L,int R,ll c) &#123; if(L&gt;r || R&lt;l) return; if(L&lt;=l &amp;&amp; r&lt;=R) return modify(o,c); int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125; ll query(int o,int l,int r,int L,int R) &#123; if(L&gt;r || R&lt;l) return 0; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; int mid=(l+r)&gt;&gt;1; pushdown(o); ll res=0; if(L&lt;=mid) res+=query(o&lt;&lt;1,l,mid,L,R); if(R&gt;mid) res+=query(o&lt;&lt;1|1,mid+1,r,L,R); return res; &#125;&#125;T;int n,m,p1,p2,a[MAXN],cnt=0;ll ans[MAXN&lt;&lt;1];struct Query&#123; int pos,c,l,r,id; Query(int pos=0,int c=0,int l=0,int r=0,int id=0):pos(pos),c(c),l(l),r(r),id(id) &#123;&#125; bool operator &lt; (const Query &amp;rhs) const &#123; return pos==rhs.pos?id&lt;rhs.id:pos&lt;rhs.pos; &#125;&#125;q[MAXN&lt;&lt;2];int stk[MAXN],tp,L[MAXN&lt;&lt;1],R[MAXN&lt;&lt;1];void init()&#123; a[0]=a[n+1]=n+1; stk[tp=1]=0; for(int i=1;i&lt;=n;++i) &#123; while(a[i]&gt;a[stk[tp]]) --tp; L[i]=stk[tp]; stk[++tp]=i; &#125; stk[tp=1]=n+1; for(int i=n;i&gt;=1;--i) &#123; while(a[i]&gt;a[stk[tp]]) --tp; R[i]=stk[tp]; stk[++tp]=i; &#125;&#125;void solve_x()&#123; cnt=0; for(int i=1;i&lt;=n;++i) &#123; if(L[i]) &#123; if(R[i]!=n+1) q[++cnt]=Query(L[i],p1,R[i],R[i],0); // (L,R) if(i+1&lt;=R[i]-1) q[++cnt]=Query(L[i],p2,i+1,R[i]-1,0); // (L,i+1 ~ R-1) &#125; &#125; for(int i=1;i&lt;=m;++i) &#123; q[++cnt]=Query(n,-1,1,R[i+n],i); if(L[i+n]-1) q[++cnt]=Query(L[i+n]-1,-1,1,R[i+n],i+m); &#125; sort(q+1,q+1+cnt); T.BuildTree(1,1,n); for(int i=1;i&lt;=cnt;++i) &#123; if(q[i].id==0) // update T.upd(1,1,n,q[i].l,q[i].r,q[i].c); else // query ans[q[i].id]+=T.query(1,1,n,q[i].l,q[i].r); &#125;&#125;void solve_y()&#123; cnt=0; for(int i=1;i&lt;=n;++i) &#123; if(R[i]!=n+1 &amp;&amp; L[i]+1&lt;=i-1) q[++cnt]=Query(R[i],p2,L[i]+1,i-1,0); // (L+1 ~ i-1 ,R) &#125; for(int i=1;i&lt;=m;++i) q[++cnt]=Query(R[i+n],-1,L[i+n],n,i); sort(q+1,q+1+cnt); T.BuildTree(1,1,n); for(int i=1;i&lt;=cnt;++i) &#123; if(q[i].id==0) // update T.upd(1,1,n,q[i].l,q[i].r,q[i].c); else // query ans[q[i].id]+=T.query(1,1,n,q[i].l,q[i].r); &#125;&#125;int main()&#123; n=read(),m=read(),p1=read(),p2=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); init(); for(int i=1;i&lt;=m;++i) L[i+n]=read(),R[i+n]=read(); solve_x(); solve_y(); for(int i=1;i&lt;=m;++i) printf("%lld\n",ans[i]+1LL*p1*(R[i+n]-L[i+n])-ans[i+m]); return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>离线</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2018 单旋]]></title>
    <url>%2F2020%2F01%2F04%2FLoj-2018-%E5%8D%95%E6%97%8B%2F</url>
    <content type="text"><![CDATA[LCT. 先考虑插入操作,经过观察容易发现,一个点被插入后,要么成为它前驱的右儿子,要么成为它后继的左儿子. 且这两个位置中恰有一个位置是空的,所以插入时在 set 中询问一下前驱后继即可. 考虑旋转操作,经过观察容易发现,如果把最小值转到根,就是先把它的右子树接在它的父亲上,再让它成为根的父亲. 旋转最大值也差不多,把它的左子树接在它的父亲上,再让它成为根的父亲. 如果接下来要将它删除,就不用从根向它连边. 而其他部分的形态是不变的,于是每次操作只会连/断 $O(1)$ 条边,可以用 LCT 来实现这些操作. 即,用一棵 LCT 维护这棵树的形态,另开数组记录每个节点在原树中的左右儿子以及父亲,并记录原树当前的根. 每次要询问一个点的深度时,就在 LCT 上询问它与根的距离即可. 可以先将所有权值离散化,然后将每个节点的权值当做它的标号. 时间复杂度 $O(m\log m)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;struct LCT&#123; struct node &#123; int fa,ch[2],rev,siz; node()&#123;fa=ch[0]=ch[1]=rev=0,siz=1;&#125; &#125;Tree[MAXN];#define root Tree[x]#define lson Tree[root.ch[0]]#define rson Tree[root.ch[1]] void pushup(int x) &#123; root.siz=lson.siz+rson.siz+1; &#125; bool isroot(int x) &#123; return Tree[root.fa].ch[0]!=x &amp;&amp; Tree[root.fa].ch[1]!=x; &#125; void rotate(int x) &#123; int y=Tree[x].fa,z=Tree[y].fa; if(!isroot(y)) Tree[z].ch[Tree[z].ch[1]==y]=x; Tree[x].fa=z; int k=Tree[y].ch[1]==x; Tree[y].ch[k]=Tree[x].ch[k^1]; Tree[Tree[x].ch[k^1]].fa=y; Tree[x].ch[k^1]=y; Tree[y].fa=x; pushup(y); &#125; int stk[MAXN],tp; void inverse(int x) &#123; swap(root.ch[0],root.ch[1]); root.rev^=1; &#125; void pushdown(int x) &#123; if(root.rev) &#123; if(root.ch[0]) inverse(root.ch[0]); if(root.ch[1]) inverse(root.ch[1]); root.rev=0; &#125; &#125; void Splay(int x) &#123; stk[++tp]=x; for(int pos=x;!isroot(pos);pos=Tree[pos].fa) stk[++tp]=Tree[pos].fa; while(tp) pushdown(stk[tp--]); while(!isroot(x)) &#123; int y=Tree[x].fa,z=Tree[y].fa; if(!isroot(y)) (Tree[y].ch[1]==x)^(Tree[z].ch[1]==y)?rotate(x):rotate(y); rotate(x); &#125; pushup(x); &#125; void Access(int x) &#123; for(int y=0;x;y=x,x=Tree[x].fa) &#123; Splay(x); Tree[x].ch[1]=y; pushup(x); &#125; &#125; void makeroot(int x) &#123; Access(x); Splay(x); inverse(x); &#125; void split(int x,int y) &#123; makeroot(x); Access(y); Splay(y); &#125; void link(int x,int y) &#123; if(!x || !y) return; makeroot(x); Tree[x].fa=y; &#125; void cut(int x,int y) &#123; if(!x || !y) return; split(x,y); Tree[x].fa=Tree[y].ch[0]=0; pushup(y); &#125; int query(int x,int y) &#123; split(x,y); return Tree[y].siz; &#125; LCT()&#123;tp=Tree[0].siz=0;&#125; &#125;T;int n=0,m,tp[MAXN],val[MAXN],key[MAXN];int rt,fa[MAXN],ch[MAXN][2];set&lt;int&gt; s;set&lt;int&gt;::iterator it;int main()&#123; m=read(); for(int i=1;i&lt;=m;++i) &#123; tp[i]=read(); if(tp[i]==1) val[++n]=key[i]=read(); &#125; sort(val+1,val+1+n); for(int i=1;i&lt;=m;++i) if(tp[i]==1) key[i]=lower_bound(val+1,val+1+n,key[i])-val; for(int i=1;i&lt;=m;++i) &#123; int ans; if(tp[i]==1) &#123; int x=key[i]; if(s.empty()) rt=x,ans=1; else &#123; it=s.lower_bound(x); int r=(it==s.end())?0:*it; int l=(it==s.begin())?0:*(--it); if(l &amp;&amp; !ch[l][1]) &#123; ch[l][1]=x; fa[x]=l; T.link(l,x); &#125; else &#123; ch[r][0]=x; fa[x]=r; T.link(r,x); &#125; ans=T.query(x,rt); &#125; s.insert(x); &#125; else if(tp[i]==2 || tp[i]==4) &#123; int x=*s.begin(); ans=T.query(x,rt); int y=ch[x][1]; T.cut(x,y); T.cut(x,fa[x]); T.link(fa[x],y); fa[y]=fa[x],ch[fa[x]][0]=y,fa[x]=0; if(x==rt) rt=y; if(tp[i]==2) &#123; if(x!=rt) &#123; fa[rt]=x; ch[x][1]=rt; T.link(x,rt); rt=x; &#125; &#125; else s.erase(x); &#125; else &#123; int x=*s.rbegin(); ans=T.query(x,rt); int y=ch[x][0]; T.cut(x,y); T.cut(x,fa[x]); T.link(fa[x],y); fa[y]=fa[x],ch[fa[x]][1]=y,fa[x]=0; if(x==rt) rt=y; if(tp[i]==3) &#123; if(x!=rt) &#123; fa[rt]=x; ch[x][0]=rt; T.link(x,rt); rt=x; &#125; &#125; else s.erase(x); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20200103]]></title>
    <url>%2F2020%2F01%2F03%2Ftest20200103%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>STL</tag>
        <tag>多项式</tag>
        <tag>网络流</tag>
        <tag>位运算</tag>
        <tag>test</tag>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2004 硬币游戏]]></title>
    <url>%2F2020%2F01%2F02%2FLoj-2004-%E7%A1%AC%E5%B8%81%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[字符串 hash + 高斯消元. 设第 $i$ 个串的答案为 $P(i)$ ,如果直接对于 AC 自动机上每个节点列出方程高斯消元,复杂度 $O((nm)^3)$ ,过不去. 由于只需要求出 $n$ 个终止节点的 $P(i)​$ ,可以尝试优化,减少方程的个数. 只需要求出向后匹配 $m$ 个字符,想匹配 $s_i$ ,却提前匹配到 $s_j​$ 的贡献. 这要求 $s_j$ 长度为 $m$ 的后缀与 $s_i$ 长度为 $m$ 的前缀相同,用字符串 hash 判断,于是 AC 自动机也可以省掉了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=315;typedef unsigned long long ull;const ull Base=137;ull Hash[MAXN][MAXN],pw[MAXN];ull calc(int x,int l,int r)&#123; return Hash[x][r]-Hash[x][l-1]*pw[r-l+1];&#125;double bin[MAXN],a[MAXN][MAXN];void Gauss(int n)&#123; for(int i=1;i&lt;=n;++i) &#123; for(int j=i+1;j&lt;=n;++j) if(fabs(a[j][i])&gt;fabs(a[i][i])) swap(a[i][i],a[j][i]); for(int j=i+1;j&lt;=n;++j) &#123; double tmp=a[j][i]/a[i][i]; for(int k=i;k&lt;=n+1;++k) a[j][k]-=a[i][k]*tmp; &#125; &#125; for(int i=n;i&gt;=1;--i) &#123; a[i][n+1]/=a[i][i]; for(int j=i-1;j&gt;=1;--j) a[j][n+1]-=a[j][i]*a[i][n+1]; &#125;&#125;int n,m;char buf[MAXN];int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; scanf("%s",buf+1); for(int j=1;j&lt;=m;++j) Hash[i][j]=Hash[i][j-1]*Base+buf[j]-'A'; &#125; bin[0]=1.0; pw[0]=1; for(int i=1;i&lt;=m;++i) bin[i]=bin[i-1]*0.5,pw[i]=pw[i-1]*Base; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) for(int k=1;k&lt;=m;++k) if(calc(i,1,k)==calc(j,m-k+1,m)) a[i][j]+=bin[m-k]; for(int i=1;i&lt;=n;++i) &#123; a[i][n+1]-=bin[m]; a[n+1][i]=1; &#125; a[n+1][n+2]=1; Gauss(n+1); for(int i=1;i&lt;=n;++i) printf("%.10lf\n",a[i][n+2]); return 0;&#125;]]></content>
      <tags>
        <tag>概率/期望</tag>
        <tag>hash</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2461 完美的队列]]></title>
    <url>%2F2020%2F01%2F02%2FLoj-2461-%E5%AE%8C%E7%BE%8E%E7%9A%84%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[分块 + two pointer. 一个数被加入到队列 $i$ 中后,队列 $i$ 再进行 $a_i$ 次 push 操作,这个数就会被 pop 出来. 考虑对于每次操作 $j$ ,求出一个 $ed(j)$ ,表示在进行了 $(j,ed(j)]$ 内的操作后,操作 $j$ 加入的每个 $x$ 都被 pop 出来了. 对于同一个 $x$ ,将 $(j,ed(j)]$ 这些区间取并,就可以得到这个 $x$ 对每次询问的贡献,那么只需要设法求出每个 $ed(j)$ . 将序列每 $\sqrt n$ 个元素分成一块,对于每次操作 $(l_j,r_j,x_j)$ ,分别考虑整块部分的 $i$ 和边角部分的 $i$ 对 $ed(j)$ 的贡献. 枚举每个整块,对于包含了这一块的所有 $j$ ,每个该块中的 $x_j$ 被完全弹出的时间是递增的,可以用 two pointer 处理. 记录两个指针 $j,k$ ,表示当前考虑了操作 $(j,k]$ 带来的影响. 设 $b(i)$ 表示第 $i$ 个队列再被 push $b(i)$ 次, $x_j$ 就会被弹出,记录一个 $cov$ 表示这一块被整体 pop 了 $cov$ 次. $k$ 增大,加入一个操作时,若它完整覆盖了该块, $cov$ 增加 $1$ ,否则,将这次操作与这一块的交集部分的 $b(i)$ 都减少 $1$ . $b(i)$ 初始都为对应的 $a(i)$ ,维护一个 $mx=\max b(i)$ ,当 $mx\le cov$ 时,说明已被完全弹出, $k$ 可以去更新 $ed(j)$ . $j$ 增大,撤销一个操作时,维护方法类似,将 $cov$ 减少 $1$ ,或将交集部分的 $b(i)$ 都增加 $1$ . 每次修改 $cov$ 是 $O(1)$ 的,修改交集部分的 $b(i)$ 是 $O(\sqrt n)$ 的. 每个操作最多完全覆盖 $O(\sqrt n)$ 个整块,最多与 $2$ 个整块有交集,但未完全覆盖,于是这部分时间复杂度为 $O(m\sqrt n)$ . 再来考虑边角部分的贡献,需要在处理整块贡献的同时维护出一些信息. 设 $s(i)$ 表示前 $i$ 次操作完全覆盖了当前块 $s(i)$ 次. 设 $c(i)$ 表示第 $i$ 个完全覆盖当前块的操作编号. 设 $d(i)$ 表示第 $i$ 个与当前块有交集,但未完全覆盖的操作编号. 设 $e(i)$ 表示第 $e(i)$ 次操作结束后,恰好完全覆盖了该块 $i$ 次. 枚举块内每个位置 $i​$ ,考虑它作为边角部分被覆盖的贡献. 用 two pointer 维护两个指针 $j,k$ ,表示当前考虑了操作 $(d(j),d(k)]$ 的影响,并维护 $mx$ 表示 $i$ 被覆盖的次数. 向后跳时,整块覆盖的次数可以由前缀和 $s$ 算出,交集部分覆盖的次数可以直接由 $d$ 存储的操作编号判断. 当 $mx\le 0$ 时,说明位置 $i$ 上的 $x_j$ 已经被 pop 出去了,此时可以更新答案. 若 $mx=0$ ,说明恰好是由操作 $d(k)$ 弹出去的,否则是 $d(k)$ 之前整块操作弹出的,用维护的 $c,e$ 数组可以找出答案. 设第 $i$ 块的数组 $d$ 大小为 $t_i$ ,则这部分的时间复杂度为 $O(\sum \sqrt n\cdot t_i)=O(\sqrt n\cdot \sum t_i)=O(m\sqrt n)$ . 于是整个算法的时间复杂度为 $O(m\sqrt n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;void upd(int &amp;x,const int &amp;y)&#123; x=max(x,y);&#125;const int MAXN=2e5+10;int n,m,a[MAXN],b[MAXN],c[MAXN],cn,d[MAXN],dn,e[MAXN],s[MAXN];int B,lp[MAXN],rp[MAXN],bel[MAXN];int l[MAXN],r[MAXN],x[MAXN],ed[MAXN],ans[MAXN];vector&lt;pair&lt;int,int&gt; &gt; vec[MAXN];int main()&#123; n=read(),m=read(); B=sqrt(n); for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); bel[i]=(i-1)/B+1; lp[bel[i]]=(bel[i]-1)*B+1; rp[bel[i]]=bel[i]*B; &#125; rp[bel[n]]=n; for(int i=1;i&lt;=m;++i) &#123; l[i]=read(); r[i]=read(); x[i]=read(); &#125; for(int id=1;id&lt;=bel[n];++id) &#123; int L=lp[id],R=rp[id],cov=0,mx=0; for(int i=L;i&lt;=R;++i) upd(mx,b[i]=a[i]); cn=dn=0; for(int j=1,k=0;j&lt;=m;++j) &#123; if(l[j]&lt;=L &amp;&amp; R&lt;=r[j]) --cov; else if(l[j]&lt;=R &amp;&amp; r[j]&gt;=L) &#123; int li=max(L,l[j]),ri=min(R,r[j]); for(int i=li;i&lt;=ri;++i) --b[i]; mx=0; for(int i=L;i&lt;=R;++i) upd(mx,b[i]); &#125; while(k&lt;=m &amp;&amp; mx&gt;cov) &#123; ++k; if(l[k]&lt;=L &amp;&amp; R&lt;=r[k]) ++cov; else if(l[k]&lt;=R &amp;&amp; r[k]&gt;=L) &#123; int li=max(L,l[k]),ri=min(R,r[k]); for(int i=li;i&lt;=ri;++i) --b[i]; mx=0; for(int i=L;i&lt;=R;++i) upd(mx,b[i]); &#125; &#125; s[j]=s[j-1]; if(l[j]&lt;=L &amp;&amp; R&lt;=r[j]) upd(ed[j],k),s[c[++cn]=j]++; else if(l[j]&lt;=R &amp;&amp; r[j]&gt;=L) d[++dn]=j,e[dn]=cn; &#125; for(int i=L;i&lt;=R;++i) &#123; mx=a[i]; for(int j=1,k=0;j&lt;=dn;++j) &#123; mx+=s[d[j]]-s[d[j-1]]; if(l[d[j]]&lt;=i &amp;&amp; i&lt;=r[d[j]]) &#123; ++mx; while(k&lt;dn &amp;&amp; mx&gt;0) &#123; ++k; mx-=s[d[k]]-s[d[k-1]]; mx-=(l[d[k]]&lt;=i &amp;&amp; i&lt;=r[d[k]]); &#125; if(mx&gt;0) &#123; if(mx&gt;s[m]-s[d[k]]) ed[d[j]]=m+1; else upd(ed[d[j]],c[e[k]+mx]); &#125; else &#123; if(l[d[k]]&lt;=i &amp;&amp; i&lt;=r[d[k]]) upd(ed[d[j]],mx&lt;0?c[e[k]+mx+1]:d[k]); else upd(ed[d[j]],c[e[k]+mx]); &#125; &#125; &#125; &#125; &#125; for(int i=1;i&lt;=m;++i) &#123; vec[x[i]].push_back(make_pair(i,1)); vec[x[i]].push_back(make_pair(ed[i],-1)); &#125; for(int i=1;i&lt;=100000;++i) &#123; sort(vec[i].begin(),vec[i].end()); int tmp=0,siz=vec[i].size(); for(int j=0;j&lt;siz;++j) &#123; int cur=tmp; tmp+=vec[i][j].second; for(int k=j+1;k&lt;siz &amp;&amp; vec[i][k].first==vec[i][j].first;++k) tmp+=vec[i][k].second,j=k; if(cur==0 &amp;&amp; tmp&gt;0) ++ans[vec[i][j].first]; else if(cur&gt;0 &amp;&amp; tmp==0) --ans[vec[i][j].first]; &#125; &#125; for(int i=1;i&lt;=m;++i) printf("%d\n",ans[i]+=ans[i-1]); return 0;&#125;]]></content>
      <tags>
        <tag>分块</tag>
        <tag>two pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2845 Innophone]]></title>
    <url>%2F2020%2F01%2F01%2FLoj-2845-Innophone%2F</url>
    <content type="text"><![CDATA[分块 + 斜率优化. 选择的 $a$ 一定是某个出现过的 $x$ ,或者 $a$ 大于所有的 $x$ . 否则将 $a$ 增大到下个出现过的 $x$ ,答案不会变劣, $b$ 的选择同理. 于是可以从小到大枚举 $a​$ ,只需要考虑 $b​$ 的选择对 $x&lt;a​$ 的点贡献的影响. 将所有 $x&lt;a$ 的点按照 $y​$ 从小到大排序. 若共有 $cnt$ 个点的 $x&lt;a$ ,那么选择第 $i$ 个点的 $y$ 作为 $b$ ,带来的贡献是 $v_i=(cnt-i+1)\cdot y_i$ . 随着 $a$ 的增大, $x&lt;a$ 的点会不断增多,每加入一个新点,它后面的点 $v_i$ 不变,前面的点的 $v_i$ 会加上 $y_i$ . 如果直接用平衡树打标记,修改后没法得到区间内新的 $\max v_i​$ ,考虑分块来处理. 若某一块整体被加了 $tag$ 次,那么块内真正的贡献为 $v_i’=tag\cdot y_i+v_i$ ,变形得到 $v_i=-tag\cdot y_i+v_i’$ . 即用一条斜率为 $-tag​$ 的直线去截块内所有点,要最大化截距,于是可以维护出块内所有点的上凸壳. 斜率只会变小,被截到的点只会往右侧移动,那么不用在凸壳上二分,记录一下当前被截到的是哪个点即可. 先算出所有点都被插入时,每个点分别在哪一块,插入时直接插到那一块中即可. 插入点时,重构一下插入的那一块的上凸壳,修改前面所有非空块的 $tag​$ ,并重新计算它们的贡献. 时间复杂度 $O(n\log n+n\sqrt n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1.5e5+10,S=400;struct v2&#123; ll x,y; int id; v2 operator - (const v2 &amp;rhs) const &#123; return (v2)&#123;x-rhs.x,y-rhs.y&#125;; &#125; ll operator * (const v2 &amp;rhs) const &#123; return x*rhs.y-y*rhs.x; &#125;&#125;p[MAXN],q[MAXN],pt[MAXN];bool cmpy(const v2 &amp;A,const v2 &amp;B)&#123; return A.y&lt;B.y;&#125;bool cmpx(const v2 &amp;A,const v2 &amp;B)&#123; return A.x&lt;B.x;&#125;int n,B,bel[MAXN],vis[MAXN];struct Block&#123; int lp,rp,cnt,tag,tp,pos; ll res; v2 stk[S]; Block()&#123;cnt=tag=res=0;&#125; ll calc(v2 cur) &#123; return cur.x*tag+cur.y; &#125; void ReBuild(int x) &#123; if(tag) &#123; for(int i=lp;i&lt;=rp;++i) if(vis[i]) pt[i].y+=pt[i].x*tag; tag=0; &#125; for(int i=lp;i&lt;x;++i) if(vis[i]) pt[i].y+=pt[i].x; vis[x]=1,++cnt; tp=0; for(int i=lp;i&lt;=rp;++i) if(vis[i]) &#123; if(tp &amp;&amp; pt[i].x==stk[tp].x &amp;&amp; pt[i].y&lt;=stk[tp].y) continue; while(tp&gt;=2 &amp;&amp; (pt[i]-stk[tp-1])*(stk[tp]-stk[tp-1])&lt;=0) --tp; stk[++tp]=pt[i]; &#125; pos=1; while(pos+1&lt;=tp &amp;&amp; calc(stk[pos])&lt;calc(stk[pos+1])) ++pos; res=calc(stk[pos]); &#125; void upd() &#123; if(!cnt) return; tag++; while(pos+1&lt;=tp &amp;&amp; calc(stk[pos])&lt;calc(stk[pos+1])) ++pos; res=calc(stk[pos]); &#125;&#125;block[S];void ins(int x)&#123; pt[x].x=pt[x].y=p[x].y; for(int i=x+1;i&lt;=block[bel[x]].rp;++i) if(vis[i]) pt[x].y+=pt[x].x; for(int i=bel[x]+1;i&lt;=bel[n];++i) pt[x].y+=pt[x].x*block[i].cnt; block[bel[x]].ReBuild(x); for(int i=1;i&lt;bel[x];++i) block[i].upd();&#125;ll query()&#123; ll res=0; for(int i=1;i&lt;=bel[n];++i) res=max(res,block[i].res); return res;&#125;int main()&#123; n=read(); B=sqrt(n); for(int i=1;i&lt;=n;++i) &#123; p[i].x=read(),p[i].y=read(); bel[i]=(i-1)/B+1; block[bel[i]].lp=(bel[i]-1)*B+1; block[bel[i]].rp=bel[i]*B; &#125; block[bel[n]].rp=n; sort(p+1,p+1+n,cmpy); for(int i=1;i&lt;=n;++i) p[i].id=i,q[i]=p[i]; sort(q+1,q+1+n,cmpx); ll ans=q[1].x*n; for(int i=1,j=0;i&lt;=n;++i) &#123; while(j+1&lt;=n &amp;&amp; q[j+1].x==q[i].x) ins(q[++j].id); i=j; ans=max(ans,q[i+1].x*(n-i)+query()); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>分块</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6499 颜色]]></title>
    <url>%2F2020%2F01%2F01%2FLoj-6499-%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[分块 + bitset + ST 表. 对序列分块,用 bitset 来合并这些区间. 每一块开一个 bitset ,每次合并两个块需要 $O(\frac n w)$ 的时间,比边角部分的暴力处理劣,需要优化. 数字种类是可重复贡献的,可以用 ST 表来快速合并多个块,即设 $f(i,j)$ 表示 $[i,i+2^j-1]$ 这些块合并后的 bitset . 记块大小为 $S$ ,预处理 ST 表的时间复杂度为 $O(\frac{n^2}{Sw}\log \frac{n}{S})$ ,单次询问的时间复杂度为 $O(S+\frac{n}{w})$ . 空间复杂度为 $O(\frac{n^2}{Sw} \log \frac n S)$ . 时间和空间限制都比较紧,可以手写 bitset ,并把 $S$ 设置得稍大一点. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10,S=1400,T=73,K=9;int n,m,p,a[MAXN],b[MAXN],cnt;struct Bitset&#123; unsigned int s[MAXN/32+2]; void set(unsigned int x) &#123; s[x&gt;&gt;5]|=1u&lt;&lt;(x&amp;31); &#125; int count() &#123; int ans=0; for(int i=0;i&lt;=cnt;++i) ans+=__builtin_popcount(s[i]); return ans; &#125; void clear() &#123; memset(s,0,sizeof s); &#125;&#125;f[T][K],ans,tmp;Bitset merge(const Bitset &amp;A,const Bitset &amp;B)&#123; for(int i=0;i&lt;=cnt;++i) tmp.s[i]=A.s[i]|B.s[i]; return tmp;&#125;int Log[T],tot,bel[MAXN],lp[T],rp[T],lastans=-1;void init()&#123; for(int i=1;i&lt;=n;++i) &#123; bel[i]=(i-1)/S+1; lp[bel[i]]=(bel[i]-1)*S+1; rp[bel[i]]=bel[i]*S; f[bel[i]][0].set(a[i]); &#125; rp[bel[n]]=n,tot=bel[n]; Log[1]=0; for(int i=2;i&lt;=tot;++i) Log[i]=Log[i&gt;&gt;1]+1; for(int j=1;j&lt;=Log[tot];++j) for(int i=1;i+(1&lt;&lt;j)-1&lt;=tot;++i) f[i][j]=merge(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]);&#125;void query(int L,int R)&#123; if(bel[L]+1&gt;bel[R]-1) &#123; for(int i=L;i&lt;=R;++i) ans.set(a[i]); &#125; else &#123; for(int i=L;i&lt;=rp[bel[L]];++i) ans.set(a[i]); int l=bel[L]+1,r=bel[R]-1,k=Log[r-l+1]; ans=merge(ans,f[l][k]); ans=merge(ans,f[r-(1&lt;&lt;k)+1][k]); for(int i=lp[bel[R]];i&lt;=R;++i) ans.set(a[i]); &#125;&#125;int main()&#123; n=read(),m=read(),p=read(); for(int i=1;i&lt;=n;++i) a[i]=b[i]=read(); sort(b+1,b+1+n); cnt=unique(b+1,b+1+n)-b-1; for(int i=1;i&lt;=n;++i) a[i]=lower_bound(b+1,b+1+cnt,a[i])-b-1; cnt=(cnt-1)&gt;&gt;5; init(); for(int i=1;i&lt;=m;++i) &#123; ans.clear(); int k=read(); for(int j=1;j&lt;=k;++j) &#123; int L=read(),R=read(); if(p &amp;&amp; lastans!=-1) &#123; L=(L^lastans)%n+1; R=(R^lastans)%n+1; if(L&gt;R) swap(L,R); &#125; query(L,R); &#125; printf("%d\n",lastans=ans.count()); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>分块</tag>
        <tag>bitset</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2957 楼房重建]]></title>
    <url>%2F2019%2F12%2F30%2Fbzoj-2957-%E6%A5%BC%E6%88%BF%E9%87%8D%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[分块. 简单转化一下题意,就是求有多少个位置的斜率,在对应前缀中是严格最大的. 每一块维护 $len(x)$ 表示若第一个选中的是块内第 $x​$ 个元素,则该块内总共被选的个数. 为了找出块内是哪个元素被选中,还要对每一块维护前 $x​$ 个数中的最大值 $mx(x)​$ . 修改时将那一块重构一下,回答询问时从第一块开始跳,二分找出下一块中第一个选中的位置. 每跳一块,当前的数就会和块内的最大值取 $\max$ . 设块的大小为 $S$ ,则单次操作的时间复杂度为 $O(S+\frac{n}{S}\cdot\log_2 S)$ ,需要手动调下参数. 为了避免精度出现问题,可以把分子分母记下来,每次比较的时候比较两个分数. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10,S=1024;int n,m,B,bel[MAXN];int lp[S],rp[S],cnt[S][S];double k[MAXN],mx[S][S];void ReBuild(int x)&#123; int tot=0; double cur=0; for(int i=lp[x];i&lt;=rp[x];++i) &#123; cnt[x][i-lp[x]+1]=tot; if(k[i]&gt;cur) cur=k[i],++tot; mx[x][i-lp[x]+1]=cur; &#125; for(int i=lp[x];i&lt;=rp[x];++i) cnt[x][i-lp[x]+1]=tot-cnt[x][i-lp[x]+1];&#125;int main()&#123; n=read(),m=read(); B=1000; for(int i=1;i&lt;=n;++i) &#123; bel[i]=(i-1)/B+1; lp[bel[i]]=(bel[i]-1)*B+1; rp[bel[i]]=bel[i]*B; &#125; rp[bel[n]]=n; for(int t=1;t&lt;=m;++t) &#123; int x=read(),y=read(); k[x]=(double)(y)/(double)(x); ReBuild(bel[x]); int ans=0; double tmp=0; for(int i=1;i&lt;=bel[n];++i) &#123; int pos=0,L=1,R=rp[i]-lp[i]+1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(mx[i][mid]&gt;tmp) pos=mid,R=mid-1; else L=mid+1; &#125; if(pos) &#123; ans+=cnt[i][pos]; tmp=mx[i][rp[i]-lp[i]+1]; &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6504 Convex]]></title>
    <url>%2F2019%2F12%2F30%2FLoj-6504-Convex%2F</url>
    <content type="text"><![CDATA[回滚莫队. 若直接用莫队处理,插入时需要先二分找出它的前驱后继,时间复杂度 $O(n\sqrt n \log n)$ . 但删除是不需要二分查找的,用链表维护好它的前驱后继,直接断掉就可以了. 于是我们可以用回滚莫队来做,就只有删除和撤销两个操作. 具体来说,把所有询问按照左端点所在块为第一关键字,右端点为第二关键字排序. 对于所有左端点所在块相同的询问,按照右端点递减的顺序一起处理. 初始时将左端点设为该块最左侧,右端点设为 $n$ ,处理询问时,将左右端点移过来,回答后再将左端点移回去. 移回去时,暴力撤销移过来的每步操作即可,切换块时,把右端点移回 $n$ ,左端点移到下一个块的最左侧. 预处理出 $1\sim n$ 形成的凸包中,每个点的前驱后继,跑莫队时就只有删除和撤销操作了. 时间复杂度 $O(n\log n+n\sqrt n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1.5e5+10;struct v2&#123; int x,y,id; ll operator * (const v2 &amp;rhs) const &#123; return 1LL*x*rhs.y-1LL*y*rhs.x; &#125; double angle; bool operator &lt; (const v2 &amp;rhs) const &#123; return angle&lt;rhs.angle; &#125;&#125;p[MAXN],tmp[MAXN];int n,m,B,pre[MAXN],nxt[MAXN];ll cur=0,ans[MAXN];struct Query&#123; int l,r,bel,id; bool operator &lt; (const Query &amp;rhs) const &#123; return bel==rhs.bel?r&gt;rhs.r:bel&lt;rhs.bel; &#125;&#125;q[MAXN];void del(int x)&#123; int l=pre[x],r=nxt[x]; cur-=p[l]*p[x]+p[x]*p[r]; cur+=p[l]*p[r]; nxt[l]=r,pre[r]=l;&#125;void undel(int x)&#123; int l=pre[x],r=nxt[x]; cur-=p[l]*p[r]; cur+=p[l]*p[x]+p[x]*p[r]; nxt[l]=pre[r]=x;&#125;int main()&#123; n=read(),m=read(); B=sqrt(n); for(int i=1;i&lt;=n;++i) &#123; p[i].x=read(),p[i].y=read(); p[i].id=i; p[i].angle=atan2(p[i].y,p[i].x); tmp[i]=p[i]; &#125; sort(tmp+1,tmp+1+n); for(int i=1;i&lt;n;++i) &#123; pre[tmp[i+1].id]=tmp[i].id; nxt[tmp[i].id]=tmp[i+1].id; cur+=tmp[i]*tmp[i+1]; &#125; pre[tmp[1].id]=tmp[n].id,nxt[tmp[n].id]=tmp[1].id; cur+=tmp[n]*tmp[1]; for(int i=1;i&lt;=m;++i) &#123; q[i].l=read(),q[i].r=read(); q[i].bel=(q[i].l-1)/B,q[i].id=i; &#125; sort(q+1,q+1+m); int L=1,R=n,t=0; for(int i=1,j=0;i&lt;=m;++i) &#123; int pos=q[i].bel*B+1; while(R&lt;n) undel(++R); while(L&lt;pos) del(L++); while(j+1&lt;=m &amp;&amp; q[j+1].bel==q[i].bel) &#123; ++j; while(R&gt;q[j].r) del(R--); while(L&lt;q[j].l) del(L++); ans[q[j].id]=cur; while(L&gt;pos) undel(--L); &#125; i=j; &#125; for(int i=1;i&lt;=m;++i) printf("%lld\n",abs(ans[i])); return 0;&#125;]]></content>
      <tags>
        <tag>计算几何</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6046 爷]]></title>
    <url>%2F2019%2F12%2F29%2FLoj-6046-%E7%88%B7%2F</url>
    <content type="text"><![CDATA[分块 + 定期重构. 把树的 dfs 序找出来,问题就变成了区间加,区间询问第 $k$ 小. 如果直接分块 + 询问二分 + 块内二分,复杂度是根号带两只 $\log$ ,跑不过去. 唯一还能利用的性质就是 $len\le 10$ . 如果一个块内最大值和最小值相差很小,就可以记录个数的前缀和,少掉一只 $\log$ . 于是可以给块大小和元素极差分别设一个阈值,当其中一者超过阈值时,就立即新开一个块. 块有分裂的操作,为了方便,可以用一个链表把所有块串起来,方便遍历. 还有一个优化,当我们对边角部分暴力修改时,原来的一块可能会因为极差超过阈值而裂成几个小块. 而这些小块是可能与前后的块进行合并的. 如果每次都检查能否合并,效果并不会很好,我们可以定期将整个数列的分块重构一下. 阈值和重构的周期可能需要照抄别人的参数手动调一下参. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10,D=3000,S=400,T=1000,inf=1e9;// max-min&lt;=D,siz&lt;=S,ReBuild after T operations.int n,m,len,ecnt=0,head[MAXN],to[MAXN],nx[MAXN],eval[MAXN];void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; eval[ecnt]=w; head[u]=ecnt;&#125;int in[MAXN],out[MAXN],idx=0,a[MAXN];void dfs(int u,int dist)&#123; in[u]=++idx,a[idx]=dist; for(int i=head[u]; i; i=nx[i]) dfs(to[i],dist+eval[i]); out[u]=idx;&#125;int bel[MAXN],cnt=0;int lp[MAXN],rp[MAXN],nxt[MAXN],tag[MAXN],mx[MAXN],mi[MAXN];vector&lt;int&gt; sum[MAXN];void pushdown(int x)&#123; if(tag[x]) &#123; for(int i=lp[x]; i&lt;=rp[x]; ++i) a[i]+=tag[x]; tag[x]=0; &#125;&#125;void ReBuild()&#123; for(int i=1; i&lt;=cnt; ++i) pushdown(i); cnt=0; int pos=1; mx[cnt+1]=mi[cnt+1]=a[1]; for(int i=2; i&lt;=n+1; ++i) &#123; if(i&gt;n || i-pos+1&gt;S || mx[cnt+1]-a[i]&gt;D || a[i]-mi[cnt+1]&gt;D) &#123; ++cnt; lp[cnt]=pos,rp[cnt]=i-1,nxt[cnt]=cnt+1,tag[cnt]=0; sum[cnt].clear(); sum[cnt].resize(mx[cnt]-mi[cnt]+1); for(int j=lp[cnt]; j&lt;=rp[cnt]; ++j) ++sum[cnt][a[j]-mi[cnt]],bel[j]=cnt; for(int j=1; j&lt;=mx[cnt]-mi[cnt]; ++j) sum[cnt][j]+=sum[cnt][j-1]; mx[cnt+1]=mi[cnt+1]=a[i],pos=i; &#125; else &#123; mx[cnt+1]=max(mx[cnt+1],a[i]); mi[cnt+1]=min(mi[cnt+1],a[i]); &#125; &#125;&#125;void bf(int L,int R,int c)&#123; pushdown(bel[L]); for(int i=L; i&lt;=R; ++i) a[i]+=c; int tmp=nxt[bel[L]],pos=lp[bel[L]],cur=bel[L]; int st=lp[bel[L]],ed=rp[bel[L]]; mx[cur]=mi[cur]=a[st]; for(int i=st+1; i&lt;=ed+1; ++i) &#123; if(i&gt;ed || i-pos+1&gt;S || mx[cur]-a[i]&gt;D || a[i]-mi[cur]&gt;D) &#123; lp[cur]=pos,rp[cur]=i-1,tag[cur]=0; if(i&lt;=ed) nxt[cur]=++cnt; else nxt[cur]=tmp; sum[cur].clear(); sum[cur].resize(mx[cur]-mi[cur]+1); for(int j=lp[cur]; j&lt;=rp[cur]; ++j) ++sum[cur][a[j]-mi[cur]],bel[j]=cur; for(int j=1; j&lt;=mx[cur]-mi[cur]; ++j) sum[cur][j]+=sum[cur][j-1]; if(i&lt;=ed) &#123; cur=cnt; mx[cur]=mi[cur]=a[i]; pos=i; &#125; &#125; else &#123; mx[cur]=max(mx[cur],a[i]); mi[cur]=min(mi[cur],a[i]); &#125; &#125;&#125;void upd(int L,int R,int c)&#123; if(bel[L]==bel[R]) bf(L,R,c); else &#123; int st=rp[bel[L]]+1; bf(L,rp[bel[L]],c); for(int i=bel[st]; i!=bel[R]; i=nxt[i]) tag[i]+=c,mi[i]+=c,mx[i]+=c; bf(lp[bel[R]],R,c); &#125;&#125;int calc(int L,int R,int c)&#123; pushdown(bel[L]); int res=0; for(int i=L; i&lt;=R; ++i) res+=(a[i]&lt;=c); return res;&#125;int query(int L,int R,int c) // num of a[i]&lt;=c in [L,R]&#123; int ans=0; if(bel[L]==bel[R]) ans=calc(L,R,c); else &#123; ans+=calc(L,rp[bel[L]],c); for(int i=nxt[bel[L]]; i!=bel[R]; i=nxt[i]) if(c&gt;=mi[i]) &#123; if(c&lt;mx[i]) ans+=sum[i][c-mi[i]]; else ans+=sum[i][mx[i]-mi[i]]; &#125; ans+=calc(lp[bel[R]],R,c); &#125; return ans;&#125;int solve(int L,int R,int k)&#123; if(R-L+1&lt;k) return -1; int res=0,l=0,r=(n-1+m)*len; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(query(L,R,mid)&gt;=k) res=mid,r=mid-1; else l=mid+1; &#125; return res;&#125;int main()&#123; n=read(),m=read(),len=read(); for(int i=2; i&lt;=n; ++i) &#123; int f=read(),w=read(); addedge(f,i,w); &#125; dfs(1,0); ReBuild(); for(int i=1; i&lt;=m; ++i) &#123; int op=read(),x=read(),k=read(); if(op==1) printf("%d\n",solve(in[x],out[x],k)); else upd(in[x],out[x],k); if(i%T==0) ReBuild(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6546 简单的数列题]]></title>
    <url>%2F2019%2F12%2F29%2FLoj-6546-%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%88%97%E9%A2%98%2F</url>
    <content type="text"><![CDATA[分块 + 斜率优化. 考虑分块,对于每一块维护块内的 $\max\lbrace a_i\cdot b_i\rbrace​$ ,以及加法标记 $tag​$ . 每次 $tag$ 被更新后,需要重新计算块内的 $\max\lbrace a_i\cdot b_i\rbrace$ . 此时每个位置实际的值是 $c_i=tag\cdot b_i+a_i\cdot b_i​$ ,要找出最大的 $c_i​$ . 这是个斜率优化的形式,写成 $-a_i\cdot b_i=tag\cdot b_i-c_i$ . 块内每个点横坐标为 $b_i$ ,纵坐标为 $-a_i\cdot b_i$ ,用一条斜率为 $tag$ 的直线去截这些点,需要最小化截距. 把它们按照 $b_i$ 从小到大排序,维护一个下凸壳,用斜率为 $tag$ 的直线去截它就可以得到答案. 由于 $tag$ 只会不断增大,每次被截到的点不可能向左移动,于是不需要在凸壳上二分,不断尝试将答案向右移即可. 对于边角部分,把块重构之后暴力询问答案. 交换操作容易处理,将影响到的两个块重构一下就可以了. 每次重构需要将该块重新按 $b$ 排序. 设块大小为 $B$ ,则复杂度为 $O(n\cdot(\frac n B+B\log B))$ ,取 $B=\sqrt \frac{n}{\log n} $ ,得到时间复杂度 $O(n\sqrt{n\log n})$ . 每次重构时最多只会有 $2$ 个元素的 $b$ 是无序的,若直接用归并排序重构,时间复杂度 $O(n\sqrt n)$ . 空间复杂度 $O(n)​$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10,S=81,K=1267;int n,m,B,a[MAXN],b[MAXN],bel[MAXN];int lp[K],rp[K],tag[K],pos[K];ll mx[K];void pushdown(int x)&#123; if(tag[x]) &#123; for(int i=lp[x];i&lt;=rp[x];++i) a[i]+=tag[x]; tag[x]=0; &#125;&#125;struct v2&#123; ll x,y; v2(ll x=0,ll y=0):x(x),y(y) &#123;&#125; bool operator &lt; (const v2 &amp;rhs) const &#123; return x==rhs.x?y&lt;rhs.y:x&lt;rhs.x; &#125; v2 operator - (const v2 &amp;rhs) const &#123; return v2(x-rhs.x,y-rhs.y); &#125; ll operator * (const v2 &amp;rhs) const &#123; return x*rhs.y-y*rhs.x; &#125;&#125;;void ConvexHull(v2 *p,v2 *stk,int siz,int &amp;tp,int &amp;pos,ll &amp;mx)&#123; tp=0; stk[++tp]=p[1]; for(int i=2;i&lt;=siz;++i) &#123; if(p[i].x==p[i-1].x) continue; while(tp&gt;=2 &amp;&amp; (p[i]-stk[tp-1])*(stk[tp]-stk[tp-1])&gt;=0) --tp; stk[++tp]=p[i]; &#125; pos=1; while(pos&lt;tp &amp;&amp; stk[pos].y&gt;stk[pos+1].y) ++pos; mx=-stk[pos].y;&#125;int tp[K];v2 p[K][S],stk[K][S];void ReBuild(int k)&#123; pushdown(k); int siz=0; for(int i=lp[k];i&lt;=rp[k];++i) &#123; ++siz; p[k][siz].x=b[i]; p[k][siz].y=-1LL*a[i]*b[i]; &#125; sort(p[k]+1,p[k]+1+siz); ConvexHull(p[k],stk[k],siz,tp[k],pos[k],mx[k]);&#125;ll calc(int k,v2 pt)&#123; return pt.y-pt.x*k;&#125;bool check(int x,v2 A,v2 B)&#123; return calc(x,A)&gt;calc(x,B);&#125;void upd(int L,int R,int c)&#123; if(bel[L]==bel[R]) &#123; for(int i=L;i&lt;=R;++i) a[i]+=c; ReBuild(bel[L]); &#125; else &#123; for(int i=L;i&lt;=rp[bel[L]];++i) a[i]+=c; ReBuild(bel[L]); for(int i=bel[L]+1;i&lt;=bel[R]-1;++i) &#123; tag[i]+=c; while(pos[i]&lt;tp[i] &amp;&amp; check(tag[i],stk[i][pos[i]],stk[i][pos[i]+1])) ++pos[i]; mx[i]=-calc(tag[i],stk[i][pos[i]]); &#125; for(int i=lp[bel[R]];i&lt;=R;++i) a[i]+=c; ReBuild(bel[R]); &#125;&#125;void Swap(int x,int y)&#123; swap(b[x],b[y]); ReBuild(bel[x]),ReBuild(bel[y]);&#125;ll query(int L,int R)&#123; ll ans=0; if(bel[L]==bel[R]) &#123; ReBuild(bel[L]); for(int i=L;i&lt;=R;++i) ans=max(ans,1LL*a[i]*b[i]); &#125; else &#123; ReBuild(bel[L]); for(int i=L;i&lt;=rp[bel[L]];++i) ans=max(ans,1LL*a[i]*b[i]); for(int i=bel[L]+1;i&lt;=bel[R]-1;++i) ans=max(ans,mx[i]); ReBuild(bel[R]); for(int i=lp[bel[R]];i&lt;=R;++i) ans=max(ans,1LL*a[i]*b[i]); &#125; return ans;&#125;int main()&#123; n=read(),m=read(); B=sqrt(n)/4; for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); bel[i]=(i-1)/B+1; lp[bel[i]]=(bel[i]-1)*B+1; rp[bel[i]]=bel[i]*B; &#125; for(int i=1;i&lt;=n;++i) b[i]=read(); rp[bel[n]]=n; for(int i=1;i&lt;=bel[n];++i) ReBuild(i); for(int i=1;i&lt;=m;++i) &#123; int op=read(),x=read(),y=read(); if(op==1) upd(x,y,read()); else if(op==2) Swap(x,y); else printf("%lld\n",query(x,y)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>分块</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2736 回转寿司]]></title>
    <url>%2F2019%2F12%2F29%2FLoj-2736-%E5%9B%9E%E8%BD%AC%E5%AF%BF%E5%8F%B8%2F</url>
    <content type="text"><![CDATA[分块 + 堆. 每次操作后,如果区间内最大值 $&gt;A$ , $A$ 就会变成区间内的最大值,并且某些数的位置会变,否则无事发生. 考虑分块,对于整块部分,对每块开一个大根堆维护块内所有元素. 修改时,若块内最大值 $&gt;A$ ,就将把 $A$ 换成它,并且打上标记,表示这一块被元素 $A$ 进行了一次操作. 对于边角部分,修改时将标记下放,然后暴力重构这一块. 按照遍历的顺序从前往后依次处理,每一块 $A​$ 被交换后的值就是下一块 $A​$ 的初始值. 唯一的问题在于某一块已经有标记时,再加入标记需要怎样处理. 首先注意到,操作的顺序不会影响块内元素最后的值,于是没必要合并标记,可以都存下来,下放标记时一起处理. 每个数显然只可能被最小的数替换一次,后面的都没用了,于是用小根堆来存储标记,下放时用堆顶不断尝试交换. 时间复杂度 $O(n\sqrt n\log \sqrt n)$ ,空间复杂度 $O(n\sqrt n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;struct Greater&#123; priority_queue&lt;int&gt; Heap; void push(int x)&#123;Heap.push(x);&#125; int top()&#123;return Heap.top();&#125; void pop()&#123;Heap.pop();&#125; bool empty()&#123;return Heap.empty();&#125;&#125;;struct Less&#123; priority_queue&lt;int&gt; Heap; void push(int x)&#123;Heap.push(-x);&#125; int top()&#123;return -Heap.top();&#125; void pop()&#123;Heap.pop();&#125; bool empty()&#123;return Heap.empty();&#125;&#125;;const int MAXN=4e5+10,S=633;int n,m,B,bel[MAXN],a[MAXN],lp[S],rp[S];Greater val[S];Less tag[S];void pushdown(int x)&#123; if(!tag[x].empty()) &#123; for(int i=lp[x];i&lt;=rp[x];++i) if(a[i]&gt;tag[x].top()) &#123; tag[x].push(a[i]); a[i]=tag[x].top(); tag[x].pop(); &#125; while(!tag[x].empty()) tag[x].pop(); &#125;&#125;void bf(int L,int R,int &amp;A)&#123; int x=bel[L]; pushdown(x); for(int i=L;i&lt;=R;++i) if(a[i]&gt;A) swap(a[i],A); while(!val[x].empty()) val[x].pop(); for(int i=lp[x];i&lt;=rp[x];++i) val[x].push(a[i]);&#125;void upd(int L,int R,int &amp;A)&#123; if(bel[L]==bel[R]) bf(L,R,A); else &#123; bf(L,rp[bel[L]],A); for(int i=bel[L]+1;i&lt;=bel[R]-1;++i) if(val[i].top()&gt;A) &#123; tag[i].push(A); val[i].push(A); A=val[i].top(); val[i].pop(); &#125; bf(lp[bel[R]],R,A); &#125;&#125;int main()&#123; n=read(),m=read(); B=sqrt(n); for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); bel[i]=(i-1)/B+1; lp[bel[i]]=(bel[i]-1)*B+1; rp[bel[i]]=lp[bel[i]]+B-1; val[bel[i]].push(a[i]); &#125; rp[bel[n]]=n; for(int i=1;i&lt;=m;++i) &#123; int L=read(),R=read(),A=read(); if(L&lt;=R) upd(L,R,A); else &#123; upd(L,n,A); upd(1,R,A); &#125; printf("%d\n",A); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2639 不勤劳的图书管理员]]></title>
    <url>%2F2019%2F12%2F28%2FLoj-2639-%E4%B8%8D%E5%8B%A4%E5%8A%B3%E7%9A%84%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E5%91%98%2F</url>
    <content type="text"><![CDATA[分块 + 树状数组处理动态逆序对. 先用树状数组扫一遍,算出初始的答案,考虑交换 $a_x,a_y(x&lt;y)​$ 对答案造成的影响. $a_x$ 与 $a_y$ 的贡献, $a_x$ 与 $[x+1,y-1]$ 内元素的贡献,以及 $a_y$ 与 $[x+1,y-1]$ 内元素的贡献需要重新计算. 可以先把原来的贡献减掉,重新计算后加回去,于是问题转化为求一个元素与一段区间内的元素产生的贡献. 考虑分块,对每一块开两个树状数组,分别维护该块内 $\le i$ 的元素数目,以及它们的权值和. 询问贡献时,边角暴力,整块的在树状数组中查询,每次修改最多会影响两个块,在对应的树状数组中直接改即可. 时间复杂度 $O(n\sqrt n\log n)$ ,空间复杂度 $O(n\sqrt n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=5e4+10,S=320;int n,m,B,bel[MAXN],a[MAXN],val[MAXN];int lp[S],rp[S];struct FenwickTree&#123; int bit[MAXN];#define lowbit(x) x&amp;(-x) void upd(int x,int c) &#123; inc(c,P); for(;x&lt;=n;x+=lowbit(x)) inc(bit[x],c); &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) inc(s,bit[x]); return s; &#125; int query(int l,int r) &#123; return add(sum(r),P-sum(l-1)); &#125;&#125;T[S][2],tmp[2]; // 0:cnt 1:sumint ans=0;int calc(int x,int L,int R,int dir)&#123; if(L&gt;R) return 0; int cnt=0,sum=0; if(bel[L]==bel[R]) &#123; for(int i=L;i&lt;=R;++i) if(dir^(a[i]&lt;a[x])) ++cnt,inc(sum,val[i]); &#125; else &#123; for(int i=L;i&lt;=rp[bel[L]];++i) if(dir^(a[i]&lt;a[x])) ++cnt,inc(sum,val[i]); for(int i=lp[bel[R]];i&lt;=R;++i) if(dir^(a[i]&lt;a[x])) ++cnt,inc(sum,val[i]); for(int i=bel[L]+1;i&lt;=bel[R]-1;++i) &#123; if(!dir) &#123; inc(cnt,T[i][0].query(1,a[x]-1)); inc(sum,T[i][1].query(1,a[x]-1)); &#125; else &#123; inc(cnt,T[i][0].query(a[x]+1,n)); inc(sum,T[i][1].query(a[x]+1,n)); &#125; &#125; &#125; return add(mul(cnt,val[x]),sum);&#125;void solve(int x,int y)&#123; if(x==y) return; if(x&gt;y) swap(x,y); if(a[x]&gt;a[y]) inc(ans,P-add(val[x],val[y])); inc(ans,P-calc(x,x+1,y-1,0)); inc(ans,P-calc(y,x+1,y-1,1)); T[bel[x]][0].upd(a[x],-1),T[bel[x]][1].upd(a[x],-val[x]); T[bel[y]][0].upd(a[y],-1),T[bel[y]][1].upd(a[y],-val[y]); swap(a[x],a[y]),swap(val[x],val[y]); T[bel[x]][0].upd(a[x],1),T[bel[x]][1].upd(a[x],val[x]); T[bel[y]][0].upd(a[y],1),T[bel[y]][1].upd(a[y],val[y]); if(a[x]&gt;a[y]) inc(ans,add(val[x],val[y])); inc(ans,calc(x,x+1,y-1,0)); inc(ans,calc(y,x+1,y-1,1));&#125;int main()&#123; n=read(),m=read(); B=sqrt(n); for(int i=1;i&lt;=n;++i) &#123; a[i]=read(),val[i]=read(); bel[i]=(i-1)/B+1; lp[bel[i]]=(bel[i]-1)*B+1; rp[bel[i]]=lp[bel[i]]+B-1; int cnt=tmp[0].query(a[i]+1,n),sum=tmp[1].query(a[i]+1,n); inc(ans,mul(cnt,val[i])); inc(ans,sum); tmp[0].upd(a[i],1),tmp[1].upd(a[i],val[i]); T[bel[i]][0].upd(a[i],1),T[bel[i]][1].upd(a[i],val[i]); &#125; rp[bel[n]]=n; for(int i=1;i&lt;=m;++i) &#123; solve(read(),read()); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2254 一个简单的询问]]></title>
    <url>%2F2019%2F12%2F28%2FLoj-2254-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%A2%E9%97%AE%2F</url>
    <content type="text"><![CDATA[莫队. 如果所有的 $l$ 都一样,那么每个询问就只有 $2$ 个右端点需要移动,可以用莫队做. 把它看成平面上对一个矩形询问,就可以想到用容斥把 $l$ 全部弄成 $1$ .$$\begin{aligned}ans&amp;={\rm get}(1,r_1,x)\cdot {\rm get}(1,r_2,x) \\&amp;-{\rm get}(1,l_1-1,x)\cdot {\rm get}(1,r_2,x)\\&amp;-{\rm get}(1,r_1,x)\cdot {\rm get}(1,l_2-1,x)\\&amp;+{\rm get}(1,l_1-1,x)\cdot {\rm get}(1,l_2-1,x)&amp;\end{aligned}$$把每个询问拆成 $4$ 次询问,用莫队的方式去移动端点就可以了. 时间复杂度 $O(n\sqrt n)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,m,cnt=0,B,a[MAXN],bucket[MAXN][2];struct Query&#123; int l,r,id,sgn; Query(int l=0,int r=0,int id=0,int sgn=0):l(l),r(r),id(id),sgn(sgn) &#123;&#125; bool operator &lt; (const Query &amp;rhs) const &#123; return (l-1)/B==(rhs.l-1)/B?r&lt;rhs.r:(l-1)/B&lt;(rhs.l-1)/B; &#125;&#125;q[MAXN];ll tmp=0,ans[MAXN];int main()&#123; n=read(); B=sqrt(n); for(int i=1;i&lt;=n;++i) a[i]=read(); m=read(); for(int i=1;i&lt;=m;++i) &#123; int l0=read(),r0=read(),l1=read(),r1=read(); q[++cnt]=Query(r0,r1,i,1); if(l0&gt;1) q[++cnt]=Query(l0-1,r1,i,-1); if(l1&gt;1) q[++cnt]=Query(r0,l1-1,i,-1); if(l0&gt;1 &amp;&amp; l1&gt;1) q[++cnt]=Query(l0-1,l1-1,i,1); &#125; for(int i=1;i&lt;=cnt;++i) if(q[i].l&gt;q[i].r) swap(q[i].l,q[i].r); sort(q+1,q+1+cnt); int L=1,R=1; tmp=1,bucket[a[1]][0]=bucket[a[1]][1]=1; for(int i=1;i&lt;=cnt;++i) &#123; while(R&lt;q[i].r) &#123; ++R; ++bucket[a[R]][1]; tmp+=bucket[a[R]][0]; &#125; while(L&gt;q[i].l) &#123; --bucket[a[L]][0]; tmp-=bucket[a[L]][1]; --L; &#125; while(R&gt;q[i].r) &#123; --bucket[a[R]][1]; tmp-=bucket[a[R]][0]; --R; &#125; while(L&lt;q[i].l) &#123; ++L; ++bucket[a[L]][0]; tmp+=bucket[a[L]][1]; &#125; ans[q[i].id]+=tmp*q[i].sgn; &#125; for(int i=1;i&lt;=m;++i) printf("%lld\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数列分块入门]]></title>
    <url>%2F2019%2F12%2F27%2F%E6%95%B0%E5%88%97%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[发现自己分块学得太垃圾,于是来入个门. 数列分块的题目,用 $0$ 下标会比较方便. 数列分块入门 1 区间加,单点查询元素的值. 分块,对于每一块维护一个加法标记 $tag$ ,表示这块内实际的值在 $a$ 的基础上还要加上 $tag$. 修改时,对于整块的部分,更新它们的 $tag$ ,对于边角部分,暴力修改 $a$. 询问时,实际的值就为 $a+tag$ . 时间复杂度 $O(n\sqrt n)$ ,空间复杂度 $O(n)​$ . code 其他做法:树状数组/线段树,时间复杂度 $O(n\log n)$ ,空间复杂度 $O(n)​$ . 数列分块入门 2 区间加,询问区间内 $\le x$ 的元素数目. 分块,对于每一块维护一个加法标记 $tag$ ,表示这块内实际的值还要加上 $tag$ . 对于每一块维护一个数组 $b$ ,表示这一块内的元素排序后的结果. 修改时,对于整块的部分,更新它们的 $tag$ ,由于相对大小关系不变,所以不用重构 b . 对于边角部分,暴力修改后重构 $b$ . 询问时,对于整块的部分,在 $b$ 中二分出 $&lt; x$ 的元素数目,对于边角的部分,暴力统计. 时间复杂度 $O(n\sqrt n\log n)​$ ,空间复杂度 $O(n)​$ . code 其他做法:树套树,时间复杂度 $O(n\log^2 n)$ ,空间复杂度 $O(n\log n)​$ . 数列分块入门 3 区间加,询问区间内最大的 $&lt; x$ 的元素. 直接把 $2$ 的做法搬过来,把计数改成求前驱就可以了. 时间复杂度 $O(n\sqrt n\log n)$ ,空间复杂度 $O(n)​$ . code 其他做法:树套树,时间复杂度 $O(n\log^2 n)$ ,空间复杂度 $O(n\log n)$ . 数列分块入门 4 区间加,区间求和. 分块,对于每一块维护一个加法标记 $tag$ ,表示这块内实际的值在 $a$ 的基础上还要加上 $tag$. 对于每一块维护一个 $sum$ ,表示这块内实际所有元素的和. 修改时,对于整块的部分,更新它们的 $tag$ 和 $sum$,对于边角部分,暴力修改 $a$ 和 $sum$ . 询问时,对于整块的部分,利用 $sum$ 更新答案,对于边角部分,暴力用每个 $a+tag$ 更新答案. 时间复杂度 $O(n\sqrt n)$ ,空间复杂度 $O(n)$ . code 其他做法:树状数组/线段树,时间复杂度 $O(n\log n)$ ,空间复杂度 $O(n)$ . 数列分块入门 5 区间开方(向下取整),区间求和. 分块,对于每一块维护一个 $flag$ ,表示这一块内的元素是否全为 $0,1$ ,维护一个 $sum$ 表示块内元素之和. 修改时,对于整块的部分,若已经全为 $0,1$ ,则直接跳过,否则暴力对每个元素开方,更新 $sum$ ,重新判断是否全为 $0,1$ . 对于边角部分,暴力开方,更新 $sum$ ,重新判断其所在块是否全为 $0,1$ . 一个大小为 $x$ 的数最多被开方 $O(\log \log x)$ 次就会变成 $1$ . 时间复杂度 $O(n\sqrt n \log \log a)$ ,空间复杂度 $O(n)​$ . code 其他做法:线段树,时间复杂度 $O(n\log n\log \log a)$ ,空间复杂度 $O(n)​$ . 数列分块入门 6 单点插入,单点查询元素的值,数据随机生成. 分块,对每一块开一个 vector 维护块内的元素,并记录该块内共有多少个元素. 插入时,先暴力找出插入的位置在哪一块,再插入到该块的 vector 中. 询问时,先暴力找出询问的位置在哪一块,再在该块的 vector 中询问. 每进行 $\sqrt n$ 次操作后,对整个数列重构一次. 定期重构保证每块的大小为 $O(\sqrt n)$ ,所以找块,插入 vector 的复杂度均为 $O(\sqrt n)$ ,共操作了 $O(n)$ 次. 而每次重构的时间复杂度为 $O(n)$ ,重构次数为 $\sqrt n​$ . 时间复杂度 $O(n\sqrt n)$ ,空间复杂度 $O(n)$ . code 其他做法:平衡树,时间复杂度 $O(n\log n)$ ,空间复杂度 $O(n)$ . 数列分块入门 7 区间乘法,区间加法,单点查询元素模质数的值. 分块,对于每一块维护两个标记 $k,b​$ ,表示该块内元素实际的值是 $k \times a+b​$ . 修改时,对于整块部分,直接修改标记. 对于边角部分,暴力修改,先把它所在块的 $a​$ 都改成实际值,把标记清空,再修改. 询问时,答案就是 $k \times a+b​$ . 时间复杂度 $O(n\sqrt n)$ ,空间复杂度 $O(n)​$ . code 其他做法:线段树,时间复杂度 $O(n\log n)$ ,空间复杂度 $O(n)$ . 数列分块入门 8 区间询问等于 $c$ 的元素数目,然后将这个区间所有数改为 $c$ . 分块,对每一块维护一个 $flag$ 表示该块内元素是否相同,维护一个 val 表示若相同,则这个值是多少. 询问时,对于整块部分,若块内元素都相同,则直接判断它是否与 $c$ 相同,若不同,则对每个元素暴力判断. 对于边角部分,先把标记下放,再对于每个元素暴力判断. 修改时,对于整块部分,直接让 $val=c$ ,对于边角部分,先把标记下放,再暴力修改,修改完再后判断块内元素是否相同. 每次修改最多会让 $2​$ 个原来元素相同的块变为元素不同的块,均摊下来每次操作复杂度还是 $O(\sqrt n)​$ . 时间复杂度 $O(n\sqrt n)$ ,空间复杂度 $O(n)$ . code 其他做法:树套树,时间复杂度 $O(n\log^2 n)$ ,空间复杂度 $O(n \log n)$ . 数列分块入门 9 区间询问最小的众数. 分块,并把元素离散化一下. 预处理 $f(i,j)$ 表示从第 $i$ 块到第 $j$ 块这些数的众数,可以先枚举 $i$ ,每加入一个元素时检查它是否为当前的众数. 询问时,答案只可能是整块部分的 $f$ ,或者在边角部分中出现过的数字. 枚举边角部分的每个数,考虑它能否成为众数,需要计算出它在询问区间 $[l,r]$ 中出现的次数. 可以先预处理一个 $sum(i,x)$ 表示前 $i$ 块中 $x$ 出现的次数,就可以得到整块部分中 $x$ 出现的次数. 再开一个桶,记录边角部分每个数出现的次数. 时间复杂度 $O(n\log n+n\sqrt n)$ ,空间复杂度 $O(n\sqrt n)$ . code 其他做法:离线后使用暴力回退的莫队,时间复杂度 $O(n\sqrt n)$ ,空间复杂度 $O(n)$ .]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCT 题目选做]]></title>
    <url>%2F2019%2F12%2F27%2FLCT-%E9%A2%98%E7%9B%AE%E9%80%89%E5%81%9A%2F</url>
    <content type="text"><![CDATA[发现自己 LCT 学得太垃圾,于是来做几个题. LCT 的讲解推荐 FlashHu 大佬的博客 ,讲得很细致. 只是打标记和我的习惯不太一样 QTREE6开两棵 LCT ,分别维护白点,黑点的信息,询问的答案就是 $u$ 所在的连通块大小. 这可以通过维护虚儿子的大小和得出. 修改时,需要将 $u$ 在某棵 LCT 中断掉,在另一棵 LCT 中加入,如果每次暴力修改,会被菊花图卡掉. 我们常常把边 $u\to v$ 的贡献放到点 $v$ 上来统计,这里可以将 $u$ 的信息放到边 $fa(u)\to u$ 上统计. 即,在白点的 LCT 中,若边 $fa(u)\to u$ 存在,说明 $u$ 为白色.这样修改时就只需要删一条边,加一条边了. 询问时,由于根节点的边 $fa(root)\to root$ 不存在,说明根的颜色与 $u$ 不同,它的所有儿子不能连起来. 于是还需要把根给去掉,在 findroot(u) 找到根后,把它 Splay 上来,它的右儿子就是 $u$ 所在的子树. 需要给原图加一个虚点,表示原图树根的父亲. 时间复杂度 $O(n\log n)$ . code QTREE7和 QTREE6 大同小异,只是把连通块大小换成了连通块内点权最大值. 用 multiset 维护虚儿子贡献上来的最大值,其它部分同 QTREE6 . 时间复杂度 $O(n\log^2 n)$ . code bzoj 1969 航线规划LCT 维护边双信息. 如果把每个边双缩成一个点,容易证明会形成一个森林,而答案就是两点所在边双在树上的距离. 于是我们可以用 LCT 来动态维护这个森林,但因为删边后,原来缩起来的点可能会裂开,不好维护,所以只能支持加边. 可以把操作离线下来,倒着做,就只有加边操作了. 在 LCT 中连接 x,y 两个点时,若它们相同,说明原来要连的那两个点已经在一个边双中了,直接跳过. 否则,若还未连通,那么可以直接把它们 link 起来. 若已连通,说明 x 到 y 路径上所有点会形成一个边双. 用 split 将这些点放入一个 splay 中, dfs 这个 splay ,把点都缩到 splay 的根上,再把这个根和它的儿子断开. 可以用并查集来维护每个点被缩到哪个点上去了. 注意 Access 在向上跳时,要跳到父亲被缩到的点,否则新加的实边就会连向已经被缩掉的点,维护的信息就不对了. 时间复杂度 $O(n\log n)$ . code Loj 2245 魔法森林LCT 动态维护最小生成树. 可以考虑从小到大枚举 $a$ ,那么就会不断加入能用的边. $a$ 已经被枚举了,只需要最小化 $b$ ,可以维护一棵最小瓶颈生成树, $1$ 到 $n$ 树上路径中 $b$ 的最大值就是需要的 $b$ . 而最小生成树一定也是最小瓶颈生成树,所以用 LCT 动态维护最小生成树即可. 加入一条边 $(u,v)$ 时,若它们已经连通,则需要找出 $u\to v$ 路径上最长的边,若比当前边长,则用当前边替换它. 边权不方便处理,可以对每条边 $(u,v)$ 新建一个点插在 $(u,v)$ 中,就变成维护点权了. 时间复杂度 $O(m\log n)$ . code Loj 2230 大融合LCT 维护子树信息. 答案显然为以 $y$ 为根时,子树 $x$ 的大小乘上 (子树 $y$ 的大小减去子树 $x$ 的大小) . 需要不断加边,并查集显然没法维护上面那个东西,考虑用 LCT 来维护. 每个节点维护 siz 表示 LCT 中所有儿子信息和时,再维护一个 si 表示所有虚儿子的 siz 之和. 虚儿子的信息只可能在 Access,link 操作时发生变化,此时更新一下 si 就可以了. code Loj 558 我们的 CPU 遭到攻击LCT 维护子树信息. 把边拆成点,变成维护路径点权之和. 由于 LCT 支持换根,所以只需要分别维护出一棵 Splay 中所有点到深度最小,最大的点的距离和,翻转的时候交换. 为了能合并 Splay 左右儿子的信息,还需要维护出子树内黑点的数目,虚边的子树内黑点到对应子树根的距离和. 当虚边被更改时将对应信息更新就可以了,时间复杂度 $O(n\log n)$ . code Uoj 207 共价大爷游长沙LCT 维护子树信息. 若一条边 $(x,y)$ 被所有路径经过,则当以 $x$ 为整棵树的根时,每条路径恰有 $1$ 个端点在子树 $y$ 中. 两个元素是否在同一侧的问题,可以用一个经典小 trick ,给每条路径的两个端点异或上一个随机权值. 那么当子树 $y$ 中所有点的异或值恰好等于所有路径权值的异或值时,就说明每条路径恰有 $1$ 个端点在子树 $y$ 中. 用 LCT 维护加边,删边,换根,修改点权,询问子树点权异或和这些操作,时间复杂度 $O(n\log n)$ . code Loj 2001 树点涂色利用 LCT 中辅助树 Splay 的性质. 每种颜色的点一定会构成一条深度严格递增的链,这和 LCT 中每棵 Splay 维护的东西是一样的. 而每次染色操作,由于是新的颜色,所以等价于进行了一次 Access(x) . 于是可以用 LCT 来维护这些操作,需要维护出每个点到根的颜色种类 $tot$ ,即到根经过的轻边数目 + 1. 每次切换轻重边时,某个子树内的 $tot$ 会 $+1$ 或者 $-1$ ,可以用线段树维护. 注意需要找到 Splay 中深度最小的点,修改它的子树. 对于操作 $2$ , $(x,y)$ 路径上颜色数目就是 $tot(x)+tot(y)-2\cdot tot(lca(x,y))+1$ . 注意这里不能直接 split(x,y) ,因为我们维护的是有根树,这样会改变树的形态. 对于操作 $3$ ,答案就是 $x$ 子树中 $tot$ 的最大值,可以在更新 $tot$ 时用线段树一起维护. code Loj 2092 大森林LCT + 扫喵线. 有时间和树的编号两个维度,一起维护不太可做,考虑去掉一个维度. 注意到长出的子节点编号只与操作次数有关,可以让每次都给所有树生长出一个新点. 这样不在 $[l,r]$ 内的树会有冗余节点,但只要不把生长节点换成它们,它们就不会对询问产生影响. 可以把每个编号的点实际存在的区间 $[l_x,r_x]$ 记录下来,对 $[l,r]$ 修改生长节点为 $x$ 时,需要将它与 $[l_x,r_x]$ 取并. 而询问操作的答案不会随着之后的操作变化,可以离线下来,最后再一起回答. 可以先把节点长好,再处理生长节点的修改,以及回答询问. 每次修改生长节点时,新建一个虚点,生长点的时候,新建一个实点接在最近的虚点上,把所有虚点按时间顺序串起来. 类似扫描线,从前往后处理每一棵树的形态,并回答询问,修改生长节点操作在 $l$ 处生效,在 $r+1$ 处失效. 简单画了一下,实心点是实点,空心点是虚点,虚点下面栽的子树就是后面生长出来的实点. 生效时,就把它的虚点栽到 $x$ 这个实点下面,这样后面长出来的点都在 $x$ 的子树中了. 失效时,就把它的虚点给移回去,即移回所有虚点按时间串好的那条链上. 回答询问时,将虚点权值设为 $0$ ,实点权值设为 $1$ ,答案就是两点路径上点权和 $-1$ . 因为我们维护的是有根树,不能用 makeroot 去改变它的形态,只能维护出每个点到根的路径点权之和 $sum(x)$ . 还需要找出 $x,y$ 的 LCA ,答案就是 $sum(x)+sum(y)-2sum(LCA)$ . 可以先 Access(x) ,再 Splay(x) ,再 Access(y) ,最后一次切换的虚边指向的点就是 LCA. code Loj 2434 历史构造 + LCT 维护子树信息. 做过树点涂色那道题的话,马上就能看出 “崛起” 这个过程等同于 LCT 中的一次 Access 操作. 每个点的贡献可以分开算,若相邻两次 Access 操作来自它的两个不同的子树,或分别来自子树和自己,就有 $1$ 的贡献. 记 $A(u)$ 表示子树 $u$ 中共有多少次 Access 操作. 当 $u$ 的所有儿子 $v$ 的 $\max A(v)$ ,以及 $a(u)$ 都没有超过 $A(u)$ 的一半时,总可以交替安排,产生 $A(u)-1$ 的贡献. 否则,若它们中的最大值为 $mx$ ,最多就只能产生 $2(A(u)-mx)$ 的贡献. 直接这样做一遍树形 dp ,就可以完成预处理,考虑如何处理修改操作. 构造一下,若 $A(x)$ 超过了 $A(fa(x))$ 的一半,就设 $fa(x)\to x$ 为实边,否则为虚边. 每个点最多只会有 $1$ 个实儿子,形成了一个实虚链的剖分,用 LCT 来维护这个东西,以及权值的子树和,即 $A(u)$ . 修改只会让 $a$ 增大,修改 $x$ 时, $x$ 到根的路径上实边不会变成虚边,它们的贡献也不变,因为 $A(u),mx$ 增加的值相同. 那么只有虚边可能变成实边,每次用 Splay 操作跳过一条实链,判断虚边是否会变成实边,去修改它的贡献. 类似于树链剖分,可以证明 $x$ 到根路径上虚边数目是 $O(\log n)$ 的,那么每次修改操作的时间复杂度也是 $O(\log n)$ . code]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6712 数树上块]]></title>
    <url>%2F2019%2F12%2F26%2FLoj-6712-%E6%95%B0%E6%A0%91%E4%B8%8A%E5%9D%97%2F</url>
    <content type="text"><![CDATA[长链剖分. 算法一使用大力枚举,状态压缩等指数级别复杂度算法,期望得分 $10$ 分. 算法二设 $f(i,j)$ 表示在子树 $i$ 中选出一个联通块,必须包含 $i$ ,并且这个联通块中最深的点到 $i$ 的距离为 $j$ 的方案数. 在树上 $dfs$ ,不断将当前节点 $u$ 的信息与它的儿子节点 $v$ 的信息合并.$$f(u,\max(i,j+1))+=f(u,i)\cdot f(v,j),i+j+1\le k$$枚举深度 $i,j$ 时只需要枚举有用的,时间复杂度 $O(n^2)$ ,期望得分 $50$ 分. 算法三对于 $k=n-1$ 的部分,相当于没有联通块直径的限制,可以在算法二的基础上去掉第二维. 即设 $f(i)$ 表示在子树 $i$ 中选出一个联通块,且必须包含 $i$ 的方案数. 时间复杂度 $O(n)$ ,结合算法二,期望得分 $60$ 分. 算法四注意到算法二的 $dp$ 第二维的下标是深度,可以利用长链剖分进行优化. 为了快速转移,需要给每个节点 $i$ 开一棵线段树维护所有的 $f(i,j)$ ,可以使用动态开点实现. 时间复杂度 $O(n\log n)$ ,期望得分 $100$ 分. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=5e5+10;int n,k;int ecnt=0,to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],head[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int mxdep[MAXN],mxson[MAXN];void dfs_init(int u,int fa)&#123; for(int i=head[u]; i; i=nx[i]) &#123; int v=to[i]; if(v==fa) continue; dfs_init(v,u); if(mxson[u]==0 || mxdep[v]&gt;mxdep[mxson[u]]) mxson[u]=v; &#125; if(mxson[u]) mxdep[u]=mxdep[mxson[u]]+1;&#125;int cnt=0;struct node&#123; int ls,rs,sum,tag; node() &#123; ls=rs=sum=0; tag=1; &#125;&#125; Tree[MAXN*30];#define root Tree[o]#define lson Tree[root.ls]#define rson Tree[root.rs]void pushup(int o)&#123; root.sum=add(lson.sum,rson.sum);&#125;void modify(int &amp;o,int c)&#123; if(!o) o=++cnt; root.tag=mul(root.tag,c); root.sum=mul(root.sum,c);&#125;void pushdown(int o)&#123; if(root.tag!=1) &#123; modify(root.ls,root.tag); modify(root.rs,root.tag); root.tag=1; &#125;&#125;void upd_add(int &amp;o,int l,int r,int pos,int c)&#123; if(pos&lt;l || pos&gt;r) return; if(!o) o=++cnt; if(l==r) &#123; root.sum=add(root.sum,c); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(pos&lt;=mid) upd_add(root.ls,l,mid,pos,c); else upd_add(root.rs,mid+1,r,pos,c); pushup(o);&#125;void upd_mul(int o,int l,int r,int L,int R,int c)&#123; if(!o || L&gt;r || R&lt;l || L&gt;R) return; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modify(o,c); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) upd_mul(root.ls,l,mid,L,R,c); if(R&gt;mid) upd_mul(root.rs,mid+1,r,L,R,c); pushup(o);&#125;int query(int o,int l,int r,int L,int R)&#123; if(!o || L&gt;r || R&lt;l || L&gt;R) return 0; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; int res=0; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) res=add(res,query(root.ls,l,mid,L,R)); if(R&gt;mid) res=add(res,query(root.rs,mid+1,r,L,R)); return res;&#125;void pr(int o,int l,int r)&#123; if(l==r) &#123; printf("%d ",root.sum); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); pr(root.ls,l,mid); pr(root.rs,mid+1,r);&#125;int rt[MAXN],delta[MAXN],ans=0;struct opr&#123; int L,R,c; int type;//0-add 1-mul&#125; opt[MAXN];int tp=0,pres[MAXN],tot;void dfs(int u,int fa)&#123; if(mxson[u]) &#123; rt[mxson[u]]=rt[u]; delta[mxson[u]]=delta[u]+1; dfs(mxson[u],u); &#125; upd_add(rt[u],0,n-1,0+delta[u],1); for(int i=head[u]; i; i=nx[i]) &#123; int v=to[i]; if(v==fa || v==mxson[u]) continue; rt[v]=++cnt; dfs(v,u); tp=0; for(int j=0; j&lt;=mxdep[v]; ++j) &#123; int tmp=query(rt[u],0,n-1,0+delta[u],min(j+delta[u],k-j-1+delta[u])); int x=query(rt[v],0,n-1,j,j); tmp=mul(tmp,x); ++tp; opt[tp].L=j+1+delta[u],opt[tp].R=k-j-1+delta[u]; opt[tp].c=x,opt[tp].type=1; if(opt[tp].L&gt;opt[tp].R) --tp; else &#123; ++tot; pres[tot]=add(pres[tot-1],x); &#125; ++tp; opt[tp].L=j+1+delta[u],opt[tp].c=tmp,opt[tp].type=0; &#125; int lstL=-1,lstR=-1; for(int p=tp; p&gt;=1; --p) if(opt[p].type==1) &#123; if(lstL==-1) upd_mul(rt[u],0,n-1,opt[p].L,opt[p].R,pres[tot]+1); else &#123; upd_mul(rt[u],0,n-1,opt[p].L,lstL-1,pres[tot]+1); upd_mul(rt[u],0,n-1,lstR+1,opt[p].R,pres[tot]+1); &#125; lstL=opt[p].L,lstR=opt[p].R; --tot; &#125; for(int p=1; p&lt;=tp; ++p) if(opt[p].type==0) upd_add(rt[u],0,n-1,opt[p].L,opt[p].c); &#125; ans=add(ans,query(rt[u],0,n-1,0+delta[u],k+delta[u]));&#125;int main()&#123; n=read(),k=read(); for(int i=1; i&lt;n; ++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs_init(1,0); rt[1]=++cnt,delta[1]=0; dfs(1,0); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>长链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Query on a tree]]></title>
    <url>%2F2019%2F12%2F24%2FQuery-on-a-tree%2F</url>
    <content type="text"><![CDATA[QTREE 系列. QTREE1树剖维护即可,注意 LCA 连向它父亲的边不能被计入贡献.利用重链上 dfn 连续这条性质,就可以做到了. 时间复杂度 $O(n\log n)$ . code QTREE2预处理出父亲的倍增数组,每个点的深度以及到根的距离.第一问找出 LCA 计算一下就可以了. 第二问可以从深度大的往上跳,如果跳到 LCA 还没结束,就换另一个点来跳. 跳的时候要记录跳过了几个点,更换跳的点的时候要处理 $k$ 的变化. 时间复杂度 $O(n\log n)$ . code QTREE3把 dfn 看作下标,则这个询问等价于询问一段区间内的第 $k$ 大. 没有修改操作,把权值离散化后建出主席树来回答询问即可. 时间复杂度 $O(n\log n)$ . code QTREE4和 捉迷藏 那题一模一样,可以用动态点分治来做,时间复杂度 $O(n\log^2 n)$ . code QTREE5和 QTREE4 大同小异,其实可以看做是 QTREE4 的一个弱化版.仍然考虑动态点分治. 给每个分治中心开一个 set ,维护它管辖的所有白点到它的距离,以及它们的编号. 修改时在点分树跳,把经过的每个 set 的信息更新一下. 询问时在点分树上跳,不断用 set 中的最小值来更新最小距离. 这样会将一些自交的链也统计进去,但由于是询问 $\min​$ ,不会影响答案正确性. 时间复杂度 $O(n\log^2 n)$ . code QTREE6开两棵 LCT ,分别维护白点,黑点的信息,询问的答案就是 $u$ 所在的连通块大小. 这可以通过维护虚儿子的大小和得出. 修改时,需要将 $u$ 在某棵 LCT 中断掉,在另一棵 LCT 中加入,如果每次暴力修改,会被菊花图卡掉. 我们常常把边 $u\to v$ 的贡献放到点 $v$ 上来统计,这里可以将 $u$ 的信息放到边 $fa(u)\to u$ 上统计. 即,在白点的 LCT 中,若边 $fa(u)\to u$ 存在,说明 $u$ 为白色.这样修改时就只需要删一条边,加一条边了. 询问时,由于根节点的边 $fa(root)\to root$ 不存在,说明根的颜色与 $u$ 不同,它的所有儿子不能连起来. 于是还需要把根给去掉,在 findroot(u) 找到根后,把它 Splay 上来,它的右儿子就是 $u$ 所在的子树. 需要给原图加一个虚点,表示原图树根的父亲. 时间复杂度 $O(n\log n)$ . code QTREE7和 QTREE6 大同小异,只是把连通块大小换成了连通块内点权最大值. 用 multiset 维护虚儿子贡献上来的最大值,其它部分同 QTREE6 . 时间复杂度 $O(n\log^2 n)$ . code]]></content>
      <tags>
        <tag>主席树</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>倍增</tag>
        <tag>LCT</tag>
        <tag>动态点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6538 烷基计数 加强版 加强版]]></title>
    <url>%2F2019%2F12%2F19%2FLoj-6538-%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0-%E5%8A%A0%E5%BC%BA%E7%89%88-%E5%8A%A0%E5%BC%BA%E7%89%88%2F</url>
    <content type="text"><![CDATA[Burnside 引理 + 牛顿迭代. 就是求每个节点的儿子个数 $\le 3$ 的有根树数目. 记答案的生成函数为 $F(x)$ ,直接 $F(x)=1+F(x)^3$ 显然是错的,因为可能出现同构的情况. 考虑 Burnside 引理,对 $3$ 个儿子的置换有 $6$ 种. 对于 $(1,2,3)​$ 这 $1​$ 种置换,每种方案都是不动点. 对于 $(1,3,2),(3,2,1),(2,1,3)$ 这 $3$ 种置换,只有在置换中成环的两棵子树相同的方案才是不动点. 对于 $(2,3,1),(3,1,2)$ 这 $2​$ 种置换,只有三棵子树都相同的方案才是不动点. 根据 Burnside 引理,本质不同的方案数是各个置换的不动点数目平均数,得到$$F(x)=1+x\frac{F(x)^3+3F(x^2)F(x)+2F(x^3)}{6}$$考虑牛顿迭代解出这个方程,设 $G(F(x))=x\frac{F(x)^3+3F(x^2)F(x)+2F(x^3)}{6}-F(x)+1$ . 若当前已知了 $F(x)\bmod x^n$ ,要求出 $F(x)\bmod x^{2n}$ ,可以发现 $F(x^2)\bmod x^{2n},F(x^3)\bmod x^{2n}$ 也已知了. 于是可以直接把它们看做常量,记 $A(x)=F(x^2)\bmod x^{2n},B(x)=F(x^3)\bmod x^{2n}$ . 注意是对 $F(x)​$ 求导,所以 $x​$ 也可以看做常量. 得到 $G’(F(x))=x\frac{3F(x)^2+3A(x)}{6}-1$ ,代入牛顿迭代公式 $F(x)=F_0(x)-\frac{G(F_0(x))}{G’(F_0(x))}$ ,$$F(x)=F_0(x)-\frac{x(F_0(x)^3+3A(x)F_0(x)+2B(x))-6F_0(x)+6}{x(3F_0(x)^2+3A(x))-6}$$时间复杂度 $O(n\log n)​$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353,G=3;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=4e5+10;int rev[MAXN],omega[MAXN],inv[MAXN],curn=0;void init(int n)&#123; if(curn==n) return; for(int i=0;i&lt;n;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(n&gt;&gt;1)); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; omega[l]=fpow(G,(P-1)/l); inv[l]=fpow(omega[l],P-2); &#125; curn=n;&#125;void DFT(int *a,int n,bool invflag)&#123; init(n); for(int i=0;i&lt;n;++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=l&gt;&gt;1; int gi=omega[l]; if(invflag) gi=inv[l]; for(int *p=a;p!=a+n;p+=l) &#123; int g=1; for(int i=0;i&lt;m;++i) &#123; int t=mul(g,p[i+m]); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int invn=fpow(n,P-2); for(int i=0;i&lt;n;++i) a[i]=mul(a[i],invn); &#125;&#125;void NTT(int *A,int *B,int *C,int lenA,int lenB)&#123; int lenC=lenA+lenB-1,n=1; while(n&lt;lenC) n&lt;&lt;=1; static int a[MAXN],b[MAXN]; copy(A,A+lenA,a); fill(a+lenA,a+n,0); copy(B,B+lenB,b); fill(b+lenB,b+n,0); DFT(a,n,false); DFT(b,n,false); for(int i=0;i&lt;n;++i) C[i]=mul(a[i],b[i]); DFT(C,n,true);&#125;void PolyInverse(int *A,int *B,int N) // B=A^(-1)&#123; int n=1; while(n&lt;N) n&lt;&lt;=1; static int res[MAXN],tmp[MAXN]; fill(A+N,A+n,0); res[0]=fpow(A[0],P-2); for(int i=2;i&lt;=n;i&lt;&lt;=1) &#123; NTT(A,res,tmp,i,i); NTT(tmp,res,tmp,i,i); for(int j=0;j&lt;i;++j) res[j]=add(mul(2,res[j]),P-tmp[j]); &#125; copy(res,res+N,B);&#125;void solve(int *F,int N)&#123; int n=1; while(n&lt;N) n&lt;&lt;=1; static int A[MAXN],B[MAXN],F0[MAXN],up[MAXN],down[MAXN]; F[0]=1; for(int i=2;i&lt;=n;i&lt;&lt;=1) &#123; for(int j=0;j&lt;i;++j) F0[j]=F[j]; for(int j=0;j&lt;i;j+=2) A[j]=F0[j/2]; for(int j=0;j&lt;i;j+=3) B[j]=F0[j/3]; NTT(F0,F0,up,i,i); for(int j=0;j&lt;i;++j) inc(up[j],mul(3,A[j])); NTT(F0,up,up,i,i); for(int j=0;j&lt;i;++j) inc(up[j],mul(2,B[j])); for(int j=i-1;j&gt;=1;--j) up[j]=up[j-1]; up[0]=0; for(int j=0;j&lt;i;++j) inc(up[j],P-mul(6,F0[j])); inc(up[0],6); NTT(F0,F0,down,i,i); for(int j=0;j&lt;i;++j) down[j]=add(mul(3,down[j]),mul(3,A[j])); for(int j=i-1;j&gt;=1;--j) down[j]=down[j-1]; down[0]=P-6; PolyInverse(down,down,i); NTT(up,down,up,i,i); for(int j=0;j&lt;i;++j) F[j]=add(F0[j],P-up[j]); &#125;&#125;int F[MAXN];int main()&#123; int n=read(); solve(F,n+1); cout&lt;&lt;F[n]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>Burnside/Polya</tag>
        <tag>牛顿迭代</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[THUWC2020游记]]></title>
    <url>%2F2019%2F12%2F19%2FTHUWC2020%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[咫尺之外 $Day -\infty$这次 THUWC 有点早,报名的时候 CSP 官方成绩都还没发布,发现自己没什么奖可以填,结果还是过审了. 考前没感冒,身体状况良好,实属罕见. $Day\ 0$中午从学校出发,晚上成功入住了豪华包间. 甚至找不到热水壶,喝水还要跑到二楼去接. 稍微颓了会隔膜就睡觉了. $Day\ 1$上午去试机,发了条围巾当纪念品, Sublime Text 3 好评,但键盘似乎并不是很顺手. 北京的室外是真的冷,室内是真的热,有点不太适应. 试机题目貌似是 THUWC2018 的题,发现 T1 很签到,后面两道都不会做,打了个 NTT 板子练手就走了. 下午考试,看了题之后,根据历史规律,猜了一下 T1 应该可做,冷静思考了一波,发现是个签到题,写了一发就 pp 了. 后面两个题没想出什么高论,打了几个暴力,还有 40 分钟的时候就差不多弃疗了. 然后还有 5 分钟的时候发现 T2 的环套树非常可做,把树的做法拿来随便改一改就好了,只是没时间写了,淦. 于是 T2 白给了 15 分,最后得分大概 170 多点. $Day\ 2$看了题,感觉都比较神仙. 冷静思考了一波,还是啥也不会,写了 T1,T2 的暴力,跑去找 T3 的性质. 把表打出来了,结果还是没找出来什么性质,喜提 5 分. 感觉今天智力出了点问题,最后喜提 91 的好成绩. $Day\ 2+$上午智力出了问题,晚上心态也出问题了. 刚开考的几分钟学习手册没发下来,就看了看问题,感觉 T1 好像比较好做,于是拿到手册后就去学 T1 的做法. 冷静思考了一波,发现是个模拟题,但是感觉歧义有点多,提个问就 no response. 于是写代码就写了 1 个小时左右,直接过了样例,交上去直接 WA 了. 小样例过水,又没有大样例,感觉 T1 都花了这么久,开后面的题应该也不太能做. 于是头铁了一波,对着代码和学习手册硬调,前后写了 10 来个版本的题意理解,都能过小样例,交上去都 WA . 快结束的时候浑身上下都在冒汗,最后还是没能调出来,于是工业场就报灵了. 后记我佛了, CSP 结束后基本上都在做数学题和多项式的数数题,结果直接给我整了 1 个 dp 和 5 个数据结构. 还有把我愉悦送走的模拟题.. 今年的比赛暂告一段落了,明年再来吧.]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6609 无意识的石子堆 加强版]]></title>
    <url>%2F2019%2F12%2F18%2FLoj-6609-%E6%97%A0%E6%84%8F%E8%AF%86%E7%9A%84%E7%9F%B3%E5%AD%90%E5%A0%86-%E5%8A%A0%E5%BC%BA%E7%89%88%2F</url>
    <content type="text"><![CDATA[容斥原理 + NTT . 每行必须有 $2$ 个石子,考虑枚举 $k$ 列有 $2$ 个石子,则有 $2(n-k)$ 列有 $1$ 个石子. 记 $S(k)$ 表示选出了这 $2n-k$ 列后放入石子的方案数,则$$ans=\sum_{k=0}^n \binom{m}{k} \binom{m-k}{2(n-k)} \cdot S(k)$$可以转化成二分图模型,左边有 $n$ 个点,度数均为 $2$ ,右边有 $k$ 个点度数为 $2$ ,有 $2(n-k)$ 个点度数为 $1$ . 那么 $S(k)$ 就是这样的二分图的数目. 将每个度数为 $2$ 的点拆成两个点,直接在这 $4n$ 个点中连边,再去掉出现了重边的方案数. 考虑容斥,枚举有 $i$ 条重边,得到 $$S(k)=\frac{1}{2^{n+k}} \sum_{i=0}^n (-1)^i \binom{n}{i} \binom{k}{i} i!\cdot 2^i\cdot (2n-2i)!$$这可以用 NTT 做一次卷积直接算出,时间复杂度 $O(n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=943718401,G=7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=8e6+10;int rev[MAXN],omega[MAXN],inv[MAXN],curn=0;void init(int n)&#123; if(curn==n) return; for(int i=0;i&lt;n;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(n&gt;&gt;1)); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; omega[l]=fpow(G,(P-1)/l); inv[l]=fpow(omega[l],P-2); &#125; curn=n;&#125;void DFT(int *a,int n,bool invflag)&#123; init(n); for(int i=0;i&lt;n;++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=l&gt;&gt;1; int gi=omega[l]; if(invflag) gi=inv[l]; for(int *p=a;p!=a+n;p+=l) &#123; int g=1; for(int i=0;i&lt;m;++i) &#123; int t=mul(g,p[i+m]); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int invn=fpow(n,P-2); for(int i=0;i&lt;n;++i) a[i]=mul(a[i],invn); &#125;&#125;void NTT(int *A,int *B,int *C,int lenA,int lenB)&#123; int lenC=lenA+lenB-1,n=1; while(n&lt;lenC) n&lt;&lt;=1; static int a[MAXN],b[MAXN]; copy(A,A+lenA,a); fill(a+lenA,a+n,0); copy(B,B+lenB,b); fill(b+lenB,b+n,0); DFT(a,n,false); DFT(b,n,false); for(int i=0;i&lt;n;++i) C[i]=mul(a[i],b[i]); DFT(C,n,true);&#125;int n,m,fac[MAXN],invfac[MAXN];int A[MAXN],B[MAXN],S[MAXN];int binom(int M,int N)&#123; if(M&lt;0 || N&lt;0 || M&lt;N) return 0; return mul(fac[M],mul(invfac[N],invfac[M-N]));&#125;ll M;int main()&#123; n=read(),M=read(); m=M%P; fac[0]=1; for(int i=1;i&lt;=2*n;++i) fac[i]=mul(fac[i-1],i); invfac[2*n]=fpow(fac[2*n],P-2); for(int i=2*n-1;i&gt;=0;--i) invfac[i]=mul(invfac[i+1],i+1); int pw=1,inv2=(P+1)&gt;&gt;1; for(int i=0;i&lt;=n;++i) &#123; A[i]=mul(binom(n,i),mul(pw,fac[2*n-2*i])); if(i&amp;1) A[i]=add(P,-A[i]); B[i]=invfac[i]; pw=mul(pw,2); &#125; NTT(A,B,S,n+1,n+1); pw=fpow(inv2,n); for(int i=0;i&lt;=n;++i) &#123; S[i]=mul(S[i],mul(fac[i],pw)); pw=mul(pw,inv2); &#125; int pos=(M&gt;=2*n)?0:2*n-M; int ans=0,tmp=1; for(int i=pos;i&lt;=2*n-1;++i) tmp=mul(tmp,add(m+i+1,P-2*n)); for(int i=pos;i&lt;=n;++i) &#123; int delta=mul(mul(invfac[i],invfac[2*n-2*i]),tmp); delta=mul(delta,S[i]); inc(ans,delta); tmp=mul(tmp,fpow(add(m+i+1,P-2*n),P-2)); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>容斥原理</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191218]]></title>
    <url>%2F2019%2F12%2F18%2Ftest20191218%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX18+xxxLa5TaqlsPgj3qI+1AZEB1nhy6CtHeW9RRXsnCqr+tBw9DF5SReH2GcxQcVG3jTBPvY3xHjw6OpoeHSh4d2zPFw35dPmA3woZdTiuO4wN9jqwDPUSIk1A7ibMoXaI3YnU4tlJ/5sgbZg+3fztfpj+0APJyz7W3UcKYxqAufwIhK93ZqIfL9VaQq1yPm3+UVEbJiCMy1J6jaXAUYLrZba7OAiygUOxhyvncHgJwTdUwxYbdEeSC/VtsbtpuBMFTeZkhndNQhOtJIglXlFfCPxozpeZhvRsYm9R+R3gcdLZLzM29/rOn15rThPFCLjN2gEX4B8f/j6NWhhkiD2y+JiTxgUZey7lYsClJIR3F1Cdl1rF+11fEBL+7wyfAsGuAsrnAsU/PTNg30fUguHq0vUNlnh6GNwwRA6kSKvmWBtT8VqgWvizJ4SjHnhPBHuDxRGvHoPqFslRPLHu6J/TMvFnFP3pld3my+HWwj9vb6KZZ5O3BeB0wv2oVNvU0WuKEzGW9TG3uf1Qi8m17NpdVN531Qbu6twx6dAjrvSFMPQ8HH/gq+1h6tvGyh+irdSio9kTE7SyDFalp6oTzVTfndvYlPT6O/Omsx/7BKNcV3ImR27gllz/p3uR9xPWQnL7FXZf3FRo0O8zHgrsBw26CC2fw9BRQ/ivJ9iNcJIGeQBHfRiukjjRWYDIHz0Qk58+MPlrB9GaCV1l+Rb/EMbu9eXXwlx4MLn3nWRBb4sJ2fgCoIBNx1yV3NlxD71rD4sefs+2gATinRcI93fVotno5/in90DKIC24n8C3wuzERSAAPnXXZpyO51+U/+Tfi92mOryTC8G5rbvMXavKMweeRP6IZHiTG8xmcSvo+0Ij20k/aw4h2jxMbPMCoI1n60EQi6UeP9q/WbC3lsrMLaDRUon8D/E7TlrhuFMrT99FiGdCqVcEIl3Dd5uzEFITysCjHC6ccGd0wMJiGm16oiu3V4k0mvC0QPUaQZlkkH1cdS1fYKl3AKWbiZQsUEPIU0WswQ8tyLuof5ALWsePz9vJSN9ag85SMGS61hyYJth9SCAhgQgZBlJyC0Mfzwn3wZEoiSXHOVpyww/H9nUeYVf3Gz8Lp2ht8Y2kgGzAtEOkzqV0MXRtfkLg7qgYph9fo0qdeGKoIpgYdk7tIwSzUi6aYT4mLScmpAakaJuWhe9FAj49pwkAcRHb20/jFbldvRN1JMPY9HPR8L10ltI1uL2N0wG4pS/P6s/6+za8RXZThnt3624Y0wf/SpmGCvFuoztGXBdP9p4ooFlm2MWkY1CN3M94E0gHryPLWnkutf300MO1760Zw/7tOsn7ndBO6hC6sslWQxrMF4uH6mAHm305DkUDNv45bmJ3ma2j6GWlxT+vfmdycfynqJzdxauRiVefGKo3IxyqkRGi8R3w8VH3OTrNS6PzBHBoUie8SjflQnJ21VVoRlg6pxfRPdma8rlJuuCWb+Ctu+YMTUA1CXOixHjyHNfVcXmYdqaychG96TyLgItjBPuqTW26XyGDTsTU7zMZCBRqyYC+/cOvl4gCXDfn6piYzYkFCc98ZepjpzUtrJd0TW6ViPJrcrFOKyKccr9mk19JU1US1Ci5LjWffuMy/f6XjmnkQW8IyK5Mvt3KUdoBxFKWwjivtLI74ctrl5H5U5Uqnvue12zJkW8sfWX6k8Mp2nD+Uu0KVUAZ2Z22FRdhvoDh53jfcPIDs10GFulWfKphkn0EhfmXPQKqccYmQHMda/ZSN7VwOje96hWIP+ETpBLtWbZzZvFa7ceXr22a67tIIwpQp6cigmkLKhpnCowI7eieKPc9EvGPC2UkG7zoz8gy2Zur1uOfMbxc/dmVqpYrO2rgF2woR+RyFP/7CuC8tcyh8PcGhLYQAoONdIyC+TBNVg0ZWBclJX6Nhh9ln48/Cv7lJFzYoBMIiKznm9XLFg86wuGHeNxJtLxjw4SbPKqdHSHedVQ8o6SLBM15Jfb2i8ntYL7UrGZfEYIvSA/UK9fHYTUXgENfNgEAJH1MQ9g0TYpPJSwLiH5l5lb2y92PuSilh0NLD/p4h8HjPejMrqAZ1QS22M1GEYGI7swXDpWv23ey6VOqlKILdOyetamBCiNWSojHMbVipxeDx3BtaolbZMYhLmOxiH73cIDBBK1awvvBkcHAKH8Q9tTysycbgaYYhCVkszybDo7y+VcqAAwtHB92LRG0QArBYk6hs33LBuEql206F4yjDvGaaxh4YUDYYOLgE4969g7vJbtehcznE1qLXNvCMf+MxeSxVSa6sDm8x9hTA2ZGkSy78d6ZTP/V1ULIt+6vTX0dYfUzw8I0KWq7EewE8xYdOxugBfqhL1oy2HwlgDJG4tL+ZGLYOz8nmi2G9WYD1NxrE+oeq6F5UK6jPpSR5Iu2YCiGjv+oAV0kXTDPeDYqEqNHJX/tjxx9JtwYz/GiLq/s7zW3Bni9cl1YRLSSbAe/a8CA6i913aHe1zL/UZdcfSEbDJ6lXHSly2x9Mi3ic9qT1O9Ju4SyxT/5mCiUKxuP2ZBRa4XM+7AYwTMCNRTgpeJNfXIXcJdfVIWzCH5hy/dFN8LzZu8fVRgMfBqKWnrOQOeid6ug7RRrvrTaculHTd5PEqWZaRQQv+PlcUeqCsGOHLNzzKs35RDkRjK+DFq1Sam2WtNuetZpInEm1oyAf1krGEwI8ZSclWMpSvMNECknIMXeN/mHYFlAKICAkIZVQZ024vHhHq5gW0FMVLqKV2AgZIu5e+5JJAxZIdTAZGd5GkkXei//MJOKDoWI6YZUWimJ5jOm25xD7wuK38wWk55Ipht3OBq/SX1yeAJXTJTbJsCFoGrypUHIjx6mSVCVbo5iwLdyBSLnDDnS/Z6/8U58O1WC5uxwuvDYlWgRf2mbyTQtArGTSCP+PQq8UIg1k3K36dUsk3OgyL5OKO4cvpq3ZvfCgBxpUN5hmO25lgIs8j8fXiIMoTRWuN7HUBWqAH7DBmqHzV0z4EZtPLZ9LmLqvbSvv2Cb20QadWpfXE2XuaL5FvwS7qHrgXp0UbCQHhHxo1iggOiO8yaX3PgrDNOD08+dL/X62LkrBD2Zav1rcXFoA9cp/rEIu6ANvRsUw1PwFrwxa/Yx1SseYayDL2pgQahbVbO+dChY9x2vKAI3xbMWbh50xdSy5Abqmo6Mf9UV19XJBQ5Yz3lTvfiVOdkLvXB+ajBH++7le0/8m1jOm4CqwhbMQscBIJVVHF56WtiNTxcM9UpgZLSKTL7homISNFnmQnuCICcfQIEwQ+lxxlUceDGs3DPwRrzLwD+0shZ3Ox1JmLjnbzisTXzym5Cd/o1wD2bJZXw8GUDrMCbd4pNtJQStBMFmFXjqmQrjtUdmnzBgMmV87K9o6bFKHWVQm7F6KKD0CChaRUbz57AXzDlect41RynVUabqg+Gb4ywSLlWZbSRDpzTIK+3sta6i6JPzB4tqAgShezgbSJd1Nlid0+W2nptveduOwxu+ggYSKgydDrf90ur1EYHaJ2QoQgJ5CH4yN4ybQ2fg1KHorgImNWB3GhwPqYGdpNCmf7U3xqp0NHm7wQB1CulmfsU4wesMvojHqWPVvBINsNg4hO/62IZrdi+evuEQWspVHbvM6fGWM5RZP0E0qQXYqy3B1hKpu4M47PMUKQdY1RlP/wt8AQ5sYw0h1fC/Hc+DpODw3YG0gg9jae3hIAfbEzNp4nJ12p4IbpFEqM/CxmYYmEyTqw3lFIQlzhe7OhBkeB0bhsDXce//Bq11QNNV3IHc5iIZWTsv1a3uU8YfHQRxYjL/DE2AjkU/uHdrYexN702wUTqX5ZyF5lQle0/3v4jGMJwGNQ/2LqhyIm6ke0FMIimhY2d2mrw6WEG75ijrVTV26bEnNVdIbcjnQSX0s05o997SzfsK1lXq5Qfz5wFq9pjAfvqxKCDGS3iitrwz/qipCFAKGvvuSIFHQUev5HYKRooRTSbQQL+y6R3/QIBiD1Q6mlwl9kdPETZMKlq5WRoey9o/JC8gdu62se9Whd7iVv+oxEYnyw7JWC8JNzQxeAXM5xsRcu+sIZ3NtaU4qFnw3JsJuvqIPNIm0phDM4fjd88amBnD9stuWyrrA6Ki2yIhqHqVOziCByFy0Afj511DnqRxteS2Gjkc9GKLC56oPzHW4r256bwAd/jFc/geLhuYhHReuec6WF8oxoXmMow7hkmkTtMRUJHADeTyPoET00UZfzlJnGsLKguzqWFJyeMHlAnqyJBLoq6Ox0xNvUtiK/ADQ4+IGpfG04ycwX2kufr242NAy4bxPvX6jLLCQCGUDLaDG+90vdr2bJElA4Z624c0yD4eU86SBifU4xiYbWX7142XNQdgO23gVQivW6PuL8bU4E8T8YqGIVBOjJ2iZ9GtPrsGaZVDZyGQsF+vJog56zB39S5xAftCdONulcRT9bw6d14WflybbbJ9/X/w82iyttFzp4Jrd5e/ROVRQyF6+dZM1Fc3tco9kAYIXarZRalPQblBXQq6MNkpgJPijyt6xztv302QLq1mWuVTVlDv70cRq6h6GxPPU0yWSo71MFhpHQUyfiEF+K667TkJNjRrV0JpsHkmtU76UcHzGZCA8L6lhVR2FvTMIcFGvUd7CT9Vb6PdsZMz12QJsJ5V4X2V5J907C98jI49KqzJ0ZCjBA5M3Wt0n2A2Q8ULnhlcOz8SLwDY/ajfM0N2jwWDp50ANTPVh16UGVVMeQ9wdA+A42foIFIP1ozeRSaUs7JvQY20nKVMxtG5hWqNLmXSP6/F8Tzjo39wmKwQSghOSKZtCt4uN3u/kPbyspFbW06yPUY4YzzLmVIL+9eOQOVMubPCIoTBQ/wWKaRdXZ69ZfMINIwJSm0AvBHFaHNCj+LAMzPAPCg5ri4OjJ7Z9VgpCwEepcgkarD7ch35u0khz0YZnJ4ItGZq4OCqyD7VcnRGNPpkGT5ObXjclkLxIrOm59cbzYg8ZGQm+ARBelYYWJDmX3vFUZ9wJA8vqLeC52UHqHPVO5tO2epwqkDjNHeSqjiKboXMlgCu/zto2+AvZUHMDiCoUoWGKCYZCPFoq2BkHp+mdtqMs9oJynEzAasQta48E8Q+pI/2MmKDkq1GTGeGW3+0za/iocfBrMCsNoH7yS6iqMkk126rA0MEajYC8GJLuxm/sdlhBEVZLhG1rJBF4T4p1v5OG5ZQLYcqT9FZmiu1FNPVnHoFHyLwV1xSjZ1B5K/PCpD8wHBGZ47NXXX2Eh5Lu6/njUT1Srrl5qKo5OiuKJlyEeUPU0XV73b+B2x81FLlsyaKWN4s8VF+vNXOjir/KcTKu79FptxMPDZyZEw1/YTxY6uQ5Y58hbQUbiCOUGgsqlPD2JmuznEiQHWOZl+dpomzc7qypCralYeOzJKi83nU+C4/l19NI7MqnKrN6jhDfqKLGxtfL37gHAy9eOSbmJDIZL1svl3cVvnxdmdLgwHfdwApq186vCPO6etqnMaoJjZSKLrk7x2Wk1L/Yk4x021i1Cwnba0bl3toebd6Qa3MTy7CWGS+2JMqDKKrdrO7OGow3FBRQeFrhwFXYdguKBaI56ETLOT57APHFPg70GJ5YI0IDmnbX5FaJ0K69bRagQKRzmAyRCQvzaFqlaIh7tZ80q8yuva3sJzPaKe3GIDxXNBnTXeKfrkLUnbTlytF2q9EGzVgvvMhn82TH9i9YOoUtExqT10V0gB8AFAobGQoJdqt/Y6l0oxN1me/gSmHlCU9EAH4NqBxOkWWr5X2qsZkjkT9fGVSZWHxUMCRIl6XTCO7BL8f+X2pjZj4XFBFS9KxPTreB7OcctZrBxDFvPhMLeFOV+/bvyjEc5eAYXeTsAMmki0HPh0IAJNFlPzNESIrX4eHE9kNQJVb2v8XSpHtix+7C8OPQH9/tkefM6h/z95zYvqkBwLGGKylddB2JQ2qGSNlvTF1kAkRh7fjQCYkkrPzBnzagSefJ7K9pHdZHlvBZJ3uQMR8wOhLHiPEeYwvhNFSF+VvUz0t0g9jHrlvVRDL5o+a2RuxYSFYKJEk1ak2EoMahfZYCcsaHzOMBkYTQr2D0RrUU6HWMMHmfh49lQWHd7ErY3d9D7NlMvHub4G4OPcbm1MwYLDKEACPVJCU75T+ySoOhjZ58Ae8fhQdJSzPdWsw/wwVavQmTg9+NTiYxxIilSgahU0cdrz3IWau/5Qhur6p2wH8IoENYI/x1dQpPcb1a1dLZTG7bBdtgwAIiloYGaSSmnpPI4wy9sQH7jR3Qaa/W/GPZ5gQ1shddEmug56Mxz0vfDxgfkCQ26wCTN4harTJNAuPS+VCr8KGDlRO0dkSoFet78262iHXuVAavkHmXPHY9cuMd6SP9b2EMQjoBM0BIqRHAs6nb4lQnq4KGpU3MH1CbuPGNtgb+64zbQ3aiw4eJJ9YIVFvcuvBSwtTzLPabhpqZ9z5QNeZoH5oJg+gPDtWh/wFcwfa/Y17r4h0WvJ2c89qnKjHV0/LjxJRZz8aQJprQhnNOK3eUWuzFv0UyeJKwtde6ExiTXABF28vJfBBupN3Zmdr7BEgbxti9Aje52g8e90tkUM6iEdW+anStKrujrVoA9r551jkIyJLm63K00j26Ym1VraB6P3ORR31X91nvq+TpEr/OFYxmCGdRq4rKKIgQDNPxRTDKYbFZ/WqgkCv5GT0mzQoNEleG3bV6amqzEfWq5/XaqJbIX0RK/UZHegjWrQNSot6FGI9PxPWPylgeiKdAieLMkATqvxXk7FufthPI18tNYg1ArzRj591WZ1pnDsd2u3sGPqpQXtj4ZUzMt9f1HiRnnUI0bUSWe2gECsaXEVwkaMvWT/GnzQ4fLTyzjkKorOtNSVHDmGPRsThFRL/9lcvbHsQE9X2B+zK3JErG/dtl/6uyfR3E8TiMBNSxTjF5htmAsuUlIb3Q0gVFHwfCV+TuV6cb53X4t/VwE3UvvTXLrlNARtiH91Bd8PTY2+zJLq5L40ybWf9NQZQlb4dKv/VGpRostL8NWoAUgHAE1lL/R2FFpDe6t0/Cpdm/Y+v/kuZY5Zd6wjJgXwHp3IqdtmgvmIGZ65BMsDh/oIN5tdFsXqj+//oaa0JaaccUmVMgu5gK8Pg+bkLcrwT8EeISZoNzK0qgZ7+Z6c9+INYsL1rUYpVdNUDL1zZYguixcU3zKBX1jO4h/l3zRycGx/e48JdTheOmUOuKUtUEPfanOYV3vgmIVNAgT0+XHX/B+/nzNUESk7uUv9uP3492t1YK7RtukKkab0EIr/+oDsrN32UdL2nF/K42O1vYYTiQHiZ5JSPyF9oQbTsjOVs3473v5JkyCbAAxoDC/hW1ovM7ICfVjULPQMm9DWbyPdUgTi0UfwoMWKdeFGjQYFvbtAeS/Eaz9DAKrbhMGFCiWlNYfA+YASVEwv5NKzfDPsfYrKYs2oD73xh3UyYr2a/OrxHV6z7v7jZL/iWjFS8NBpQsdt6ldBxN5J7Tko6Z+S6NoGWxn6YJiFuyyDNNSBSrQ1Qh+7u4+1StbYMG7zzuns8QtbIs2VYSSjkMYnW7eSTm2d6HcXfmIH/U/KFoIGbLQbs1aLgPK9WnavcuSho2EH7P2jLs9pYDq78wHQWsJB/Iz3QDkhbQhkzb+0NXkgrwgWeHkhfFehesQhWDSp/fsl8rytybldgFPN68hw7fr9Cd+smdhnmihHvdPFKUEzFlXU9LPAGhYPh4XoYzvwirzdWe5vkSlUambGeeSee+oA9ayYmVg0lmlGFrSYJ43+Xj0eiWOvMLPz/6Zq+4OPeD8wd23hwxB9A+TBb9rGRBKZ6xqJ3wANfksNfRtB3KNrHLwsv7oxZn5lKMGlbVVouGxw5UTnn5pMgtXYi5RmQAQ1VQU6wVCdrvihCDeq9+vJ9t2FqX8XanRL2H/unnma3aS+qi+27+RLMOIk0f/5dgY37Jv8bhkfe57YhHNnJbCaO39Bug0E1lU5aCHRrMumtWi6jEDpcQgUlxMseNaRu6/wod+2c2j3DsGz6RVdRAo0vd1p5Mjr8A0ogdpphWaeut+ce65YsxbEdwkeuiYT2SVnx+zkmKT2s9GqjAxV5DOoheKKuk+ogaypJXQ50HZ6VviEpuVAWMuqEMyevRamhzXDQ74D4PhX2uoakfkEE27cyCaBCvW8QoY+eopf7/lKOQpzmtu3pzhRhvEPopsJkGLj27OQ2YurnE5arhudXQWEtPlLUTJ3hMNf6ou/lfPMmO897vSRj0TleTOn9cjXXgd2cJvw0lLGLo02MS42yB8Cf28eRJj8InoncUERxU60Bjg+a2pDOTTMR2oVf+bict2bzyzKJyMEnsIFVssZ/QsShGT5hZfgR/hqMDDpPTtKLYa+MS9B56vSdPH4bL0iROw/5lQz851OIx3lcrs7R5L87RLPSxabmqTCC/njI+cm5pVwsOJricV/utCSwVemk7SzzkbZH+A4yLDivWK1uOidZoBsdoUNwL/7OvnPSbAMiQC3jQGLzyeD49+t+U8TKrLSk0sqgW7beTwmGxQvlrlItFC3ctiKGs0h7udqA7U0KrUVwvxsg/SBAlkNxPTzSRDS3cqpJkAb1CNSMeS7e+jlxuTqACjXP0LvgiNJPhVqhCbmSRFvx/HGbucrqDhYH3SQYjyazAjUcVdxFerb/FKacjXFwgcJ7bERTMrNzY5Qd7m+XLSrcAEGPkUS32EFoni5tsN31VJqI/1Yor3uvvpREVTdlTFHldeDb/Sk09Lv9Z54ceo61PWUW6O7ttjQAG09jTrYoSOEgoNCaNh8aBtj6s/ECCPs5peSYdPhGyC4OtgA+Poj7f0ZMU7qYNeW2pMnbdtKP01JerOHj5bevxiau2TF9K2Py4RCjqV/99203GO0Kup4w6tJTaBKP1X43Q1Cg5LYdFRvOdYovFIhkhmsGpi37k9C16cOglrXQIt7mu1zwy1SJX12B/0PkidHiHEEmpILzj9sMGvXj5cuwVBfVNA1BwTyAPakAYXGHwDBVbEaOgfMiUWu1QP2AbLIUy8nMsOgTQIte4RiuqhrW5eDgQ4vJz7FTar5xNNDYtfPL95QSATfUKmyTtx1a2omXNu0vZZWz+p7Xq3q6BYhPRza6AJ8t8lpgfvYoCNYwoY2oI5eoazafHzbVKYi/o4T2ae0+4Nxx3h4+m6875xv5jFtZEons2Vyxkj1hGgwzu5dHWS17wC0+diaNT58GdZh5Ich4A5MD3gnC4jTq23Acz5LDIp/6qv3X2fO4Aog78YgbSdflBh2Llwx6XTodhGsn6wLb5PNBd7a9GFuSTh5MaAQVS1+AJyEUmowRevancjQqHuLb1gteAiyepctiPrq+b8RyeE8omxFfmDRJOX06pQMrSWgsM9kRQR3FYEC/D4W55R5iYgkADIYNFnitsrejbHLvpC/iytFTszF+cWLPJ5wfJtW8oBMXgUASBsVjhLBza5eKKCL4M8sixQBkoSVxmnSePUiT2XznrQ+nY5Ipg9bbGbq32Tx0d/6m9rnqXWmbWvs2I0WMZTtCTZUR+KnXDvrVn29R2G92EwJ4nFGLjMWIHpKh36UQaFm85yIv7eebYnYc6tKTO2M1Jcwbecg5XvCYszvxQ8cimCJ95tNos+zfdzd1R1WwyPxRZ3HRFDg2rFADNHS5yl64zjILx7ORhZm3CON8OtJvJ533WSk8iIu2TrrYPeS4MoYvTEbzG+SxsIL3dQZikkUBngxhLQNgxY/sDrM/A2KNHqX4IKnUCAb/pwBmBnweNwE/rLzXDQd/XQaxmufXmpdm6aXOZtFm12OBgsL+y1txIB8Z5Hp2V1LPf9b0GW/A4pcGeMJqYSk3aMi4IHwBMWFxfanBpe2ugOcnRqM1V8hc4gMb+Q6+X/GT0l++gscq9FcZVDehoiBNQK+vdcb4aheK3c9z1deNks1f+UMhPtrT4iNS62REOLetALW9CgdVFVH8Md0tSboY4qy7dR6BWXd8UDHWUABrqIg5KNSeCwuiQqptSf5EouOKd9DlaNfl9e4MZYfQf8qDT01cNhHw5jYh3ks1I/BqxKfMpXqn3SyXSF+dHjFNEPbLrzFRKQLPONpui19yyarEds2Bn0oUE4D58ryneSvkLX8H1Z8UH985E4TnBktBUdStnP0aeXp+PtRajiyOSV7pbzUiky37HRyrdsnKJ3xbHYRhYMx3tWxXmWbCn2tDgeDxobFBsTiJvFgNLA7C478NHnHaiJyNlGv4hj7cFbqP2aX76sT2DrVbE+Z791R8dkGaulroxzSPUgQCv9LOOmc9PR3F1RlKAWZxgqiRkzdgu4g2gT908yBZseMugqkulaV5AX7jHaSNIvOW5Dp/Bvnu4U7w96Nq3fFBYQiFesA+WJOXch0rbusPblR6pp5a39JzR2bHbJ8dTK9TGtZfwfq6kjSGJ+y13JFpQarYHEWC0qwtMBnhH+OG1yiWjO5qchYDfO6c7XRcqNPsfC91qPx47nlKWvzyD5lQhfTfGNcE1JIzK0jVzAndx7JFGOTVnoHZ0ymuPWqaxTQO3pWnX+povFNLOubOkAeh1ncuR4vOU0CQkmx0Ddiuj7gdF040IKfbFxKa/jVjvoHR8VW2SEfufHg71t+yU34dM0+HTxidvTdrMaA8+cy8GepXpJRBvsxCTz/sytJLsAxEVJjtt7Q4uvrTfe8zqG2aBlfD1HAJTk5OVo2AUk6+6WM8isV4F9WMNbEEzTCVJqeedH8vfRxKx0ULxP9Nm9j8f8zpa/Qs2ZvxwGMGCuFQYvMVAsIqQ9fbrou4ZPDJu1NxHdbeEU0Lv1prcYLTfjzrmk9gjpNPll2bJU7ls6RA4AcYJ+8tBsyaMoboYhzRzGGZjZbQeePClfFcnkcVdc9ePufm5Iy9osjmBKBDTOUSilUD0yVCGU6kaClA/uXvkcI+CUNcGMittM0mdVitguNM0pvYGtlzPx11rSOetPK9Kc7YTieE4HiyIuQ7HiUHEqKjwjgQv5eHdGQGbrJ3MlkzbQ97Ug8d1eDrOatKNEC6fnjWXxihFe5c0NwrKPJFnV74sVpi+wZBaNVPlA6+P0QshTjiuDY0wXBo3UezfDMsUED8ucWOlCjVYYeDuX4Pe4RElj0WCY1w1SlaYSbqeVrLpR9DAZ3tfEB+1oijaakTSCTDxJKnMN4pvu/8Gw8yp5hf5gfQbKzdlpmL0nrcaf3RwoJI9IselRBbyOzUvjcxaquIyCdhkY1KeZnKZqghctUOVgIswCihwzteueKCXXriRMegjeJrebUv24R/Zim/7w9I+eoyE7Zuvj1/G89Ze4R8kaa3vd2TYL6NXRbI6w1rHfAtnGgL50sffyk/M8eYQIDxS6KZ4awQNtmVfQ4c+iahQFKfUtasbPlvuHx2pX+lbC67XlG8pNtBHXCB0sbc8zJ4GwbD90N+bg2cVRwC9dFwCcdnR6rigJ8c22F8FoEaF5zBIEeFYg9iXTcdFmZwbqI/UIe6SHdGSM65k8d46zxWU/s5qIDRl1T6Nmj/BtH3X5yDPbiOol2XuwPhOkyZuTPDe3siKvD7U/ufJK7ZfQMiKgx5o/+UDEBO7NymhFzFpqDwBhgmbuksCgNfKn+28mD9I8SQbVdRXZxEOkhY8lHz9NpN0j6iD1H5eU41NZctyyckVh3t6bci4U4yylcfzBJIi+8TOktYWWX8RI3MPxeiIGZ+wlbKX9DOW6/iKgvYWlPZasTCm5GOAX+z4klAnH5Ta0TkGPXN3CKdIcYSZBsKPrK/Vhby1EmZ5wzx9aTJA1GLs97YylcCxK0MNjDTCUS8HVmZBuQ1M0aowLTZtGbp88VvU15zXz2J4/mJfxt8u9SNXSC7Ia6elm/qwNwQKBc8CDIZTn1e4oPQl4+L4r912czFdyUKX0EUP+Z8jrfXCjN8M8fADe1eogpqp71LItTG5mT+LL6b629E1xWUzni5MGQUwYuE6ecvrHgyO/E04riEOesIGODYQke5I961zszyrETKuNvGOa9Q5STKOXqwOqXKGDPQfsOKIHTMjTLII6VakH+kKM7j55TQMhvmfAecedgTlszL3io6VUijFErBzSMjZlbblmSbNhNtmQw4lTG9vuvkitXqJF5DMSgpa4EUQ3nCpxkxqi/EmlwdTViy9Vd3oQWwEwZxPh+lYmrRFa7lsFGQEiupkrKNk1Rz1husBQhVNI/t5xizRGRefEVwv0gajbdLJTztSLK3Nj5/OnGSq6CiTA5H89xo/l2uDouw/1jmWWvUuP9F51mErHR4DIdTKD3bkfD+WZFkBpEiij9K2vl24qYWa4J1QLId0PIpBdrq6kdo9LKYenSv5tvpqOC52L1u5veNOLbKJrySRIZRtyA4bkyxMkh0SNaiB0inYLbcTm8avCZiQ6KriDc/o48aRfDpwDyKNPhotPWw5bVPDBuKoh4htao9hXZVi40CccepJ/Gd7ioZItTYacRScRs8HudmGWORR29cc93snXRv4nXy0H0+QoVG0V0QzmYk4FyPI0g1hnBZeVrHK1QGtOCkDr/S4WKEncxxRNHY5s+QD3456GRKdSlhVDc2Y7mG+0ktQBdk6FaLDBWp7EzscSwJcGM6modmR08PcrDXwSUiGXEw7d868n18AkSDyqiIb3h2LCivapmhpUvStUKerYku26nf4GlZdI2z9Ef/OxjhAB85cxpFZom0bVakEoIOQs/pXNYPnBtfI441PfbJc0i8eUJXIiQHFOICUQHtfBTQ//Tnk0QpgAeHh1KlWBmyVWl4xEEEF9epDSL3MVt7ep87sZ3e7wCvQev3TzKX8Mk1hiFj6Sgv0nSWfoyqFwKfoUiyS+xHOk3S4/mrPNjvAj2fbQ7AzSd2XbLoJ/wnZJ2N+OxV8fTi5PDqd8u6sIR5qWtwPLKnvtaHbHbq7V+C3cYtqdNbluMn/y2MkmGbgSZGeTRzyI+/OlNK49r+ClthzeJjByix8Pjs+mC8Q1b9bHo29iTmYuyHMACiZ3FEqz5t7X4DBCj7pEQSUZZo/cLYe6IRPrnFQVPvelew6HiNtmvMVgfCT3ZsyatpZKJJtdNXqhv4EtO/xfKieBEHRSQr2eF/2KTx3nKCw97Titu8diXRO9Fqet6PvTNqGrumGxgDYT1B8V38rQ+Tlf6PZpH+uIvwMWrZK8mj66Uqhj2GQ+oTR/Kq4Rb182+q9gcmZjJptA3WVRBq3qO3t758ShKWLj9W82L2hDHEgKA8emlYoVajbMyo0d9oVruvBidJqHzJh3Iy4NU3X1OvI+VV6uoPT1ZO3kW0Ad1Nt4On7JhTR6OFeR2U4bB6OxvOBQmwS7lC9UWpj2AYIkLQGbEKMtxpnt9oFrJnb/X5rLUIaj6/Egt3sWRcuvpHxbEdfXmhRE+ak3jiX8HevGwh/CFSqTBezUJNk3Gj2EtC+MfHmUfgNDcdEYzTsFh76nS527eIenR44XCRD+WfMazWiWyyP3YxWBLlCyKrkVVcjw1x4x40RYkAkFuAzQwQzk2F4PJTtSRvtU0F80pgOiqQZmlKj1ro6C1JyYQTcJNd8C8vUVO1esJKKDqMCWjPKvHgKkYwbo92GQshUuA1pnqLh/SnTdtiKfrZFTxpYpdCrwxJZ5ZjOw4FGpAqDyzk2HCIfDO6HCfkqMQih2Su9JTJ6GXkvGiZ0GufCcvBIb1mcb3b4OmLoVmEm8Z142/vkt6z8YhEnC6TjWbjlbkP81ETSAftYQscJgcsARL8qatTfCNcq0543qxQapXg5SVptGuqSpiE3PQnumJW7yAlHrWWh+HxQhaWsZlkLduHoMvzqd8l9EDURyBIwabwZngk4bD4pcAlx7x4avk3Bk1semvoApRpvbNRrMKCQJEQg+PBqrmTVobSJzgTTHhhoAnNc2NaxQzufcaMd/fQEtG8EQoiKOX2bOtu1MftetyITNNtGr13qSH3NjqHDnuZJqgjxgSwgCfX4IfTFfb912/At66qBygsNU+rA2a7nZK5t+Vhlnm41tmgNaEk6xwoQiEH0+yBVpse9oXLETv8XcdfVPgDFA8t8yNrxq1aX9nn2SBuJGWcl+NpgdDZqvCb5I+5eOcD4OccuVtAkv4HInX6IVnQZxa1dy8tT0SFBpYYNHKhcnC3QURMtiJDHqmhq+B8SEJEeotUm+Wu083M7g6uqPNVcrlaMoAC5ML0zbmMqOoch3IqljAFh0mV6ufZejdQG0iexEIb6z23LvKfUAK45uJUr3YR0qrDvG9q3y3WyIuK8zTw8mH7wTukdMXDID4H9Ap3p4xgiYDmdoGA2xpaW9BzEuDc1GXrGESgee5kZrHPseXViL68CEEcdpIYz733QxeBPrkljwqj8rL4hfEuT329VjX+df06q0E7Gzgopvvh01+heBJOfCf5CEQXI9ht+GfiIbYwndaCOAhirexP62WFOe3n1YB/wmjIKhhH+EO7/jpK/itGLRrFrGaX+Dx6PtTvF+5dbhkUmjn9+KJkJvB7lKPfBEb4NPOw6W7i7+F/LyG86vU1WNa3Nnwuqc3oiw2bJl7XUSPqwbXDFltOVO5JyY2ZNQ1CWqNcLv8rl5Hj2U7eeUIFV9w0Th6gL8LR882Cdn+qCInrvujyWodRUEKXKNL7Vs/I3Ppg9QQAxL/VycP0xiBE+Bj0bOAOXtiktV5oWqivN2ymUG4BxRkmQOVr1qkwi8pDe1l6l/zrCN+5FXtDgqi6/zifVIJeVrsG56PIu8FTAjtb9KyKrfeVHBhyYcy7Lsb2PgrxQ4e/aZ6PRpEerzgSpq14kxg/5AUJrfwLX9qwg64vUZgUBj1V/S+yJvpNMimYEd53Z0ZFk0YEbtXDtMV91FNYUAenMnU9nJg1lv+2kafwPf2xtn35uNWBIgrZDs29MbHWliiIQhnlOnJrOt1zLu3Ugz/J5cATVsrqX/xlRsf1xHbBfgpo2nhdJ+HNR166K2V4XjMOZiWJUr1yY/WL/eBtT0PAWMz02PquK9jaX6NGW3rs6JTMcwtxrW9EeBb5/bptUS+0g0Y/Oyn2CAWf6UG/X4DeMmlRfDMJzEex1HwXgItDQ8mG74b31Jxw+hJJW4EZB+m4maB7sCVfzU2D1Gz2OV68hKSX8mnNJ4rgjZiL0JruxUKFvM2v1VwfuSSiaG9OhOZYQRysN2LaVzqyms7PTbWNHI1MXKQMQcGHZ1SvFuTKxsB9fL4WZ5P2b+ocfF4gGZfiewh2BsVibLTtiD7+wL8THePX0braucoW9bgb8U5ksKvjarTyQ/lAIG9h2JjRyb/qtzOBB/MJUKj+DNwlKJSKoHF2lQP0lJXbMeC7m3RJfbTldUD2IyzjCABqiR7Oqpfumo1rp/qFqeuJUwP0TgO0wbpivwVA7MJw1zlYY7Hil5ykPkwVw4neptra+E+buBclbLWgxohEpyXyU4E7IKXszr0dceZVYOw2VgO0BpB1qVaUZhqPEys8sHEw6yQjIkFFhnOQKGNi1t1gB0eMl28mg6LEKuhlnJhUX2JdypVcMVuZTLzdnSHUzhUR4kAfdGq7xlyEGWRFxIeYcofrJns1ltN41aUvVEo+QP/NOW1FvcKRq0/lIbt72MOrbxGb4oyzmk3awBS9dWyk9o90yVWr3R5U/twsvjOPPRbynVzBlAkObIoSr37jfxWW7De3yRvWP61HlDEiE3XS4LqC6jCk06E/Co8t+m9MaNmCLw/mXkMHmgh1RFdqN/Hg+Vq60rvHi69Mk91ifePqgkDZr/n42p3l2IjZA72diXkos3IhhqsRqmB904Xp9a9Fdy8oK8g+rsDT+I942Lg0PMXMbHZNRWBvse6lJLqDwP9SGD2q3V9uT6fbZzXPPcOtvkl/V3AlFPD6zydKL+nzNTGGly9k9XhDh1a4LdzB7+sxTVXwBlkPewFpnskSFXljBv2yRs2WNiFX6IpPkGt5bxhA13LsTMviU6OUb/Qse/vX+VVqPQwDX3R0E/T8L0gx5YyUWBN/sABHC7UnEwppDz9GKKpNUZVCXrjTn/dItpdRXdPTq2H+iB24Lavy6s+7/rgK6v0squw3T6vKdIByGNN0ihTAhSFbQJLAE2Vq/XXr7PHkk7HoUz48823VEXW5Xi+GveNoP8c50ca81RPd8I3F2XSi0sLVWgQ6rJ0Y1OHeqGKCMwkZrPKToAsimamK75uhGZLI1p5/Sk0pv76gkvEEUw+qOoY1D6hfXjk5UGszfIma7MwXJktJ0ygNXP9MmfqWbUsHgsKhMJxcJGI7zlTQcK83FOOVNXLtSh56EMPjK8lEjAXzlpzDSJSsuGup2nVtGV/osLU3n0JN+vcXuo3r/8sOEQ8szNQdDdqRGmF2aO3+wU9R7/m4rO6sxh1sbF+hXV267eumfDfpAJZFtBZD/iuIA4zBWKU4120zKNd0IGMoTegssPr5mHIMesV1MeDHfxOgA5Sfo8GIH4gMHJq5e8GQAqoZc3gHNFfVkHS8HXmPD3bRyk/hjymOM8gfBk3MrzRorf1InYJgUl4pe0pLM/V+l4I8gipFlw22x87W5cYfJi70+zMtv9d3wtkG6pFVH5UcEbFodsYcmVq3luyYjOO5XYz1NgSKNnwYY8CUAuhDxajMw/xiBiAhmzzOWjKxNdwRoHvaiBaD2A26JIlCEKJmMpT9MKQaPJDn44Xp7p+GBqif95Lj2AzDErw4kFpyw6kyjF1zt8JunVQeuJn8xFC4IcxTTEBQWowNlKmGF8dVSv+zp8E4f3XQKl9z8zd4fqz7CRtUXSEEP+lqq+NjvDG6ojpxyDdV8krSn/GdEUE7bbvBAK7uOBq9E9BBVgyYBpRpA06MxH0xYDbU6jXwTBGvrWA9kbP5hua/KwSkfAstOVXTWC+drwOGl+1GBBuwuFiehMtLyWY2f7yQd+sUChPGv5SqB//yYBzGfCoGzCs3m7NWOgLywYmU9k7YA8AQraB2ZAugmiU0L36kzHmaDFkmdzswPt51SMDvD+ZWApT9D0tMJukSVj+y9uGNuSib5qp3ICcMjTCLX4X5xgYLe5ZKF6G1cguFxtmjq/v7a+3x00Dn7Dvsdvg6U+vE2mDYIHKZAcYM+42ysd1UtSdS1NChqLFQtHOx2Qav9xhFrPs9BB3kiiKPu4VVZmm5+w+r+WBneU3hL609LfHKnY5CW+V6Zk+up6JXTPM0o6KRWY/0KJ3G7RU9YsjI0q6RgoMGE+7woRhoEAx8CYBrYpY3qp7MEwnp2AKVQatOZyIDLcznx9vOLIt5k5KDdCoLEHcqcqlMykesuElzl+RlIl5DSbrzxFEylEIo7ShPoHgVJZ2kcT8Qhg1vx/q4pEKQV1K3pp+wJRB4SWaxju7oE8IkaguoZYk7N753tHRw7i+V5Cmlf4l25SOegv+WTzM8W4Ke0ipAVOaQyhrgMk6bHHtPd3kXQxW88Rw0KnqrkwjsOLK1cphNJHYZbv1uhNV06oT/g2hszTDE95jEoqw7fU/+f9222+kN0+n3on9AC/RyzgQzxVMvijAg6SVm6UZxzy3YwPjVdFVZm85C3O0e/KvywUxiRAdHMGH0sdScTSd970Fha5RhBThezmYoGIYqobv2NfjBiovLQZrQXXuZPF8z39yBidc3kruc/wARWUl3dCPjZCsndSuoV0lFsbE27B3tDmGIFsqSA2dgK0hVWmGxxvg7UKM75CSiSoTKUSouuBGr7wE1k5CxuM5jjItJesQEFQmrz7bAGFgYte6mou4aJ9ygUoJAJ6qJh6W81o1sZFgF6hxjxyFhB5ydFQZI3FZooe0WQeF06TtnEoeKmnDckcoU4USYsfacjWNCvLAh72C/90A5NG6C+wBPtme/VyjP9/tz+y36/DXB57VLuqdZAWRDQ8AGy4HymxkFTwYaQyAvhvyyG76GJMFE6JBITfm4k9zR7vaNLLI8V1gGnzNSCItqV5UNcTsXTqZK9ss34xAF6K0PlsNPLWmOUa82n7tji80OSIzKAMS2+YgCPNx1qv0M6RNV6ljSQEjuxRKeEdXZ8w/RNl1kA6lEUDrEkGAuZ38A9hFFWyPKsebqHUZeSQYr077uo/Jp9+ZY/rXCncaQkFTGfMw5KVbQX1yPpaHMmChW4v1lKTnJwPftYcfG3kmiuCCOpZY8sdS5WjmaNi5LtJarnlb1SMbHZEVD56ADvY7xX/SAB9ELYNVY4ZdOuyxmEFxeHzv1oqACc1AgNJMO0shxE9/+dxOzUY35wjLUhkDaLplH+VcPSCwUadsyhahdNrIvsc3jt/cWXZHWHJzLhlh+0ngrlW0BLfEpEsAsKLlSFxNHNMb67vPhtL5Swpla4lO0KQEyH862/Rr0qOHtRdysYQxXO8YrEqFHtXel5nqn62InPIOHYOcbeoeZvnx5Z/amh3vKDnfDXSU8dCF18k/hdUEpcrN89pt7XhzQz3tXMGFH6YNrXLbQnYe/e+HQ/P2R5wm5yFeat61IfenpFRZNzKP5FQ/vwQfp1EPm/PRNYZAnMb/IfqBHSzvAVaADqgRhmOkkTkxGzWtrwc4mWtU8MpBOO8ztS2IrKKjTvmivKUZEVMv1WDuRpSVrpvmSINSEcMtiKVJYp6y56SSOjJXjM1+kd+KX2QKnlbaSmpjLcrpzYYO7AzIytQ1KNOnBtZGI7kCGWB/yD9xcMZYoNs74GBN8p3C1I/OpfNd4lQ96LmgJm7NjzbjrXXK708EWlAsuxm2h2VO4LorMmSZghtnKZPVCKvTbimpy1XAD4cAr1CH3WgHlXgK8v26LNsHPJ41AGJgnSmDpSP3dnYfzeVtJs/Ir9rRiEVgVkF/uEDKrFdgwBo0+6dONjSfECHEqE03Uj+bPyEig5t3GhNC6qS1hV+emz3QwGz19rIwCRPMx6qPAPVM7S08InzMOW1YNS3CH04bI+E4Pl2KDYUf6ecsQst0Le9n1NyTlxQbp2sE9pFGiF6jDAq1OpaJeVC1q9tYDywWbLW4PefKfLk2zdapt3i6J8MdttKr700/5Z24wI3k+fTMQB2fN2cTap2ZUBgZno1kQWpJpTUt5ysbacD/q8zez+F96H9t+o8f8EWm5JlSsDgKZKWaR+PZzvSHTbrKCIBg12ypF3hM8E5g5CffDZqrfKZkRnIMFRAC/Dc5+zgN6KrryPQ+tV+Gcm8Krixg/x7e4OiMR9QKe9HHZutbotEKWvxc//FkowItGtsT/EEdF9z8CeADP5XeEWoIDep/CXiDYM+Fm2Qom0Fxu0QvosphRz6mq0mQEi4RJ9EAPjWQD5plmX9lnXPc2I2rXp5tlRs/nypd6Cx206gL7yzF/FubILyWEc7VojZmpD91F+4zkPagjl8AFWL94+qteFYWjQRUPGvTKsKwMyMuVl1lm6/7xloiErDw+VZ5gNkj4lFlE1CBlpQYZzah+z4GuzLN4LHMwnAQZG0SU3WIkx4UnVNmODfqqPBf2jYqq1p5IB91YR+wpoiJDczy8Ulibd/8ueR62m5LYIlvs4Q899231hh93F2sxBkXgCtgvuSYKTGQK61a1wIJzZhveZbUODrWA0XxsRD85pbhHtQMU1a7BP6UaremZv4Lk0nPPxuozyjtfV5mKxcJNlg61iHONNOeg5wYxHbJeChhSGiz4sjZdPoNP9AxiTLIwwtH32bLsZP0WPaFJ3ctXc4TwBIIZLzRz9X6g3hkniGA+mWG1HHhk4Mr8i+yUSPfwJFRJzXchWoEhiaZY8SHgxWdjD8dXISXVBZEQzYahRoJlYEwv/PIlwrJl9zKq5hId6NqQ1qcThpHbkfvns1lQFZ0BT2TQuA9jFnVoMgJej7LYjLWxLOJjfAxT2I4ISkvA2lUp2ZtuhPcTWjL4OVcEdrBWF3B0PuOnq2ZHl1leHLys5+vsd5AEZELxTB2fY2mUFRq2xNevjsuqelehTTEAEStREOe6LNeYKU3Zj334oAUoh8oNNsAWXk3721NCUxa+s95EorHWHni3YEEZGvssnWta04DtZ3H1FJXijVVva2PBWrWxGAy9lQ1sPLP/I/5s2VyhpCANsNRcT93a2+SNmeY5oc/OIbX8zjZ7IaTWDSsYT+akC1DVS5j7hxCLYCFlonfUrCk83beS+GvulL1covyt5j8kIf1GxclvZmyH5+alstGuoS10h81Xx5EpqFP98zrSg7m1RkS1OWgVdLK7RZCqT75Eln5OaDVNo4rpMLwiPsKFGKIvjNrhvZiIa+uFkhavk6f8W3Ixhr5wgirovSO+hnjpWp0cT4rJ6FJvr8XWE4V5ft8PLibaCDyZh2Pbm6Ob9JI3Ht3ZcuP0zbIpiIA4O08EHHJEylYuXZkKfwt0X/5Znd01ejMqWgbHryGl7+1TnYuSkIj7YSvtmp8i5F+w3X5onH6lKk+EaQXbJ/AcDVrfu7htaGXPCildH/hKn4K8Oe19TQAdayYLVIjhm/KdyK4cYRRBiR+3m1S4k0Ys5xfz+8MvkeM/8IB3ysg3+UDotUToc16kAbNFtPuUqSgaT1ZbRd/0BBdyKicTbbefFGE8q+Yz84/oU55jQY1AMBQcDhhMm0amAmbrWOIsrfjjo0kCdfmeB0ARpPM5qEX/Pibd3TpsPVDHM8d0FgDGSWdWRbWvcYGEdONSuRUe8OCfs8ukx8vJIKySEMa0WBzYfGyyeZ8lhVAgHb4znIU7RYYIi0qjD7aj6W5b9dkj/GC6AP7LCFt/htiVQTGAVXuHWLAiYlKUT26PAQd52YGFWujmlE1/Kj6Pyz96jRfROtHrV2PGuaEkFYlsuDoRBWbFC8FoJNKAiChXfFmKCQiiGGqKBAu/zB9LHoyucqr5cLlBym8lRqXdZSlv29d1mWG2EmWlzU7XSxTavUWnM/QEvxJ4m10Mk5mwZvdWxLybPhy2ffb1H3X8dcQAHtA3LF8kMC7sZ3MGAGYzNLfrrNaxQUug5PP90jQxvTGDnSes792nDsiCM1iYSIJ9eqJbqFceZ3XnRjJztIxk0A0jBte8clppSr0IUAJ595lQXitJhY9sGM/ZaItFvEw8i8jQBWqxG2McVRy6liLjUtYdCvnktVr1F/bagDCX0IvrKUHhKvYRVyma2lctr7rXI/mHd64+hbvEXM005V3BolShyDO1zgto0/QvoXQDI+N6tj0aC8FE/ViSvws/e6yz9GlRskS4jZHfnBMw+O77XfblQiQHyl3chFxeDg1MGe20jN0vWZ3ZX8dpM5n2ww4ZGdBnIpOk5IedW8p2oTFDcJF4mxKrwjRoSr5IEx5UJh/2Edpb4Nvbmp09T7+FU0RscPy5V4URJm+pKUmPuNx/RQqRfCSG3MnFXb5mUCU0mZ8IyqUxTTmfRGRqTGQ8ETuysuIQi23quajX/IlvLZpuaO49RPKeH9xrOz2nJ38Y/8Ye6r1q3BM322ACSdpBZZ1tF3o3KGYui3qvsGNqauKIN3svdYfZLjnrv62swg82dCftgfJBJknmBgjxVLhiEV69OwRduPih2D2K8xXJOpLyEVqzia6PxuEvusDf5XVSvpfZkk2dTOrm7XERTgHC3m5wlJWb6pOp9nWcHXYlam6vlSPMYHEOvcYQJGZrj/20iTyvvcfjS7+4lCorshMtOXB93+b9A45GFyhiw+jNvvFlSzyLXa6MqZWmuGopskKHkacSU/bhbrEoanhXmvIJy05T259QeVG/Ac9EXjUceO+CCBIFVThNxVB0dL8irENM5owQzA8MkTrhdwInKAe4nU8v93jOiYB9m+AZlxw6z83zfH6Nm0d2eZd6oF/EkxA3W3sgJRX1umAJ4mVrfFs2E5AjIc9syWRLdED2rY26ftOAd2FoEGLVbFQ4etvJ2N7uMDFQoCav2NJh3XqEKHy8Y1T2AICWekPGg6D2Tk8TeJynF8NwzOAQHPAfUUaf5Qdhwzew5CgNMHVnjveWJ96TpDXTanvMRlyDa6Lpk6Scslq9ctGagqTysd/uHhuQIeQPtFn1nk/TTUTJaTmvRWYNSGJnvXhgrT3n/hDk5zm71CC0pxYL4M/4/X6LSCb9NYJl5HA9Nx51A7+kcgYoevGhwiS2dOe263VR/h4L7izWh3DNzfzCkwcD49UV5codFf/LpWAn4q6IEZ/pW+TpPo6AbLDsJzQI+mtssDraq7+OgxQ8iysK3DCqGOK/Yt3LpMpa7WzLOIOYkFemFHFHoKXWrb2LwR/tvmDm/6LUjJdDR12l6sTHY9QmXMefKEL8Sgn7osYiz7Vf67ZflgwscmL/opTZLGjsNThtsRAF4ToNNMtZi9OvvBjGe1/Nj2D7yZud3p75rE/gmxxiRT/25qBSrWpdwrFaaSodBEokxa5sqGD2yh3TBWsHXjWNVuheBz0KkslApsV3oBtuHlaMflgaOXlP7E4pwPexaJJUQ5YubaiiaccWEgYPjh/Tib0+AnxniIZt/AGv0vuY1KVcFRTPIvjAciEy4Kb7xkQlIdtbmjwxfCA1dUVqP/2oWOTO9AfP07cHMNC7tRkiV56yPq5VLz18wBtZFYo+Il8N4nHTuBXI+zQTZd0pE5w3j3ixIREDZEVeItIp8+zh8cB42W27HCX+x2i8sA5W7tHA58RG3hM0NexSfF+hpWW9eia4Jl4VggzK+NGPA2+Ynw8eQO6z/sPGbQJk0gQFSs4tof2IRWYvp17Oy9H/s+rAflLwf49ad8KPj7zSx7lhi8PRtjI5qaeW6vIfKKhKbmfUwMutrTYMCo3uXexW2b4TI6S0kQ3Z6fgP9CPIIPgwl7vT2ZQqQPOnFl8U1iw2tCEA87nMEYq4Yxb6T6SN6ILWv3KYWNfxwznxuYI46Pmp+9yt8XSDREzU3hImzvh0IoUAXlI+EYlXDT55lCJJTUc6yx8VNkq752UtttwfAav7YBU2W5IY/Ejfu5hsQJDa4V/ZayrwYELE2ZR+5I9FmJEtKVpgWIngUWTdV/ZWldBsUibyke+5Ist4lnFrxI7lI+2ooNslAgoa+TWVqlx1loJOIoUexCrSo4CtzxqjZ4A0CjAemcC10QutZIKBlI2m9atWBZVI/OOq0nxH9WccgpgNF8fLxzpbS4ogpCJvGdLTtk2cvUm2GrweB8QHpmI5C9AlEMteAxRpyaEzXxaO6rnZMa0dPaCPpt/2Czi8CUxMvrIqYSgw5M3e1xeAgTLPZwp6/p/QeXuwy3DmcOIoROmSQowkfgRmonOmsC7T1g6kNZkGsgLVEpWqOOE2jaRXFyKnJKJM0039vj4/R/DB6gBWI81TAf4NIsU8bZnWzQhHEu5jladwlDdwvNPmu2/XWonNjr+TdGPbkaOW5plmhuS/DzZMroRO3VC/bOoq/A8wKHkiWSEozCL2GjWdPuXbFQFBu5yTxqrG8feBcRkP9E0Nzwvb817dWtMOYOmIZlnr7CNuOJE542kohUIS0HUSXOXF/fhXlIu8lfq1m7sb3pYrG5X9Uh2dRXtUuVRmD/ZK6ZgSL+d/6TpNZ+BEDdp/76FKOWacDikpemncaftTx//iRwIQJSfK14ELjWXZN1Tp4Cb9lWN17bZUyBhPNzKYyk0GvVdqVtHzOuSt8o/mOxQNa7/xsTC4Vq8E9zCFbV6aV6iE9V28btSRKWOeYCS43FKElLcSrZawD16OJStrShODCLcaOnZG+ZctbQwKhtYtAqMZ7HhjM3RNNzIkKdGyzK9M+ebO4CKFF4iJEq6F8MCaMhASlW7QG46tM14azbE63MBHnziGvZKvPZtYM69nMRhl+qbEfa5uUrsx/1pFq0uq4UkEIpBYHrFCpGdvzEijqGN8ga4DYYjbV40lLnFIrOMrirYCVpBHIKnXG3jwfFiZJH8mHjmls3WqVLZAmRAuYSjTqWqF7fZp0YPIY3hykE7YWqons8SC0BCNlQBno7nNoE0mRm37v3zQZIV8QwoEySTuNuWwUg3+XiTmfVFxzFvzY8YPYpVx7US2GpcQjWVXbjpN6KWRZXvfKvj4s+xU/bOiZZclU6wXw6N2SwU+w2Xfe7aKAFNMN/1Vfs2UH3s2fxjcxccJcvrDWVi0de/Q587kGYQ6IgOnv6ISfs1bIyykO5Mezy2Oi3k1Bm76GKCUiJfqWeDmQHnWe4xDBYA8CVNdnI8Ts/LRKhVCY3JmzAGTU8FSlILE2qlqe+P5HqXgcyEDEFKqInls1dz8CZXW3HQ7Ve2vtdOUtfbMHB+smKKCfFXI/0ScmFlFtU3WySATdpABOHMAzGyP1k/xOfsze42mCdvWN9p0ybRjB6RaQw9YFShIILZdEgC6gEznVElFrM69Qsm/vYCNNIROGiCTttw2wqY1w3IWlbki3egC1gioTnKpI6kcuhxIotjM2Gazj2Oi2Hu3NWfxxIS/CfD/bxg9NpsIqrwu5lZRz8OSXl+998zd+a0Ciw0HrPW8BuyEtAje1dPhLZ9vJZ78rc2nBpxkeEmCAJ8zyVUGfbHShKGBP25GOc9ODoACML7VbIUoM7/fGqMwcQ3GMqf20he3fLNRv8MMUks0sutB0DLM3Nn43hjZo9Hf0Nwtl114pOhsM2dfvMjfzRicN180NroupO1GXgIIfrPtUglWUX9FXJ2mE6RSaVKUSaJYuHiyr34jxsElWtXUn+CHCBAQQ7cLxCwNLF5YSWBKOx3pk67X/3CrXxcheJisAL7MlCSCQrq1hZmFzpkSqRDLv5sbU0O0HsAxQkjtPFTgT0FkLyTRiKfckBM1ZNk9pGcGkkwOpaMBNb93WRTwbJhAMCUgsq6kvCVL5rWxEzJPUxoLjTD/U2+l0b4690Kr6h6D7c6X/S+IU5KElxomsmzSMjqFq8iHa9Qf+H9MC1uXl1FhMnI8ojDzGBFqACJmaO065R8w+0GYRdpVM6+452Z7nOdAIVZx49tRyXlXBZj4U7kJ/ENDXf7oeGkdKz6IQOWlZARD8ze+EV+1QDBVQTtXmBser5FWNX0h7X2DdD5jKF8jMqpLOpFVbI2KgvFZCRdSfQWUT14M9nSkHmu/eU96HLsMNd3gujVfKXpoj8f6DYva83UNoqdE1EXGCmQ+fD8NX2ZNlqnEajN8g37BqAIC3LKZV6SDPRKl/GkWpOBYQG9TwZaQ4qE3edbd0+60PhPRZAK5DzPPNDGznRXAFNTRe7mJuMttxTL8QrtwsUn1uNva/DkvsgVpmzmdkGrP8zls6Jl80Q9blIYGaxXB5vKK5hvpQu63QH2sbVWeP5mjo6kJR7XQmWVpRFg2T1uWLxodqCFHe9m+SG+g59c/TsPCHblsko5/b6l1RijLxb8jpTYtqs1xVj69O4X+LaWYSId+WjKTLO+d6N/3gVhEjWLdyXXXmLc4BWPDMn6sSxAakDwQdld1j4SujQp+rKcVv/mw63iAB8MjwiqvTGPsHoOarVnsY4BOHCrrOQh0Ddv1VRnYnQkjhZYfzKcwfkqYsckfR7thJm1QBi5Hx89GfHrMUsc/i4XQQuvdBtMiMZfULkBBmDf+GhGoaSpX9yIaGnuQqVnsTXuXLNxAhWnmhzNIsI0uAKso8Ufxn9ZYsDfp0bTbmcM0E3vGYJwuXQq8/AQ9ogkV86AO9NFQSJylsE1kbYDgAXMdOMhmkfIaFqWY4t3Y7KNX9bYzLn/JlCVhwHrutigbIMyq3DtaPFWNOqQlDynmeQxmOYii0tOBmojxfDew9yEbIJxPFxxnNzdUuEPtpRyvIA3y1UvU6tVnHz2/YTxwfJe5jByCozBIX9arJFbN9pLWwwSwCwjzJDybJY2VDNsY/HsX306PjNetVDJxJVw2Z4hqSgqdl0Vo69zhlFLI0+Mvm6q5eX+c6eC0IsYg/R6Xm0K927uDhV1mxhgr8B6VTXyYS/RgwjLa3CCjWV730zh/rLzMpkyzEKA5a340vmGqNBMw+W7MUOzTHARCZ062+DfzFLf1u6c0s8pMNBN4a9wZKBb9csfBUqSNKKLG10sWgCtYSxzRkG8N1Q8zZGtihMWQb0JkjDdBGCLyrJ93gwFHJVV56LHNBmwh+cYn1UDZfPFmptzx+RfmP7VjgNJBatImVqGVJHuvrf49N2ukPRvkZ+PROtUBHlkPDqTurRSlrjHvAoDnOxj8haRqVX/iZ3CgK/zZ8laT84/KV65ZTv3WXpXzu2wTFcPbpJC5avOKmJ9+ABjP961/c1V4SoEpxrZm1lvxBA8FfmtZOIS/xn1Eaf3Wx+3u5pb/DKmg3nHBEJ1smT5LrUqPGPCxObNDXinwPZdclZ5qr2Esq4NSxdgoUJfcaqGJUtcij3oZnKpGMn5Tq60jpWppAQxdT1io7u9GS+samSPYTLarv+UuFHqFLMGzp5oyJs8Z9badIrAJ8odrk7lJ02LN0uImidXkiYKLEDAXFmirMUfNwlSjJlRGuBEPnoYAR+xNfYj2D/k+AKN9N+ZqbEBUt6QZ4DtlfbC37l2fawhlG+z1KfE8/YbqstZpwg8bHtuhq/NKEkARLJCKS6v4XiowjyvVF5S7mDM9liAuAHKMhqhxY+S9n7YBZ/Yb4gZH8tWXVwQqKeqYtglWXi131Dl08iKlVqKhpFIekAJDB89gggD6H0RNzEgPDEKopmiUymC03oBM187bzjV4Xm+fSxR9L8XK76wPomACsaagx+vyKQomVVdoGyn7w4BdA/PjkB0ZPIaIIFbrF704iaympK9t1SXITPTJ1UXMvYwrciAU9HJ1M++3Peb1umge7HBFVVasZNGrcPMDmIdWF09j3lQM5P8UUDxYRxufpJeqG1lF4F/x+U54Ozg9zqj2LLIKeltPv70bNcT6wacMNmN3ncDP6WtYg1Hlva3gCO2Nl/9VxrWf1fi/pJUshZ1prt4GNj//9k2B0oXgZeL9M1OteQsd9CPOYVWM4sUKF2BHcjHi7MsEXIhibLev7tMuGXm93yGoG21hJBbevYR/7fgh5H/d1ldVi6Tdp2LpwceexBYU9VGR6f6rksxyO/8dybK7IFIRtViB4gucCgbrzXMUItnSKcbGzrtL7RCqcwUXi3K4TAUs9NrjJ2AflK8NZB8Dv+AMzVjXWgTnW0SEzZHUPSAxWCbMkr0Dt0lG1C+L/5R7Dje2D5vcLtMLuuMDlqXm4i9cxG4C73bGO12JQuvCAnMW0dgw3L6Rb0N+kq+RFzY0t1WkPIavrIkaG3NsAf+TwKO1uOYVkd524ZfPDZynriXr5bKoCU9AoWrTqr8sdv0dMmxpKmAYgNxtZ4XPH1TF/jwUWrl8296iFZhlWOpFNhEOfnVUtLjgzxG9V2JLpxXQ/svgioLJOmCJ1pHQQkWzq2Baae7h/znGawmVeavKUZY6cPEP+IaCwgzwGseO5hqWd2EH7Z5gZIcuRQzW8jYZSjP/TRlQ0LT5Hk1zz6z08eHD0PScIAJcy6RzaLXm0ZEGB1EqCoHDAWtD2OaVda/6BwgtQ6dCTNg3tNzoPhUncNvMBucFcG4XZ9ZtXN+hfYUJuCCFt01Q9fH+RyhmH2ppFtrzbTyY9rEjrDNtn7Uq18381yW9dobEoh+wFRK3xDq2n6bzSVkUFpWouYY6uPZxA4cIAOZ0mL6IvkcMtkk482CJSGZsOFPTOnWoGyZ5BJ2l8ydpI+BMp+aK4hCDpKrGzvVB0s67qzVTJnWOokVHYx8jxjqvyM5iVxFOs6gDSaXjPMSzNbfrOOvCczjI/LkFQ7HaC/p4eWVJZxmCEK/0qdqs+xZva1KiohkBVZVYBsIsybZiFatQfAYnU2EFOT4Biv05Dc3Yea9GNfbUrNu3x+3QXGcXDxWhHK3RXTr6yZYR0sQCq1O5qBumJ6ehlS3t67rmVFLUCM1TvguDMq16KodbqxVnreAtYPbob4jJ9XPIw73B7JKSM7zDClkmLV0Lf6L/lSFDNZmNIUhA8AgOhSw+/aZCtBe63q1BHPGo02uSR6d4jJ5UA5bkhp43T/7x1wlfMcsyxVtLlYApVeiRCpEDK52/BOXS5J+Ohi7kb23RUE+8DYt/HJxZ7OrUiIEpXIZ4sDJT71EE1bvAsNH5UKTyXnRDaOsjhXCgwrL2bfiMF5ah1yGZBc6UAImKGvs5nyTJFZ/nS54OMRY8uBydiSLGTSNKpoQEeOxTOPak9veohowARza40gKPkKIukkk2y9pMBkY5QPQB+qLYrGprhU92+g5YD7GpcGibf4Jnuwujo1tscjvkjDL3V0x+3hHkykUuUoUKqcFHCWpN7nMzpH0c6xGQvuGVjWtElYAyw1+vKT0O39inQX9LY2IfhtMsOYNT45SkTeRjq2idEmRj8CTncPD++HLLZGxJC0JwkAo2cAYJMuf8pzSoQQ5tERbtOmwhhhY1LPlBuFC8sCB0lP8QIbv/ssI86TVi0BzQjEWTpdJ/3tgi3oyMvXGlDLlzAs1FQnIKY/fdrJjPujF396/rYiyuMlEASLA6q8sZH9KXFmyYI0JubraQhfo2MjqHwbMZp9Y0f0/EQX9kOQN4815VEKsWvhLwBVsrF5l1ulnHjHOhsWxQkDwKqpBMJe8jlWa6ka672RGX1Cc/O1dKbZB5ABaAqODZpVWiTWxQtQzRpEM0cTjiU+/F7VwI8Um3Sb/tdaTLMqxHd5z0NiCvSUl6kM8Nr+0DI3lMDKpGWLm2snXWMdoRSLkEzMmQYNnNQfuTZKmJy//kfRSVjXy2TVZFeHav707sO9o0ySaVe/mpeNauAA3JxtgOcSnb/RSPiKNNelejMUqpEedef9jx8WMzzFi+cThCZ9HYa2KoZg1Cpopxm3fowruszpv2x35d5WGSlzpIQFLszb1NksRL9sloPszGLelSAAdb/Xa3B2u4LhL5ZU5jAPZBNPQtMO3xgQHbFAL/7zqYpx3fv4G4UCrLkOkC766FdkNs4UkulgEpuyT5hL7xQW/xrTy0OK6zVObmpaGlqNWerGmY7SNN8I/mlYAR1GxaupU/vIvGIWFe41WYVL4y0onw9D8SkOWWmF3rTwdN+6Pq6j0Jw+G8Nr6ypBELa2R6slD8DbqzI9n+lRdjsQXVgfTzZBurIsZOsFw1/NwHxeYT/jJDPrsQv8FPxf98rPyBCsfgA9z0JQdQO791GBfXdnVqRhCdmZTYmXrlAhK4aeyAua05C4cE8YQTymbkuO++XmNLWeC6AzHILRke1x6yewWsohoNU1ZWAZ1hWy5rc7YGyMDS+mHX2sXfGeiFbrxxeJwi/WY5SvC+xaDaAObLDrtoTkWgUAHl6wbiaeg8FkwjnN+Fu3/ny/LU0IZk2OtqIRch5INBhyqlm1VyYUIh7m7gMf6pLxkRna+OjT9nrdS1++h1d1Kv9IaVXRs58hGT2UPm3WvJ3vhDurmJDtRZhpmrOpJFTUHBTjL1DLANoI0kvIX8lN6Yk/6bZG/YMLTc89AspsL+OO3MyNt840cAj3p2VreGQXXVwjAGLfHC3YSbNZQ7yttqQ0qnKLagW/nXN/k63EVKxRXSeiMVGsF8oSY8PjP33wh2Nuc5wGtogc1lVtFSAlpvmgllfCsxMF+y2kZlCUuue4+YgMS2T+deMiuEWHJaRYOpQR8pCjk/OYyTWb0Lge481pQP3QdIWVCiz3Ndj0OKmCYODQhZ1VPj+iDYKcpKIeI8HPi8H8xgqHN5sHrzQij5Tz3BnVf34w0hcoaGfu+TAEOs50UXIq9MCFTgNOd4nHoGeh/VfcrCRjELFyDn2tbnCYOi/tVw5hDhrgfHk0A27pIa7hSt7+mZmaIikwpx8UN/r7iK89P6r7yyHTafDQW1W2cy5GnniC2yVp6vBWWjGAouFAe1EDqryHm/jd8cmMqmeZXDrR/SDZOb2+FsdLgWUJAlucMgKFz/rwvWmWzZAM/Y5cetBUBJgXCjabkWaryFNMUCaKQLV1VTLgxbZZqgN9kV3yXMn3EhnjUn0Tbyl20pUbo+jwsZ0oo05t2brdIN7LClhRfs318DbPpeHmHdcP9T3JJ9SE38N4eifCnyKG70bPIWE7KTjuFyowhtv7tN6CPVAgUnqP7NiKrlpzkYTRSSu47mk8zRWcDjE3yfQNj+PSxA+GaVdWNcLRYuK1f3KVqQHNYX00ecsEGbKciCZXOdZmAB3HPNRaypQlYj0NnNKXIdRzpMXB4JsjLAM0Al3lUxl0+biFFNerJLOwG0g2/8vzTq8S/kaUihw3w9uPakM4KmbxxpghFDdI5HcqP32VMMzhqm1+a8oJeWhfm8YJu3BhPDTNr0ZWYJcMTowj2dWadkx5W0Z/jEYue0HcKYS2ayN9V+KJiMtYz/iyFU+rGtZg2SsHQAmWSBTCdO31Zpbu2xS5YIvvbfmsg6Xe3wqTzNriosbMWXfIxXD6gPfT+soFWFmLAmFO+FqlL6wER6LhF1jMMLL5wqlFrKawhfJdGFMdy6WpsbXtS2koaLJ7C0UyJhNspPRB8qW8Ps2Pus34arRrJ5YuZrco7EGidsNCT5dQBlMUZqJBFPqbOOFuGrfasyrRrNQuEBgE8qZubX8+l0LZ452dgqdsEu4y6g6w2iVe1HzW/PDNNu4Al/5bH2H/3KucxLxrXqlugSnDLGb2vitpHhmCtLR4KT/wsmYkP5hr2X8Sx/cZQWCJ9kAuRY1QiePuAqbiwi3RprbKoalyIKmBgXOqrDHYYYoXFWWNf4kFYzahDu/iFAf1pXcyVeQ3Mx2A7GzrKiX+kTHTLmrGUuGm2yE5dmWpnVQ6d0XjLJ/Si7Idl1J4ixHQed1CqYJFnx6R3L/UY3OJSriP7thOXFwJHZL7KhpXBJYBYQsUP9W0IzvSy9Ud9v3jiohcmhNoSUM894vF926hV245Hh1OKrCl4NLlBTrLzKipcI8kRD7aUIBEOSNMZK/pL36CS4o57iffwHQVT1PtNSnVK5x1vckpCnCe56uMccOZlsXHxJ2/fiG69BHHujsDeyBGDUnoIItAjT8udlzsXHwtXssVm3kdTvlG0R1Rl/dnkee1T7nOHBLe1+FfRtOTgJGv3htL1fYfGxo4Ryt5s3laht4gqiyv+KkjmWK7XZ1hjJfuIf1yaOjR1qYm1ixfE6QxhwSzlGS0dJDClHFCD46gpplrmK/n685qsbkADF2Sdxcp7jlrGF3fCvbuGuuaGMKCk9uDF09L0YdlIUayhoI2fUmmP95xRKxx+rXJZ5oDCKZhaZuIuxQoIzK6S9CerbZWoF+LE7hNxba48gqZOwGgrKgdu/Qzx2QDUN0dPEgrzXnQGKk2EjDCVnGugccZcJrakerbl0gN/ort/ThdS1vWyYl6Lf6g/e2OoEIfKg9i04bGrOYjb/jf/jd0rD0kCGVMja5vqcJJCNfejNjTTL6bGaLbNFQwIBgArjVafS/mtaf3PzZjEvOLqfmkg9QK3LGh+9W8U/3uRw0MBt2aW3evygv7kBMTP/8Pv199uZYMxu96xskYua23NQazaIWOjnaah/D+h3SV77e3hImhf3FTT8GijAlEwm+ApyC4fwF3Hhth7BmOO9JCk9gsoLsIgoUL8BVpbZe0hwJVbPSOYI/jyvdRKqODgj+7frccppTGtn/8eSATMUnUqkyq2EtGm6S5eEyO7fiIvJG2zoVIlLUy87h0Goc3T8nrZKAcFz6QYgxyVZHc81ZXie7nd6jyawOEeRhe2R7gH4tEtlW+nweuBepU1jKaMh2eNWqh6FNF/LilgxhusEHeXm6HhvsKSSXEvmubv8tuq08CXX9yZRKhdCwYKvWSv9kA9b0CeRv6bWCodyO0tiTgiH5d78P5Uu00zuY7pTVfLT9zS/l50vdPdaWOjO9ufBWZK8cPvLKaajfGTKeWubuluFrgaKCqXNuEOV/WTVtjT4juMDpnd158/bzKAxxVLpj8Les2umuQhj2DM2NCHFRLyk/eWRLE/2VGZJvffhNG0rEQIidiy3Us8PhZ2O+VQZjDsPoRH7QdfsMT13ku1M09Kd4Cj0VjOb1uDk7eAgYWXamKIAsvPAU29PLccndKE4bsae8FMJ8egakuMGhP/Bdb8rhxWpdbS9NiHWRZziGUHDMyAHRjdKNYObDlfERbd0u1ekfygz4z/5kWdKX1xjJnfvqCSRhJe4ag3V5TKl0Me9+OATtyxAvWby/Sy+7PrU6waji5FX1iUAy5Cft9uJktntiVazlJfsoUikwfx6Eb9HLYKFGZ04xi90tw8B7BiFEXWeZICRVoDegWZ3lnR8ci3AKu/OgYDZfDvbk+UriAefpG6utV0HZSTPhUHsS3imbc8Rv6TtFHrfe0aAMU7yQSGKTP8hf4VpwWEIjMQGK5t2ucXDetnTJUpPQ8YkXG1b6pYQgKxI8zIlHLb1NK23RqHiHFzQ75gnWrslqMGKk0ZQEHVIADML2ITZEko4WUFZt59JUZ5LREeH7dvCJ8D3h3VsfLQK9eihGt/cjArBneoWyZdFe9+4EWqNEte8N8OXq3eH7UQJFXYT+gnB+cG8RzRhEW/yitVLcL6rT5o3c4/0ijyEVLmN1WUbBeKBhg+C0Orub9Vrb533Lj+qvtVdp6inObmi5K+SlnkY5/SGWJsS84c1dcxUEArKdOrrRiouYgzXJEyFYbdgyg3ANLrq8ufMhkxOKmteA8+hytzzd8D7b6nRyBzBL3tL6CQvn8qqQ00smNIaWg0GbhCRv6fJ/CBCLMGdNugDioTiMQHgzkfdtfBQZaByB8A2/8sAHotFcpxls70awrjEX20T3hPLmVt2WBEkx7hAha6k/5S0VFQVQy1oUe1WCiRi972UqZZ/P8hsykr3LzoVe6ZU2jyuhtbs4FsItWu9Y1UEW0DBMi0WhnvbbDXCaoggJjG9fK3n5NTh0TGKan+rca1Vc8bIgxzzi7cYSKKIB5b7+uT3AL1WrmVk8De3jDVMh8XTHPWcm7ZbPnmVmP740ZeecO5q3f2JJc3i0U278nFqSX7wFnusIucuGEvyMGSC05Xuk8eoFdL2bFfHoGyqBllVOnJlLoGkJsIDeS9tVQcHrlyD/xgqja7Q0z4ens6/8N6WLLeVZV5+cZ56UtA28+eKSh6q0ZExKy5Qs6tjEB3DyOYwLbZD6UkPa41L+sLM/i4XL+57o2vaIu0W8kjVZI+4eIo/H0Y9DraHWRkvNFApO/azwLNE80WowbmHK/4KUtxUS3TyfMcH9JKxKfwTphI1VyNlNwq0o7ai93OpjsVBUezSvJu38Rn1FUf09m06CoZoLWmAFo+IXhyyVwNKMa7lo0k7/7imynSHtaim4nkWzD+SmVesd3wTIdurMW+UUI/LB+EKEnWSJvPxYJQeNip1AviRDZzRIR1CXNwlW2ouclPUo3i6KLgV2tmz/wyqhzl8vykNVsToJIX/tZeMHGTqr4WrFhvaGrmpiVNdEgbSU7w+xMeVVwS/4ApBqleyjJGtKm3/L6PJ/mlNhzRKFKaYO249N+kCVd46feCP6ZJkHz7duYGe4DHSo7k+75qi1hARP4eeivd6Y+2nOZW9RXoRXCRpReDlSWcUv+hxFV4RwfL3itDzGhID3lP4GCGWgfG9yyUyMS5OY5EgiyUAxk9U/zuy17fGDzqHZAHhR1wL5sYN9iyLDtKRv9aXnqpV0BS9SdiaPPVTltr/+5UOFx6+o9ozTmGj8DMeRMZzuSxj/ZdToiziRg6NFgyth47bnuPxqfLBjfC2HyjMlCB4Jv4rGeSgjRsOnw0uygZVJ7Wr4RlsuVIe2CzgBxI9rGcOUOXPnSD4A4PrlHsouSwn2KS8IP1EJdN9DNkYC4PFLcLigEfBuejwCU7bcRCGKmcVK9m4CM9USCqeJkiQvYG06Cz0GlyQA3QQcuf0SSSavmATdpGdYKuMIm77CZRX4S9rrRgwEXqmcSzsFc0bFfb/GKPJUdaGALyzWDpwm2pMgPE5K0KFoXEn5FJWlwAC/a9+oypukLmwzphIJt2VO12Tiso/kwBalfIDjbX+xjACCof/7DwCrhDgrGstIyOGh+epIBi8KWAFea2T3qn7VLdA5xxABDKb9zGmodb7yn9MQV3LoIqBp1Lcw7wuUW9K95pPWNkE2iZ6iffJ+9nA6l2vYzdtQd4T5fZ3ML752zuU3l0Ko5c7aMa38OyLtvP4nCg87jCJq4PsMM9AXqTQbknZlFT3tPvvpfw+YkWIdBydfyh7Zwgdfp3t/FGF4jvdvgcGOkpR8m0LcP1Na2Z8tSGACPBP6/+hkQH3qvdWoSHtCScIAOf5UQPl95ZW14pNIHhhqz0sX3aqWjQPdSC2diJWt5zxbmIym1G58wKz2g1holkvTqPiU2ngaf3sIsAHhOja0tUlZcRgIsN63F4uiO4iplKdIZ/JcfM1RIFaXwKyqq99DREtB+NKG83y7TYqoQSl3aNaY7wza+G+zu08bodU5txFVoAOBB1K45YXk244haiBsUcF8mkPKTRcD2emVTk8YPJ3S2JlzXxWyzCiAfkjxfzaLgU5RAWB76wCjS+RAOVL+4N3rHRfSc7msCuhR65d8YJUABv3wO/jOIJsA69AlA8PMYLNuEIok0FWpINGBwQkG4WlKfjlHjqtZIPzkS3f1TPcHaV+IaLMEk5tDnsnC/ZQott/zXt9GLH1fwaBA8WAu3IujA0HMoRJ/wjg5Ql4rduocuoYRcumnycf1q7UMHCtvHhwPgNEjHiVL1jf+iOyLct6jl7axIfz/85sl7079E4DBITRIJpwZXwskmOklKKN9eVeJLKmdO8k9GnAzAVkRdu8sPofDSrZCDmpDpAY3MB0n6IDANg7unb+mP7dNI2TdcZgnYIQYB/B8AJgO5bQ5VfZ1tkOJlPOU9zbHAC9W+1q6nUytWmG7qNk3e2A7oJkr5bMOThEeZEgxiP4Ql23rw4bslWhriLIMGhQsJy8LFjLMsZiXfWs/okIU1tROPKwFG7lAqZ/igedoExygJnq3J0deSrisYpf83K2NZXicZuIu19RZThC0fVQDR728Wd/sIBH09O4BtKDC830kkZKSg075rUU04vlmb4RuwPegA9pOLsU8mUPeIHHoIoUhsIfRadO0g3XPR+0CMTMwhlUolUBrrogyHgdi5ZGABGMCWSonclgORVoyoFLQ6pCypo34z4+l2isdc51qqUiv76xD5Z/VBV7ngDH6qnsuT590ko8VqnP+9zp1ARlwPkdTsaNaIZofZbEjHLa2LXbYuQFOOLHdEnTepPY6vq12gTXWGddwOLGxjPc8H1K7iX81ZY2DKQItz7BaA4kI19RiQUaPA82doVX+NENQvAtlpBmGFYzxh1vaOD6M76FUee9Ny7e0RFLrGrlrXBCAiak6yIK0rw49Se2B/X4Y6tkVOFQHUHAHFr9+nRR84sqHCOJFP+sCag2Qpja6ecJPGLz/Pdt6PVaGedgTF+MZNfnv2lptpYwcf9BwLFmNhPlur1yhGtBnvUp0VPqFPNZEq9nUUDBXUuD51DHf0OEb7wE3S3X6LJfxXIDznQnuPcOXqEQVJBC/mYBpFpuDPMLtSEq4RNS7DuJJol/rc2TsQ7g/JlwJN95qP7tRl9InR9GDJ2fo/M5uMfiIUhkU2zbqlrxLEvtrvATEV2C5n+Vqq1Xv10FgpY9u/VzwcsOkjCMPLKupmKPfN3EcMksncY5TFkMo5Ozs3+/kCDVeKnxOS0zKd3LKgbs3N9ZVEnD7VLBGwb3H7v98NZuZYw5DlK+E9AcYPhRAJQqrlOWJFOBliVsAVqbDeOXczUYjxbsgjkGf44dBCYXfVMHuKBjRO3s64fATKo+HeuIZW9zZZpM2hfqLjYDpDij1gUUV9ntn25K29M1wDmt9stdAvDNymAHLRJz5N6jtOsK1AHq+vXUGkmkNtUIrBEXSw9OLvIUQQfxT52wjWmEjli3PGTFAvqmqaUyyfnvyjyosyGlgaOpYK3gUzndyABgCf2qThCTyyeSQ22SJAvCU+NRnjarLaD+NgcrkOcFAshFSaCTDtUh3rdVuNzGNUfVJHC1oKA5792LDZoVDXoUuMh1PvfsmGu48f97gPGDqu17/YmiipwsdwDdPzkPXgaLYQdii8rbOLBf2T0LVZyT2ZDjd53Wx7WuK0n918gedGKFHbiBqAeCNM6bJtQRSKVpy19S10FV92XgHOANLjX+6xKqVENBH6Sk7KfZZ3QIXTdpHo2O7keZrnEHJOGdihg7013ZWU/JKku7VxSF2uuget8Ee+0h/XQ9zwWwoymhuPxAz0WSZHEfvWf+E39SyCekQmhXvpzKwvM0QP3wFNzfynq1S0cTNxTogRl+Jg7jivDGPrFip5yepiuuOszq7PijB9zsxvL+UiX4tuBAccqkCWy0GMBgcc6xCsu1jvZ/1GFuKljRRlu6REzLLOmN2mSHAGP4zz93PpwWQYzM4x9ocXz8RUfkhBYJW4sp+xeoVfDm5sQAClNOntGcZ3ZcWDXHUFHPbbRMxyMmQEL0wIDrRjK3LbVKJMtGa8hvmaOKx0dV8larG97d7C57yOTmjsrR5OG8j5mVGrAJMya/MuzlIeZhqhsDZOv3kOGhSKIVAtWkg+ShyiOkrPSiw9UJz1dtxyW4mOcKuEeHAyNnWmgWNVllpVhpefk1ilOgeXXDOFBDyUDXhUa6mIZz8S7gtx5Xk3EkD0qplQkn8XNuhIs1hbg7erzMcIFeGSd5Eajv++mH+daz8L5LQ0HO5GHd+tsSSBeo2DlExJbsN6SPSx/7inEjR+0zw90BgTiPLppfiQv12p7WZ6SkB6d5l49sMbSQdEl7q66ozhlzu1Ky4c9ibL/DYHP/oNTGq/tAZ18BiGAsf5akdCVo999mm4OH7Isv2k1hdRct3ssIygHyL9Au2DJQ9ZvXDy5jdcW/WBFAoFR2GZbGXsiZCGI4M2VpJNZv2Xf5BzviyGY0Y2Jw7+MiI4EWkYarulv2rw1ttr46GrIOy2Rulb2S7EQecCNiJhh5Fb9OpgSfRmE6rLp+gznbm6/PQ4km/Sadc6QQrf6338dsp90XpuMFAiSwWNDszbn5CnOouQ+Ouf9oz3ES6aVSAW7Anos5C8S4c1XpXEOyUWpI46I/g/3IH/GFgBEPauOyMrSs8HY2lMoP+LmD5kxyu0XbUmglhMZf7klKFIq9nGPQNyBzoSZW+nUQacemBt3L/Rpd1VAZR5ygERn7qkqoH578fXTmGHeJwul3q8DbkPuNgQgME57NfUA6GTvx0mjzFwD7i+Hk6ea/YGWeN0VGkUsvoiMpKN4K+HZorBVs3Is8nF/shJDcKHN/Z+9KK7o02T15bfgV+UelsMQlu6XG9i+ezURnEBergVCZBD4FfM9A39skD44UkBotrWNXr6nXx+NWuPt75kWKbFNAMKNBagG/AqYnTmUDy0CMME5pzTokUniEfYaq/+BFcBGJi2TKCsuSyiReibgS7su7nMD5a9nHRKYDsssxNwr5IF2mpcOMWXfu8bqCJ4bBE54YkAtExOufjzBywgVfk3UZT12N55Af2T7j6bb21k0Seym/+b+WusykBjpuM58zVyFyEYQ6nO3wSP7C+TcBmznVxIHNDN3TUg/OCwyoguDg9nV9irIcyuIOmbWOr4SCJfsMGpkOiCPdddumOyT5mkcVytrymnrBbaycH699r7fPnvvstU0JIa3WSJYjkaEBeNPknUuzKSl8tYPg6yCSdmL1Muy2hMF8ZF9pEGDQHY6R8vyoeBlBp/Cf8QFpcyWikyuALGjIcL9j783SY0YWix46f7xgHYEYVMYRCZFqT/oWqU4v94kMpRRDvGL3m9w0ENc8N5j7PhAQrXfvTzAEXNTV+fDg+8OBW1pS0qaCWGCLigDC1VTJJrPMkoSUzN3cdFAqcR0hPhtieQ8anx0ScRvUqODVGwVzUAJWDT4aOcmRVtxtJj54d6YW3yafuUwn8L+POmIRAB94EUa7agy4Yefytv9hF1JMzbXf8SR50RsKCW2wKBwajc7TtxOM2MKxJpkRddjtSE5v5VQCIyySIeExv/rmqhVvlmBmOgGxvwDk6OMf6TwkWZfVJaE5rYSri91VF5Yns47pc1JxaqIhNDXPAs/wpfWp00R7OY6gAluvgUCYxdl5DrP9pI28mmE65++BYB2wcl6pS9SsJLMRe6jH5hkYxcRBQkjAHz15lv2O3+kjd6Qzp03oomBbqBaJV1b4JlOKuw2jk4obmXhakxPFU04P3U84f1gNkzW/hHn0jWWcGHD6A5JdW88vjqo0Za5nf59an/DtjZRRu56N4bR9YYyHZjXEHGntumqbDBEQc6Rx/g+uP95VLypL3FMnZnauy44YwznAFAOEm86dXc47U+tCY/h2W1/5BzrEzxNkEjM6+Jew3/3t6SbUD4QFvyFOwP/M46O7euTUjm2Bbfja1UE1uo2pRXfZHQujp9LhnNiC1ZXCkN+rtcMnEV5WTtjJv9oX85RhGwH8mpJiwo5iqGwTKLcrz4TYvrIYCrXxPcWelsrcPqGZ5RnQ6J0BUtXwUOBoftV17YnoXj4ywTfMhjt6zC3dPgT9ZRooF8H1pBILtyxqb/1jbYlJA6T50KoCy1l7F9QxPzO/unO6eQ6O+YWM8jq6p2ZonyrSH/7zpX3uDgKXgR1XnjeVcrVvvuq0OVAvjCOxO8cVgL6wCYJHnuAaDbvEiNDSHvFCCYpXf/hvYEPuoNj6c7snF3d5/dk+Yu3NRP5R3aVG2GENlMZnTo0fiJDEdN8/1sruxL9JmxmzTele0/YaSUGJ0coOi1E3qIxk1IUGYniiuUjXJ+hksducoPV3Kef767nzVlrzVddvoOjBXMSeF31V9e0QNFn/C39AUK6oxAOGjc+h6XgheClYRNr3T7P2MtiZ3L9ir2hKrpdMtNwB4ZmkdEc6d8GWEpgYNdJ2I7DXpmH7jaV8cKcMpFKvEczQOITuea6HwQiY6dHAapXN5Ry09D5g/31Fg/cmvgyzCQbo1H7vOh2dj/EA/8c4ph4BJLe03JVGGDyj/hV8ed3P7p7BlMWbD0sgRmWO2et8dbxDXlP+0QhDrPvDxbw0+XTAALHKGNzglZzHGzReWwQtfkS4BJFNGfz7gMeJVe+P+HQS5vLkcTuZyYPc86QpNNF8A0wd+siFZi3n9c2QtkntyGJy7sD3Q+ah1xvtZPDHUgCjz/O4Tws6hTYNvPPRRsMKpvnBeRFE36EP4xj2mXzcPxO1D9u3xbkCQaBMk+0tlOgn7eI3JyAIIpJKNimvjZ/VjlwpW+A/u6MomuBalxRSMi91oENG4YlCN9hMnT4O8iR0jOi26HpDezuCC2WlB74eyEswsqcgv5kkKWWyDCmLbJRTGXTySunCWkXGS3IBeswR8Au227bEXC8QQQ5J0PIFW3sEaP1qkZ/V/5DaIucaJnzSMQEKmFwYrndKmIhrZFJd+hDT7ZoEr31cVImjy3c6gckK/msJpX5LueIGsYlpfbf3XnrJLBtvQVnnDCiw8ZjS2VdJEiL+VtBYmrSJbeJ4nRcALI1KZac3RaAjAcvO/hgth05GG8MWly5EJ+0jrNLxw8jdMNyNnAQ2spQ1HFp07oE36Fdjv4UZGgcSs54gNeuwnurfn7CQYQkqpEko+EsfClDLQnICG4BzrA5wbs3gv2E3+Llz0nSj6evShhYgZnOrZYC/F400XmlIFlHf0j94h76u2hI80psHJsmGJYAMvXuz/hDtwL/5IvLDT3weIKqSIbLL+WtgTXRJhbCzSVqVNAEoSsxnmnJil27EsJT3cTU8/UUKGeRlSYskXxskbdjY1K983KoSd3TPri5EM0VNxPqKH7I+0BImJeb/ox05JASmMt8uzgeRRVfXXx23HQmEYo3RCMGC8QIvHBUZ6Wa9hMcnKhIjlw4IoWr+WsNSsfMhKOvrjLhGjuzb3merx/hxnUk4uyUU4yzwGP69XpE2hxRtf1vHUCpFNByHfKIYmTS+IqSocKQQdk6PyXg8huEkt+r84LqccVnh4aSn93/em0lHsmOiyFmXO5aeJjXJzg1wfgwFq0knQKuD1I4/fJF94J+BSA9C6SDPhVzWdwrhFXd3NN6CL2BTH68xp/7xTf2eczHIiuZu5NyTVy1+Azi3qIWzrHkl+XcgMoac6ItcwNkl8wNURaywvxdHkGY4fhhfOhwGYsVa/2CWH6yDc9sYcWCgkQcb3lWR+BwNHAxxCDj9R5XwR4xjVZHdaXcLSIkcu7m6yo2rBXOR1m/I2W3BINvEX3rlM+M63gmYinUaVnoS4In/4RAKw4kV1DbrbJfb/IP7LTxXM97JvI9FrvIu0//IJHAV91HLcusDkcVmwWRM1eg2ZnZmW3tUg4BN5m53IxuhAFkseVIqJYvBZ09NW08pXlwCAgK5SAlpkAEia+2azq1IfTPR52qJo+AF7XizwikOfD/QwJvJXfBnupxKwyJT+yLOGLdyvqA86oDI2hkOuFSNgRPPcm+iO+nqMHGNYYTBDtEDMcqxY5V3ImS2t64r6DAjs8wQrenot0/sUOO2YkEP/6N/zzKmrfN4qgNWUXrttLP6WvnQTDfRzIlzQE/RVkygsQYGPJfzIsFSP2bob7XPxEonS3aAD4SmSsI1+H7YjBKXeYs7eC1LgnsaiLwpT3zEN3oYo4YcHx2512T+gCi+0RsVfLvj6pAqM2KNRrdUa3l6GAAt/JG6ofVAuTV91PhUovIlBGJqRFfe5xa2oI11/RAo71UkfUAuDd3oYnGwloBBbZNWbVNSX5l9mGVTFTex2Du3+Mcj1OmcvrDtuSeaU0TFbtq3Ax77FeEDIWtFMeMj0ngnidBKuyNBvuQtUcwRyaHeoSAw3SSS76tfxbG9a/65w/rPBpT9Xw/CJ2m3Xu+fcTPPCyk1dY6QHLzpsV7B9qHzvDu3nM6SNMKK25zx8ajNRWV3tuXFZC+5dQYuZg8ncBQHr7BmtxB/hFKOMkXD02RSAEZOHdcFF1tP+q3v0PDWbViplZGyfLknZI1So/M98PlZNMwvYo7b38CKLzCd7nC8ImWysdnGyCmeEEoZND5dvM/ck8zl6gBBgsUoRFs+Jk04YeSvgauTZh5bBNdftHi9dkJFpXAc6X4mQcokiTKe1c82GLWDt4zO/BxAqNzhKuxF4hIKG0uhMgBnpPBKklXL4ahcF9P9K7PkRa4uK1Y+4b1fhXV96KCUFlj5K45wtelq3m4AvjNfJTQ7aPENY9mR6fDKwA3eqqOdnSi8soc310J17RG+EdVmOLvziBmqxlMccRJCw1OaNceJIgm/lweQ2szEpOVWvluGLCzl97wsbJDPqpQcPmAtZi4eCCu6lsgEpDwGjKjTg+x0lTbaSUqVJ2eBdQ1ni1ZhSzuLQiD42jEaPAe14PD0jPfEJC2atKhhcs8+tOVaflhozKOLNErcq/r77NVL/5kp0EhuUUHlkh1tC2rSz7gjtgChtA1S03G80IMspDCy02cO+9aIaR3FksWhGCANR/DWaXXTG9hNZ5pSXandVJ16SWFzW2LJMgVzhij8hGC38xykZPTVYAmmRUcjGMGdbaYtyuB9cqt7iqaznO4Ge0njwQWklBPkf0fF4uhXJE0rEHQm4Ox0f3JLWdIyLFj9+iTM6W7ZLHmogtF/LUJLcDrP25Zw2imPze5ssJkudIkH9Xwy8nQXlp8HTV28ka2ZSjs9akzsg/oii6oWsS9/JXMIhFQKK+RWziIIRaf3aCoz879rm6oS48RWAU+EerQytJjbF7ozjZsEVMWuI6w3DZBEa0Q3atA+uBFr2xyQJZiZ2cPxbZH9FqpINx9eUIx5zlc7p/QxCqZY7BYfdQt0lLEihUfkuyrkMVnAkis74dRAO+wf3BkvJV+RgemL7iaolJ9qnbeiO19ctOe96xFW50pctuAUym9jBKP6t4U3VuLOH44Ffw0ZPPZtymnDbwoN2pnqbjYqRF/3ysWDbRWTnYxcQHkuWEhcBTEvG7dqz7L1Wc6YKg0iHWYl5tz6QzJnoGcdaypWf7VfXRTHTUJh9wComNwpM2v0iHPpNDgB5+/xxViRilPjBGNnl0ZaIai3yJNrzlmWTiZ1U+sPoXgqW5ngeOtsWWfXoD/G7Ns0C9piVwQivGIUDAtCqQr0ASrmYXuX7NnenN5ZHhcSYiuGE2bW0kiT6GT/oghGAbYlrw1CqwDPE/z3oGEOJPIEnD5LYMAGQPEpPKK+isuUL1LvgNbSKnHtH1d3vm+jxt7aslKY1yHI5x+V9E65ZBYaXAkrDGdAwoOaA5+7Wrc0AKcO8UYFThKvQw8Abqi0EzWi6YcgaAwI5kFiEGjKxpSr32P3iWNMRfAxALpN6zzxEzt7sQwK22VYyz73REcv8uq1H756KcReNmSYVChgIAH+MqmnBdw20PkoMe5EBNefiHBA19RanUS0BAmc2lbm5bgQZioifJ67ZlohoOB530pA7UhDYRkpfToZOEXVOt4rNGBHKU+BarhmEblVhuGz/xJF4pyZJsoDLYfx2uuGjc/C35kJQkBdOnt8jPTDl5+luXK9bIoyGbaw15vImvyOentNs9izsmIooILsXnqeTKdPvPPjTq/Ywrxd7MYE/ODQqeEWpQ+Mal/zzNIVXlpDf8QBPuih4gpQw2dACN0bQHxJ9ZlZlyJNLF8P3vCsrEdbRUqv9P4T9aE940CKw00Da045ZyaUkUe/IXlfZ1ljPm0fzULcApgzJoZZsdaUu0FE0t/6rToZq+coGmsw2XVvXFh7gRNZa/6ll8iaJ3d2Sj2QDDD7hm0wFDS4NEFlVmrmVnSlrVN9FN8zimxIfbGLDFPi5gddU2DPhW4GPnC0OY6zGPVWv51yz9jyZEAg1sSc3lOU3MEFtsonvXM1kBieXUpoSdd7/9ZnsurPVu0A8HAtE4MY830Oqof7uRysjHD/NYlGvB2qnmV5Mal72oja1yVBceCa/zUNntyc5h4NfvWAGVjwRPWImAKIuv33vUUnfu8QF4+x9GPGadbncrZxc7hsvYG/U8XWf6wBfP/AakB8iWaef4pVTNnmJw0WXJYiBjFbT8T39no74Bpn+T5d1thsM6NthwbTmRWEgCTIXGNbvBRZ+eHeLBA1NjNwAn+WcoLQOMWaWERWd62Ll0J4kjqC+XGBV3lRXzF83WbSdC6FWUPusr+d4pRHs5cGJ/0ZdVGAq9pPuadJ8FvTobzbYqzXA1H6VJDs/rnHXXGF8rDLvD9+zNbhBlqiaZIvQoiqWO2Yj0bs47auuM5sH8McUN3QksNnQj5H52GMfTbwAeCTKhdcD7gAxGLEhC8hRhhfBg5JdCghv4vSLQGJtfU/2AIhLXXRpLIjSe+599tHeXYIWu1TnJGSu210ia/uc5mSZJU+064K2AC95+WRv3sOAL/SvtG/NSKT1fEw5UNrqXAuFDY0CuDsYgUHlQJjpU+NPWmiRunth1/+nYlYQPxv/I+MlBks5gi/w8zDRjRw/jKW4+RM8MUbNUylRnce6N9VQGqSFhvWLrlxgLbmFWm7I4D24lwTFM5fQ7J48giND+zfVPOeXflDy0ObNTYkAmQAkvsQo07ggeFg4PbUmo9Tlc4qmhNl1NAcOJ8ZJ8Zplfzyq9r3eVdIEOMQUzNW5ELesJKjk1QzPmkl8KDBg2sAzPaoefRVwSpk9WT9/303hV/+hCgngsMAc2KYVRJ0r63QyoiMxBkmqMaQc1NCqZdiyM38SfensXK1tshCmFZv14H629awOrxAwEJzaQbM3cMXujLJvTNNASOVNUxUzGzeLrpP3fmvbdGzAyRCriM2SR639fQlOg7BFJRAUwRpe4IZe3oCQcrMotFeLIo9Ba39OMbPPohNRLw5f9wioFiGih/qgfyIsOyhc1K6NfemgojDTtbFr3vFDrDfEUljW0ppQn+Q80kRaFs0tt30sBbolwPaAGbHQ+jxaCn+K8wT3JG9Jk/frPzmvOVFchSDJBZliXvHh+DkoTgeDN7pjq5jP3dpVGs5kUM1g2GDtuR98aI8A49SFnH0BE3oea3BMssQpxbbgeoC9vvq94bapjAXIcFvSIZOWfI99cEo39wWnjWhP63rVQAEaJiOwT21JNdmJHHziDNDV8L6Bx6yTV18bzmqe4wl0JKLoQXMCgWPa01zMU4L/4yPGR0S6nOQZvwFhKKA93m3Rlv2NZZrVzqGM8+oZwvhAyNadutuL19JGWG+PjeP1WrSEsMf04/uKe1oiSRixYITgIxp4lNNg+XpAkZOaca+M7AddwFuPA00FP+H/mhT9AOJjZ15IvZQKoG07VmnNgD0kc0fgUhRS+jJbWR60gdL6SkiyLtVPwhHYqi8KWbfQ4Ri51CHnugS2BD9wVK2WKYF9bSMiYThi/oVLvZeGFW+KF5eJyp4zNnHL9ObSFnzssHLOke3EmjCnWSZ64TPsu86FmK6iy6h5t9xlJKKPBpz9mXHAoq4OP0uAZODS79WNDXx3vMl1CRZzh2f101ezYp4124X8Sc/jf2HBiQbD/7mmcPJjmg8AUzHlswxuwZ1YWiGqRQ3F4OQjpKFrETwDL5bdWA00/zDXUGW1tXvvdhQZFMUPJNnZeUX9GGTM2WL/k8LYMlC9tvCVKnDbDxWXISA0PBd+phng0vfkNi/qBOXqaOfdNhI/QtagMRCyoYwjRaQcfw0ro30BLZ1doht2o16DFmXp3d4T8YJLyCRkJ53WzCoMsi0UFWWU4Stl1B9hjnjH5FlZWC+At2vPw/uXFd3Vqw3yljLJczG5KChgHNcFsxy9nrzC2840DoU4bVsLDuNZCDbteBhLJcRRWk2Orxf3I2mrkUItwWfOGcPsd2C7JlPdyHwUEhd9TeCxaulNET+xdZvuAJn996EHqoFy6itHwTQjd4GJpovgZpL1lvxJMS65Go76AjoALOH+zNsf83LN6euuQRde5XN6+yALAruGFWgQWxUF9EpfK0h5FYQveW3tCzDDKvguAnOuioA/0vr4sgFLdJUfz9zO1AlFpaG1HmMYYS1m+mdDCx9eRrc3Xzkj8vqQKV/zro0iBsXx88jfeVnqXQYTUKNrnV8w8Dgq2bvY2VFbmEtIQ7cvtxF+jOpcan2eVVxNFKFGrmwYnsu8UH67Dq7bulLk0bIC74FhJAJmufFqMsDfxD5n/PkdROnN7d7MqeuEbNl3YcO6HzYyw1vaGQh/qUzIwee6ROAgxF0NzUqOhNdWrGyRSZbm358o8ERElCFrCaTFqc12OgdJI0Xfl6rki3B3Ul8iMix8jQR/Dq7bXu6sb7Rp67Z90SIaTpbs8uA50mYBQM2KVCTw4TCjGTkTL755x46YHkCTv92IyuFOEeCzh7kZxiv6wtRJThKEjORu6E92mHuL3CpOX9RDRii6022ofkmjwUT+iUUmpc1U37jFopyEt2jHQIv07Q3XyH8pBAOuLXsZ9hJisvE0fQqeJsikWFIZgQAw6Oy3xrFLUfXOXTpylTGObMUvIRmLjUKpnVHRVRZZ7dfNTIDygG1Mb2yNDgcOisaEOe+RYd9dF35ht2KMl+ijb2H1LsahXDtHhSb0mIqaia8yiItTkaHtfxNVrT08O3UOEKmR1fVQaOpzpYFdTHLQ32Hszc+TVg2AQ8XkkleTMYGoZgebgcAaToxpWC5PJPWl92PhQru6vFYPiFWpn3Qz8y1YSeYCaj/ro1UuLD2NkTVaoZrjVk/Vs0o2icuudsC0RJD+g0RytCQlp2RclT6kxTJlNAd4xGJxPSRJv7l1D/WUW1YzdmJ7ESL/uwfk2JdEC4ZmE1GnQxCjBE+kDE7XxbrqIMlKjMjzpgFlLanuTKID8SRrNuF2YYJ/aAez+751aFkvamaBVb9P6CnRMPsrpBTZG2B4o7gMrI0HKfFQ3rtUS0Bdqa+SHxyjY4kLHhtRWi5qbymUrqNwbnIE+rtEQApyxMLleFVr0LJ1ZioSnTbsa74MPQr7gchzIfryDSU3LW27El0u8kYOgqcBmxiL1zCX9/iWEDhuv+4NCwaVAZyHUZe7906MWbb5Vi/LTOUkIZB3HJAQayJaVjkp5Y5TrYU51FDew5jPaJY4DdBZIQ6vB9vSTniarB1tkB9PbVwNVINij/3DwjCWlcCl94qb4Bcruk398f+sMnfhWa8O1kTYVGghsSSIGkj6rTxN99RHh4YIN38BsnyDcE6uNEYEQRCPaRjI2p/plIwwjm7cszqfDtFlph1mONcdv6bH33qSx6x+qpnpoQuKxeUqK0Zu2a5eu0A2BFx1nGOwE3+MlR4v4A9qONptzjJsuQqP7FAu8bWGNu2/c1IDKgwu6yd6t3sGIh2yo8VJ6HMt7QIF0qG2oEoWFvC2nv8aN5XeFRrO6nQB+Z4Tt0rKAVjHpD3yJcOtUBuXqOC/jAgvdSWnAJf0Z0IRderdd8rZ+9sDnco9Md86LBMdPfeOmljTyEe/py0bykUJ/e1SkGO9PYsyQNzHwz8HIZI44JCTQt6/ywG5qIuFeQjYmbZES8dHEGh6TzvUU5e85vpgTFVei2S8CbCGwmk= var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>离线</tag>
        <tag>网络流</tag>
        <tag>数位dp</tag>
        <tag>test</tag>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prufer 序列学习笔记]]></title>
    <url>%2F2019%2F12%2F17%2FPrufer-%E5%BA%8F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[发现自己完全不会 prufer 序列,于是来学一学. prufer 序列是无根树的一种序列. 有标号的 $n$ 个顶点的无根树与长度为 $n-2$ ,每个元素 $\in[1,n]$ 的 prufer 序列一一对应. 构造方法无根树 $\to$ prufer 序列无根树的叶子定义为度数为 $1$ 的节点. 找到编号最小的叶子,记为 $x$ . 将与 $x$ 相邻的那个节点添加入 prufer 序列,然后在树中删除 $x$ . 重复以上操作,当整棵树只剩下两个节点时退出. prufer 序列 $\to$ 无根树 取出 prufer 序列的第一个元素 $u$ ,然后将 $u$ 从 prufer 序列中删除. 在点集中找到没有在当前 prufer 序列中出现的最小编号的节点 $v$ ,然后将 $v$ 从点集中删除. 将 $u,v$ 连边. 重复以上操作,当点集中只剩下两个点时,将它们连边后退出. 这两种构造本质是相同的,第二种构造中每次找到的 $v$ 实际上就是第一种构造中的 $x$ ,而 $u$ 就是与 $x$ 相邻的点. 这可以说明有标号无根树与 prufer 序列的一一对应关系. 两种构造都可以用 set 来维护,时间复杂度 $O(n\log n)$ . 性质可以从构造方法 (定义) 中找出 prufer 序列本身的一些性质.记无根树的节点数目为 $n$ . prufer 序列的长度为 $n-2$ ,其中的每个元素都是 $1\sim n$ 中的整数.正确性显然. $x$ 在 prufer 序列中出现的次数等于编号为 $x$ 的节点在无根树中的度数 $-1​$. 证明: 与 $x$ 相邻的节点被删掉时, $x$ 会被加入 prufer 序列.若 $x$ 不是最后剩下的两个点之一,那么删除它的时候,恰好还有 $1$ 个与它相邻的节点没有被删掉,出现次数为 $ \deg-1$ .若 $x$ 是最后剩下的两个点之一,那么只有另外一个点没有被删掉,其他与 $x$ 相邻的点都被删掉了,出现次数也为 $\deg-1$ . 推论由于 prufer 序列与无根树的一一对应关系,一些树的计数问题可以通过转化为 prufer 序列,对序列计数来求解. Cayley 定理: $n$ 个点有标号无根树有 $n^{n-2}$ 个, 有标号有根树有 $n^{n-1}$ 个,有标号有根树森林有 $(n+1)^{n-1}$ 个. 拓展 Cayley 定理: $n$ 个有标号点形成一个 $k$ 棵树的有根树森林,若 $k$ 个根已钦定,方案数为 $k\cdot n^{n-k-1}$ ,否则再乘上 $\binom n k$ ,表示先将这 $k$ 个根选出. 证明: 记 $f(n,k)$ 表示 $n$ 个有标号点形成一个 $k$ 棵树的有根树森林, $k$ 个根已钦定时的方案数,归纳证明,奠基显然.假定对于 $i&lt;n$ 的 $f(i,j)$ 都已完成证明,考虑枚举编号最小的根的度数 $i$ ,将它删掉后,图会变成 $n-1$ 个点, $k+i-1$ 棵树.$$f(n,k)=\sum_{i=0}^{n-k} \binom{n-k}{i} \cdot f(n-1,k+i-1)$$代入得到 $f(n,k)=k\cdot n^{n-k-1}$ . 第 $i​$ 个点的点权为 $a_i​$ ,边的权值为端点点权之积,树的权值为所有边权之积,则所有树权值和为 $(\prod a_i)\cdot (\sum a_i)^{n-2}​$ .若将每个点的点权设为 $1​$ ,则得到 Cayley 定理.若将 $k​$ 个根合并成一个点权为 $m​$ 的点,则得到拓展 Cayley 定理. 证明: 记所求为 $ans$ .$$ans=\sum_{Tree} \prod_i (a_i)^{\deg(i)} \\ans=\sum_{p} \prod_i (a_i)^{t(i)+1} \\ans=(\prod a_i)\cdot \sum_{p} \prod_i (a_i)^{t(i)}$$其中 $p$ 表示任意一个 prufer 序列, $t(i)$ 表示 $i$ 在 $p$ 中出现的次数. 那么后面的 $\sum$ ,相当于每个位置可以选 $a_1,a_2,\dots,a_n$ ,每个 $p$ 的贡献是选出的数之积,用乘法分配律变回去,就是 $(\sum a_i)^{n-2}$ ,于是得到 $ans=(\prod a_i)\cdot (\sum a_i)^{n-2}​$ . 确定了度数,第 $i$ 个节点度数为 $\deg(i)$ 的无根树数目,由上面的性质,等价于可重排列的数目,为 $\frac{(n-2)!}{\prod (\deg(i)-1)!}$ 完全图 $K_n$ 的生成树数目为 $n^{n-2}$ ,完全二分图 $K_{n,m}$ 的生成树数目为 $m^{n-1}\cdot n^{m-1}$ . 证明: 前者显然.后者的 一个证法 是根据矩阵树定理,构造出基尔霍夫矩阵,手算行列式. 用 prufer 序列也可以证明,构造 prufer 序列时,最后剩下的两个点之间有边,它们一定在二分图的两侧. 而对于其它点,每个左侧的点被删掉时,会加入一个右侧的点,每个右侧的点被删掉时,会加入一个左侧的点. 于是 prufer 序列中会有 $m-1$ 个左侧的点, $n-1$ 个右侧的点,方案数为 $m^{n-1}\cdot n^{m-1}$ .]]></content>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>prufer序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191217]]></title>
    <url>%2F2019%2F12%2F17%2Ftest20191217%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19PUTAV04qdDGJ47Q890WsVLfWQg5ZW+AglxzfsiRzqlf0uY0WHRKvZOn4F5H4bs4MpClf2njIQChO2mgjiRKUrAhqMReyn7oncj+R8Q1591qZHBfHVcOhyPn+zWNEoLTwmJCUkCcM2SltYY/8IVCGUgg17tjpaaYga+ae93+NfkIE9Qzzs/zL6nWcHQw/IuaqeE/lL6ce0ra3QkAEYaAE+WJoEGkltkik5kQYmG//D5DT9or5xb2UquRK0+rUCbmEK5eBF1sJS6+GgPgH+celBXTeHhpA5J9i9ABuISqPxPh3x36sUzaaiuFarxyeLmoftP3OhLFZPiTQD3LS4d5QhdWtIc0yDJA7VeCs0dyvL6T0CR1DGa3k1SNGVNbSH+cg3+hmxYbXReHW4Thy3vKJyw4/mJR3Jy9tr/fgIrWPn0whLX6zAE4RHA2y1a1qELY7l0HP8IguYMNSdzCYIYUsBBZDFW1o5mT7VvwabV7sP4ClXCl326D9lkGx/6Kfdp4/0rykBm+nwCDdauwt/VrckShIGYQBwN87AoXDGrhWJETUUk+xVeJpaAAcl7je4VmKlRWDu5JDKo1hwnOKPTDqr3EGGI21b0pz6sfU62sroiG7eP/4dCBMd0ZJsHE1lk4sXSdB673F8SA5BC7QjzaBoheqWaGIhulPUmfGKQVtpG/P5iuLsgUTbYiXh1+YZoqX0HkurCJFSc8uZGoe7c9rmim2tNNCZ13/iuZF6vrHt1dChTnX08fj95JXqpOoNd1LXVgQi3e+YgWJ6ohrJMx7/DFlkf2lJ2N9G2xnGjTauMqekYJQsHX9W43Zbf22w7RJrTMpkiVVK8E2DDuQagE8UzWgNWta3anKosUI5gNjyi+M1muHtqEeumZ86yjHrNG5tJd597ofPBIgwRunGpGCYjQBWklXHpo1g141RDn0y40PNZS21IpJB8Obr7/i5FN6JGynKo+wEtwcNQk1rLvqEofAtUymqtiYciq/0klCGgeE4MunX/ub5pi4eOjrmPJyvAYouHFsJzXGzjFqJh+hgKvQbydeEkErauXMkFI113JJK7BgrxtoJXWP6YKY/7+cgkqupsf9SGZkX+fL5l3cHer00zZt8cB08jkX8F2s1LsFrrLrcfEvzqTQFd6rOp49QNK+Kwqd/eASOI4xoXjcx2fYNp9VxS1BLpy/Fn/GBC6WM7xg9gTEbtC00RUDfi9wFrEQWqebGbCP1hcAMIltRY8dlgdSzw5eXc2JFdJqAxluccGoeTz7g2UsgJcIXZh3GtFHKbniTlF/St7HMIislB/R5oTeLAXGWvNZzFXOjW4WryWe/3Qmci3TTeuKXv1BnkK2s+fXkk0H2raR8059BVwndeARRvS8W6n/Qf6eSfdr7MtW05P+bRpozJBiXPGOjirEgda9+YT+X54zgOg0w+EVq0FpkLALgTI3FAQEJW36LInQ+fZOaOf+xLvLI5KBBczHjxXkV1MRh/yaZNXg6PsLy0zJZDNOWaK5i0AIgRqWIMlT4/tMWRyNG/eBHAlHdi9/XtW2aGgZxVZDnLj+SlSYE22np0WGVJcKayjB4YaMNYCtmfmPJGhTaEQ7eG38dit3L048gk7obhV2nNy3jr1I43FEs/5V6XdWI+AE4wntKQ0YAxhxFR8krkNwj5+xH9ITpDq143kIr5H+BI600xO2V9x7wQp+JieSvEC/taAUI5wtuRlQkxeKmdsBOfJFGZZLG0Jxwa7d9cn9kEG/M2p56JBulUZUYbMjbWi12ECHjaAjrACSNawQFfSngqbbtW694N6z6A0HoHXH8lVYmfdR6Ovd7R2/cgjffBwvriM+hnlQTHofINWO7Qc8jS6ZfI1GdB2y3//liUMBnq9ua8heX0C8MLQQuD5mJKJ32NcCCjgFKM371lcDzONu4Wqqz/DNITl3mENyttytGq46m8xN30Du/zkHE2M/Kkqn8k2g3kWh5nNS+wG8WvZ7YcA4uDAJsD6IEb48ScCx/8MQK3txUmmsp4p42uRreGG4p/BJWQ/fiu3nJC4C4VorDfhjnz+aqhNDJ6eUYsWdqyVTEHSnozegK8zMDisyKZawgk6b+ddEswuZZkKW3otknOgoEIYty5PzsLWpLGpOGQMDuhVlpUzpkihXStT6y6zgz7FyQoNHgstQ8oI8pYfuqnCHNP3ustMUoT7ijGjvFkXmifXdXKFv/S78TRz6WfBoJu/j3gWgGnrC0ScpUo2J1Ch2EjxcUvnx5rNYiCyGuiNl6HYFX5CKKuzjbyFiI3gFtvlR4IwWOiE1SMq3cSgIvds/8NvJ8Bek8/c8ZPkQmWyEf2hWLBdSoXbNmT5MGBY65svbvzHROGfYR4gb2rZwEnkXO0Z6u2q2B/uKUDDKwLcbVqKZNJUzHu73N3aX7nprhm+sumxfLOU+277IyXvk9oZR+0ARfe5sHvCtRphCmq1o3IZXxFbOA8yMiHA+iwmj6yzfi/TWAd/mWptnTzeVhToA6x6Q2p9y8MRWWxBtejiNoXaYRy0s3WtdVa8M5PWSumnCTWn94v9+0vSXVWGF3qYKUQgelL/PXHxG6R9Uznql/kY1NGy010Vt41COKCMZaqJi7Z3OmkYmtJvt1LsGLC90ZYAFtE02MxIue6W1Q0qlsGVz/DEPZWt0l4cQ6hIQ2GhHrXRRlnFftwILVVA1jRK7FIJgziENj2HSlV0eucPfNHNNFHUT/DOLe3RVSHpZy9Orq40X12stW5ePuFKAh+yZAwb+eGZtvY425qDcrYf6kzV7YwSdDWG0oyOal6n6+W0UR3dkZcSQAM12+4hoRUWqN9JSv7p7a7XyoCCEnqOfayjrRSugdaNgviGz+IeqV+cawloLYH0eeMwdxzB6oPGZwQ9ZaQ5WIFcpz4uVz8lCCf49doeivV1PHG9U3eehXUTCC4mKldRAaT7gz92UwuBa8hfZd3xmr7NXG0h1lii/TQSTsHQtWlOjCmuj6o4hTFE9UMCaZkymeX4iidm8uwbWgfAxXzcp0g6vV4QrbYUOLVY0z7zFJlN9cPFX0vhvU85ZL3xI/CjbB88fpBbXamornB5KKYcDHEo3H8xoDRSNqi/IHUYLQmtUi+o2WP3s4Y4XMhlfoqLKayh3VtnaNRjawh/7fuRSfPYlYqRONCN7cKKhiEp1vWhXyATLWiHP01COKfwfuLhKHRQqlblCQKnla/qIYEJVnAIHjbI5Cn0gRgTWY5EKxWWW/flWoqtEkmfQQea3HyKAX/EP+pp1rLsuo42AfoaTkxM0J3eu9BxKxvjvMj3puF2nCnJvLpK8Bjza/ea0ZTbUDnqOQlowfJPDZMmhqAZ4oyVnxwlcBNf1iBCVcOgpl5qTyNVsIgC9ayFGRYM0qKsFk1649rd9SLIF/y017x+CDiwf837rj16b5RTz3k53IDufJOOK9CO90HLK8qQXMxJcOle//vTeiyuGL9p8MHHJzH0K35nk5YG9ENESiW9KmTCV+iZEqHe1i8rkoSIYJG730AAzyytosmciSVBRWy8lwvvV6rZZ+ctIJGBG4v44LE6garu7XHl4tvVFmsVp2rlfC+0F/UYGDlbj8iiscrWcyV/zhYd6fGFaIJGZIqHoEBn3OzDD4vYYacuf6rmv4wY8CBbZHOcwgVVWdsUlbMJPMzL4ekd22LKNCfZNqmTu+6bVVuBzG/KGTVXYPO1ZnzZJyzm7yFBzqJ9xojbDYXnzlkOOVETNrDfc3KOwimHLaFI71FKWg9Cm6Vy/JvMlyK6G5CFWyEzUgy+HcbvInq0JSyDixRs+Hu6Ot1iCYT76zbV3FWw4RVXVPAccTkYyRUChnAGBQL5+qxSvY4sG4RQQpMJ2TaxVf95F5e8Uy2Y7r2EOpMMF2ifSlnhAfykVuCf8OXIBtg5V0M0Cj++9fUXr7+954QX3ADeCHrcCNeINH3CZvKzR4n5qLxaOCsKuhopxpkikHDwPoeU//LXsDRfgJkLQNRBEr6IGJaS9l35zYLAKevvyGaS7u7qiX3pOTIb4s var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>test</tag>
        <tag>矩阵树定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191216]]></title>
    <url>%2F2019%2F12%2F16%2Ftest20191216%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>启发式合并</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191214]]></title>
    <url>%2F2019%2F12%2F14%2Ftest20191214%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1152 歌唱王国]]></title>
    <url>%2F2019%2F12%2F13%2Fbzoj-1152-%E6%AD%8C%E5%94%B1%E7%8E%8B%E5%9B%BD%2F</url>
    <content type="text"><![CDATA[概率生成函数 + kmp. 概率生成函数: 无情的复读机器人,通过生成函数的方法简化运算. 定义概率生成函数 $F(x)=\sum_{i=0}^{\infty} P(X=i) x^i$ ,其中 $P(X=i)$ 表示随机变量 $X$ 为 $i$ 的概率. 显然有 $F(1)=\sum_i P(X=i)=1$ . 期望 $E(X)=\sum_i i\cdot P(X=i)=F’(1)$ . 方差 $Var(X)=E(x^2)-E(x)^2=\sum_i i^2\cdot P(X=i)-(F’(1))^2=F’’(1)+F’(1)-(F’(1))^2$ . 记字符集大小为 $m$ ,字符串长度为 $n$ . 设 $f_i$ 表示结束时随机序列的长度,其概率生成函数为 $F(x)$ . 设 $g_i$ 为随机序列长度达到 $i$ 还没结束的概率,其普通生成函数为 $G(x)$ . 如果在一个未结束的序列后加一个数字,可能结束,也可能没结束, $1$ 是初始时序列为空的情况.$$F(x)+G(x)=1+G(x)\cdot x \quad (1)$$如果在一个未结束的序列后加上给定的序列,则一定会结束,也可能没添加完就结束了,此时已有序列一定是 border . 设 $a_i$ 表示给定序列的前缀 $i$ 是否为它的 border .$$G(x)\cdot (\frac{1}{m}x)^n=\sum_{i=1}^n a_i\cdot F(x)\cdot (\frac{1}{m}x)^{n-i}\quad(2)$$要求的是 $F’(1)$ ,将 $(1)$ 式两边对 $x$ 求导后代入 $x=1$ ,得到$$F’(x)+G’(x)=x\cdot G’(x)+G(x) \\F’(1)=G(1)$$将 $x=1$ 代入 $(2)$ 式,得到$$G(1)=\sum_{i=1}^n a_i\cdot F(1) \cdot m^i \\F’(1)=\sum_{i=1}^n a_i\cdot m^i$$于是只需用 kmp 判断给定序列的每个前缀是不是它的 border 就可以了. 用 %04d 可以达到题目要求的输出效果,当然也可以自己写一下输出. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;typedef unsigned long long ull;const int P=1e4;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return a * b % P;&#125;int n,m,T,pw[MAXN],s[MAXN],fail[MAXN];int main()&#123; m=read(),T=read(); pw[0]=1; for(int i=1;i&lt;=100000;++i) pw[i]=mul(pw[i-1],m); while(T--) &#123; int ans=0; n=read(); for(int i=1;i&lt;=n;++i) s[i]=read(); for(int i=2;i&lt;=n;++i) &#123; int j=fail[i-1]; while(j &amp;&amp; s[j+1]!=s[i]) j=fail[j]; if(s[j+1]==s[i]) ++j; fail[i]=j; &#125; for(int i=n;i;i=fail[i]) inc(ans,pw[i]); printf("%04d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>kmp</tag>
        <tag>概率生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2707 走迷宫]]></title>
    <url>%2F2019%2F12%2F13%2Fbzoj-2707-%E8%B5%B0%E8%BF%B7%E5%AE%AB%2F</url>
    <content type="text"><![CDATA[tarjan 缩点 + 高斯消元. 设 $f(i)$ 表示当前在点 $i$ ,到达终点的期望步数,转移有$$f(i)=1+\sum_{i\to j\in E} \frac{f(j)}{outdeg(i)}$$直接高斯消元复杂度是 $O(n^3)$ ,无法接受. 注意到成环的情况只可能存在于同一个 SCC 中,而每个 SCC 的大小 $\le 100$ ,考虑对每个 SCC 高斯消元. 用 tarjan 将每个 SCC 缩成一个点,删掉那些不能到终点的点,或者存在某个后继不能到终点的点. 如果起点此时被删掉了,说明答案为 INF . 缩点后的图为 DAG ,将所有点做一个拓扑排序,按照拓扑序从后往前处理每个 SCC . 处理某个 SCC 时,对于每条内部点连出去的边,另一端要么也在该 SCC 内,要么已经在其他 SCC 中被计算过了. 于是用高斯消元可以解出这个 SCC 内所有点的 $f$ 值. 记 SCC 大小为 $s$ ,则时间复杂度为 $O(m+\sum s^3)$ . 实数的高斯消元需要注意精度问题,加个 eps 来判断是否为 0 . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e4+10,K=101;const double eps=1e-8;double a[K][K],tmp[K],f[MAXN];int siz;void Gauss()&#123; for(int i=0;i&lt;siz;++i) &#123; int j; for(j=i;j&lt;siz;++j) if(fabs(a[i][j])&gt;eps) break; for(int k=i;k&lt;=siz;++k) swap(a[i][k],a[j][k]); for(int j=i+1;j&lt;siz;++j) &#123; double t=a[j][i]/a[i][i]; for(int k=i;k&lt;=siz;++k) a[j][k]-=t*a[i][k]; &#125; &#125; for(int i=siz-1;i&gt;=0;--i) &#123; tmp[i]=a[i][siz]/a[i][i]; for(int j=i-1;j&gt;=0;--j) a[j][siz]-=tmp[i]*a[j][i]; &#125; for(int i=0;i&lt;siz;++i) for(int j=0;j&lt;=siz;++j) a[i][j]=0;&#125;int n,m,S,T;int dfn[MAXN],low[MAXN],idx=0,stk[MAXN],tp=0,bel[MAXN],rnk[MAXN],cnt=0;vector&lt;int&gt; scc[MAXN],inv[MAXN];int ecnt=0,head[MAXN],to[MAXN*100],nx[MAXN*100],indeg[MAXN],outdeg[MAXN];void addedge(int u,int v)&#123; ++ecnt,++outdeg[u]; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt; inv[v].push_back(u);&#125;bool vis[MAXN],del[MAXN],in[MAXN];queue&lt;int&gt; q;void init()&#123; vis[T]=true; q.push(T); while(!q.empty()) &#123; int u=q.front(); q.pop(); siz=inv[u].size(); for(int i=0;i&lt;siz;++i) &#123; int v=inv[u][i]; if(!vis[v]) &#123; vis[v]=true; q.push(v); &#125; &#125; &#125; for(int i=1;i&lt;=n;++i) if(!vis[i]) &#123; del[i]=true; q.push(i); &#125; while(!q.empty()) &#123; int u=q.front(); q.pop(); siz=inv[u].size(); for(int i=0;i&lt;siz;++i) &#123; int v=inv[u][i]; if(!del[v]) &#123; del[v]=true; q.push(v); &#125; &#125; &#125;&#125;void tarjan(int u)&#123; in[u]=true,stk[++tp]=u; dfn[u]=low[u]=++idx; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(!dfn[v]) &#123; tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(in[v]) low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u]) &#123; ++cnt; int x=0,t=0; while(x!=u) &#123; x=stk[tp--]; bel[x]=cnt; scc[cnt].push_back(x); rnk[x]=t++; in[x]=false; &#125; &#125;&#125;int p[MAXN],tot=0;vector&lt;int&gt; G[MAXN];void toposort()&#123; for(int i=1;i&lt;=cnt;++i) vis[i]=false; for(int i=1;i&lt;=cnt;++i) &#123; siz=scc[i].size(); for(int j=0;j&lt;siz;++j) &#123; int u=scc[i][j]; for(int k=head[u];k;k=nx[k]) &#123; int v=to[k]; if(bel[u]!=bel[v] &amp;&amp; !vis[bel[v]]) G[i].push_back(bel[v]),vis[bel[v]]=true,++indeg[bel[v]]; &#125; &#125; for(int j=0;j&lt;siz;++j) &#123; int u=scc[i][j]; for(int k=head[u];k;k=nx[k]) &#123; int v=to[k]; if(bel[u]!=bel[v]) vis[bel[v]]=false; &#125; &#125; &#125; for(int i=1;i&lt;=cnt;++i) if(!indeg[i]) q.push(i); while(!q.empty()) &#123; int u=q.front(); q.pop(); p[++tot]=u; siz=G[u].size(); for(int i=0;i&lt;siz;++i) &#123; int v=G[u][i]; --indeg[v]; if(!indeg[v]) q.push(v); &#125; &#125;&#125;void solve()&#123; while(cnt) &#123; int x=p[cnt]; siz=scc[x].size(); for(int y=0;y&lt;siz;++y) &#123; int u=scc[x][y]; if(u!=T) &#123; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(del[v]) continue; if(bel[v]==bel[u]) a[y][rnk[v]]-=1.0/outdeg[u]; // 可能有重边,用-= else a[y][siz]+=f[v]/outdeg[u]; &#125; a[y][siz]+=1; &#125; a[y][y]+=1; // 可能有自环,用+= &#125; Gauss(); for(int y=0;y&lt;siz;++y) f[scc[x][y]]=tmp[y]; --cnt; &#125;&#125;int main()&#123; n=read(),m=read(),S=read(),T=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); addedge(u,v); &#125; init(); if(del[S]) return puts("INF"),0; for(int i=1;i&lt;=n;++i) if(!del[i] &amp;&amp; !dfn[i]) tarjan(i); toposort(); solve(); printf("%.3f\n",f[S]); return 0;&#125;]]></content>
      <tags>
        <tag>概率/期望</tag>
        <tag>tarjan</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3143 游走]]></title>
    <url>%2F2019%2F12%2F13%2Fbzoj-3143-%E6%B8%B8%E8%B5%B0%2F</url>
    <content type="text"><![CDATA[图上随机游走. 每条边的贡献是它被赋上的权值乘上它期望被经过的次数. 根据排序不等式,显然应该给期望被经过次数更大的边赋更小的权值,给期望被经过次数更小的边赋更大的权值. 设 $f(i)$ 表示点 $i$ 期望被经过的次数,则边 $(u,v)$ 期望被经过的次数为 $[u\neq n]\frac{f(u)}{\deg(u)}+[v\neq n]\frac{f(v)}{\deg(v)}$ . 转移有,$$f(i)=[i=1]+\sum_{(j,i)\in E,j\neq n} \frac{f(j)}{\deg(j)}$$ 高斯消元解出所有的 $f(i)$ ,时间复杂度 $O(n^3)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const double eps=1e-8;const int MAXN=1&lt;&lt;9,MAXM=MAXN*MAXN/2;int n,m,x[MAXM],y[MAXM],deg[MAXN];double a[MAXN][MAXN],f[MAXN],val[MAXM];void Gauss()&#123; for(int i=1;i&lt;=n;++i) &#123; int j; for(j=i;j&lt;=n;++j) if(fabs(a[j][i])&gt;eps) break; for(int k=1;k&lt;=n+1;++k) swap(a[i][k],a[j][k]); for(int j=i+1;j&lt;=n;++j) &#123; double t=a[j][i]/a[i][i]; for(int k=i;k&lt;=n+1;++k) a[j][k]-=t*a[i][k]; &#125; &#125; for(int i=n;i&gt;=1;--i) &#123; f[i]=a[i][n+1]/a[i][i]; for(int j=i-1;j&gt;=1;--j) a[j][n+1]-=a[j][i]*f[i]; &#125;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); x[i]=u,y[i]=v; ++deg[u],++deg[v]; if(v!=n) a[u][v]=-1; if(u!=n) a[v][u]=-1; &#125; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) a[j][i]/=deg[i]; a[1][n+1]=1; for(int i=1;i&lt;=n;++i) a[i][i]=1; Gauss(); for(int i=1;i&lt;=m;++i) &#123; if(x[i]!=n) val[i]+=f[x[i]]/deg[x[i]]; if(y[i]!=n) val[i]+=f[y[i]]/deg[y[i]]; &#125; sort(val+1,val+1+m); double ans=0; for(int i=1;i&lt;=m;++i) ans+=val[i]*(m+1-i); printf("%.3f\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>概率/期望</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3720 Gty的妹子树]]></title>
    <url>%2F2019%2F12%2F13%2Fbzoj-3720-Gty%E7%9A%84%E5%A6%B9%E5%AD%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树上分块. 考虑对树分块,限制块大小为 $\sqrt n$ . 加入一个点时,若它的父亲所在块大小达到了 $\sqrt n$ ,就给它新建一个块,否则将它加入父亲所在块. 对于每个块,用一个数组维护块内所有的权值,若有修改,直接将它重新 sort 一遍. 询问时,从 u 开始向下 dfs ,遇到 u 所在的块,暴力统计,遇到其他块,在维护的权值数组中二分即可算出贡献. 时间复杂度 $O(n\sqrt n \log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=6e4+10,B=250;int n,m,lastans=0,ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int w[MAXN],bel[MAXN],tot=0;struct Block&#123; int siz,val[B]; void Sort() &#123; sort(val,val+siz); &#125; void add(int x) &#123; val[siz++]=w[x]; Sort(); &#125; void modify(int x,int y) &#123; int pos=lower_bound(val,val+siz,w[x])-val; val[pos]=w[x]=y; Sort(); &#125; int query(int x) &#123; return siz-(upper_bound(val,val+siz,x)-val); &#125;&#125;b[MAXN];int Fa[MAXN];vector&lt;int&gt; G[MAXN];void dfs(int u,int fa)&#123; Fa[u]=fa; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa) continue; if(b[bel[u]].siz==B) &#123; bel[v]=++tot; b[tot].add(v); G[bel[u]].push_back(tot); &#125; else &#123; bel[v]=bel[u]; b[bel[v]].add(v); &#125; dfs(v,u); &#125;&#125;int dfs_block(int u,int x)&#123; int res=b[u].query(x); for(int i=0;i&lt;(signed)(G[u].size());++i) &#123; int v=G[u][i]; res+=dfs_block(v,x); &#125; return res;&#125;int dfs_calc(int u,int x)&#123; int res=0; if(w[u]&gt;x) ++res; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==Fa[u]) continue; if(bel[v]==bel[u]) res+=dfs_calc(v,x); else res+=dfs_block(bel[v],x); &#125; return res;&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; for(int i=1;i&lt;=n;++i) w[i]=read(); bel[1]=++tot; b[tot].add(1); dfs(1,0); int m=read(); for(int i=1;i&lt;=m;++i) &#123; int op=read(),x=read()^lastans,y=read()^lastans; if(op==0) printf("%d\n",lastans=dfs_calc(x,y)); else if(op==1) b[bel[x]].modify(x,y); else &#123; int z=++n; w[z]=y; addedge(x,z); if(b[bel[x]].siz==B) &#123; bel[z]=++tot; b[tot].add(z); G[bel[x]].push_back(tot); &#125; else &#123; bel[z]=bel[x]; b[bel[z]].add(z); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3712 Fiolki]]></title>
    <url>%2F2019%2F12%2F12%2Fbzoj-3712-Fiolki%2F</url>
    <content type="text"><![CDATA[树上求 LCA . 对于第 $i$ 个操作,新建一个点 $p$ ,从 $p$ 向 $a,b$ 连边,之后如果 $b$ 还会参与反应,就用 $p$ 代替. 最后会连成一棵森林,考虑每对会产生沉淀的液体 $c_i,d_i​$ 带来的贡献. 如果它们不在一棵树中,显然没有贡献.否则,这两种液体会在它们的 LCA 处形成沉淀(如果还有剩余). 需要考虑之前发生的反应的影响,将所有反应按照 LCA 深度为第一关键字,优先级为第二关键字排序,模拟即可. 时间复杂度 $O(n\log n+k\log k+k\log n)​$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=4e5+10,K=19;int ecnt=0,to[MAXN],nx[MAXN],head[MAXN];int n,m,k,cnt=0,fa[MAXN][K],col[MAXN],dep[MAXN];void addedge(int u,int v)&#123; fa[v][0]=u; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;struct Reaction&#123; int x,y,dep,pri; bool operator &lt; (const Reaction &amp;rhs) const &#123; if(dep!=rhs.dep) return dep&gt;rhs.dep; return pri&lt;rhs.pri; &#125; &#125;p[MAXN&lt;&lt;1];void dfs(int u,int F)&#123; fa[u][0]=F,col[u]=cnt; for(int i=1;(1&lt;&lt;i)&lt;=dep[u];++i) fa[u][i]=fa[fa[u][i-1]][i-1]; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; dep[v]=dep[u]+1; dfs(v,u); &#125;&#125;int lca(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=K-1;i&gt;=0;--i) if((1&lt;&lt;i)&lt;=dep[x]-dep[y]) x=fa[x][i]; if(x==y) return x; for(int i=K-1;i&gt;=0;--i) if((1&lt;&lt;i)&lt;=dep[x] &amp;&amp; fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;int g[MAXN],pos[MAXN];int main()&#123; n=read(),m=read(),k=read(); for(int i=1;i&lt;=n;++i) g[i]=read(),pos[i]=i; for(int i=1;i&lt;=m;++i) &#123; int a=read(),b=read(); addedge(n+i,pos[a]); addedge(n+i,pos[b]); pos[a]=pos[b]=n+i; &#125; for(int i=1;i&lt;=n+m;++i) if(!fa[i][0]) &#123; ++cnt; dfs(i,0); &#125; cnt=0; for(int i=1;i&lt;=k;++i) &#123; int x=read(),y=read(); if(col[x]!=col[y]) continue; ++cnt; p[cnt].x=x,p[cnt].y=y; p[cnt].dep=dep[lca(x,y)]; p[cnt].pri=cnt; &#125; ll ans=0; sort(p+1,p+1+cnt); for(int i=1;i&lt;=cnt;++i) &#123; int x=p[i].x,y=p[i].y; int t=min(g[x],g[y]); ans+=t; g[x]-=t,g[y]-=t; &#125; cout&lt;&lt;(ans&lt;&lt;1)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3717 Pakowanie]]></title>
    <url>%2F2019%2F12%2F12%2Fbzoj-3717-Pakowanie%2F</url>
    <content type="text"><![CDATA[状压 dp. 考虑将所有包按照容量从大到小排序,从前往后依次装好每个包. 设 $f(S)$ 表示已经装了集合 $S$ 中的物品,最少用的包的数目,. 设 $g(S)$ 表示在用最少的包的前提下,最后的那个包最多还剩的容量. 枚举加入哪个物品,若剩余容量足够,就加入剩余容量,否则去新开一个包. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=24;int n,m,a[MAXN],c[MAXN*5];int f[1&lt;&lt;MAXN],g[1&lt;&lt;MAXN];bool in(int S,int x)&#123; return (S&gt;&gt;x)&amp;1;&#125;void upd(int &amp;x,int y)&#123; x=max(x,y);&#125;int main()&#123; n=read(),m=read(); for(int i=0; i&lt;n; ++i) a[i]=read(); for(int i=1; i&lt;=m; ++i) c[i]=read(); sort(c+1,c+m+1); reverse(c+1,c+m+1); memset(f,0x3f,sizeof f); int inf=f[0]; f[0]=0,g[0]=0; for(int S=0; S&lt;(1&lt;&lt;n); ++S) if(f[S]&lt;inf) for(int i=0; i&lt;n; ++i) if(!in(S,i)) &#123; if(g[S]&gt;=a[i]) &#123; if(f[S]&lt;f[S|(1&lt;&lt;i)]) f[S|(1&lt;&lt;i)]=f[S],g[S|(1&lt;&lt;i)]=g[S]-a[i]; else if(f[S]==f[S|(1&lt;&lt;i)]) upd(g[S|(1&lt;&lt;i)],g[S]-a[i]); &#125; else if(c[f[S]+1]&gt;=a[i]) &#123; if(f[S]+1&lt;f[S|(1&lt;&lt;i)]) f[S|(1&lt;&lt;i)]=f[S]+1,g[S|(1&lt;&lt;i)]=c[f[S]+1]-a[i]; else if(f[S]+1==f[S|(1&lt;&lt;i)]) upd(g[S|(1&lt;&lt;i)],c[f[S]+1]-a[i]); &#125; &#125; if(f[(1&lt;&lt;n)-1]&lt;inf) cout&lt;&lt;f[(1&lt;&lt;n)-1]&lt;&lt;endl; else puts("NIE"); return 0;&#125;]]></content>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3711 Druzyny]]></title>
    <url>%2F2019%2F12%2F12%2Fbzoj-3711-Druzyny%2F</url>
    <content type="text"><![CDATA[cdq 分治 + 线段树. 设 $f(i)$ 表示前 $i$ 个人能分成的组数最大值,转移有,$$f(i)=\max_{j=0}^{i-1} \lbrace f(j) \rbrace +1 ,\max c\le i-j \le \min d$$其中, $\max c$ 表示区间 $[j+1,i]$ 内最大的 $c$ , $\min d$ 表示区间 $[j+1,i]$ 内最小的 $d$ . $d$ 的限制是容易处理的,若只考虑 $d$ 的限制,对于每个 $i$ ,合法的 $j$ 显然是一段后缀,设为 $[g(i),i-1]$ . 而 $g(i)​$ 是不降的,可以用双指针扫,每次用线段树问一下区间最小的 $d​$ ,就能在 $O(n\log n)​$ 的时间内预处理出来. 要加上 $c$ 的限制,考虑 cdq 分治,要算出 $[l,r]$ 内的每个 $f(i)$ ,若 $l=r$ ,就返回. 否则,先取划分位置 $k$ 表示区间 $[l+1,r]$ 内 $c$ 最大的位置. 递归处理 $[l,k-1]$ 后,考虑 $[l,k-1]$ 的 $dp$ 值对 $[k,r]$ 的贡献,再递归处理 $[k,r]$ . 在区间 $[k,r]$ 内依次枚举 $i$ ,计算左边区间对右边区间每个 $i$ 的贡献,并且时刻维护合法的 $j$ 中, $f(j)$ 的最大值. 初始时,合法的 $j$ 所在区间为 $[\max(l,g(i)),\min(k-1,i-c_k)]$ . 每当 $i$ 往右边移动一个位置,当 $i&lt; k+c_k$ 时, $j$ 所在区间右端点也会往右边移动一个位置,直接把它的贡献加入. 而 $j​$ 所在区间左端点也可能往右边移动,由于不支持删除一段区间的贡献,只能用线段树重新查询一次. 当 $i$ 移动到 $k+c_k$ 时,右端点不再移动,而左端点单调不降,每次二分出左端点相同的一段 $i$ ,用线段树一起更新答案. 计算贡献的同时还要计算方案数,可以定义一个二元组 $(mx,cnt)​$ ,一起转移即可. 这样计算,时间复杂度 $T(n)=T(x)+T(n-x)+\min(x,n-x)​$ ,为 $O(n\log n)​$ . 如果我们对于每个 $i$ ,都对合法的 $j$ 所在区间用线段树查询一次,由于划分位置不一定是区间中点,就退化了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7,inf=1e9;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;const int MAXN=1e6+100000;struct Info&#123; int mx,cnt; Info(int mx=0,int cnt=0):mx(mx),cnt(cnt) &#123;&#125; friend Info operator + (const Info &amp;a,const Info &amp;b) &#123; if(a.mx!=b.mx) return a.mx&gt;b.mx?a:b; else return Info(a.mx,add(a.cnt,b.cnt)); &#125; Info operator + (int x) &#123; return Info(mx+x,cnt); &#125; Info operator += (Info b) &#123; *this=*this+b; return *this; &#125;&#125; f[MAXN];int n,c[MAXN],d[MAXN],g[MAXN];struct node&#123; int maxc,pos,mind; Info f,tag;&#125; Tree[MAXN&lt;&lt;1];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1]void pushup(int o)&#123; root.maxc=max(lson.maxc,rson.maxc); if(lson.maxc&gt;rson.maxc) root.pos=lson.pos; else root.pos=rson.pos; root.mind=min(lson.mind,rson.mind); root.f=lson.f+rson.f;&#125;void BuildTree(int o,int l,int r)&#123; root.tag=Info(-inf,0); if(l==r) &#123; root.maxc=c[l]; root.pos=l; root.mind=d[l]; root.f=f[l]; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o);&#125;int query_pos(int o,int l,int r,int L,int R)&#123; if(L&lt;=l &amp;&amp; r&lt;=R) return root.pos; int mid=(l+r)&gt;&gt;1; if(R&lt;=mid) return query_pos(o&lt;&lt;1,l,mid,L,R); if(L&gt;mid) return query_pos(o&lt;&lt;1|1,mid+1,r,L,R); int lp=query_pos(o&lt;&lt;1,l,mid,L,R); int rp=query_pos(o&lt;&lt;1|1,mid+1,r,L,R); return c[lp]&gt;c[rp]?lp:rp;&#125;int query_mind(int o,int l,int r,int L,int R)&#123; if(L&gt;R) return n+1; if(L&lt;=l &amp;&amp; r&lt;=R) return root.mind; int mid=(l+r)&gt;&gt;1; if(R&lt;=mid) return query_mind(o&lt;&lt;1,l,mid,L,R); if(L&gt;mid) return query_mind(o&lt;&lt;1|1,mid+1,r,L,R); int ld=query_mind(o&lt;&lt;1,l,mid,L,R); int rd=query_mind(o&lt;&lt;1|1,mid+1,r,L,R); return min(ld,rd);&#125;void upd_add(int o,int l,int r,int L,int R,Info c)&#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; root.tag+=c; return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd_add(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd_add(o&lt;&lt;1|1,mid+1,r,L,R,c);&#125;Info query_f(int o,int l,int r,int L,int R)&#123; if(L&gt;R) return Info(-inf,0); if(L&lt;=l &amp;&amp; r&lt;=R) return root.f; int mid=(l+r)&gt;&gt;1; if(R&lt;=mid) return query_f(o&lt;&lt;1,l,mid,L,R); if(L&gt;mid) return query_f(o&lt;&lt;1|1,mid+1,r,L,R); Info lf=query_f(o&lt;&lt;1,l,mid,L,R); Info rf=query_f(o&lt;&lt;1|1,mid+1,r,L,R); return lf+rf;&#125;Info query_f(int pos)&#123; int o=1,l=0,r=n; Info res=Info(-inf,0); while(l!=r) &#123; res+=root.tag; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) o=o&lt;&lt;1,r=mid; else o=o&lt;&lt;1|1,l=mid+1; &#125; return res+root.tag;&#125;void upd_set(int o,int l,int r,int pos,Info c)&#123; if(l==r) &#123; root.f=c; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd_set(o&lt;&lt;1,l,mid,pos,c); else upd_set(o&lt;&lt;1|1,mid+1,r,pos,c); root.f=lson.f+rson.f;&#125;void modify(int l,int k,int r)&#123; int i=max(c[k]+l,k); if(g[i]&gt;=k || i&gt;r) return; int jl=max(l,g[i]),jr=i-c[k]; Info tmp=query_f(1,0,n,jl,jr)+1; while(i&lt;=k+c[k]-1 &amp;&amp; i&lt;=r) &#123; if(g[i]&gt;jl) &#123; if(g[i]&gt;=k) return; jl=g[i]; tmp=query_f(1,0,n,jl,jr)+1; &#125; f[i]+=tmp; ++jr; if(jr&gt;=jl) tmp+=f[jr]+1; ++i; &#125; while(i&lt;=r) &#123; if(g[i]&gt;jl) &#123; if(g[i]&gt;=k) return; jl=g[i]; &#125; tmp=query_f(1,0,n,jl,k-1)+1; int t=query_mind(1,0,n,jl+1,n); if(t&gt;r) &#123; upd_add(1,0,n,i,r,tmp); return; &#125; upd_add(1,0,n,i,t-1,tmp); i=t; &#125;&#125;void cdq(int l,int r)&#123; if(l==r) &#123; if(l) upd_set(1,0,n,l,f[l]+=query_f(l)); return; &#125; int k=query_pos(1,0,n,l+1,r); cdq(l,k-1); modify(l,k,r); cdq(k,r);&#125;int main()&#123; n=read(); for(int i=1; i&lt;=n; ++i) c[i]=read(),d[i]=read(); BuildTree(1,0,n); for(int i=0; i&lt;=n; ++i) d[i]=n+1,f[i]=Info(-inf,0); f[0]=Info(0,1); for(int i=0,j=0; i&lt;=n; ++i) &#123; while(j&lt;i &amp;&amp; i-j&gt;query_mind(1,0,n,j+1,i)) ++j; g[i]=j; if(d[g[i]]&gt;n) d[g[i]]=i; &#125; BuildTree(1,0,n); cdq(0,n); if(f[n].mx&gt;0) printf("%d %d\n",f[n].mx,f[n].cnt); else puts("NIE"); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>cdq分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3875 骑士游戏]]></title>
    <url>%2F2019%2F12%2F12%2Fbzoj-3875-%E9%AA%91%E5%A3%AB%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[SPFA. 设第 $i$ 只怪物的消耗为 $f(i)$ ,则$$f(i)=\min\lbrace K_i,S_i+\sum_{j\in son(i)} f(j) \rbrace$$这个转移可能成环,存在后效性,用 SPFA 去转移,一个点更新之后,要把所有连向它的点入队更新答案. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,in[MAXN];ll dis[MAXN],s[MAXN];vector&lt;int&gt; sons[MAXN],fa[MAXN];queue&lt;int&gt; q;void SPFA()&#123; for(int i=1;i&lt;=n;++i) &#123; q.push(i); in[i]=1; &#125; while(!q.empty()) &#123; int u=q.front(); q.pop(); in[u]=false; ll tmp=s[u]; for(int i=0;i&lt;(signed)(sons[u].size());++i) tmp+=dis[sons[u][i]]; if(tmp&lt;dis[u]) &#123; dis[u]=tmp; for(int i=0;i&lt;(signed)(fa[u].size());++i) &#123; int v=fa[u][i]; if(!in[v]) &#123; q.push(v); in[v]=1; &#125; &#125; &#125; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; s[i]=read(); dis[i]=read(); int m=read(); for(int k=0;k&lt;m;++k) &#123; int j=read(); sons[i].push_back(j); fa[j].push_back(i); &#125; &#125; SPFA(); cout&lt;&lt;dis[1]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2271 遗忘的集合]]></title>
    <url>%2F2019%2F12%2F12%2FLoj-2271-%E9%81%97%E5%BF%98%E7%9A%84%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[多项式 $\ln$ + 莫比乌斯反演. Loj 556 是给出每种物品的体积,问填充背包的方案数,而这个题是给出填充背包的方案数,问各个物品的体积. 仍然考虑生成函数,设方案数的生成函数为 $F(x)$ ,集合 $S$ 是否包含 $i$ 记为 $a_i$ ,则$$F(x)=\prod_{i=1}^n (\frac{1}{1-x_i})^{a_i} \\\ln(F(x))=\sum_{i=1}^n a_i\cdot \ln(\frac{1}{1-x_i}) \\\ln(F(x))=\sum_{i=1}^n a_i\cdot \sum_{j=1}^{\infty} \frac{x^{ij}}{j} \\\ln(F(x))=\sum_{i=1}^{\infty} x_i\cdot \sum_{d|i} a_d\cdot \frac{d}{i}$$将 $\ln(F(x))$ 求出,注意卷积要使用 MTT . 记 $\ln(F(x))$ 对应的数列为 $f$ ,则$$n\cdot f_n=\sum_{d|n} d\cdot a_d$$莫比乌斯反演,$$i\cdot a_i=\sum_{d|i} \mu(\frac{i}{d})\cdot d\cdot f_d$$预处理 $\mu$ 后,将每个 $d\cdot f_d$ 的贡献加到 $i$ 中,根据调和级数,时间复杂度 $O(n\log n)$ . 最后可以直接输出每个不为 $0$ 的 $i\cdot a_i$ ,因为 $a_i$ 只会是 $0,1$ . 写了一发 myy 的 $4$ 次 DFT 的 MTT ,注意这个做法中,虚部也存了信息,所以 IDFT 的时候不能只对实部除以 $n$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=(1&lt;&lt;21)+1000;int P;int add(int a,int b)&#123; return ((1LL*a+1LL*b)%P+P)%P;&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;struct Complex&#123; double r,i; Complex(double r=0,double i=0):r(r),i(i) &#123;&#125; Complex operator + (const Complex &amp;rhs) const &#123; return Complex(r+rhs.r,i+rhs.i); &#125; Complex operator - (const Complex &amp;rhs) const &#123; return Complex(r-rhs.r,i-rhs.i); &#125; Complex operator * (const Complex &amp;rhs) const &#123; return Complex(r*rhs.r-i*rhs.i,r*rhs.i+i*rhs.r); &#125; Complex conj() &#123; return Complex(r,-i); &#125;&#125;;const double Pi=acos(-1.0);int rev[MAXN],curn;Complex omega[MAXN],inv[MAXN];void init(int n)&#123; if(curn==n) return; for(int i=0; i&lt;n; ++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(n&gt;&gt;1)); for(int i=0;i&lt;n;++i) omega[i]=Complex(cos(Pi*i/n),sin(Pi*i/n)); curn=n;&#125;void DFT(Complex *a,int n,bool invflag)&#123; init(n); for(int i=0; i&lt;n; ++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; int m=l&gt;&gt;1; for(Complex *p=a; p!=a+n; p+=l) &#123; for(int i=0; i&lt;m; ++i) &#123; Complex t=omega[n/m*i]*p[i+m]; if(invflag) t=omega[n/m*i].conj()*p[i+m]; p[i+m]=p[i]-t; p[i]=p[i]+t; &#125; &#125; &#125; if(invflag) &#123; for(int i=0; i&lt;n; ++i) a[i].r/=n,a[i].i/=n; &#125;&#125;void MTT(int *A,int *B,int *C,int lenA,int lenB)&#123; int lenC=lenA+lenB-1,n=1; while(n&lt;lenC) n&lt;&lt;=1; if(lenA&lt;=10 &amp;&amp; lenB&lt;=10) &#123; static int tmp[MAXN]; for(int i=0;i&lt;lenC;++i) tmp[i]=0; for(int i=0;i&lt;lenA;++i) for(int j=0;j&lt;lenB;++j) inc(tmp[i+j],mul(A[i],B[j])); for(int i=0;i&lt;lenC;++i) C[i]=tmp[i]; return; &#125; static Complex a[MAXN],b[MAXN],c[MAXN],d[MAXN]; for(int i=0; i&lt;lenA; ++i) a[i]=Complex(A[i]&amp;32767,A[i]&gt;&gt;15); for(int i=0; i&lt;lenB; ++i) b[i]=Complex(B[i]&amp;32767,B[i]&gt;&gt;15); for(int i=lenA;i&lt;n;++i) a[i]=Complex(0,0); for(int i=lenB;i&lt;n;++i) b[i]=Complex(0,0); DFT(a,n,false); DFT(b,n,false); for(int i=0; i&lt;n; ++i) &#123; int j=(n-i)&amp;(n-1); Complex A0=(a[i]+a[j].conj())*Complex(0.5,0); Complex A1=(a[i]-a[j].conj())*Complex(0,-0.5); Complex B0=(b[i]+b[j].conj())*Complex(0.5,0); Complex B1=(b[i]-b[j].conj())*Complex(0,-0.5); c[i]=A0*B0+A0*B1*Complex(0,1); d[i]=A1*B0+A1*B1*Complex(0,1); &#125; DFT(c,n,true); DFT(d,n,true); for(int i=0; i&lt;lenC; ++i) &#123; int s1=(ll)(c[i].r+0.5)%P; int s2=(ll)(c[i].i+0.5)%P; int s3=(ll)(d[i].r+0.5)%P; int s4=(ll)(d[i].i+0.5)%P; C[i]=add(s1,mul(s4,1&lt;&lt;30)); inc(C[i],mul(add(s2,s3),1&lt;&lt;15)); &#125;&#125;void PolyInverse(int *A,int *B,int N) // B=A^(-1)&#123; int n=1; while(n&lt;N) n&lt;&lt;=1; static int res[MAXN],tmp[MAXN]; res[0]=fpow(A[0],P-2); for(int i=2; i&lt;=n; i&lt;&lt;=1) &#123; MTT(A,res,tmp,i,i); MTT(tmp,res,tmp,i,i); for(int j=0; j&lt;i; ++j) res[j]=add(mul(2,res[j]),P-tmp[j]); &#125; copy(res,res+N,B);&#125;void PolyDiff(int *A,int n)&#123; for(int i=0; i&lt;n-1; ++i) A[i]=mul(i+1,A[i+1]); A[n-1]=0;&#125;void PolyInt(int *A,int n)&#123; for(int i=n+1; i&gt;=1; --i) A[i]=mul(fpow(i,P-2),A[i-1]); A[0]=0;&#125;void PolyLn(int *A,int *B,int n) // B=ln(A)&#123; static int invA[MAXN],tmp[MAXN]; PolyInverse(A,invA,n); copy(A,A+n,tmp); PolyDiff(tmp,n); MTT(tmp,invA,tmp,n,n); PolyInt(tmp,n); copy(tmp,tmp+n,B);&#125;int n,m=0,ans[MAXN],a[MAXN],f[MAXN];int cnt=0,prime[MAXN],mu[MAXN],ism[MAXN];int main()&#123; n=read(),P=read(); for(int i=1; i&lt;=n; ++i) f[i]=read(); f[0]=1; PolyLn(f,f,n+1); ism[1]=1,mu[1]=1; for(int i=2; i&lt;=n; ++i) &#123; if(!ism[i]) &#123; prime[++cnt]=i; mu[i]=P-1; &#125; int lim=n/i; for(int j=1; j&lt;=cnt &amp;&amp; prime[j]&lt;=lim; ++j) &#123; ism[i*prime[j]]=1; if(i%prime[j]) mu[i*prime[j]]=P-mu[i]; else &#123; mu[i*prime[j]]=0; break; &#125; &#125; &#125; for(int i=1; i&lt;=n; ++i) &#123; int x=mul(i,f[i]); for(int j=i; j&lt;=n; j+=i) inc(a[j],mul(mu[j/i],x)); &#125; for(int i=1; i&lt;=n; ++i) if(a[i]) ans[++m]=a[i]; printf("%d\n",m); for(int i=1; i&lt;=m; ++i) printf("%d ",ans[i]); puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2253 礼物]]></title>
    <url>%2F2019%2F12%2F11%2FLoj-2253-%E7%A4%BC%E7%89%A9%2F</url>
    <content type="text"><![CDATA[二项式定理 + 矩阵快速幂. 设 $f(i)$ 表示前 $i$ 个人带来的礼物总和,显然有 $f(0)=0,f(i)=2f(i-1)+i^k$ . 答案为 $f(n)-f(n-1)=f(n-1)+n^k$ ,于是只需要设法求出 $f(n-1)$ . 用矩阵快速幂加速递推,需要将 $i^k$ 也通过一些元素线性表示出来. 考虑将它用二项式定理展开,$$i^k=((i-1)+1)^k=\sum_{j=0}^k (i-1)^j \binom{k}{j}$$可以发现 $i^k$ 可以由 $(i-1)^0,(i-1)^1,\dots,(i-1)^k$ 线性表示. 于是向量中维护 $i^0,i^1,\dots,i^k,f(i)$ 这些元素,用矩阵快速幂加速转移. 时间复杂度 $O(k^3\log n)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int K=12;int k;struct Matrix&#123; int v[K][K]; Matrix()&#123;memset(v,0,sizeof v);&#125; Matrix operator * (const Matrix &amp;rhs) const &#123; Matrix res; for(int i=0;i&lt;=k+1;++i) for(int p=0;p&lt;=k+1;++p) if(v[i][p]) for(int j=0;j&lt;=k+1;++j) inc(res.v[i][j],mul(v[i][p],rhs.v[p][j])); return res; &#125; void init() &#123; for(int i=0;i&lt;=k;++i) &#123; v[i][0]=1; for(int j=1;j&lt;=i;++j) v[i][j]=add(v[i-1][j],v[i-1][j-1]); &#125; memcpy(v[k+1],v[k],sizeof v[k+1]); v[k+1][k+1]=2; &#125;&#125;st,trans;Matrix fpow(Matrix a,ll b)&#123; Matrix res; for(int i=0;i&lt;=k+1;++i) res.v[i][i]=1; while(b) &#123; if(b&amp;1LL) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;ll n;int main()&#123; n=read(),k=read(); if(n==1) return puts("1"),0; trans.init(); for(int i=0;i&lt;=k+1;++i) st.v[i][0]=1; st=fpow(trans,n-2)*st; int ans=st.v[k+1][0]; inc(ans,fpow(n%P,k)); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>二项式定理</tag>
        <tag>矩阵加速</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 165,166 拉格朗日插值]]></title>
    <url>%2F2019%2F12%2F11%2FLoj-165%2C166-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%2F</url>
    <content type="text"><![CDATA[拉格朗日插值. 给出 $n$ 次多项式 $f(x)$ 上的 $n+1$ 个点 $(x_0,y_0),(x_1,y_1),\dots ,(x_n,y_n)$ . 则对于没有给出的 $f(x)$ 可以表示为 $$f(x)=\sum_{i=0}^n y_i\cdot \prod_{j\neq i} \frac{x-x_j}{x_i-x_j}$$ Loj 165 拉格朗日插值 1对已经加入的每个点 $(x_i,y_i)$ ,维护一个$$t_i=y_i\cdot \prod_{j\neq i} \frac{1}{x_i-x_j}$$加入新点时,需要计算这个点的 $t$ ,以及修改之前所有点的 $t$ . 询问时,先计算一个 $prod=\prod (x-x_j)$ , 答案就是 $\sum_{i} t\cdot \frac{prod}{x-x_i}$ . 每次将 $x-x_i$ 的逆元一起求出,时间复杂度可以做到 $O(n^2+n\log P)$ . 比较懒,就写了复杂度 $O(n^2\log P)$ 的做法. 注意要特判询问的 $x$ 的点值已经给出的情况. code Loj 166 拉格朗日插值 2给出的 $x$ 是连续的,于是第 $i$ 个询问可以变成$$\begin{aligned}f(m+i)&amp;=\sum_{j=0}^n y_j\cdot \prod_{k\neq j} \frac{m+i-k}{j-k} \\&amp;=\frac{(m+i)!}{(m+i-n-1)!}\cdot \sum_{j=0}^n \frac{y_j\cdot (-1)^{n-j}}{j!\cdot (n-j)!\cdot (m+i-j)} \\&amp;=\frac{(m+i)!}{(m+i-n-1)!}\cdot \sum_{j=0}^n \frac{y_j\cdot (-1)^{n-j}}{j!\cdot (n-j)!} \cdot \frac{1}{m-n+(n+i-j)}\end{aligned}$$前面的系数是一个下降幂的形式,可以依次求出. 可以设$$A(i)=\frac{y_i\cdot (-1)^{n-i}}{i!\cdot (n-i)!} \\B(i)=\frac{1}{m-n+i}$$这样后面就是 $\sum A(j)\cdot B(n+i-j)$ 了,用 NTT 做卷积,$f(m+i)$ 就存在 $n+i$ 的位置上了. 时间复杂度可以做到 $O(n\log n)$ .比较懒,就写了 $O(n\log P)$ 的做法. code]]></content>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
        <tag>拉格朗日插值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191211]]></title>
    <url>%2F2019%2F12%2F11%2Ftest20191211%2F</url>
    <content type="text"><![CDATA[被虐了. $Polynomial$把 $A=1,A&gt;B,B&gt;C​$ 的情况判掉,剩下的情况用 exgcd 暴搜就可以了. $Password$打表可以发现,对于任意 $i\ge 1$ ,都有第 $i+1$ 行和第 $i+3$ 行完全相同. 于是只需要维护前 $3$ 行的信息. 分块,维护前 $i$ 个块中, $j$ 一共出现了几次,前缀出现次数为 $j$ 的位置有几个,分别去更新第 $2$ 行,第 $3$ 行的答案. $Proposition$每次询问时,枚举所有变量的取值以及 $Q$ 的取值,用一个栈去模拟公式 $P$ 的计算. 可以得出对于每组变量的取值,为使 $P$ 为真, $Q$ 需要为真/假/都可以. 设 $f(i,S,0/1)$ 表示用了 $i$ 个符号,变量的取值状态为 $S$ , $Q$ 为 $0/1$ 时的方案数. 注意到 $a\to b=\lnot a\lor b$ ,所以转移是一个 or 卷积的形式,用 $FWT$ 优化.]]></content>
      <tags>
        <tag>状压dp</tag>
        <tag>分块</tag>
        <tag>暴力</tag>
        <tag>test</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 556 咱们去烧菜吧]]></title>
    <url>%2F2019%2F12%2F10%2FLoj-556-%E5%92%B1%E4%BB%AC%E5%8E%BB%E7%83%A7%E8%8F%9C%E5%90%A7%2F</url>
    <content type="text"><![CDATA[泰勒展开 + 多项式 $\exp$ 处理多重背包计数. 这题的数据有锅,原本的题面是 $a_i&gt;0$ 的,但 std 数据造错了,造出了 $a_i=0$ 的数据,甚至有 $a_i=b_i=0$ 导致答案为 $\infty$ 的数据,但管理员修的时候以为是题面数据范围写错了,就把题面改掉了. $a_i=0$ 可以直接忽略它,最后将方案数乘上 $b_i+1$ ,于是在接下来的分析以及代码中都不考虑 $a_i=0$ 的情况. 无限背包可以转化成多重背包,将 $b_i$ 调整为最多能放下的物品数目即可,于是只用考虑多重背包的计数. 考虑写出答案的生成函数 $A(x)$ ,$$A(x)=\prod_{i=1}^m (\sum_{k=0}^{b_i} x^{k\cdot a_i})=\prod_{i=1}^m \frac{1-x^{(b_i+1)\cdot a_i}}{1-x^{a_i}}$$直接求乘积需要先做 $m$ 次多项式求逆,时间复杂度不能接受. 考虑将两边同时取对数,得到$$\ln A(x)=\sum_{i=1}^{m} \ln(1-x^{(b_i+1)\cdot a_i})-\ln(1-x^{a_i})$$设 $f(k)=\ln(1-x^k)$ ,将它在 $x_0=0$ 处做泰勒展开,得到$$f(k)=\ln(1-x^k)=-\sum_{i=1}^{\infty} \frac{x^{ki}}{i}$$把相同的 $\ln (1-x^k)$ 合并同类项后,对每个 $k$ ,暴力枚举 $i$ ,将次数 $\le n$ 的贡献加入 $\ln A(x)$ 中. 每个 $k$ 需要枚举的次数是 $\frac{n}{k}$ ,而最多只有 $2m$ 个不相同的 $k$ 需要枚举. 将 $m,n$ 看做同阶,根据调和级数的求和,在这一步就可以用 $O(n\log n)$ 的时间复杂度求出 $\ln A(x)$ . 最后再做一次多项式 $\exp$ 得到 $A(x)$ . 时间复杂度 $O(n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353,G=3;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=4e5+10;int rev[MAXN],omega[MAXN],inv[MAXN],curn=0;void init(int n)&#123; if(curn==n) return; for(int i=0;i&lt;n;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(n&gt;&gt;1)); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; omega[l]=fpow(G,(P-1)/l); inv[l]=fpow(omega[l],P-2); &#125; curn=n;&#125;void DFT(int *a,int n,bool invflag)&#123; init(n); for(int i=0;i&lt;n;++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=l&gt;&gt;1; int gi=omega[l]; if(invflag) gi=inv[l]; for(int *p=a;p!=a+n;p+=l) &#123; int g=1; for(int i=0;i&lt;m;++i) &#123; int t=mul(g,p[i+m]); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int invn=fpow(n,P-2); for(int i=0;i&lt;n;++i) a[i]=mul(a[i],invn); &#125;&#125;void NTT(int *A,int *B,int *C,int lenA,int lenB)&#123; int lenC=lenA+lenB-1,n=1; while(n&lt;lenC) n&lt;&lt;=1; static int a[MAXN],b[MAXN]; copy(A,A+lenA,a); fill(a+lenA,a+n,0); copy(B,B+lenB,b); fill(b+lenB,b+n,0); DFT(a,n,false); DFT(b,n,false); for(int i=0;i&lt;n;++i) C[i]=mul(a[i],b[i]); DFT(C,n,true);&#125;void PolyInverse(int *A,int *B,int N) // B=A^(-1)&#123; int n=1; while(n&lt;N) n&lt;&lt;=1; static int res[MAXN],tmp[MAXN]; res[0]=fpow(A[0],P-2); for(int i=2;i&lt;=n;i&lt;&lt;=1) &#123; NTT(A,res,tmp,i,i); NTT(tmp,res,tmp,i,i); for(int j=0;j&lt;i;++j) res[j]=add(mul(2,res[j]),P-tmp[j]); &#125; copy(res,res+N,B);&#125;void PolyDiff(int *A,int n)&#123; for(int i=0;i&lt;n-1;++i) A[i]=mul(i+1,A[i+1]); A[n-1]=0;&#125;int Inv[MAXN];void PolyInt(int *A,int n)&#123; for(int i=n+1;i&gt;=1;--i) A[i]=mul(Inv[i],A[i-1]); A[0]=0;&#125;void PolyLn(int *A,int *B,int n) // B=ln(A)&#123; static int invA[MAXN],tmp[MAXN]; PolyInverse(A,invA,n); copy(A,A+n,tmp); PolyDiff(tmp,n); NTT(tmp,invA,tmp,n,n); PolyInt(tmp,n); copy(tmp,tmp+n,B);&#125;void PolyExp(int *A,int *B,int N) // B=exp(A)&#123; int n=1; while(n&lt;N) n&lt;&lt;=1; static int res[MAXN],tmp[MAXN]; res[0]=1; for(int i=2;i&lt;=n;i&lt;&lt;=1) &#123; PolyLn(res,tmp,i); for(int j=0;j&lt;i;++j) tmp[j]=add(A[j],P-tmp[j]); inc(tmp[0],1); NTT(tmp,res,res,i,i); &#125; copy(res,res+N,B);&#125;int n,m,t[MAXN],A[MAXN];int main()&#123; n=read(),m=read(); int N=1; while(N&lt;n+1) N&lt;&lt;=1; Inv[1]=1; for(int i=2;i&lt;N;++i) Inv[i]=mul(P/i,add(P,-Inv[P%i])); for(int i=0;i&lt;m;++i) &#123; int a=read(),b=read(); inc(t[a],1); if(b &amp;&amp; a&lt;=n/(b+1)) inc(t[a*(b+1)],P-1); &#125; for(int k=1;k&lt;=n;++k) if(t[k]) for(int i=1;i*k&lt;=n;++i) inc(A[i*k],mul(t[k],Inv[i])); PolyExp(A,A,n+1); for(int i=1;i&lt;=n;++i) printf("%d\n",A[i]); puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
        <tag>泰勒展开</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191210]]></title>
    <url>%2F2019%2F12%2F10%2Ftest20191210%2F</url>
    <content type="text"><![CDATA[被虐了. $sim$每 $q​$ 次操作可以看成一个置换 ,相当于进行了 $\lfloor \frac m q\rfloor​$ 次置换和 $m\bmod q​$ 次操作. 置换的 $\lfloor \frac m q\rfloor$ 次方可以用快速幂求出,剩下的 $m\bmod q$ 次操作直接模拟就可以了. $cs$可以发现一个结论,如果把期望得分分别为 $a,b$ 的两个相邻的裁判 $i,i+1$ 交换,且 $a\le b​$ . 那么最终的得分要么不变,要么减少 $1$ . 先考虑它们两人对得分的影响. 如果之前他们都投 $1$ ,交换后 $b$ 肯定也会投 $1$ , $a$ 投 $0$ 或 $1$ ,两人总得分不变或减少 $1$ . 如果之前 $a$ 投的 $1$ ,而 $b$ 投的 $0$ ,交换之后 $b$ 会投 $1$ ,而 $a$ 会投 $0$ ,两人总得分不变. 如果之前 $a$ 投的 $0$ ,而 $b$ 投的 $1$ ,交换之后,要么两者都投 $0$ ,要么 $b$ 投 $1$ , $a$ 投 $0$ ,两人总得分不变或减少 $1$ . 如果之前他们都投 $0$ ,交换之后,也都会投 $0$ ,两人总得分不变. 于是得出,交换后两人总得分不变或减少 $1$ . 再考虑交换之后,后面的人总得分变化情况. 若 $a,b$ 的总得分不变,后面的人投票情况也不会变,总得分不变. 若 $a,b$ 的总得分减少了 $1$ ,后面最多有一个人从 $0$ 变成 $1$ ,而其他人不变,总得分不变或减少 $1$ . 于是得出,交换后全局的总得分不变或减少 $1$ . 把所有裁判按照 $v$ 从小到大排,得分最大,从大到小排,得分最小. 而通过不断交换相邻的两个数,类似冒泡排序的过程,可以让最小值到最大值中每个分数都被取到. 那么当 $p$ 不能取到时,最优的方案就是让得分为最大值或最小值. 当 $p$ 能取到的时,最优的方案就是让得分为 $p$ . 用二分来做不断交换的这个过程. $count$考虑每对颜色相同的边 $a\to b,b\to c$ 的贡献,最多会有 $O(n^3)$ 对这样的边. 可以将这两条边删去,加入边 $a\to c$ ,得到了一张新图,贡献即为这张新图的欧拉回路数目. 若新图中, $b$ 的度数为 $0$ ,说明在原图中,任意一条欧拉回路都有 $a\to b,b\to c​$ 这部分,贡献就是原图的欧拉回路数目. 否则,得到的新图也是一张弱连通图,可以用 BEST theorem 求解欧拉回路个数. BEST theorem: 在弱连通图 $G​$ 中,若存在欧拉回路,则其数目为$${\rm ec}(G)=t_w(G)\prod_{v\in V} (\deg(v)-1)!$$其中 $w$ 是图 $G$ 中任意一个节点,而 $t_w(G)$ 表示在图 $G$ 中,以 $w$ 为根,边由儿子朝向父亲的有向生成树个数. 根据 matrix tree theorem ,这个数目等于图 $G$ 的 Laplacian 矩阵去掉第 $w$ 行第 $w$ 列的余子式. 每次用高斯消元算一遍余子式,时间复杂度 $O(n^6)$ . 考虑怎样由原图的 Laplacian 矩阵得到新图的 Laplacian 矩阵. 可以发现需要将 $(b,a),(c,b)$ 这两个位置 $+1$ ,而将 $(b,b),(c,a)$ 这两个位置 $-1$ . 为了方便,我们选择将第 $b$ 行第 $b$ 列去掉来算余子式,那么对行列式的影响只有 $(c,a)$ 这个位置减少了 $1$ . 考虑矩阵 $A​$ 的伴随矩阵 ${\rm adj\ } A​$ ,根据定义,它的第 $i​$ 行第 $j​$ 列是矩阵 $A​$ 去掉第 $j​$ 行第 $i​$ 列的代数余子式. 而当 $A$ 可逆时,有 $A^{-1}=\frac{1}{\det A}{\rm adj\ } A$ ,所以矩阵 $A$ 第 $i$ 行第 $j$ 列的代数余子式就是 $A^{-1}_{j,i}\cdot \det A$ . 那么把 $(c,a)$ 这个位置减掉 $1$ ,对行列式的影响就是减掉 $A^{-1}_{a,c}$ 乘上原来的行列式. 对于每个 $b$ 都要求一次去掉第 $b$ 行第 $b$ 列后的逆矩阵,时间复杂度 $O(n^4)$ . 上面那个做法瓶颈在求 $n$ 次逆矩阵,尝试进一步优化. 考虑用高斯消元求逆矩阵的过程,如果消掉了除了 $x$ 之外的元,那么提取出逆矩阵,将它去掉第 $x$ 行第 $x$ 列也是对的. 于是可以分治消元,定义函数 $solve(l,r)$ 表示当前 $[l,r]$ 内的元还没有消. 当 $l=r$ 时,表示其它元都消过了,于是就得到了原矩阵去掉第 $x$ 行第 $x$ 列后的逆矩阵. 否则,将 $[l,mid]$ 内的元消掉,调用 $solve(mid+1,r)$ ,将 $[mid+1,r]$ 内的元消掉,调用 $solve(l,mid)$ . 时间复杂度 $O(n^3\log n)$ .]]></content>
      <tags>
        <tag>二分</tag>
        <tag>线性代数</tag>
        <tag>高斯消元</tag>
        <tag>倍增</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2989 NOIP十合一]]></title>
    <url>%2F2019%2F12%2F09%2FLoj-2989-NOIP%E5%8D%81%E5%90%88%E4%B8%80%2F</url>
    <content type="text"><![CDATA[提交答案. 考虑仔细观察数据特点. 测试点 1特点: 图是由每个奇数点 $i$ 向 $i+1$ 连 $1$ 的边,向 $i+2$ 连 $0$ 的边,每个偶数点 $i$ 向 $i+1$ 连 $0$ 的边构成的. 询问 $(u,v,w)$ 时,特判 $u=v$ 的情况.否则,若 $u$ 为偶数,将它变成 $u+1$ ,若 $v$ 为偶数,将它变成 $v-1$ . 此时 $u,v$ 都是奇数,每次考虑让 $u$ 的编号 $+2$ . 若走 $u\to u+1\to u+2$ ,长度为 $1$ ,走 $u\to u+2$ ,长度为 $0$ . 那么可以得到答案为 ${(v-u)/2\choose w}$ . 模数不是质数,把它分解成 $2^{12}\times 3^8$ 后分开做,大概和拓展 Lucas 的做法差不多,最后 crt 合并. 测试点 2特点: 图是一条 $1\sim n$ 的链,链上边权为 $0$ ,每个点再向自己连出自环,自环有边权.每次询问的 $u$ 都为 $1$ . 设 $f(i,j)$ 表示从 $1$ 走到 $i$ ,路径边权和为 $j$ 的方案数. 注意一个自环可以走多次,所以是一个完全背包. 测试点 3特点: 图和测试点 2 一样,但询问的 $u$ 不一定为 $1$ . 跑 $n​$ 次完全背包. 本机大概跑了 80s . 测试点 4特点: 点数 $n$ 只有 $5$ . 设 $f(i,j,k)$ 表示从 $i$ 走到 $j$ ,经过的边权和为 $k$ 的方案数. $k$ 这一维是有拓扑序的,先枚举 $k​$ 就可以完成转移了. 本机大概跑了 120s. 测试点 5特点: 把 $2$ 条边看成一组,每组都是 $i\to k,k\to j$ 的形式,且 $i,j\le 10$ ,各组的 $k$ 互不相同. 把每一组的两条边并在一起,就变成测试点 4 了,只是点数变成了 $10$ . 本机大概跑了 10s. 测试点 6,8,10特点: 所有的边权都是 $1$ . 先处理出邻接矩阵 $A$ ,其中 $A_{i,j}$ 表示从 $i$ 到 $j$ ,经过 $1$ 条边的方案数. 那么根据矩阵乘法的定义,容易发现 $A^w_{i,j}$ 就表示从 $i$ 到 $j$ ,经过 $w$ 条边的方案数,即边权和为 $w$ 的方案数. 倍增预处理出 $A^1,A^2,A^4\dots$ ,询问时,只用 $A^w$ 和 $u$ 那一列的向量乘起来的贡献就可以了. 时间复杂度 $O(n^3\log w+q\cdot n^2\log w)$ . 其实有多项式的更优做法,不过反正是提答题,就咕了. 测试点 7特点: 绝大部分边权都是 $1$ ,只有很少的边权为 $2$ . 对于每条边权为 $2$ 的边,新建一个点,把这条边拆成两条边权为 $1$ 的边,然后就和测试点 6,8,10 一样了. 测试点 9]]></content>
      <tags>
        <tag>提交答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 552 MIN&MAX I]]></title>
    <url>%2F2019%2F12%2F09%2FLoj-552-MIN-MAX-I%2F</url>
    <content type="text"><![CDATA[分段打表. 考虑 $3$ 个位置 $i&lt;j&lt;k$ 能形成三元环,需要满足 $p_j&gt;\max(p_i,p_k)$ ,且区间 $(i,j),(j,k)$ (如果有) 中的数都 $&gt;p_j$ . 或 $p_j&lt;\min(p_i,p_k)$ ,且区间 $(i,j),(j,k)$ (如果有) 中的数都 $&lt;p_j​$ . 两种情况是对称的,只需要算第一种情况的贡献,最后将答案乘上 $2$ . 考虑给出一个排列 $p $ ,某个位置 $j$ 能产生 $1$ 的贡献,当且仅当 $p_j$ 既不是前缀最小值,也不是后缀最小值. 这个概率为 $1-\frac{1}{j}-\frac{1}{n-j+1}+\frac{1}{n}$ . 即所有的减去它是前缀最小值的概率,减去它是后缀最小值的概率,加上同时是最小值的概率. 于是得到答案为$$\begin{aligned}ans&amp;=2\cdot\sum_{i=1}^n (1-\frac{1}{i}-\frac{1}{n-i+1}+\frac{1}{n}) \\&amp;=2\cdot(n+1-2\cdot \sum_{i=1}^n \frac{1}{i})\end{aligned}$$只需要快速求出 $\sum_{i=1}^n \frac 1 i$ ,分段打表即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int K=1e6;void gen()&#123; freopen("data.out","w",stdout); printf("0,"); int sum=0; for(int i=1;i&lt;P;++i) &#123; inc(sum,fpow(i,P-2)); if(i%K==0) &#123; printf("%d,",sum); cerr&lt;&lt;i&lt;&lt;endl; &#125; &#125; puts("");&#125;const int sum[]=&#123;&#125;;int calc(int n)&#123; int res=sum[n/K]; for(int i=n/K*K+1;i&lt;=n;++i) inc(res,fpow(i,P-2)); return add(res,res);&#125;int main()&#123; int n=read(); int ans=n+1; inc(ans,P-calc(n)); inc(ans,ans); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>概率/期望</tag>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4818 序列计数]]></title>
    <url>%2F2019%2F12%2F08%2Fbzoj-4818-%E5%BA%8F%E5%88%97%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[生成函数. 用所有的方案数减去每个数都不是质数的方案数. 答案的生成函数显然是一个多项式的 $n$ 次方,并且是循环卷积. 由于长度很小,所以直接暴力卷积就可以了. 时间复杂度 $O(m+p^2\log n)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int Mod=20170408;int add(int a,int b)&#123; return (a+b&gt;=Mod)?(a+b-Mod):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % Mod;&#125;const int M=2e7+10,P=100;int n,m,p;void polymul(int *a,int *b,int *c)&#123; static int tmp[P]; memset(tmp,0,sizeof tmp); for(int i=0;i&lt;p;++i) if(a[i]) for(int j=0;j&lt;p;++j) inc(tmp[(i+j)%p],mul(a[i],b[j])); memcpy(c,tmp,sizeof tmp);&#125;int cnt=0,prime[M/15];bool ism[M];int res[P],a[P];int main()&#123; n=read(),m=read(),p=read(); int ans=0; for(int i=1;i&lt;=m;++i) ++a[i%p]; int b=n; res[0]=1; while(b) &#123; if(b&amp;1) polymul(res,a,res); polymul(a,a,a); b&gt;&gt;=1; &#125; inc(ans,res[0]); ism[1]=true; for(int i=2;i&lt;=m;++i) &#123; if(!ism[i]) prime[++cnt]=i; int lim=m/i; for(int j=1;j&lt;=cnt &amp;&amp; prime[j]&lt;=lim;++j) &#123; ism[i*prime[j]]=true; if(i%prime[j]==0) break; &#125; &#125; memset(a,0,sizeof a); for(int i=1;i&lt;=m;++i) if(ism[i]) ++a[i%p]; b=n; memset(res,0,sizeof res); res[0]=1; while(b) &#123; if(b&amp;1) polymul(res,a,res); polymul(a,a,a); b&gt;&gt;=1; &#125; inc(ans,Mod-res[0]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1265]]></title>
    <url>%2F2019%2F12%2F08%2FCF1265%2F</url>
    <content type="text"><![CDATA[$Div.2$ A Beautiful String如果有两个相邻字母相同,则肯定无解. 否则,每次用合适的方法填好连续的一段问号就可以了. code B Beautiful Numbers考虑从大到小加入每个数,如果在加入第 $i$ 个数后,加入的数的位置形成了一段连续的区间,则第 $i$ 个答案为 $1$ . 记录一下加入的数中,最左边的位置 $L$ 和最右边的位置 $R$ ,若 $R-L+1=i$ ,则是连续的区间. code C Beautiful Regional Contest把同一种分数的所有人看成一个数,数字大小为这些人的个数. 从大到小枚举有多少个人有奖牌,检验是否有合法解. 在有奖牌的人中,至少要有 $3$ 种分数,取分数最高的那些人获得金牌,二分出多少人得银牌时,金牌数小于银牌数. 剩下的就是铜牌,再检验一下金牌数是否小于铜牌数. code D Beautiful Sequence$0$ 只能和 $1$ 相邻, $3$ 只能和 $2$ 相邻. 所以当 $0$ 的数目比 $1$ 多时,答案只可能是 $010101\dots010$ 的形式,否则无解, $3$ 与 $2$ 同理. 否则,可以在开头放下一段 $0101\dots 01$ ,在末尾放下一段 $23\dots2323$ . 此时还剩下若干个 $1$ 和若干个 $2$ 没有放. 若两者数目相同,就直接在中间放下 $2121\dots21​$ . 若 $1$ 的数目比 $2$ 的数目多 $1$ ,就在最开头放个 $1$ ,中间放下 $2121\dots21$ . 若 $2$ 的数目比 $1$ 的数目多 $1$ ,就在最后放个 $2$ ,中间放下 $2121\dots21$ . 其余情况无解. code E Beautiful Mirrors设 $E(i)$ 表示当前应该去问第 $i$ 面镜子时,期望的天数. 边界有 $E(n+1)=0$ ,转移有 $E(i)=\frac{p_i}{100}E(i+1)+\frac{100-p_i}{100} E(1)+1$ . 从前往后推出每个 $E(i)=k_i\cdot E_1+b_i$ ,再根据 $E(n+1)=0$ 解出 $E_1$ . code F Beautiful Bracket Sequence (easy version)考虑给出一个括号序列时,怎样计算它的深度. 如果最左边是 ) ,就把它删掉. 如果最右边是 ( ,就把它删掉. 如果最左边是 ( ,最右边是 ) ,就把它们同时删掉,并且让深度 $+1​$ . 设 $f(i,j)$ 表示 $[i,j]$ 这段括号序列对答案的贡献,根据这个过程来 $dp$ 即可. code]]></content>
      <tags>
        <tag>构造</tag>
        <tag>二分</tag>
        <tag>概率/期望</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1100 对称轴]]></title>
    <url>%2F2019%2F12%2F07%2Fbzoj-1100-%E5%AF%B9%E7%A7%B0%E8%BD%B4%2F</url>
    <content type="text"><![CDATA[计算几何 + Manacher . 沿着多边形转一圈,把经过的边和角存下来,形成了一个环. 在这个环上断掉一个位置,若形成的序列是回文的,说明断掉的那个边的中点/角处有一条对称轴. 把环倍长成链,一条对称轴会在两端都被统计,用 Manacher 找有多少个长度为 $n$ 的回文串,它的一半就是答案. 判断边是否相同可以直接判长度,判断角是否相同,需要判形成它的两条边的叉积. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int N=4e5+10;struct v2&#123; int x,y; v2(int x=0,int y=0):x(x),y(y) &#123;&#125; v2 operator + (const v2 &amp;rhs) const &#123; return v2(x+rhs.x,y+rhs.y); &#125; v2 operator - (const v2 &amp;rhs) const &#123; return v2(x-rhs.x,y-rhs.y); &#125; v2 operator * (const double &amp;k) const &#123; return v2(k*x,k*y); &#125; ll modulus() &#123; return 1LL*x*x+1LL*y*y; &#125;&#125;;ll Cross(v2 A,v2 B)&#123; return 1LL*A.x*B.y-1LL*A.y*B.x;&#125;int n,m,tot,ans,r[N];ll s[N],buf[N];void Manacher()&#123; int p=0,mx=0; for(int i=0;i&lt;m;++i) &#123; if(i&gt;mx) r[i]=1; else r[i]=min(mx-i,r[2*p-i]); while(s[i-r[i]]==s[i+r[i]]) ++r[i]; if(i+r[i]-1&gt;mx) mx=i+r[i]-1,p=i; ans+=(r[i]&gt;n); &#125;&#125;v2 p[N];ll Edge(int x)&#123; return (p[x]-p[(x+1)%n]).modulus();&#125;ll Angle(int x)&#123; int y=(x+1)%n; int z=(y+1)%n; return Cross(p[y]-p[x],p[z]-p[y]);&#125;void solve()&#123; memset(r,0,sizeof r); ans=tot=0; n=read(); for(int i=0;i&lt;n;++i) &#123; p[i].x=read(); p[i].y=read(); &#125; for(int i=0;i&lt;n;++i) &#123; s[2*i]=Edge(i); s[2*i+1]=Angle(i); &#125; for(int i=2*n;i&lt;4*n;++i) s[i]=s[i-2*n]; m=4*n; Manacher(); printf("%d\n",ans&gt;&gt;1);&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>计算几何</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1039 无序运动]]></title>
    <url>%2F2019%2F12%2F07%2Fbzoj-1039-%E6%97%A0%E5%BA%8F%E8%BF%90%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[计算几何 + AC 自动机. 考虑如果给出两个长度相同的点列,如何判断它们能否匹配. 若点数 $=2$ ,则通过平移,旋转,放缩一定可以匹配. 若点数 $&gt;2$ ,先不考虑翻转,只考虑平移,旋转,放缩这三种操作. 如果任意两条相邻的边的边长之比和夹角都相等,就可以匹配. 为了避免精度问题,边长比可以用边长平方比来表示,夹角可以用叉积与点积之比来表示. 将分子分母,化成既约分数保存,注意夹角比值的分子分母都要保留符号. 将这些信息离散化,就变成了数字串的匹配,用 AC 自动机来计算匹配次数. 再考虑翻转操作,若一个点列不是所有点共线,则它翻转后不能和原来的点列通过平移,旋转,放缩匹配. 将它翻转后再做一次上面的匹配. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int N=2e5+10,M=1.6e6+10,U=(1&lt;&lt;22)-1;int sgn(int x)&#123; return x&gt;0?1:-1;&#125;struct v2&#123; double x,y; v2(double x=0,double y=0):x(x),y(y) &#123;&#125; v2 operator + (const v2 &amp;rhs) const &#123; return v2(x+rhs.x,y+rhs.y); &#125; v2 operator - (const v2 &amp;rhs) const &#123; return v2(x-rhs.x,y-rhs.y); &#125; v2 operator * (const double &amp;k) const &#123; return v2(k*x,k*y); &#125; int modulus() &#123; return x*x+y*y; &#125;&#125;;int Dot(v2 A,v2 B)&#123; return A.x*B.x+A.y*B.y;&#125;int Cross(v2 A,v2 B)&#123; return A.x*B.y-A.y*B.x;&#125;int n,m,ans[M],len[M],l[M],cnt,all[M];struct Info&#123; int a,b,c,d; Info() &#123;&#125; Info(int A,int B,int C,int D) &#123; int g=__gcd(A,B); a=A/g,b=B/g; if(!C) c=0,d=sgn(D); else if(!D) d=0,c=sgn(C); else &#123; g=__gcd(abs(C),abs(D)); c=C/g,d=D/g; &#125; &#125; bool operator &lt;= (const Info &amp;rhs) const &#123; if(a!=rhs.a) return a&lt;rhs.a; if(b!=rhs.b) return b&lt;rhs.b; if(c!=rhs.c) return c&lt;rhs.c; return d&lt;=rhs.d; &#125; bool operator &lt; (const Info &amp;rhs) const &#123; if(a!=rhs.a) return a&lt;rhs.a; if(b!=rhs.b) return b&lt;rhs.b; if(c!=rhs.c) return c&lt;rhs.c; return d&lt;rhs.d; &#125; bool operator != (const Info &amp;rhs) const &#123; return (a!=rhs.a) || (b!=rhs.b) || (c!=rhs.c) || (d!=rhs.d); &#125;&#125; pool[M];bool cmp(const int &amp;x,const int &amp;y)&#123; return pool[x]&lt;pool[y];&#125;int calc(const Info &amp;x)&#123; int l=1,r=cnt,mid,t=0; while(l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if(pool[all[mid]]&lt;=x) t=mid,l=mid+1; else r=mid-1; &#125; if(!t) return 0; if(pool[all[t]]!=x) return 0; return t;&#125;int tot,f[M],q[M],tag[M];int head[U+1],G[M],ecnt;struct E&#123; int x,y,z,nx; E() &#123;&#125; E(int _x,int _y,int _z,int _nx) &#123; x=_x,y=_y,z=_z,nx=_nx; &#125;&#125; e[M];struct S&#123; int y,z,nx; S() &#123;&#125; S(int _y,int _z,int _nx) &#123; y=_y,z=_z,nx=_nx; &#125;&#125; s[M];int son(int x,int y)&#123; int u=(x&lt;&lt;8|y)&amp;U; for(int p=head[u]; p; p=e[p].nx) if(e[p].x==x &amp;&amp; e[p].y==y) return e[p].z; e[++ecnt]=E(x,y,++tot,head[u]); head[u]=ecnt; s[ecnt]=S(y,tot,G[x]); G[x]=ecnt; return tot;&#125;int ask(int x,int y)&#123; int u=(x&lt;&lt;8|y)&amp;U; for(int p=head[u]; p; p=e[p].nx) if(e[p].x==x&amp;&amp;e[p].y==y) return e[p].z; return 0;&#125;void solve()&#123; int h=0,t=0,x,y,z,k; f[0]=-1; while(h&lt;=t) for(int i=G[x=q[h++]]; i; i=s[i].nx) &#123; y=s[i].y,q[++t]=z=s[i].z; if(x) for(int j=f[x]; ~j; j=f[j]) if((k=ask(j,y))) &#123; f[z]=k; break; &#125; &#125;&#125;bool oneline[M];v2 a[N];int b[N],c[N];int main()&#123; n=read(),m=read(); for(int i=1; i&lt;=m; ++i) &#123; int k=read(); len[i]=k; for(int j=1; j&lt;=k; ++j) a[j].x=read(),a[j].y=read(); if(k&lt;=2) continue; l[i]=cnt+1; oneline[i]=true; for(int j=2; j&lt;k; ++j) &#123; v2 A=a[j]-a[j-1],B=a[j+1]-a[j]; oneline[i]&amp;=(Cross(A,B)==0); pool[++cnt]=Info(A.modulus(),B.modulus(),Cross(A,B),Dot(A,B)); &#125; &#125; for(int i=1; i&lt;=cnt; ++i) all[i]=i; if(cnt&gt;1) sort(all+1,all+cnt+1,cmp); for(int i=1; i&lt;=n; ++i) a[i].x=read(),a[i].y=read(); for(int i=2; i&lt;n; ++i) &#123; v2 A=a[i]-a[i-1],B=a[i+1]-a[i]; b[i]=calc(Info(A.modulus(),B.modulus(),Cross(A,B),Dot(A,B))); c[i]=calc(Info(A.modulus(),B.modulus(),-Cross(A,B),Dot(A,B))); &#125; for(int i=1; i&lt;=m; ++i) if(l[i]) &#123; int en=l[i]+len[i]-2; int x,j; for(x=0,j=l[i]; j&lt;en; ++j) x=son(x,calc(pool[j])); l[i]=x; &#125; solve(); for(int x=0,i=2; i&lt;n; ++i) &#123; while(x &amp;&amp; !ask(x,b[i])) x=f[x]; tag[x=ask(x,b[i])]++; &#125; for(int i=tot; i; --i) tag[f[q[i]]]+=tag[q[i]]; for(int i=1; i&lt;=m; ++i) if(l[i]) ans[i]+=tag[l[i]]; for(int i=0; i&lt;=tot; ++i) tag[i]=0; for(int x=0,i=2; i&lt;n; ++i) &#123; while(x &amp;&amp; !ask(x,c[i])) x=f[x]; tag[x=ask(x,c[i])]++; &#125; for(int i=tot; i; --i) tag[f[q[i]]]+=tag[q[i]]; for(int i=1; i&lt;=m; ++i) if(l[i] &amp;&amp; !oneline[i]) ans[i]+=tag[l[i]]; for(int i=1; i&lt;=m; ++i) if(!l[i]) printf("%d\n",n-len[i]+1); else printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>计算几何</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1094 粒子运动]]></title>
    <url>%2F2019%2F12%2F06%2Fbzoj-1094-%E7%B2%92%E5%AD%90%E8%BF%90%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[计算几何的一些基础操作. 为了后续处理起来方便,可以先将坐标系平移,使得圆心成为坐标系的原点. 考虑枚举两个点,计算它们在移动过程中出现的最近距离来更新答案. 每个点的运动路径是 $k$ 条线段组成的折线,考虑先把这 $k$ 条线段的起止位置,时间都算出来. 尝试去模拟点的运动,通过解方程可以确定在哪里撞上边界,撞上后需要更新速度. 假设交点是 $B$ ,先找到 $A$ 满足 $\vec{AB}=\vec v$ ,求出交点处的法线,把 $A$ 沿着它对称过去得到 $A’$ ,则新的速度为 $\vec{BA’}$ . 点关于直线 $y=\tan\theta \cdot x$ 的对称可以通过角度的运算实现,用 $\alpha,\beta$ 分别表示对称前后的极角,则 $\beta=2\theta-\alpha​$ . 这样可以求出一个点的 $k$ 条线段的信息. 考虑两个点的最近距离,每个点有 $k$ 个关键时间点,所以最多需要考虑 $2k$ 个时间段. 每个时间段内两个点的方向都不会变,设 $t$ 表示「当前时刻 - 该时间段开始的时刻」,则距离的平方是 $t$ 的二次函数. 用二次函数在区间内求最小值的方法,就可以求出该时间段内两点的最近距离,注意可能有退化成一次函数的情况. 时间复杂度 $O(n^2\cdot k)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const double inf=2e9,Pi=acos(-1.0),eps=1e-8;const int N=100+10;int n,k;struct v2&#123; double x,y; v2(double x=0,double y=0):x(x),y(y) &#123;&#125; v2 operator + (const v2 &amp;rhs) const &#123; return v2(x+rhs.x,y+rhs.y); &#125; v2 operator - (const v2 &amp;rhs) const &#123; return v2(x-rhs.x,y-rhs.y); &#125; v2 operator * (const double &amp;k) const &#123; return v2(k*x,k*y); &#125; double modulus() &#123; return sqrt(x*x+y*y); &#125;&#125;p[N],v[N];double sqr(double x)&#123; return x*x;&#125;double R,cx,cy,ans=inf;void report(double x)&#123; ans=min(ans,x);&#125;v2 st[N][N],vec[N][N];double t[N][N];double solve(double x,double y,double vx,double vy)// (x+t*vx)^2+(y+t*vy)^2=R^2&#123; double a,b,c; a=vx*vx+vy*vy; b=2*x*vx+2*y*vy; c=x*x+y*y-R*R; double delta=b*b-4*a*c; // assert(delta&gt;0); return (-b+sqrt(delta))/(2*a);&#125;v2 reflect(v2 vel,v2 pos)&#123; v2 A=pos-vel; double dist=A.modulus(); double alpha=atan2(A.y,A.x); double theta=atan2(pos.y,pos.x); double beta=2*theta-alpha; if(beta&gt;2*Pi) beta-=2*Pi; return v2(dist*cos(beta),dist*sin(beta))-pos;&#125;void init(int i)&#123; v2 pos=p[i],vel=v[i]; double tim=0; for(int j=1;j&lt;=k+1;++j) &#123; st[i][j]=pos,t[i][j]=tim,vec[i][j]=vel; if(j&gt;k) break; double tc=solve(pos.x,pos.y,vel.x,vel.y); tim+=tc; pos=pos+vel*tc; vel=reflect(vel,pos); &#125;&#125;double MinDist(double T,v2 pa,v2 pb,v2 va,v2 vb)// t \in [0,T] , Dist^2=at^2+bt+c&#123; double a=sqr(va.x-vb.x)+sqr(va.y-vb.y); double b=2*(va.x-vb.x)*(pa.x-pb.x)+2*(va.y-vb.y)*(pa.y-pb.y); double c=sqr(pa.x-pb.x)+sqr(pa.y-pb.y); double x; if(fabs(a)&lt;eps) &#123; if(b&gt;0) x=0; else x=T; &#125; double mid=-b/(2*a); if(0&lt;=mid &amp;&amp; mid&lt;=T) x=mid; else &#123; if(mid&lt;0) x=0; else x=T; &#125; return sqrt(a*x*x+b*x+c);&#125;void calc(int i,int j)&#123; int k1=1,k2=1; while(k1&lt;=k &amp;&amp; k2&lt;=k) &#123; double Tmin=max(t[i][k1],t[j][k2]); double Tmax=min(t[i][k1+1],t[j][k2+1]); v2 pa=st[i][k1]+vec[i][k1]*(Tmin-t[i][k1]); v2 pb=st[j][k2]+vec[j][k2]*(Tmin-t[j][k2]); report(MinDist(Tmax-Tmin,pa,pb,vec[i][k1],vec[j][k2])); if(t[i][k1+1]&lt;t[j][k2+1]) ++k1; else ++k2; &#125;&#125;int main()&#123; scanf("%lf%lf%lf",&amp;cx,&amp;cy,&amp;R); n=read(),k=read(); for(int i=1;i&lt;=n;++i) &#123; scanf("%lf%lf%lf%lf",&amp;p[i].x,&amp;p[i].y,&amp;v[i].x,&amp;v[i].y); p[i].x-=cx; p[i].y-=cy; &#125; for(int i=1;i&lt;=n;++i) init(i); for(int i=1;i&lt;n;++i) for(int j=i+1;j&lt;=n;++j) calc(i,j); printf("%.3f\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2288 大葱的神力]]></title>
    <url>%2F2019%2F12%2F05%2FLoj-2288-%E5%A4%A7%E8%91%B1%E7%9A%84%E7%A5%9E%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[提交答案题. 需要大力观察数据的特点. 测试点 1~2$n,m$ 比较小,爆搜 + 最优化剪枝. 测试点 3只有 $1$ 个抽屉,变成了 01 背包问题. 测试点 4~5每个物品的体积是一样的,那么每个抽屉能容纳的物品数目是确定的,与放哪些物品无关. 建出费用流模型,从源点 $S$ 向每个物品连边,流量为 $1$ ,费用为 $0$ . 从每个物品 $i$ 向每个抽屉 $j$ 连边,流量为 $1$ ,费用为 $w_{ij}$ . 从每个抽屉向汇点 $T$ 连边,流量为它能容纳的物品数目,即 $\lfloor \frac b a\rfloor$ ,费用为 $0$ . 跑一遍最大费用最大流即可求出最优解,为了输出方案,只需在最后检查物品向抽屉连的边中,哪些边有流量. 测试点 6每个物品的体积差别不大,通过验证发现每个抽屉能容纳的物品数目仍是确定的. 于是和上两个测试点做法相同. 测试点 7只有第 $1$ 个物品的体积和其他物品的体积不同,枚举它放在哪个抽屉里面,对剩余的物品,像测试点 4~5 那样做. 测试点 8~10数据没有什么特点,由于这个问题是 NPC 的,并没有什么高论. 可以尝试贪心,或者模拟退火搞一搞,得分各凭本事.]]></content>
      <tags>
        <tag>提交答案</tag>
        <tag>网络流</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191205]]></title>
    <url>%2F2019%2F12%2F05%2Ftest20191205%2F</url>
    <content type="text"><![CDATA[被虐了. $split$ $pal$ $rev$ 如果是 01 序列,可以分治来做,每次从中间剖开,把左边的 $1$ 和右边的 $0$ 换过来. 考虑从高到低区分权值的每个二进制位,代价为 $O(\log a\cdot n\log n)​$ .]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态点分治学习笔记]]></title>
    <url>%2F2019%2F12%2F03%2F%E5%8A%A8%E6%80%81%E7%82%B9%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[发现自己根本不会动态点分治,于是来学一学. 在做点分治的时候,把每个重心和它下一层的重心连起来,就形成了一棵新树. 称它为点分树,根据点分治的性质,这棵树的根是原树的重心,且它的树高是 $O(\log n)$ 的. 对于点分树上的每个点,维护它作为重心时管辖的那个连通块的信息. 单点修改某个点的点权时,就在点分树上暴力向上跳,把跳到的点的信息更新一遍,只会修改到 $O(\log n)$ 个点. 于是我们通过在点分树上维护信息,就实现了支持单点修改权值的点分治,这就是动态点分治. 大概可以把点分树维护信息的模式看成线段树维护信息的模式,单点修改时向上不断 pushup 即可. bzoj 1095 捉迷藏如果没有修改操作,直接点分治,在分治中心处用不在一棵子树内的深度最大的两个黑色节点更新一下答案. 现在增加了修改颜色的操作,对每个点开两个 multiset . 第一个 multiset 维护它管辖的所有黑点中到它的父亲的所有距离. 第二个 multiset 维护它在点分树中每个儿子的第一个 multiset 中的最大值,用其中最大的两个数更新答案. 若自己是黑点,那么第二个 multiset 里面还要放入一个 $0$ . 还需要开一个 multiset 维护全局的答案. 有修改操作时,就在点分树上暴力跳,并更新跳到的 multiset 以及维护答案的 multiset. 修改时,把原来的贡献删掉,修改之后,再把新的贡献加进去. 时间复杂度 $O(n\log^2 n)$ . 注意点分树的形态与原树不一样,算距离时要在原树上求出 lca 来算. code bzoj 3730 震波考虑建出点分树,每次询问与 $x$ 距离 $\le k$ 的点权和时,就在点分树上跳. 若从重心 $a$ 跳到了重心 $b$ ,那么 $b$ 所管辖的连通块中,去掉 $a$ 的那一部分,剩下的点到 $x$ 的路径都会经过 $b$ . 那么将 $b$ 所管辖的连通块中,与 $b$ 距离 $\le k-dis(x,b)$ 的点权和计入答案. 再减去 $a$ 所管辖的连通块中,与 $b$ 距离 $\le k-dis(x,b)$ 的点权和. 用动态分配内存,给每个点开 $2$ 个树状数组,都以距离为下标,分别维护到自己的,到父亲的点权前缀和. 修改时就在点分树上跳,把 $O(\log n)$ 个祖先的树状数组都改一遍. 时间复杂度 $O(n\log^2 n)$ ,空间复杂度 $O(n\log n)$ . code bzoj 4372 烁烁的游戏这个题和震波几乎是一样的. 用树状数组去维护以深度为下标的点权差分值就可以了. code SCOI2018 D1T1 树 有一棵 $n$ 个点的无根树,每个点有点权. 需要支持以下两种操作: 询问: 给出一个点 $u$ ,询问从 $u$ 出发的简单路径中,最大的点权和. 修改:将一个点 $u$ 的点权修改为 $v$ . 操作总次数为 $m$ . $n,m\le 10^5$ ,时间限制 3s ,空间限制 64MB . 建出点分树,以 $u$ 出发的简单路径可以看成这样的形式. 从 $u$ 出发,先到 $u$ 在点分树上的某个祖先 $w$ (可以是自己),再到 $w$ 管辖的某个点 $v$ . 对每个点开两个 multiset . 第一个 muliset 维护所有它管辖的点到它在点分树上的父亲的路径权值. 第二个 multiset 维护它在点分树上所有儿子的,第一个 multiset 中的最大值. 询问时,在点分树上往上跳,从 $a$ 跳到 $b$ 时,将 $a$ 对 $b$ 的第二个 multiset 的贡献临时去掉,再查询 $b$ 的第二个 multiset 中的最大值,就一定是从不被 $a$ 管辖的点来的,再加上 $b\to u$ 的点权和 (不算 $b$ ) 来更新答案. 修改时,在点分树上往上跳,把影响到的祖先全部修改过来,并在树状数组上更新重链点权前缀和. 需要一些高超的卡空间技巧. short + char 可以拼出 $\frac 3 4$ 个 int . code]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>动态点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[THUSC2017 选做]]></title>
    <url>%2F2019%2F12%2F02%2FTHUSC2017-%E9%80%89%E5%81%9A%2F</url>
    <content type="text"><![CDATA[老张觉得比较简单,但我一道都不会做. 巧克力如果颜色数目比较少,可以暴力枚举是哪 $k$ 种颜色作为连通块中必须包含的颜色. 二分一个美味度作为中位数,大于它的赋值为 $1001$ ,小于等于它的赋值为 $999$ . 这样就达到了一个二元组的效果,会优先个数最少,再尽量让选出的 $999$ 尽量多. 用斯坦纳树进行检验,判一下最优解中, $999​$ 的个数是否 $\ge​$ $1001​$ 的个数. 用随机化乱搞加速,每次将每种颜色随机染成 $[0,k)$ 内的一种颜色,算一遍答案,这样算出来的答案肯定是合法的. 若染色时,将最优解中的 $k$ 种颜色染成了两两不同的颜色,就能求出这个最优解. 即,最劣情况下,只有一种颜色组合是最优解,此时做一次随机化求出正确答案的概率是 $\frac{k!}{k^k}​$ . 当 $k=5$ 时,做 $300$ 次随机化,求不出最优解的概率就只有 $1-(\frac{k}{k!})^{300}\approx 8\times 10^{-6}$ 了. 注意用斯坦纳树处理点权将集合 $S$ 拆成 $S1,S-S1$ 时,会将根节点的点权多算一次,需要减掉. code 杜老师把 $[L,R]$ 内的数可能含有的 $m$ 个质因数找出来,若选了 $x$ ,则 $x$ 含有的奇数次方的质因子出现次数会异或上 $1$ . 于是可以把每个数看成一个 $m$ 位的二进制数,现在要选出一些数,让它们异或起来为 $0$ . 方案数显然为 $2^k$ ,其中 $k$ 表示自由元的个数. 由于是异或方程,所以可以用线性基来代替高斯消元,最后的 $k$ 就是 $R-L+1$ 减去线性基的大小. 异或运算可以用 bitset 进行优化. 直接这样做,时间复杂度是 $O((R-L+1)\cdot \frac{R}{32})$ ,可以获得 $50$ 分. 优化一下,注意到每个数最多会有一个大于 $\sqrt R$ 的质因子,所以一个 $&gt; \sqrt R$ 的质因子一旦出现,线性基里就肯定有它. 于是线性基只需要维护 $\le \sqrt R$ 的质因子. 对于最大质因子相同且 $&gt;\sqrt R$ 的一堆数,只需要把第一个插到线性基里面,后面的异或上它再插进去. 时间复杂度优化到了 $O((R-L+1)\cdot \frac{\sqrt R}{32})$ ,可以获得 $70$ 分. 正解比较神仙,由于 $R\le 10^7$ ,所以当 $R-L&gt;6000$ 时,就认为线性基的大小就是 $[L,R]$ 内所有质数的个数. 当 $R-L\le 6000​$ 时,就用上面那个算法来做. 官方题解的证明 code 换桌考虑先建出一个费用流的模型. 从源点 $S$ 向每个人所在的点连边,流量为 $1$ ,费用为 $0$ . 把同一张桌子的所有点连成一个环,每条边流量为 $\inf$ ,费用为 $0$ . 每个人所在的点向每张桌子对应的点连边,流量为 $1$ ,费用为换桌子需要的代价. 每个点向汇点 $T$ 连边,流量为 $1$ ,费用为 $0$ . 这个图的点数 $|V|$ 是 $O(nm)$ 的,但边数 $|E|$ 是 $O(n^2m)$ 的,可以获得 $70$ 分. 注意到每个人可以去的桌子是一段区间,可以用线段树来优化建边. 因为换桌子的花费有绝对值,所以可以拆成左右两边来做. 开 $2m$ 棵线段树,每个位置有 $2$ 棵线段树,一棵表示向左换桌子的,另一棵表示向右换桌子的. 向左换桌子的线段树,第 $i​$ 个叶子的出边有个额外费用 $-2i​$ ,向右的线段树额外费用为 $2i​$ . 注意要限制对应的两个叶子总流量 $\le 1​$ . 在第 $j​$ 张桌子时,往左边连的边有额外费用 $2j​$ ,往右边连的边有额外费用 $-2j​$ . 仍然把同一张桌子上的叶子节点连成一个环,每条边流量为 $\inf$ ,费用为 $0$ ,这样就考虑了换位置的贡献. 边数被优化到了 $O(m\cdot n\log n)​$ ,跑个 zkw 费用流就可以过了. code 大魔法师用线段树给每段区间维护一个列向量$$\begin{bmatrix}\sum A\\ \sum B \\ \sum C \\ len \end{bmatrix}$$其中 $len$ 表示这个区间的长度. 修改标记可以统一成一个 $4\times 4$ 的转移矩阵,然后就变成线段树的一些基本操作了. 时间复杂度 $O(n\log n\cdot k^3)$ ,其中 $k=4$ . code 如果奇迹有颜色考虑 $Burnside$ 引理,记 $f(i)$ 表示不考虑同构时长度为 $i$ 的合法环的方案数. 则答案为$$ans=\frac{\sum_{i=1}^n f(\gcd(i,n))}{n}=\frac{\sum_{d|n}\varphi(\frac n d)\cdot f(d)}{n}$$于是需要快速求出 $f(d)$ . 考虑暴力状压 $dp$ ,先枚举一个 $s$ 表示开头 $m-1$ 个点的颜色状态. 记 $g(i,t)$ 表示已经给 $i$ 个点染了色,最后 $m-1$ 个点的颜色状态用 $t$ 表示的方案数. 最后判断每个 $g(i,t)$ 的尾部是否能和首部的 $s$ 接在一起,若合法,就计入 $f(i)$ . 每次转移需要枚举当前的点染哪个颜色,每次转移的复杂度是 $O(m)$ . 于是得出状压 $dp$ 的总时间复杂度 $O(n\cdot m^{2m-1})$ . 直接 $dp$ 复杂度显然爆炸,可以在本地把每个 $m$ 对应的前 $1000$ 项 $f(i)$ 打出来,用 $BM$ 求线性递推式. 发现当 $m=7$ 时,线性递推式的长度为 $k=410$ . 于是需要写一个 $O(k^2\log n)$ 的线性递推. 将 $n$ 质因子分解后, $O(\frac {\sqrt n}{\ln n})$ 枚举所有 $d$ ,总时间复杂度 $O(k^2\sqrt n)$ . 最后一个点要特判一下,因为 $n$ 的因数比较多,常数大. code 宇宙广播 不懂为啥要出成提答题,方便调精度? 设公切面为 $\sum_{i=0}^{K-1} a_i\cdot x_i=d​$ ,并保证 $\sum_{i=0}^{K-1} a_i^2=1​$ . 考虑 $K​$ 维空间中一个点 $(x_0,x_1,\dots,x_{K-1})​$ 到这个公切面的距离$$dis=\frac{|d-\sum_{i=0}^{K-1} a_i\cdot x_i|}{\sqrt{\sum_{i=0}^{K-1} a_i^2}}$$保证了分母为 $1$ ,所以这个点到公切面的距离就是 $|d-\sum_{i=0}^{K-1} a_i\cdot x_i|$ . 每个球的球心到公切面的距离都是这个球的半径. 所以对于第 $j$ 个球,可以得到方程 $|d-\sum_{i=0}^{K-1} a_i\cdot x_{j,i}|=r_j$ . 共有 $K$ 个这样的方程,暴力枚举每个方程绝对值取正号还是负号. 确定符号后高斯消元解出每个 $k_i,b_i$ ,表示 $a_i=k_i\cdot d+b_i$ 将所有的 $a_i$ 代入 $\sum_{i=0}^{K-1} a_i^2=1$ 就可以解出 $d$ 了. 解出 $d$ 后,这个公切面也就确定了,只需要再对每个球,求出公切面与这个球的切点. 用高斯消元解一个法向量 $\vec {n}$ 出来,把球心沿着/逆着这个法向量移动 $r$ 的距离,检验一下哪个在平面上,它就是切点了. 时间复杂度 $O(2^K\cdot K^3)​$ . code]]></content>
      <tags>
        <tag>计算几何</tag>
        <tag>BM</tag>
        <tag>常系数线性递推</tag>
        <tag>状压dp</tag>
        <tag>高斯消元</tag>
        <tag>提交答案</tag>
        <tag>随机化</tag>
        <tag>斯坦纳树</tag>
        <tag>费用流</tag>
        <tag>线段树连边</tag>
        <tag>burnside</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3878 奇怪的计算器]]></title>
    <url>%2F2019%2F12%2F02%2Fbzoj-3878-%E5%A5%87%E6%80%AA%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[线段树. 注意到每次修改后,所有数的相对大小关系不会发生改变. 于是先将所有数排好序,每次修改时,会有一段前缀被改成 $L$ ,一段后缀被改成 $R$ ,中间的正常修改. 用线段树维护这些数即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int a[MAXN],b[MAXN];struct node&#123; int val,x,addtag,multag,sxtag,settag; node() &#123; addtag=sxtag=settag=0; multag=1; &#125;&#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]void BuildTree(int o,int l,int r)&#123; root.val=root.x=0; if(l==r) &#123; root.val=root.x=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r);&#125;void modify_add(int o,int c)&#123; root.val+=c; root.addtag+=c;&#125;void modify_mul(int o,int c)&#123; root.val*=c; root.addtag*=c; root.multag*=c; root.sxtag*=c;&#125;void modify_sx(int o,int c)&#123; root.val+=root.x*c; root.sxtag+=c;&#125;void modify_set(int o,int c)&#123; root.val=c; root.addtag=root.sxtag=0; root.multag=1; root.settag=c;&#125;void pushdown(int o)&#123; if(root.settag) &#123; modify_set(o&lt;&lt;1,root.settag); modify_set(o&lt;&lt;1|1,root.settag); root.settag=0; &#125; if(root.multag!=1) &#123; modify_mul(o&lt;&lt;1,root.multag); modify_mul(o&lt;&lt;1|1,root.multag); root.multag=1; &#125; if(root.addtag) &#123; modify_add(o&lt;&lt;1,root.addtag); modify_add(o&lt;&lt;1|1,root.addtag); root.addtag=0; &#125; if(root.sxtag) &#123; modify_sx(o&lt;&lt;1,root.sxtag); modify_sx(o&lt;&lt;1|1,root.sxtag); root.sxtag=0; &#125;&#125;void upd_add(int o,int l,int r,int L,int R,int c)&#123; if(L&gt;R) return; if(L&lt;=l &amp;&amp; r&lt;=R) return modify_add(o,c); pushdown(o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd_add(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd_add(o&lt;&lt;1|1,mid+1,r,L,R,c);&#125;void upd_mul(int o,int l,int r,int L,int R,int c)&#123; if(L&gt;R) return; if(L&lt;=l &amp;&amp; r&lt;=R) return modify_mul(o,c); pushdown(o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd_mul(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd_mul(o&lt;&lt;1|1,mid+1,r,L,R,c);&#125;void upd_sx(int o,int l,int r,int L,int R,int c)&#123; if(L&gt;R) return; if(L&lt;=l &amp;&amp; r&lt;=R) return modify_sx(o,c); pushdown(o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd_sx(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd_sx(o&lt;&lt;1|1,mid+1,r,L,R,c);&#125;void upd_set(int o,int l,int r,int L,int R,int c)&#123; if(L&gt;R) return; if(L&lt;=l &amp;&amp; r&lt;=R) return modify_set(o,c); pushdown(o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd_set(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd_set(o&lt;&lt;1|1,mid+1,r,L,R,c);&#125;int query(int o,int l,int r,int pos)&#123; if(l==r) return root.val; pushdown(o); int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) return query(o&lt;&lt;1,l,mid,pos); else return query(o&lt;&lt;1|1,mid+1,r,pos);&#125;int n,m,lb,rb;struct opt&#123; int op,x;&#125;q[MAXN];char buf[MAXN];int main()&#123; m=read(),lb=read(),rb=read(); for(int i=1;i&lt;=m;++i) &#123; scanf("%s %d",buf,&amp;q[i].x); if(buf[0]=='+') q[i].op=1; else if(buf[0]=='-') q[i].op=1,q[i].x*=-1; else if(buf[0]=='*') q[i].op=2; else q[i].op=3; &#125; n=read(); for(int i=1;i&lt;=n;++i) a[i]=b[i]=read(); sort(a+1,a+1+n); BuildTree(1,1,n); for(int i=1;i&lt;=m;++i) &#123; int op=q[i].op,x=q[i].x,L,R,pre,suf; if(op==1) &#123; L=1,R=n,pre=0; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; int v=query(1,1,n,mid); if(v+x&lt;lb) pre=mid,L=mid+1; else R=mid-1; &#125; L=1,R=n,suf=n+1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; int v=query(1,1,n,mid); if(v+x&gt;rb) suf=mid,R=mid-1; else L=mid+1; &#125; upd_set(1,1,n,1,pre,lb); upd_set(1,1,n,suf,n,rb); upd_add(1,1,n,pre+1,suf-1,x); &#125; else if(op==2) &#123; L=1,R=n,pre=0; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; int v=query(1,1,n,mid); if(1LL*v*x&lt;1LL*lb) pre=mid,L=mid+1; else R=mid-1; &#125; L=1,R=n,suf=n+1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; int v=query(1,1,n,mid); if(1LL*v*x&gt;1LL*rb) suf=mid,R=mid-1; else L=mid+1; &#125; upd_set(1,1,n,1,pre,lb); upd_set(1,1,n,suf,n,rb); upd_mul(1,1,n,pre+1,suf-1,x); &#125; else &#123; L=1,R=n,pre=0; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; int v=query(1,1,n,mid); if(1LL*x*a[mid]+v&lt;1LL*lb) pre=mid,L=mid+1; else R=mid-1; &#125; L=1,R=n,suf=n+1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; int v=query(1,1,n,mid); if(1LL*x*a[mid]+v&gt;1LL*rb) suf=mid,R=mid-1; else L=mid+1; &#125; upd_set(1,1,n,1,pre,lb); upd_set(1,1,n,suf,n,rb); upd_sx(1,1,n,pre+1,suf-1,x); &#125; &#125; for(int i=1;i&lt;=n;++i) &#123; int pos=lower_bound(a+1,a+1+n,b[i])-a; printf("%d\n",query(1,1,n,pos)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5006 随机二分图]]></title>
    <url>%2F2019%2F12%2F02%2Fbzoj-5006-%E9%9A%8F%E6%9C%BA%E4%BA%8C%E5%88%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[状压 $dp$ . 考虑如果只有单独的边,可以用状压 $dp$ 来做. 设 $f(S,T)$ 表示左边已经匹配的集合为 $S$ ,右边已经匹配的集合为 $T$ 的期望方案数. 为了避免重复计数,规定加入边的顺序为按照左边点的编号从小到大排序. 现在有边组,考虑仍然把它们看成独立的两条边. 可以发现边组二少算了 $\frac 1 4$ 的贡献,边组三多算了 $\frac 1 4$ 的贡献,把边强行绑在一起形成新边,把这些贡献调整过来. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7,inv2=(P+1)&gt;&gt;1,inv4=(P+1)&gt;&gt;2;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int N=15,M=N*N*3;int n,k,m,U;struct Edge&#123; int l,r,w; Edge(int l=0,int r=0,int w=0):l(l),r(r),w(w) &#123;&#125;&#125;E[M];int lowbit(int x)&#123; return x&amp;(-x);&#125;bool intersect(int S,int T)&#123; return S&amp;T;&#125;map&lt;pair&lt;int,int&gt;,int&gt; f;int dfs(int S,int T)&#123; if(S==U &amp;&amp; T==U) return 1; pair&lt;int,int&gt; tmp=make_pair(S,T); if(f.count(tmp)) return f[tmp]; int ans=0; for(int i=0;i&lt;m;++i) &#123; int l=E[i].l,r=E[i].r,w=E[i].w; if(!intersect(S,l) &amp;&amp; !intersect(T,r) &amp;&amp; intersect(l,lowbit(U-S))) inc(ans,mul(dfs(S^l,T^r),w)); &#125; return f[tmp]=ans;&#125;int main()&#123; n=read(),k=read(); for(int i=0;i&lt;k;++i) &#123; int tp=read(),a=read()-1,b=read()-1; E[m++]=Edge(1&lt;&lt;a,1&lt;&lt;b,inv2); if(tp) &#123; int c=read()-1,d=read()-1; E[m++]=Edge(1&lt;&lt;c,1&lt;&lt;d,inv2); if(a==c || b==d) continue; E[m++]=Edge((1&lt;&lt;a)+(1&lt;&lt;c),(1&lt;&lt;b)+(1&lt;&lt;d),tp==1?inv4:P-inv4); &#125; &#125; U=(1&lt;&lt;n)-1; int ans=mul(1&lt;&lt;n,dfs(0,0)); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>概率/期望</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5019 遗失的答案]]></title>
    <url>%2F2019%2F12%2F01%2Fbzoj-5019-%E9%81%97%E5%A4%B1%E7%9A%84%E7%AD%94%E6%A1%88%2F</url>
    <content type="text"><![CDATA[状压 $dp$ + $FWT$ . 若将每个数分解质因数,则 $\rm gcd,lcm$ 的限制等价于给出了每个质因子次数的 $\min,\max$ . 注意到 $n$ 的不同质因子个数 $\omega(n)\le 8$ ,比较少. 用一个 $16$ 位的二进制数 $S$ 表示各个质因子的 $\min,\max$ 是否被取到. 只有那些既是 $\rm gcd$ 倍数,又是 $\rm lcm$ 约数的数才有用,把它们全部爆搜出来,记这样的数共有 $m​$ 个. 记 $f(i,S)​$ 表示考虑了第 $1\sim i​$ 个数,是否被取到的状态为 $S​$ 的方案数. 记 $g(i,S)$ 表示考虑了第 $i\sim m$ 个数,是否被取到的状态为 $S$ 的方案数. 那么强制要求选第 $i$ 个数时,就把 $f(i-1)$ 和 $g(i+1)$ 用 $FWT​$ 做个或卷积. 将那些与第 $i$ 个数的状态 $S_i$ 或起来后为全集 $U$ 的位置上的值加起来,就是答案. $m$ 并不会太大,可以将每次询问的答案记忆化下来,时间复杂度 $O(Q+m\cdot 4^{\omega(n)} \omega(n))$ . 实测发现 $m&lt; 800$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;void FWT(int *a,int n)&#123; for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=l&gt;&gt;1; for(int *p=a;p!=a+n;p+=l) for(int i=0;i&lt;m;++i) inc(p[i+m],p[i]); &#125;&#125;void IFWT(int *a,int n)&#123; for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=l&gt;&gt;1; for(int *p=a;p!=a+n;p+=l) for(int i=0;i&lt;m;++i) inc(p[i+m],P-p[i]); &#125;&#125;const int N=800,M=1&lt;&lt;16;int tot=0,factor[N],l[N],r[N];int n,Gcd,Lcm,m=0;struct info&#123; int a,s; info(int a=0,int s=0):a(a),s(s) &#123;&#125; bool operator &lt; (const info &amp;rhs) const &#123; return a&lt;rhs.a; &#125;&#125;p[N];void dfs(int k,int prod,int st)&#123; if(k==tot) &#123; ++m; p[m].a=prod; p[m].s=st; return; &#125; for(int i=1;i&lt;=l[k];++i) prod*=factor[k]; for(int i=l[k];i&lt;=r[k];++i) &#123; int t=st; if(i==l[k]) t|=1&lt;&lt;k; if(i==r[k]) t|=1&lt;&lt;(k+tot); dfs(k+1,prod,t); if(n/prod&lt;factor[k]) return; prod*=factor[k]; &#125;&#125;int f[N][M],g[N][M],ans[N],tmp[M];int main()&#123; n=read(),Gcd=read(),Lcm=read(); if(Lcm%Gcd) &#123; int Q=read(); while(Q--) puts("0"); return 0; &#125; for(int i=2;i*i&lt;=Lcm;++i) if(Lcm%i==0) &#123; factor[tot]=i; while(Gcd%i==0) ++l[tot],Gcd/=i; while(Lcm%i==0) ++r[tot],Lcm/=i; tot++; &#125; if(Lcm&gt;1) &#123; factor[tot]=Lcm; r[tot]=1; if(Gcd==Lcm) l[tot]=1; tot++; &#125; int N=(1&lt;&lt;(2*tot)); dfs(0,1,0); sort(p+1,p+m+1); f[0][0]=1; for(int i=0;i&lt;m;++i) for(int S=0;S&lt;N;++S) if(f[i][S]) &#123; inc(f[i+1][S],f[i][S]); inc(f[i+1][S|p[i+1].s],f[i][S]); &#125; g[m+1][0]=1; for(int i=m+1;i&gt;1;--i) for(int S=0;S&lt;N;++S) if(g[i][S]) &#123; inc(g[i-1][S],g[i][S]); inc(g[i-1][S|p[i-1].s],g[i][S]); &#125; memset(ans,-1,sizeof ans); int Q=read(); while(Q--) &#123; int c=read(); int x=lower_bound(p+1,p+1+m,info(c,0))-p; if(c!=p[x].a) &#123; puts("0"); continue; &#125; if(ans[x]!=-1) &#123; printf("%d\n",ans[x]); continue; &#125; ans[x]=0; FWT(f[x-1],N); FWT(g[x+1],N); for(int i=0;i&lt;N;++i) tmp[i]=mul(f[x-1][i],g[x+1][i]); IFWT(tmp,N); IFWT(f[x-1],N); IFWT(g[x+1],N); for(int S=0;S&lt;N;++S) if((S|p[x].s)==(N-1)) inc(ans[x],tmp[S]); printf("%d\n",ans[x]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>状压dp</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3684 大朋友和多叉树]]></title>
    <url>%2F2019%2F12%2F01%2Fbzoj-3684-%E5%A4%A7%E6%9C%8B%E5%8F%8B%E4%B8%8E%E5%A4%9A%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[生成函数 + 拉格朗日反演 + 多项式操作. 设 $f(x)$ 表示权值为 $x$ 的神犇多叉树的个数,边界为 $f(1)=1$ . 转移时,枚举根节点有 $k$ 个孩子,转移是将他们全部卷积起来. 设 $F(x)$ 是答案的生成函数,则$$F(x)=\sum_{k\in D} F^k(x) + x$$可以找出它的复合逆 $G(x)=x-\sum_{k\in S} x^k$ . 保证了 $S$ 中的元素 $\ge 2$ ,所以 $F,G$ 的常数项都为 $0$ , $1$ 次项系数都为 $1$ . 于是可以用拉格朗日反演求出 $[x^n] F(x)$ .$$[x^n] F(x)=[x^{n-1}] \frac 1 n (\frac{x}{G(x)})^n$$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=950009857,G=7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=8e5+10;int rev[MAXN],omega[MAXN],inv[MAXN],curn;void init(int n)&#123; for(int i=0;i&lt;n;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(n&gt;&gt;1)); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; omega[l]=fpow(G,(P-1)/l); inv[l]=fpow(omega[l],P-2); &#125; curn=n;&#125;void DFT(int *a,int n,bool invflag)&#123; if(curn!=n) init(n); for(int i=0; i&lt;n; ++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; int m=(l&gt;&gt;1); int gi=omega[l]; if(invflag) gi=inv[l]; for(int *p=a; p!=a+n; p+=l) &#123; int g=1; for(int i=0; i&lt;m; ++i) &#123; int t=mul(g,p[i+m]); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int invn=fpow(n,P-2); for(int i=0; i&lt;n; ++i) a[i]=mul(a[i],invn); &#125;&#125;void NTT(int *A,int *B,int *C,int lenA,int lenB)&#123; static int a[MAXN],b[MAXN]; int lenC=lenA+lenB-1,n=1; while(n&lt;lenC) n&lt;&lt;=1; for(int i=0;i&lt;lenA;++i) a[i]=A[i]; for(int i=lenA;i&lt;n;++i) a[i]=0; for(int i=0;i&lt;lenB;++i) b[i]=B[i]; for(int i=lenB;i&lt;n;++i) b[i]=0; DFT(a,n,false); DFT(b,n,false); for(int i=0; i&lt;n; ++i) C[i]=mul(a[i],b[i]); DFT(C,n,true);&#125;void PolyInverse(int *A,int *B,int N)&#123; int n=1; while(n&lt;N) n&lt;&lt;=1; static int tmp[MAXN]; B[0]=fpow(A[0],P-2); for(int i=2;i&lt;=n;i&lt;&lt;=1) &#123; NTT(A,B,tmp,i,i); NTT(tmp,B,tmp,i,i); for(int j=0;j&lt;i;++j) B[j]=add(mul(2,B[j]),P-tmp[j]); &#125;&#125;void PolyDiff(int *A,int n)&#123; for(int i=0;i&lt;n-1;++i) A[i]=mul(A[i+1],i+1); A[n-1]=0;&#125;void PolyInt(int *A,int n)&#123; for(int i=n;i&gt;=1;--i) A[i]=mul(A[i-1],fpow(i,P-2)); A[0]=0;&#125;void PolyLn(int *A,int *B,int n)&#123; static int tmp[MAXN],Inv[MAXN]; copy(A,A+n,tmp); PolyDiff(tmp,n); PolyInverse(A,Inv,n); NTT(tmp,Inv,B,n,n); PolyInt(B,n);&#125;void PolyExp(int *A,int *B,int N)&#123; int n=1; while(n&lt;N) n&lt;&lt;=1; static int tmp[MAXN]; B[0]=1; for(int i=2;i&lt;=n;i&lt;&lt;=1) &#123; PolyLn(B,tmp,i); for(int j=0;j&lt;i;++j) tmp[j]=add(A[j],P-tmp[j]); tmp[0]=add(tmp[0],1); NTT(tmp,B,B,i,i); &#125;&#125;void PolyPower(int *A,int *B,int k,int n)&#123; static int tmp[MAXN]; PolyLn(A,tmp,n); for(int i=0;i&lt;n;++i) tmp[i]=mul(tmp[i],k); PolyExp(tmp,B,n);&#125;int n,m,g[MAXN],Invg[MAXN],f[MAXN];int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int k=read(); g[k-1]=P-1; &#125; g[0]=add(g[0],1); PolyInverse(g,Invg,n+1); PolyPower(Invg,f,n,n+1); cout&lt;&lt;mul(f[n-1],fpow(n,P-2))&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>拉格朗日反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拉格朗日反演学习笔记]]></title>
    <url>%2F2019%2F12%2F01%2F%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%8F%8D%E6%BC%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[若两个多项式 $F(x),G(x)$ ,都满足常数项为 $0$ , $1$ 次项不为 $0$ ,且两者互为复合逆,即, $G(F(x))=x$ ,则有 $$[x^n] F(x)=\frac 1 n [x^{-1}] \frac{1}{G^n(x)} \\[x^n] F(x)=\frac 1 n [x^{n-1}] (\frac{x}{G(x)})^n$$ 两个式子是等价的,在计算中常用第二个式子. 得到 $G(x)$ 后,用多项式求逆 + 多项式快速幂,可以在 $O(n\log n)$ 的时间复杂度内求出 $F(x)$ . 拓展拉格朗日反演:$$[x^n]H(F(x))=\frac 1 n[x^{n-1}]H’(x)(\frac x {G(x)})^n$$ 证明: 设 $F(x)$ 的各项系数为 $a_i$ ,即 $F(x)=\sum_{i} a_ix^i​$ . 由于 $F(x),G(x)​$ 互为复合逆,代入 $F(G(x))=x​$ ,得到$$\sum_{i} a_i G^i(x) =x$$两边同时对 $x​$ 求导,得到$$\sum_{i} a_i\cdot i\cdot G^{i-1}(x)\cdot G’(x)=1$$两边同时除以 $G^n(x)$ ,得到$$\sum_{i} a_i\cdot i\cdot G^{i-n-1}(x)\cdot G’(x)=\frac{1}{G^n(x)}$$取 $x$ 的 $-1$ 次项,$$[x^{-1}] \sum_{i} a_i\cdot i\cdot G^{i-n-1}(x)\cdot G’(x)=[x^{-1}]\frac{1}{G^n(x)}$$对于那些 $i\neq n$ 的项,注意到 $G^{i-n-1}(x)\cdot G’(x)=\frac{1}{i-n} (G^{i-n})’(x)$ ,是个多项式. 而任何一个多项式求导后 $x^{-1}$ 系数都为 $0$ ,所以这些项对 $x^{-1}$ 的系数没有贡献. 只需要考虑 $i=n​$ 的那一项,即$$[x^{-1}] a_n\cdot n\cdot G^{-1}(x)\cdot G(x)=[x^{-1}]\frac{1}{G^n(x)}$$ 当 $i=n$ 时,$$\begin{aligned}G^{-1}(x)\cdot G’(x)&amp;=\frac{a_1+2a_2x+3a_3x^2+\dots}{a_1x+a_2x^2+a_3x^3+\dots} \\&amp;=\frac{a_1+2a_2x+3a_3x^2+\dots}{a_1 x} \cdot \frac{1}{1+\frac{a_2}{a_1}x+\frac{a_3}{a_1}x^2+\dots}\end{aligned}$$对于 $1+\frac{a_2}{a_1}x+\frac{a_3}{a_1}x^2+\dots$ 这个多项式来说,它的常数项为 $1$ ,所以一定可逆,且求逆后常数项也为 $1$ . 而对于前面那个分数,将它拆开后,只有第一项的次数为 $-1$ ,且这一项的系数为 $1$ . 于是将两者乘起来,得到 $[x^{-1}] F^{-1}(x)\cdot F’(x)=1$ . 代入 $[x^{-1}] a_n\cdot n\cdot G^{-1}(x)\cdot G’(x)=[x^{-1}]\frac{1}{G^n(x)}$ 中,就得到了 $a_n=\frac {1}{n} [x^{-1}] \frac{1}{G^n(x)}$ . 即$$[x^n] F(x)=\frac 1 n [x^{-1}] \frac{1}{G^n(x)}$$由于 $G(x)$ 的常数项为 $0$ ,而一次项不为 $0$ ,所以 $\frac {x}{G(x)}​$ 是可以求的,上面的式子就可以变成$$[x^n] F(x)=\frac 1 n [x^{n-1}] (\frac{x}{G(x)})^n$$]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>多项式</tag>
        <tag>拉格朗日反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3625 小朋友和二叉树]]></title>
    <url>%2F2019%2F11%2F30%2Fbzoj-3625-%E5%B0%8F%E6%9C%8B%E5%8F%8B%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[生成函数 + 多项式操作. 设 $F(i)$ 表示权值为 $i$ 的二叉树数目, $C(i)$ 表示 $i$ 这个数字是否在集合中出现过. 边界有 $F(0)=1$ ,转移时枚举根节点权值为 $i$ ,左子树权值为 $j$ . $$F(n)=\sum_{i=0}^n C(i)\sum_{j=0}^{n-i} F(j)F(n-i-j)$$ 这个式子和卡特兰数的递推式很像. 利用类似的做法求通项,把 $F,C$ 都看成多项式,得到$$F=CF^2+1 \\F=\frac{1\pm \sqrt{1-4C}}{2C}$$考虑到边界条件 $C(0)=0,\lim _{x\to 0} F(x)=1$ ,可以发现此处应该取负号. 于是得到$$F=\frac{2}{1+\sqrt{1-4C}}$$用多项式开根 + 多项式求逆处理,时间复杂度 $O(n\log n)$ ,多项式开根可以直接套牛顿迭代来做. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353,G=3,inv2=(P+1)&gt;&gt;1;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=4e5+10;int rev[MAXN],omega[MAXN],inv[MAXN],curn;void DFTInit(int n)&#123; if(n==curn) return; for(int i=0;i&lt;n;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(n&gt;&gt;1)); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; omega[l]=fpow(G,(P-1)/l); inv[l]=fpow(omega[l],P-2); &#125; curn=n;&#125;void DFT(int *a,int n,bool invflag)&#123; DFTInit(n); for(int i=0;i&lt;n;++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=l&gt;&gt;1; int gi=omega[l]; if(invflag) gi=inv[l]; for(int *p=a;p!=a+n;p+=l) &#123; int g=1; for(int i=0;i&lt;m;++i) &#123; int t=mul(g,p[i+m]); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int invn=fpow(n,P-2); for(int i=0;i&lt;n;++i) a[i]=mul(a[i],invn); &#125;&#125;void NTT(int *A,int *B,int *C,int lenA,int lenB)&#123; static int a[MAXN],b[MAXN]; int lenC=lenA+lenB-1; int n=1; while(n&lt;lenC) n&lt;&lt;=1; copy(A,A+lenA,a); fill(a+lenA,a+n,0); copy(B,B+lenB,b); fill(b+lenB,b+n,0); DFT(a,n,false); DFT(b,n,false); for(int i=0;i&lt;n;++i) C[i]=mul(a[i],b[i]); DFT(C,n,true);&#125;void PolyInverse(int *A,int *B,int N) // B=A^(-1)&#123; int n=1; while(n&lt;N) n&lt;&lt;=1; static int tmp[MAXN]; B[0]=fpow(A[0],P-2); for(int i=2;i&lt;=n;i&lt;&lt;=1) &#123; NTT(A,B,tmp,i,i); NTT(tmp,B,tmp,i,i); for(int j=0;j&lt;i;++j) B[j]=add(mul(2,B[j]),P-tmp[j]); &#125;&#125;void PolySqrt(int *A,int *B,int N) &#123; int n=1; while(n&lt;N) n&lt;&lt;=1; B[0]=1; static int tmp[MAXN]; for(int i=2;i&lt;=n;i&lt;&lt;=1) &#123; PolyInverse(B,tmp,i); NTT(tmp,A,tmp,i,i); for(int j=0;j&lt;i;++j) B[j]=mul(inv2,add(B[j],tmp[j])); &#125;&#125;int n,m,C[MAXN],tmp[MAXN],F[MAXN];int main()&#123; n=read(),m=read()+1; C[0]=1; for(int i=1;i&lt;=n;++i) &#123; int x=read(); C[x]=P-4; &#125; PolySqrt(C,tmp,m); tmp[0]=add(tmp[0],1); PolyInverse(tmp,F,m); for(int i=1;i&lt;m;++i) printf("%d\n",mul(F[i],2)); return 0;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1263]]></title>
    <url>%2F2019%2F11%2F30%2FCF1263%2F</url>
    <content type="text"><![CDATA[$Div.2$ A. Sweet Problem假设从小到大依次是 $a,b,c$ ,则先把 $a$ 用完,用的时候让 $b,c$ 尽可能接近,最后再加上剩下的 $b$ . B. PIN Codes遇到一个已经出现过的串时,就把它改成一个在全局中都没有出现过的串. 可以改的有 $36$ 种串,而 $n\le 10$ ,所以每次一定都能选出. C. Everyone is a Winner!整除分块裸题.记得把 $0$ 加上. D. Secret Passwords给 $26$ 种字符各自建一个虚拟节点,对于每个串,若它含有字符 $x$ ,就将它向 $x$ 的虚拟节点连边. 用并查集实现上面的过程,最后答案就是含有字符串节点的连通块数目. E. Editor左,右括号分别视作 $+1,-1$ ,用线段树维护每个前缀的权值,以及区间内前缀的最大值,最小值. 修改时是给一段前缀 $+1$ 或者 $-1$ . 询问时,若所有前缀最小值为 $0$ ,且最后一个前缀权值为 $0$ ,则合法. 此时询问的颜色种数,可以发现就是括号的最大深度,即所有前缀的最大值. 光标移到左边就不能移了,没写这个却 pp 了,喜提 FST . F. Economic Difficulties考虑删掉一条边 $u\to v$ 时,子树 $v$ 里面的边就没有任何影响了. 为了让删去的边最多,就把子树 $v$ 里面的边也全部删掉. 从节点 $v$ 来看,可以删掉子树 $v$ 里面的所有边,以及它的父亲边 (如果有) ,这样会覆盖掉一段叶子 $[l,r]$ . 当每个叶子恰好被覆盖一次时,一定是最优的,而且容易发现这一定可以做到. 于是将每个节点看成一条线段 $[l,r]​$ ,并且有一个收益 $c​$ ,要求不重叠地覆盖 $[1,n]​$ 时能获得的最大收益. 设 $f(i)$ 表示不重叠地覆盖 $[1,i]$ 时能获得的最大收益,每条线段 $[l,r]$ 只能去转移 $f(l-1)$ ,时间复杂度 $O(a+b)$ .]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>线段树</tag>
        <tag>codeforces</tag>
        <tag>并查集</tag>
        <tag>整除分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5093 图的价值]]></title>
    <url>%2F2019%2F11%2F29%2Fbzoj-5093-%E5%9B%BE%E7%9A%84%E4%BB%B7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[第二类斯特林数 + $NTT$ . 每个点的贡献可以单独考虑,答案是 $1$ 个点的贡献 $\times n$ ,而 $1$ 个点的贡献可以通过枚举其度数计算. 公式不知道为啥炸了,只好贴图片了. 只用算后面那个 $s=\sum_{i=0}^{n-1} {n-1\choose i}\cdot i^k​$ . 为了方便,把这里的 $n$ 变成 $n-1$ ,即 $s=\sum_{i=0}^{n} {n\choose i}\cdot i^k$ . 套路地,考虑 $i^k$ 的组合意义,它表示将 $k$ 个不同的球放进 $i$ 个不同盒子中的方案数,盒子可以为空. 枚举有 $j$ 个盒子不为空. 而第二类斯特林数 $S(k,j) $ 表示将 $k$ 个球放入 $j$ 个相同的盒子中,盒子不能为空的方案数,于是得到$$i^k=\sum_{j=0}^{i-1}{i\choose j}\cdot S(k,j)\cdot j!$$代入 $s$ 的计算式,得到$$\begin{aligned}s&amp;=\sum_{i=0}^{n} \sum_{j=0}^{i-1} {i\choose j}\cdot j!\cdot S(k,j)\cdot {n\choose i} \\&amp;=\sum_{j=0}^{k} S(k,j)\cdot j!\cdot \sum_{i=0}^{n} {n\choose i}\cdot {i\choose j} \\&amp;=\sum_{j=0}^k S(k,j)\cdot j!\cdot {n\choose j} \cdot 2^{n-j}\end{aligned}$$考虑利用容斥原理计算一行的斯特林数,$$S(n,m)=\frac{1}{m!}\sum_{i=0}^m (-1)^i {m\choose i}(m-i)^n \\=\sum_{i=0}^m \frac{(-1)^i}{i!} \cdot \frac{(m-i)^n}{(m-i)!}$$用 $NTT$ 求出所有的 $S(k,j)$ ,直接带进去计算即可,时间复杂度 $O(k\log k)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353,G=3,inv2=(P+1)&gt;&gt;1;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=8e5+10;int rev[MAXN],omega[MAXN],inv[MAXN],curn;void init(int n)&#123; for(int i=0;i&lt;n;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(n&gt;&gt;1)); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; omega[l]=fpow(G,(P-1)/l); inv[l]=fpow(omega[l],P-2); &#125; curn=n;&#125;void DFT(int *a,int n,bool invflag)&#123; if(curn!=n) init(n); for(int i=0; i&lt;n; ++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; int m=(l&gt;&gt;1); int gi=omega[l]; if(invflag) gi=inv[l]; for(int *p=a; p!=a+n; p+=l) &#123; int g=1; for(int i=0; i&lt;m; ++i) &#123; int t=mul(g,p[i+m]); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int invn=fpow(n,P-2); for(int i=0; i&lt;n; ++i) a[i]=mul(a[i],invn); &#125;&#125;void NTT(int *A,int *B,int *C,int lenA,int lenB)&#123; static int a[MAXN],b[MAXN]; int lenC=lenA+lenB-1,n=1; while(n&lt;lenC) n&lt;&lt;=1; for(int i=0;i&lt;lenA;++i) a[i]=A[i]; for(int i=lenA;i&lt;n;++i) a[i]=0; for(int i=0;i&lt;lenB;++i) b[i]=B[i]; for(int i=lenB;i&lt;n;++i) b[i]=0; DFT(a,n,false); DFT(b,n,false); for(int i=0; i&lt;n; ++i) C[i]=mul(a[i],b[i]); DFT(C,n,true);&#125;int fac[MAXN],invfac[MAXN],Inv[MAXN];void InitFac(int k)&#123; fac[0]=1; for(int i=1;i&lt;=k;++i) &#123; fac[i]=mul(fac[i-1],i); Inv[i]=(i==1)?1:mul(Inv[P%i],add(P,-P/i)); &#125; invfac[k]=fpow(fac[k],P-2); for(int i=k-1;i&gt;=0;--i) invfac[i]=mul(invfac[i+1],i+1);&#125;int S[MAXN],A[MAXN],B[MAXN];int calc(int n,int k)&#123; for(int i=0;i&lt;=k;++i) &#123; A[i]=(i&amp;1)?add(P,-invfac[i]):invfac[i]; B[i]=mul(fpow(i,k),invfac[i]); &#125; NTT(A,B,S,k+1,k+1); int s=0,binom=1,pw=fpow(2,n); for(int i=0;i&lt;=k;++i) &#123; int tmp=mul(S[i],fac[i]); tmp=mul(tmp,mul(binom,pw)); inc(s,tmp); pw=mul(pw,inv2); binom=mul(binom,Inv[i+1]); binom=mul(binom,add(n,P-i)); &#125; return s;&#125;int main()&#123; int n=read(),k=read(); if(n==1) return puts("0")&amp;0; InitFac(k); int ans=calc(n-1,k); ans=mul(ans,n); ans=mul(ans,fpow(2,1LL*(n-1)*(n-2)/2%(P-1))); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3160 万径人踪灭]]></title>
    <url>%2F2019%2F11%2F29%2Fbzoj-3160-%E4%B8%87%E5%BE%84%E4%BA%BA%E8%B8%AA%E7%81%AD%2F</url>
    <content type="text"><![CDATA[$Manacher+FFT$ . 考虑去掉第 $2$ 个限制,即允许选出的位置连续,算出所有的数目后再减去连续的数目. 连续的数目即回文串的数目,可以利用 $Manacher$ 求出,顺便填充间隔字符,便于下面的处理. 为了计算前者,可以考虑每个位置作为回文中心的贡献,若有 $x$ 对字符关于 $i$ 对称,则 $i$ 的贡献为 $2^x-1$ . 而两个相同的字符,若位置分别为 $j,k$ ,则它们关于 $(j+k)/2$ 对称. 分别计算字符 $a,b$ 的贡献,而贡献是一个卷积的形式,模数是 $P-1$ ,但系数不会超过 $n^2$ ,用 $FFT$ 优化. 注意当 $j\neq k$ 时,这对会贡献两次,需要简单处理一下. 时间复杂度 $O(n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const double Pi=acos(-1.0);const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=8e5+10;struct Complex&#123; double r,i; Complex(double r=0,double i=0):r(r),i(i) &#123;&#125; Complex operator + (const Complex &amp;rhs) const &#123; return Complex(r+rhs.r,i+rhs.i); &#125; Complex operator - (const Complex &amp;rhs) const &#123; return Complex(r-rhs.r,i-rhs.i); &#125; Complex operator * (const Complex &amp;rhs) const &#123; return Complex(r*rhs.r-i*rhs.i,r*rhs.i+i*rhs.r); &#125; Complex conj() &#123; return Complex(r,-i); &#125; ll out() &#123; return ((ll)(r+0.5)); &#125;&#125;;int rev[MAXN],curn;Complex omega[MAXN],inv[MAXN];void init(int n)&#123; if(curn==n) return; for(int i=0;i&lt;n;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(n&gt;&gt;1)); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; omega[l]=Complex(cos(2*Pi/l),sin(2*Pi/l)); inv[l]=omega[l].conj(); &#125; curn=n;&#125;void DFT(Complex *a,int n,bool invflag)&#123; init(n); for(int i=0;i&lt;n;++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=l&gt;&gt;1; Complex gi=omega[l]; if(invflag) gi=inv[l]; for(Complex *p=a;p!=a+n;p+=l) &#123; Complex g=Complex(1,0); for(int i=0;i&lt;m;++i) &#123; Complex t=g*p[i+m]; p[i+m]=p[i]-t; p[i]=p[i]+t; g=g*gi; &#125; &#125; &#125; if(invflag) &#123; Complex invn=Complex(1.0/n,0); for(int i=0;i&lt;n;++i) a[i]=a[i]*invn; &#125;&#125;void FFT(Complex *A,Complex *B,Complex *C,int lenA,int lenB)&#123; static Complex FFT_A[MAXN],FFT_B[MAXN]; int lenC=lenA+lenB-1; int n=1; while(n&lt;lenC) n&lt;&lt;=1; copy(A,A+lenA,FFT_A); fill(FFT_A+lenA,FFT_A+n,Complex(0,0)); copy(B,B+lenB,FFT_B); fill(FFT_B+lenB,FFT_B+n,Complex(0,0)); DFT(FFT_A,n,false); DFT(FFT_B,n,false); for(int i=0;i&lt;n;++i) C[i]=FFT_A[i]*FFT_B[i]; DFT(C,n,true);&#125;int n,tot=0,ans=0,R[MAXN];char buf[MAXN],s[MAXN];void Manacher()&#123; s[++tot]='$'; for(int i=1;i&lt;=n;++i) &#123; s[++tot]='#'; s[++tot]=buf[i]; &#125; s[++tot]='#'; s[++tot]='@'; int p=0,mx=0; for(int i=1;i&lt;=tot;++i) &#123; int j=2*p-i; if(i&gt;mx) R[i]=1; else if(mx-i&gt;R[j]) R[i]=R[j]; else R[i]=mx-i+1; while(s[i-R[i]]==s[i+R[i]]) ++R[i]; if(i+R[i]-1&gt;mx) mx=i+R[i]-1,p=i; inc(ans,P-(R[i]&gt;&gt;1)); &#125;&#125;ll f[MAXN];Complex A[MAXN];void solve(char ch)&#123; A[0]=Complex(0,0); for(int i=1;i&lt;=tot;++i) &#123; A[i]=Complex(s[i]==ch?1:0,0); if(s[i]==ch) f[2*i]++; &#125; FFT(A,A,A,tot+1,tot+1); for(int i=1;i&lt;=2*tot+1;++i) f[i]+=A[i].out();&#125;int main()&#123; scanf("%s",buf+1); n=strlen(buf+1); Manacher(); solve('a'); solve('b'); for(int i=1;i&lt;=2*tot+1;++i) &#123; f[i]&gt;&gt;=1; inc(ans,add(fpow(2,f[i]%(P-1)),P-1)); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>Manacher</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2018 选做]]></title>
    <url>%2F2019%2F11%2F29%2FBJOI2018-%E9%80%89%E5%81%9A%2F</url>
    <content type="text"><![CDATA[老张觉得比较简单,但我一道都不会做. 求和把每个点到根的 $k$ 种权值和全部预处理出来,每次求出 $lca​$ 回答询问. 时间复杂度 $O(nk+m\log n)$ . code 二进制考虑给定一个二进制串,如何判断能否重排成 $3$ 的倍数. 这显然只和 $0,1$ 的个数有关,注意到,当 $k$ 为偶数时, $2^k\bmod 3=1$ ,当 $k$ 为奇数时, $2^k\bmod 3=2$ . 于是当 $1$ 的个数为偶数时,一定有解,将 $1$ 都放在后面, $0$ 全部弄成前导 $0$ . 当 $1$ 的个数为奇数时,需要放一个 $10101$ ,剩下的 $1$ 依次放在前面, $0$ 弄成前导 $0$ . 这要求 $1$ 的个数 $\ge 3$ , $0$ 的个数 $\ge 2$ . 整理一下,即,不合法的情况只有两种: $1$ 的个数为奇数,且 $0$ 的数目不超过 $1$ ,或者 $1$ 的个数为 $1$ . 这些区间要么只有一个 $1$ ,要么只有 $1$ 个 $0$ ,或者没有 $0$ ,用 $set$ 维护所有 $0,1$ 的位置,用树状数组维护答案. 时间复杂度 $O(n\log n)​$ . code 染色若不是二分图,显然可以被卡掉.若有度数 $\le 1$ 的节点,显然可以直接去掉. 于是只用考虑每个点的度数 $\ge 2$ 的二分图,不同的连通块可以分开做. 对于完全二分图 $K_{3,3}$ ,样例已经给出了卡掉的方法. 对于完全二分图 $K_{2,4}$ ,一边是 $(AB),(CD)$ ,另一边是 $(AC),(AD),(BC),(BD)$ ,就可以卡掉了. 如果有两个偶环,它们有公共点,且各自独有的点数目 $\ge 2$ ,也可以卡掉. 在一个偶环上构造出 $(AC),(AB),(BC)$ ,之后的点就不能染 $C$ 了. 再换一种颜色在另一个偶环上进行类似的构造,另一种颜色也没法染了. 当一个点的度数 $&gt;3$ 时,一定可以找出两个这样的偶环,于是只考虑最大度数为 $2,3$ 的情况. 当所有点的度数为 $2$ 时,一定是个偶环,显然顺着环染色,是卡不掉的. 于是只剩下了有 $2$ 个点度数为 $3$ ,其余点度数为 $2$ 的情况. 这两个度数为 $3$ 的点之间有 $3$ 条边不相交的路径,只有它们的长度为 $2,2,k$ ,其中 $k$ 为偶数时,是卡不掉的. 而对于 $2,4,4$ 或者 $1,3,3$ 都有卡掉的办法. 整理一下,先把所有度数为 $\le 1$ 的点剥掉. 再对于每个连通块判断其是否为偶环,或恰有两个度数为 $3$ 的点,且两者间的路径长度为 $2,2,k$ ,其中 $k$ 为偶数. 时间复杂度 $O(m)$ . code 双人猜数游戏 手玩了两个小时,喜提 $4$ 分. 按照题目中给的优先级枚举 $a,b$ 作为答案,尝试检验. 设 $f(i,a,b)$ 表示询问了 $i$ 次,若 $m=a,n=b$ ,则它们是否会被猜出来. $i=1$ 时是边界情况,分情况讨论一下. 如果第一次问的是 Alice ,那么能猜出来,当且仅当把 $ab$ 拆成两个 $\ge s$ 的数字之积时方案唯一. 如果第一次问的是 Bob,那么能猜出来,当且仅当把 $a+b$ 拆成两个 $\ge s$ 的数字之和时方案唯一. 对于 $i&gt;1$ 的情况,根据奇偶性判断这次是问的谁. 从可能的数对 $(x,y)$ 中找出 $f(i-1,x,y)$ 为 $0$ 的个数,若只有 $1$ 个,就可以把它猜出来了. 同时,若另一个人在第 $i+1​$ 回合也能猜出这个数对,那么它就是答案了. code 链上二次游戏询问长度在 $[L,R]$ 内的链的权值和时,用长度 $\le R$ 的答案减去长度 $\le L-1$ 的答案. 于是只需要考虑如何计算长度 $\le k$ 的链的权值和. 考虑每个点的贡献,分情况讨论一下每个点会被算多少次,显然用线段树维护 $\sum a_i,\sum a_i\cdot i,\sum a_i \cdot i^2​$ 即可. 时间复杂度 $O(n+m\log n)$ . code 治疗之雨 这个是暗影打击装甲被削之前出的题. 先特判答案为 $-1$ 的情况. 当 $k=0$ 时,答案为 $-1$ . 当 $m=0$ 时,若血量上限 $n&gt;1$ ,且每次扣血 $k=1$ ,答案也为 $-1$ . 对于剩下的情况,设 $E(i)$ 表示当前有 $i$ 点血,被暗影打击装甲打死期望需要的回合数. 由于 $E(0)=0$ ,所以可以不用考虑转移到 $E(0)$ ,也不用处理血量被打成负数的问题. 设 $f(i)$ 表示 $k$ 个暗影打击装甲攻击后,恰好对英雄造成 $i$ 点伤害的概率,容易预处理出来.$$f(i)=\frac{ {k\choose i}\cdot m^{k-i} } { (m+1)^k }$$设 $g(i,j)​$ 表示当前血量为 $i​$ ,一轮后血量变成 $j​$ 的概率,讨论一下 $i​$ 是否为 $n​$ ,就可以根据 $f(i-j)​$ 算出它. 于是对于血量 $i&lt;n$ 的 $E(i)$ ,有转移$$E(i)=\sum_{j=1}^i E(j)\cdot g(i,j)+E(i+1)\cdot g(i,i+1)+1$$对于 $i=n$ 的情况,有转移$$E(i)=\sum_{j=1}^{i} E(j)\cdot g(i,j)+1$$直接做高斯消元,复杂度是 $O(n^3)$ 的. 它虽然不是稀疏矩阵,但注意到每次最多回 $1$ 点血,即, $E(i)$ 要转移到 $j&gt;i$ 的 $E(j)$ ,只可能是 $E(i+1)$ . 于是就可以像树上高斯消元那样搞一搞,将每个 $E(i)$ 都表示成 $k\cdot E(1)+b$ 的形式. 根据转移方程$$E(i)=\sum_{j=1}^i E(j)\cdot g(i,j)+E(i+1)\cdot g(i,i+1)+1$$可以从前往后依次求出每个 $E(i)$ 的 $k,b$ . 而 $E(n)$ 的转移方程还没有用,把所有 $E(i)$ 代入到 $E(n)$ 的转移方程中,就可以解出 $E(1)$ ,代入求得 $E(p)$ . 时间复杂度 $O(T\cdot n^2)$ . code]]></content>
      <tags>
        <tag>构造</tag>
        <tag>概率/期望</tag>
        <tag>线段树</tag>
        <tag>STL</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3456 城市规划]]></title>
    <url>%2F2019%2F11%2F28%2Fbzoj-3456-%E5%9F%8E%E5%B8%82%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[多项式求逆. 要求的是带标号的 $n$ 个点的无向连通图数目. 设 $f(i)$ 表示 $i$ 个点时的答案,可以用图的总数减去不连通的图的数目. 枚举 $1$ 号节点所在连通块的大小为 $i$ 进行转移.$$f(n)=2^{n\choose 2}-\sum_{i=1}^{n-1} {n-1\choose i-1}\cdot f(j)\cdot 2^{n-i\choose 2}$$边界有 $f(1)=1​$ . 为了进行优化,考虑将 $f(n)$ 这一项也弄到 $\sum$ 里面去.可以两边乘上 $\frac {1}{(n-1)!}$ ,整理得到,$$\frac{f(n)}{(n-1)!}+\sum_{i=1}^{n-1} \frac{f(i)\cdot 2^{n-i\choose 2}}{(i-1)!(n-i)!}=\frac{2^{n\choose 2}}{(n-1)!}$$规定 $f(0)=0$ ,就可以把 $f(n)$ 也弄进去了,对比可以验证正确性.$$\sum_{i=0}^{n} \frac{f(i)\cdot 2^{n-i\choose 2}}{(i-1)!(n-i)!}=\frac{2^{n\choose 2}}{(n-1)!}$$等式左边是一个卷积的形式,设三个多项式 $A,B,C$ 分别为$$A(x)=\sum_{i} \frac{f(i)}{(i-1)!} \cdot x^i \\B(x)=\sum_{i}\frac{2^{i\choose 2}}{i!} \cdot x^i \\C(x)=\sum_{i} \frac{2^{i\choose 2}}{(i-1)!} \cdot x^i$$则有 $A(x)B(x)=C(x)$ ,而 $C(x)$ 的最高次数为 $n$ . 于是$$A(x)\equiv B^{-1}(x)\cdot C(x) \pmod {x^{n+1}}$$用多项式求逆解决,时间复杂度 $O(n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int P=1004535809,G=3;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL *a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=8e5+10;int rev[MAXN],omega[MAXN],inv[MAXN],curn=0;void init(int n)&#123; if(curn==n) return; for(int i=0;i&lt;n;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(n&gt;&gt;1)); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; omega[l]=fpow(G,(P-1)/l); inv[l]=fpow(omega[l],P-2); &#125; curn=n;&#125;void DFT(int *a,int n,bool invflag)&#123; init(n); for(int i=0;i&lt;n;++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=l&gt;&gt;1; int gi=omega[l]; if(invflag) gi=inv[l]; for(int *p=a;p!=a+n;p+=l) &#123; int g=1; for(int i=0;i&lt;m;++i) &#123; int t=mul(p[i+m],g); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int invn=fpow(n,P-2); for(int i=0;i&lt;n;++i) a[i]=mul(a[i],invn); &#125;&#125;void NTT(int *A,int *B,int *C,int lenA,int lenB)&#123; static int NTT_A[MAXN],NTT_B[MAXN]; int lenC=lenA+lenB-1; int n=1; while(n&lt;lenC) n&lt;&lt;=1; copy(A,A+lenA,NTT_A); fill(NTT_A+lenA,NTT_A+n,0); copy(B,B+lenB,NTT_B); fill(NTT_B+lenB,NTT_B+n,0); DFT(NTT_A,n,false); DFT(NTT_B,n,false); for(int i=0;i&lt;n;++i) C[i]=mul(NTT_A[i],NTT_B[i]); DFT(C,n,true);&#125;void PolyInverse(int *A,int *B,int N) // A^(-1)=B mod x^N&#123; int n=1; while(n&lt;N) n&lt;&lt;=1; static int tmp[MAXN]; fill(B,B+2*n,0); B[0]=fpow(A[0],P-2); for(int i=2;i&lt;=n;i&lt;&lt;=1) &#123; NTT(A,B,tmp,i,i); NTT(tmp,B,tmp,i,i); for(int j=0;j&lt;i;++j) B[j]=add(mul(2,B[j]),P-tmp[j]); &#125;&#125;int n;int fac[MAXN],invfac[MAXN];int A[MAXN],B[MAXN],invB[MAXN],C[MAXN];int main()&#123; n=read(); fac[0]=1; for(int i=1;i&lt;=n;++i) fac[i]=mul(fac[i-1],i); invfac[n]=fpow(fac[n],P-2); for(int i=n-1;i&gt;=0;--i) invfac[i]=mul(invfac[i+1],i+1); B[0]=1,C[0]=0; for(int i=1;i&lt;=n;++i) &#123; B[i]=mul(fpow(2,1LL*i*(i-1)/2%(P-1)),invfac[i]); C[i]=mul(fpow(2,1LL*i*(i-1)/2%(P-1)),invfac[i-1]); &#125; PolyInverse(B,invB,n+1); NTT(invB,C,A,n+1,n+1); int ans=mul(A[n],fac[n-1]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AGC035 Skolem XOR Tree]]></title>
    <url>%2F2019%2F11%2F26%2FAGC035C-Skolem-XOR-Tree%2F</url>
    <content type="text"><![CDATA[构造题. 当 $n=2^k$ 时,显然无解,因为那两个权值为 $n$ 的点路径上权值异或和一定会 $&lt;n$ . 否则,若 $n$ 为奇数, $n$ 至少为 $3$ ,可以做如下构造: 即,将两组 $1,2,3$ 串在一起,从 $4$ 开始,将 $k,k+1$ 串在一起,分别正着,反着挂在中间那个 $1$ 下面. 容易验证这样做是合法的. 若 $n$ 为偶数,只需要先构造出 $n-1$ 的解,再将两个 $n$ 挂上去. 和中间那个 $1$ 直接相连的点中,包含了 $2\sim n-1$ 的所有权值. 当 $n​$ 不为 $2​$ 的幂的时候,总能在 $2\sim n-1 ​$ 中选出 $2​$ 个数 $x,y​$ ,使得 $x\oplus y\oplus 1=n​$ ,将这两个 $n​$ 挂在上面即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;void report(int x,int y)&#123; printf("%d %d\n",x,y);&#125;int N;void solve(int n)&#123; report(1,2); report(2,3); report(3,1+N); report(1+N,2+N); report(2+N,3+N); for(int i=4;i&lt;=n;i+=2) &#123; report(1+N,i+N); report(i+N,i+1+N); report(1+N,i+1); report(i+1,i); &#125;&#125;int main()&#123; int n=read(); N=n; if(__builtin_popcount(n)==1) puts("No"); else &#123; puts("Yes"); if(n&amp;1) solve(n); else &#123; solve(n-1); for(int i=2;i&lt;n;++i) &#123; int j=(n+1)^i; if(1&lt;j &amp;&amp; j&lt;n &amp;&amp; i!=j) &#123; report(n,i&amp;1?i:i+N); report(n+N,j&amp;1?j:j+N); break; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tarjan算法学习笔记]]></title>
    <url>%2F2019%2F11%2F25%2Ftarjan%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[发现自己根本不会 $tarjan​$ ,于是来学一学. $tarjan$ 算法的几个不同应用中,都有建出 $dfs$ 树的过程. 若无特殊说明, $dfn$ 表示每个点的 $dfs$ 序, $low$ 表示这个点以及它的所有子孙连的所有点中 $dfn​$ 的最小值. 在无向图中,由父亲走来的那条边不被用作更新 $low​$ ,也不用判断点是否已经入队. 强连通分量对于一个有向图的子图,若子图中的任意两个点可以互相到达,则称这个子图为强连通子图. 强连通分量, $SCC$ ,是极大的强连通子图,即无法通过拓展得到更大的强连通子图. 可以利用 $tarjan​$ 算法求出每个点所在的强连通分量. $dfs$ 时不断将当前节点入栈. 回溯时,若当前节点 $u$ 满足 $dfn(u)=low(u)$ ,则不断弹栈.将这些点都归入一个新的 $SCC$ 中,直到将 $u$ 也弹出. 割点无向图中,若去掉节点 $u$ 以及所有与它关联的边后,连通块的数目增加,则称 $u$ 为割点. 可以利用 $tarjan$ 算法求出所有割点. $dfs$ 时,若节点 $u$ 为其所在连通块的根,则当它的度数 $&gt;1$ 时, $u$ 是割点. 若节点 $u$ 不为根,则当存在一个儿子 $v$ ,满足 $low(v)\ge dfn(u)$ 时, $u$ 是割点. 桥无向图中,若去掉边 $(u,v)​$ 后,连通块的数目增加,则称边 $(u,v)​$ 为桥. 可以利用 $tarjan$ 算法求出所有桥. $dfs$ 回溯时,若 $dfn(u)=low(u)$ ,则边 $(u,fa_u)$ 是桥. 边双连通分量对于一个无向图的连通子图,若任意两点间存在两条边不相交的路径,则称这个子图为边的双连通子图. 这也等价于删掉这个子图中的任意一条边后,这个子图仍然连通,即子图内部不存在桥. 边双连通分量, $e-DCC$ ,简称边双,是极大的边的双连通子图,即无法通过拓展得到边更多的边的双联通子图. 每个点只会属于一个边双,除了桥之外,其他每条边也只会属于一个边双. 可以利用 $tarjan$ 算法求出每个点所在的边双. 若先将所有桥求出,则把所有桥删掉后,剩下的每个连通块就是边双了. 这个过程可以不显式的进行,在 $dfs$ 时,不断将点入栈,若 $dfn(u)=low(u)$ ,说明 $u$ 的父亲边是桥. 不断弹栈,将这些点归入一个新的边双,直到 $u$ 也被弹出. bzoj 1718 Redundant Paths将每个边双缩点,由于原图连通,最后会形成一棵树. 若这棵无向树有 $k$ 个叶子,则只需要将这些叶子两两连一条边,答案为 $\lceil \frac k 2\rceil$ . 由于有重边,所以在跑 $tarjan$ 时不记录父亲节点,而是记录从父亲节点来的边的编号. 时间复杂度 $O(m)​$ . code bzoj 4435 Juice Junctions由于每个点的度数不超过 $3$ ,所以两个点之间的流量只可能是 $0,1,2,3$ ,依次进行判断. 若 $S,T$ 不在同一个连通块,流量为 $0$ . 若 $S,T$ 在一个连通块,但不在一个边双中,流量为 $1$ . 只需要区分 $2$ 和 $3$ ,其实它们分别表示了 $S,T$ 之间有 $2/3$ 条边不相交的路径. 暴力枚举断掉一条边,求出断掉这条边后每个点所在的边双. 若所有的 $m+1$ 种情况下, $S,T$ 所在的边双都一样,则答案为 $3$ ,否则为 $2$ ,这可以利用 $hash$ 进行判断. 时间复杂度 $O(m^2)$ . code bzoj 3590 Quare要用最小的代价把整张图连成一个边双,考虑边双的形成方式,可以这样进行理解. 单独的一个点是一个边双,在一个边双上加入一条链,满足链的首尾都在这个边双中,可以得到更大的边双. 于是可以用状压 $dp$ 来处理这个过程. 设 $f(S)$ 表示将集合 $S$ 中的点连成一个边双的最小花费. 设 $g(S,i,j)$ 表示将集合 $S$ 中的点连成一条首尾是 $i,j$ 的链的最小花费. 转移时枚举这条链,还需要把这条链接进当前的边双中. 设 $h(S,i,0)$ 表示从 $i$ 向 $S$ 中的某一个点连一条边的最小花费. 由于这条链可能只有 $1$ 个点,所以还要设 $h(S,i,1)$ 表示次小花费. 转移时,枚举链的首尾以及链包含的所有点,枚举它接进的边双含有的点.$$f(S)+g(T,i,j)+h(S,i)+h(S,j)\to f(S+T),i\neq j,S\cup T=\emptyset \\f(S)+g(T,i,i)+h(S,i)+g(S,i)\to f(S+T),S\cup T=\emptyset$$需要预处理出 $g,h$ ,瓶颈在 $g$ 的预处理上,时间复杂度 $O(3^n\cdot n^4)$ ,但显然跑不满. code bzoj 4229 选择把所有操作离线下来,倒着做,就变成了加边的同时动态维护边双信息. 利用 $LCT$ 维护边双森林,加边时,若两点未连通,就直接连起来,否则就把这两点路径上的所有点缩成一个边双. 每次要用到一个点时,都改成用它所在边双的那个超级点,这样能够保证 $dfs$ 总复杂度为 $O(n)$ . 用并查集维护每个点所在的边双以及原图的连通性. 时间复杂度 $O(n\log n)​$ . code bzoj 2959 长跑把每个边双缩成一个点,这个超级点的点权为原来所有的点点权之和. 可以发现,答案就是两个点所在边双路径上的超级点权值之和. 由于要支持加边操作,需要用 $LCT$ 动态维护边双,时间复杂度 $O(n\log n)​$ . code 点双连通分量对于一个无向图的连通子图,若任意两点间存在两条除起点终点外点不相交的路径,则称这个子图为点的双连通子图. 这也等价于删掉这个子图中的任意一个点后,这个子图仍然连通,即子图内部不存在割点. 点双连通分量, $v-DCC$ ,简称点双,是极大的点的双连通子图,即无法通过拓展得到点更多的点的双联通子图. 原图中的每个割点可能属于多个点双,但每条边只会属于一个点双. 可以利用 $tarjan$ 算法求出每条边所在的点双. 在 $dfs$ 时不断将边入栈,当通过边 $(u,v)$ 发现 $low(v)\ge dfn(u)$ ,就找到了一个割点 $u$ . 不断弹栈,将弹出的边归入一个新的点双,直到边 $(u,v)$ 也被弹出. bzoj 2730 矿场搭建用 $tarjan$ 算法求出所有点双和割点. 对于一个点双,记它包含的点数为 $x$ ,分以下 $3$ 种情况讨论. 点双内没有割点,那么要在点双中建两个救援点,贡献分别为 $2,{x\choose 2}$ . 点双内有 $1$ 个割点,那么在点双中选一个不是割点的点作为救援点就可以了,贡献分别为 $1,x-1$ . 点双内有 $2$ 个或更多的割点,那么不用在这个点双内建救援点,贡献分别为 $0,1$ . 由于救援点不会建在割点上,所以统计的贡献不会重复. code 广义圆方树在无向图中利用 $tarjan$ 算法求出所有点双,对于每个点双建一个方点,原来的点是圆点. 每个方点向这个点双中所有圆点连边,在圆点上维护这个点的信息,方点上维护这个点双的信息. 这样就可以处理一些与无向图路径,或点双有关的问题了.贴一张网上找来的图. 严格来说,这样形成的新图其实是一个森林,树的数目是原图中连通块的数目. 显然,圆点只会与方点相邻,方点只会与圆点相邻,若两个方点有公共的相邻圆点,则这个圆点代表这两个点双的割点. 注意有圆点和方点,要开两倍的空间. bzoj 1123 BLO把圆方树建出来,去掉一个圆点 $u$ ,增加的不能互通的点对数目就是两端都是圆点,且经过 $u$ 的路径数目. code bzoj 3331 压力考虑把圆方树建出来,那么两个圆点之间的必经点,就是圆方树上两点路径上的所有圆点. 用树上差分打下标记就可以处理了. code bzoj 5138 Push a Box枚举第一步怎么推之后,状态数只有 $O(nm)$ ,只用记录箱子的位置以及人在箱子的哪一个相邻块上. 转移时,有两种决策,一种是推一步箱子,另一种是不移动箱子,走到另一个与箱子相邻的块上. 如下图,当前箱子在黑色格子 $w$ ,人在红色格子 $u$ ,要走到绿色格子 $v$ . 障碍的位置是不变的,一开始就可以直接处理掉,只建出有用的边. 而箱子的位置是可以变化的,这等价于每次询问断掉箱子所在的点 $w$ 后 $u$ 与 $v$ 是否连通. 当没有断掉 $w$ 时, $u\to w\to v$ 是一条合法路径,所以断掉 $w$ 后两者连通,等价于原来 $u,v$ 在一个点双中. 建出圆方树,则等价于询问在树上是否有 $dis(u,v)= 2$ ,这只可能是祖孙或者兄弟关系,简单判一下即可. 时间复杂度 $O(nm)​$ . code bzoj 5463 铁人两项考虑建出圆方树,若枚举 $s,f$ ,则合法的 $c$ 的数目就是 $s$ 到 $f$ 经过的所有点双的点数和减去 $s,f$ 这两个点. 将方点权值设为其代表点双的点数,圆点权值设为 $-1$ ,则合法的 $c$ 的数目就是圆方树上 $s$ 到 $f$ 路径的点权和. 考虑枚举每个点作为 $c​$ 的贡献,就是它的权值与经过它的两端都是圆点的路径数目之积. code 仙人掌和圆方树仙人掌是一种特殊的无向连通图,满足任意一条边最多会在一个简单环上. 仙人掌的圆方树构造,和一般无向图的圆方树构造略有不同. 对于每一个环(点双)建一个方点,这个方点向环内所有圆点连边,不在一个环上的两个圆点之间的边保留. 方点只会和圆点相连,圆点可以与方点相连,也可以与圆点相连. 对于很多仙人掌的题,可以先考虑在树上怎么做,再额外考虑方点怎么处理,尝试将做法搬到圆方树上来. bzoj 4316 小C的独立集在遇到环时,把环的最后一条边断掉,强制第一个点选/不选,对这个环额外做两次 $dp​$ . 其余部分和普通的树形 $dp$ 一样. code bzoj 1023 cactus设 $f(i)$ 表示从节点 $i$ 往下走,能走出的最长路径. 遇到环的时候,把这个环拿出来单独做一次 $dp$ . 假设 $i,j$ 是环上不同的两点,那么可以用 $f(i)+f(j)+dis(i,j)$ 去更新答案. 把这个环上所有点存在一个序列中,还要复制一半接在后面,就可以直接用后面的编号减去前面的编号作为 $dis$ 了. 只有距离不超过环的一半的点才能更新答案,这可以用一个单调队列进行优化转移. 最后还要更新这个环的入点的 $f​$ 值. code bzoj 2125 最短路把圆方树建出来,定义一个环的根为方点的父亲,这相当于在环中取出了一个点作为代表点. 对于圆方边,将权值设为这个圆点到方点的根的最短距离. 询问时,就像在树上询问最短路一样,先求出 $lca$ ,但这里要分情况讨论. 若 $lca$ 是圆点,则可以直接回答. 若 $lca$ 是方点,那么就不能算接在 $lca$ 的那两条边的贡献,而是改成与 $lca$ 相邻的两个圆点的最短距离. 考虑当询问在同一个环上,但都不是代表点的两个点的距离时,不特判 $lca$ 是方点就会出错. code Uoj 189 火车司机出秦川把圆方树建出来,对于每次询问,建出所有关键点的虚树. 需要考虑的贡献分为两部分. 对于虚树上的每条边,代表了圆方树上的一条链,考虑计算出这条链的贡献. 对于虚树上的每个方点,需要算出对应的环上有哪些连续段被计入了贡献. 用树状数组维护每个点到根的树边长度总和 $f$ ,到根的最短路长度 $g$ ,到根的最长路长度 $h$ . 每个环的权值前缀和也需要用树状数组进行维护,这里可以用指针分配内存来实现开多个树状数组. 考虑通过树上差分打标记的方式,判断虚树上每条边有没有被计入最短路/最长路的贡献. 如果只计入了其中一者,则贡献为对应的 $g$ 或 $h$ ,如果两者都被计入,则贡献为 $g+h-f$ . 对于每条路径 $(x,y)$ ,先求出它们的 $lca$ ,若 $lca$ 是圆点,则直接打标记. 否则,把进入 $lca$ 的那两个圆点 $p_x,p_y$ 拿出来,对于路径 $(x,p_x),(y,p_y)$ 打标记,而对 $lca​$ 这个方点特殊处理. 根据询问是最短路/最长路,可以求出这个方点上的 $1$ 或 $2​$ 段区间有贡献,将区间记在这个方点上. 最后对每个方点,将这个方点上的区间排序取并,通过维护的环的权值前缀和计算贡献. 对于修改操作,分树边和环边两种情况讨论. 若修改的是树边,则会影响子树内的 $f,g,h$ . 若修改的是环边,则会影响环的权值前缀和,环上某一段子树的 $f,g$ ,另一段子树的 $f,h$ . 在对应的树状数组上进行修改即可. 时间复杂度 $O(S\log n)$ . code]]></content>
      <tags>
        <tag>tarjan</tag>
        <tag>学习笔记</tag>
        <tag>圆方树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1261]]></title>
    <url>%2F2019%2F11%2F24%2FCF1261%2F</url>
    <content type="text"><![CDATA[$Div.1$ A Messy容易发现在不改变左括号,右括号个数的情况下,把这个序列变成任意一个序列都是可以的. 考虑把括号序列搞成 $()()()()\dots()((()))$ ,即前面放了 $k-1$ 对括号,剩下的括号全部嵌起来,显然是合法的. 对于每个位置 $i$ ,找到从 $i$ 往后第一个需要的括号的位置 $x$ ,把 $[i,x]$ 这一段翻一下就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e3+10;char s[MAXN];int n,k,val[MAXN],tmp[MAXN];set&lt;int&gt; lp,rp;void rev(int L,int R)&#123; for(int i=L;i&lt;=R;++i) &#123; tmp[i]=val[i]; if(val[i]==1) lp.erase(i); else rp.erase(i); &#125; for(int i=L;i&lt;=R;++i) &#123; val[i]=tmp[R+L-i]; if(val[i]==1) lp.insert(i); else rp.insert(i); &#125;&#125;void fl(int i)&#123; while(1) &#123; int x=*lp.begin(); if(x&lt;i) lp.erase(x); else break; &#125; int x=*lp.begin(); printf("%d %d\n",i,x); rev(i,x);&#125;void fr(int i)&#123; while(1) &#123; int x=*rp.begin(); if(x&lt;i) rp.erase(x); else break; &#125; int x=*rp.begin(); printf("%d %d\n",i,x); rev(i,x);&#125;void solve()&#123; n=read(),k=read(); lp.clear(),rp.clear(); scanf("%s",s+1); for(int i=1; i&lt;=n; ++i) &#123; if(s[i]=='(') val[i]=1,lp.insert(i); else val[i]=-1,rp.insert(i); &#125; printf("%d\n",n); for(int i=1; i&lt;=2*(k-1); ++i) &#123; if(i&amp;1) fl(i); else fr(i); &#125; int L=2*(k-1)+1,R=n; int mid=(L+R)&gt;&gt;1; for(int i=L;i&lt;=mid;++i) fl(i); for(int i=mid+1;i&lt;=R;++i) fr(i);&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125; B Optimal Subsequences对于每个数定义一个优先度,数字越大,优先度越高,若数字相同,则位置靠前的优先度更高. 那么长度为 $k$ 的最优子序列就是由优先度最大的 $k$ 个数字构成的. 把所有询问离线下来,按照优先度从高到低加入每个数,加入了 $k$ 个数时,就回答所有 $k_i=k$ 的询问. 需要用一颗平衡树,或者权值线段树,来支持插入和求第 $pos$ 个数字. 比赛时没离线询问,写了主席树. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,m,k,pos,a[MAXN];struct info&#123; int val,pos; bool operator &lt; (const info &amp;rhs) const &#123; if(val!=rhs.val) return val&gt;rhs.val; return pos&lt;rhs.pos; &#125;&#125;p[MAXN];struct node&#123; int ls,rs,siz; node() &#123; ls=rs=siz=0; &#125;&#125;Tree[MAXN*20];int idx=0,rt[MAXN];#define root Tree[o]#define lson Tree[root.ls]#define rson Tree[root.rs]void upd(int &amp;o,int pre,int l,int r,int pos)&#123; o=++idx; root=Tree[pre]; ++root.siz; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(root.ls,Tree[pre].ls,l,mid,pos); else upd(root.rs,Tree[pre].rs,mid+1,r,pos);&#125;int query(int o,int l,int r,int k)&#123; if(l==r) return a[l]; int mid=(l+r)&gt;&gt;1; if(lson.siz&gt;=k) return query(root.ls,l,mid,k); else return query(root.rs,mid+1,r,k-lson.siz);&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); p[i].val=a[i]; p[i].pos=i; &#125; sort(p+1,p+1+n); for(int i=1;i&lt;=n;++i) upd(rt[i],rt[i-1],1,n,p[i].pos); m=read(); for(int i=1;i&lt;=m;++i) &#123; k=read(),pos=read(); printf("%d\n",query(rt[k],1,n,pos)); &#125; return 0;&#125; C Arson In Berland Forest需要先观察到,每个初始起火的点,最后会形成一个以它为中心,每条边上有 $2T+1$ 个点的正方形. 因为这些正方形可以重叠,所以答案显然是可以二分的. 预处理一个二维前缀和,二分答案后检查是否能用这样的正方形覆盖住所有着火点. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;char buf[MAXN];vector&lt;int&gt; a[MAXN],s[MAXN],tmp[MAXN],ans[MAXN];int n,m;bool check(int x)&#123; x=x*2+1; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) ans[i][j]=tmp[i][j]=0; for(int i=1;i+x-1&lt;=n;++i) for(int j=1;j+x-1&lt;=m;++j) &#123; int tot=s[i+x-1][j+x-1]-s[i-1][j+x-1]-s[i+x-1][j-1]+s[i-1][j-1]; if(tot==x*x) ans[i][j]=1; &#125; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) tmp[i][j]=tmp[i-1][j]+tmp[i][j-1]-tmp[i-1][j-1]+ans[i][j]; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) if(a[i][j]) // 判断这个点是否被覆盖 &#123; int tot=tmp[i][j]; if(i&gt;x) tot-=tmp[i-x][j]; if(j&gt;x) tot-=tmp[i][j-x]; if(i&gt;x &amp;&amp; j&gt;x) tot+=tmp[i-x][j-x]; if(!tot) return false; &#125; return true;&#125;int main()&#123; n=read(),m=read(); s[0].resize(m+1),tmp[0].resize(m+1); for(int i=1;i&lt;=n;++i) &#123; a[i].resize(m+1); s[i].resize(m+1); tmp[i].resize(m+1); ans[i].resize(m+1); scanf("%s",buf+1); for(int j=1;j&lt;=m;++j) &#123; a[i][j]=(buf[j]=='X'); s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j]; &#125; &#125; int L=0,R=(min(n,m)-1)&gt;&gt;1,res; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid)) res=mid,L=mid+1; else R=mid-1; &#125; check(res); printf("%d\n",res); for(int i=1;i&lt;=n;++i,puts("")) for(int j=1;j&lt;=m;++j) if(i-res&gt;0 &amp;&amp; j-res&gt;0 &amp;&amp; ans[i-res][j-res]) putchar('X'); else putchar('.'); return 0;&#125; D Wrong Answer on test 233考虑利用生成函数,将 “变换后的答案与变换前的答案之差” 看做 $x$ 的次数. 若位置 $i​$ 与位置 $(i\bmod n)+1​$ 上的数相同,则无论怎样取,这个差都不会变,记这样的位置有 $a​$ 个. 若位置 $i$ 与位置 $(i\bmod n)+1$ 上的数不同,则各有 $1$ 种选法让差 $+1,-1$ ,其余的不变,记这样的位置有 ​$b$ 个. 记 $p=k-2$ ,则这个生成函数为 $k^a\cdot (x+x^{-1}+p)^b$ ,只有次数 $&gt;0​$ 的项的系数会被计入答案. 把后面的式子乘上 $x^b$ ,后面就变成了 $(x^2+px+1)^b$ ,只有次数 $&gt;b$ 的项的系数会被计入答案. 直接用多项式快速幂乘出来,常数太大,不可取. 枚举 $px$ 选了 $i$ 个,则$$k^a\cdot (x^2+px+1)^b=k^a\cdot \sum_{i=0}^b {b\choose i}p^{b-i}x^{b-i}\cdot \sum_{j=0}^i {i\choose j}x^{2j}$$由于只算次数 $&gt;b$ 的项的系数和,对于后面那个 $\sum$ ,只有 $2j&gt;i$ 的 $i\choose j$ 会产生贡献. 当 $i$ 为奇数时,这个贡献是 $2^{i-1}$ ,当 $i$ 为偶数时,这个贡献是 $\frac{2^i-{i\choose i/2}}{2}$ . 时间复杂度 $O(n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353,inv2=(P+1)&gt;&gt;1;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=2e5+10;int fac[MAXN],invfac[MAXN],pw2[MAXN],pw[MAXN];int binom(int M,int N)&#123; return mul(fac[M],mul(invfac[N],invfac[M-N]));&#125;int n,k,p,a=0,b=0,val[MAXN];int main()&#123; n=read(),k=read(); p=k-2; for(int i=1;i&lt;=n;++i) val[i]=read(); for(int i=1;i&lt;=n;++i) if(val[i]==val[i%n+1]) ++a; else ++b; fac[0]=pw2[0]=pw[0]=1; for(int i=1;i&lt;=b;++i) &#123; fac[i]=mul(fac[i-1],i); pw2[i]=mul(pw2[i-1],2); pw[i]=mul(pw[i-1],p); &#125; invfac[b]=fpow(fac[b],P-2); for(int i=b-1;i&gt;=0;--i) invfac[i]=mul(invfac[i+1],i+1); int ans=0; for(int i=0;i&lt;=b;++i) &#123; int tmp=mul(binom(b,i),pw[b-i]); if(i&amp;1) tmp=mul(tmp,pw2[i-1]); else tmp=mul(tmp,mul(inv2,add(pw2[i],P-binom(i,i&gt;&gt;1)))); inc(ans,tmp); &#125; ans=mul(ans,fpow(k,a)); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; E Not Same先把所有元素从小到大排序,考虑一列一列地去构造出这个解. 这里的 $n$ 指还需要构造的元素的数目. 如果最大的元素 $x&lt;n$ ,则可以从前往后递归构造解. 即,先求出后 $n-1$ 个元素的解,记第一个元素为 $y$ ,再将前 $y$ 个操作加上第一个元素. 如果最大的元素 $=n$ ,这样做时,最后一步就会出现问题. 此时应该构造出一个解,有 $n$ 次操作都包含了最后那个元素,最多有 $1$ 次操作没有包含. 如果次大的元素也 $=n$ ,就将所有除了最后一个元素的 $=n$ 的元素减去 $1$ ,递归构造前 $n-1$ 个元素的解. 次大元素现在是 $n-1$ ,所以前面只可能构造出 $n-1$ 或者 $n$ 个操作. 将这些操作全部加上最后一个元素,若操作数是 $n-1$ ,则还需要加上一个只包含最后一个元素的操作. 如果次大的元素 $&lt;n$ ,记它为 $x$ ,则可以先将开头的 $n-x-1$ 个数全部操作 $1$ 次,. 然后递归构造前 $n-1$ 个元素的解,这样也会得到 $n-1$ 或者 $n$ 个操作. 将这些操作全部加上最后一个元素,若操作数是 $n-1$ ,则还需要加上一个只包含最后一个元素的操作. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef pair&lt;int,int&gt; pii;#define val first#define pos secondvoid solve(vector&lt;pii&gt; A,vector&lt;vector&lt;int&gt;&gt; &amp;ops)&#123; int n=A.size(); if(n==1) &#123; if(A[0].val) ops.push_back(&#123;A[0].pos&#125;); return; &#125; if(A[n-1].val&lt;n) &#123; auto B=A; B.erase(B.begin()); solve(B,ops); for(int i=0;i&lt;A[0].val;++i) ops[i].push_back(A[0].pos); return; &#125; else &#123; auto B=A; B.pop_back(); if(A[n-2].val==n) &#123; vector&lt;int&gt; op; for(int i=0;i&lt;n-1;++i) if(B[i].val==n) &#123; B[i].val--; op.push_back(B[i].pos); &#125; solve(B,ops); for(int i=0;i&lt;ops.size();++i) ops[i].push_back(A[n-1].pos); if(ops.size()&lt;n) ops.push_back(&#123;A[n-1].pos&#125;); ops.push_back(op); &#125; else &#123; int x=A[n-2].val; for(int i=0;i&lt;n-x-1;++i) B[i].val--; solve(B,ops); for(int i=0;i&lt;n-x-1;++i) ops.push_back(&#123;A[i].pos&#125;); for(int i=0;i&lt;ops.size();++i) ops[i].push_back(A[n-1].pos); if(ops.size()&lt;n) ops.push_back(&#123;A[n-1].pos&#125;); &#125; &#125;&#125;int main()&#123; int n=read(); vector&lt;pii&gt; A(n); for(int i=0;i&lt;n;++i) &#123; A[i].val=read(); A[i].pos=i; &#125; sort(A.begin(),A.end()); vector&lt;vector&lt;int&gt;&gt; ops; solve(A,ops); cout&lt;&lt;ops.size()&lt;&lt;endl; for(int i=0;i&lt;ops.size();++i) &#123; string ans(n,'0'); for(int x:ops[i]) ans[x]='1'; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; F Xor-Set考虑建出一颗管辖区间 $[0,2^{60}-1]$ 的线段树,把 $A,B$ 集合的线段各自在这棵线段树上划分出来. 那么这个线段树上一个深度为 $x$ 的节点,代表前 $x$ 位固定后,后面的 $60-x​$ 位任意取,这样的数集合中都有. 那么 $A$ 集合中的一个线段树节点与 $B$ 集合中的一个线段树节点异或,贡献是容易计算的. 由于 $C$ 是集合,所以相同的数只会被算一次,那么把两者固定的长度(红色部分)取个 $\min$ ,贡献不变. 即把黑色部分也看成可以任意取. 在线段树上的意义就是,把深度较深的那个节点向上跳,跳到两者深度相同,贡献不变. 于是可以对集合 $A$ ,只给划分出来的线段树节点打标记,对集合 $B$ ,给划分出来的线段树节点的所有祖先打上标记. 利用线段树的性质可以证明,$A,B$ 各自标记的线段数目不会超过 $4n$ . 枚举每个深度,只计算深度相同的,有标记的节点之间产生的贡献,时间复杂度 $O(n^2\log 10^{18})​$ .]]></content>
      <tags>
        <tag>构造</tag>
        <tag>二分</tag>
        <tag>贪心</tag>
        <tag>平衡树</tag>
        <tag>线段树</tag>
        <tag>codeforces</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3159 决战]]></title>
    <url>%2F2019%2F11%2F23%2Fbzoj-3159-%E5%86%B3%E6%88%98%2F</url>
    <content type="text"><![CDATA[树链剖分 + 非旋 treap. 考虑树剖,维护每条重链信息时,由于线段树无法支持翻转操作,把它换成非旋 treap . 给每个重链开一棵非旋 treap ,以深度作为下标. 前面四种操作可以直接做,对于翻转操作,可以把操作到的所有点合成一个 treap ,打完标记后再放回去. 修改操作保证了起点和终点有祖先后代关系,处理起来就简单一些了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e4+10,inf=1e9;char op[10];int n,m,Root;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int idx=0,rt[MAXN];struct node&#123; int ls,rs,fa,rev,tag,mx,mi,siz,info,weight; ll sum; node() &#123; ls=rs=fa=rev=tag=info=0; mx=-inf,mi=inf; siz=0; &#125;&#125;treap[MAXN];#define root treap[o]#define lson treap[root.ls]#define rson treap[root.rs]int newnode(int val)&#123; int o=++idx; root.weight=rand(),root.siz=1; root.info=root.sum=root.mx=root.mi=val; return idx;&#125;void pushup(int o)&#123; root.sum=lson.sum+root.info+rson.sum; root.siz=lson.siz+1+rson.siz; root.mx=max(root.info,max(lson.mx,rson.mx)); root.mi=min(root.info,min(lson.mi,rson.mi));&#125;void reverse(int o)&#123; if(!o) return; root.rev^=1; swap(root.ls,root.rs);&#125;void modify(int o,int c)&#123; if(!o) return; root.tag+=c; root.mx+=c,root.mi+=c; root.info+=c,root.sum+=root.siz*c;&#125;void pushdown(int o)&#123; if(root.rev) &#123; reverse(root.ls); reverse(root.rs); root.rev=0; &#125; if(root.tag) &#123; modify(root.ls,root.tag); modify(root.rs,root.tag); root.tag=0; &#125;&#125;void split(int &amp;x,int &amp;y,int k,int o)&#123; if(!o) x=y=0; else &#123; pushdown(o); if(lson.siz&lt;k) &#123; x=o; split(root.rs,y,k-lson.siz-1,root.rs); &#125; else &#123; y=o; split(x,root.ls,k,root.ls); &#125; pushup(o); &#125; &#125;int merge(int x,int y)&#123; if(!x || !y) return x+y; pushdown(x),pushdown(y); if(treap[x].weight&lt;treap[y].weight) &#123; treap[x].rs=merge(treap[x].rs,y); pushup(x); return x; &#125; else &#123; treap[y].ls=merge(x,treap[y].ls); pushup(y); return y; &#125;&#125;void ins(int id,int val)&#123; rt[id]=merge(rt[id],newnode(val));&#125;ll query_sum(int id,int l,int r)&#123; int x,y,z; split(x,y,l-1,rt[id]); split(y,z,r-l+1,y); ll ans=treap[y].sum; y=merge(y,z); rt[id]=merge(x,y); return ans;&#125;int query_mx(int id,int l,int r)&#123; int x,y,z; split(x,y,l-1,rt[id]); split(y,z,r-l+1,y); int ans=treap[y].mx; y=merge(y,z); rt[id]=merge(x,y); return ans;&#125;int query_mi(int id,int l,int r)&#123; int x,y,z; split(x,y,l-1,rt[id]); split(y,z,r-l+1,y); int ans=treap[y].mi; y=merge(y,z); rt[id]=merge(x,y); return ans;&#125;void upd(int id,int l,int r,int c)&#123; int x,y,z; split(x,y,l-1,rt[id]); split(y,z,r-l+1,y); modify(y,c); y=merge(y,z); rt[id]=merge(x,y);&#125;int siz[MAXN],mxson[MAXN],dep[MAXN],top[MAXN],fa[MAXN];void dfs1(int u,int f)&#123; fa[u]=f; siz[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==f) continue; dep[v]=dep[u]+1; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;int cnt=0,tot[MAXN],rnk[MAXN],bel[MAXN];void dfs2(int u,int tp)&#123; top[u]=tp,bel[u]=bel[tp]; rnk[u]=++tot[bel[u]]; ins(bel[u],0); if(mxson[u]) dfs2(mxson[u],tp); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa[u] || v==mxson[u]) continue; bel[v]=++cnt; dfs2(v,v); &#125;&#125;void Increase(int x,int y,int c)&#123; if(dep[x]&lt;dep[y]) swap(x,y); while(top[x]!=top[y]) &#123; upd(bel[x],1,rnk[x],c); x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y]) swap(x,y); upd(bel[x],rnk[y],rnk[x],c);&#125;void Invert(int x,int y)&#123; int tx=x,ty=y; if(dep[x]&lt;dep[y]) swap(x,y); int tmp=0,a,b,c,d; while(top[x]!=top[y]) &#123; split(d,rt[bel[x]],rnk[x],rt[bel[x]]); tmp=merge(d,tmp); x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y]) swap(x,y); int l=rnk[y],r=rnk[x]; split(a,b,l-1,rt[bel[x]]); split(b,c,r-l+1,b); tmp=merge(b,tmp); reverse(tmp); x=tx,y=ty; if(dep[x]&lt;dep[y]) swap(x,y); while(top[x]!=top[y]) &#123; split(tmp,d,treap[tmp].siz-rnk[x],tmp); rt[bel[x]]=merge(d,rt[bel[x]]); x=fa[top[x]]; &#125; rt[bel[x]]=merge(a,merge(tmp,c));&#125;int t=0;ll Sum(int x,int y)&#123; ll res=0; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); res+=query_sum(bel[x],1,rnk[x]); x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y]) swap(x,y); res+=query_sum(bel[x],rnk[y],rnk[x]); return res;&#125;int Major(int x,int y)&#123; int res=-inf; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); res=max(res,query_mx(bel[x],1,rnk[x])); x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y]) swap(x,y); res=max(res,query_mx(bel[x],rnk[y],rnk[x])); return res;&#125;int Minor(int x,int y)&#123; int res=inf; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); res=min(res,query_mi(bel[x],1,rnk[x])); x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y]) swap(x,y); res=min(res,query_mi(bel[x],rnk[y],rnk[x])); return res;&#125;int main()&#123; n=read(),m=read(),Root=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs1(Root,0); bel[Root]=++cnt; dfs2(Root,Root); for(int i=1;i&lt;=m;++i) &#123; scanf("%s",op); int x=read(),y=read(); if(op[0]=='I') &#123; if(op[2]=='c') // Increase &#123; int c=read(); Increase(x,y,c); &#125; else // Invert Invert(x,y); &#125; else if(op[0]=='S') // Sum printf("%lld\n",Sum(x,y)); else if(op[0]=='M') &#123; if(op[1]=='a') // Major printf("%d\n",Major(x,y)); else // Minor printf("%d\n",Minor(x,y)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>平衡树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3874 宅男计划]]></title>
    <url>%2F2019%2F11%2F22%2Fbzoj-3874-%E5%AE%85%E7%94%B7%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[三分 + 贪心. 乍一看有点像网络流,但天数太大了,没法处理. 先将那些没用的食物扔掉,即,若存在 $i,j$ 满足 $S_i\le S_j,P_i\ge P_j$ ,则 $i$ 这种食物就可以扔掉了. 考虑将外卖小哥来的次数记为 $x​$ ,则在最优策略下,能宅的时间 $f(x)​$ 是一个关于 $x​$ 的先增后减的单峰函数. 这可以感性理解?如果来的次数少,则每次会买贵的,但运费少,若来的次数多,则每次会买便宜的,但运费多. 于是可以三分 $x$ ,考虑在给定 $x$ 时如何计算 $f(x)$ . 每次送外卖时都选择当前最便宜的食物,如果保质期过了,就考虑次便宜的食物,直到买不起了,就退出. 时间复杂度 $O(n\cdot \log S)$ . 注意需要先算一个不算太大的上界. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e2+10;int n,cnt=0;ll f,m;struct node&#123; ll p,s; bool operator &lt; (const node &amp;rhs) const &#123; return s&lt;rhs.s; &#125;&#125;a[MAXN],b[MAXN];ll calc(ll x)&#123; ll money=m-x*f; if(money&lt;=0) return 0; ll res=0,tmp=0; for(int i=1;i&lt;=cnt;++i) &#123; ll d=min(b[i].s-tmp,money/(b[i].p*x)); // 买的个数 tmp+=d,res+=d*x,money-=d*b[i].p*x; if(tmp&lt;b[i].s) &#123; res+=money/b[i].p; break; &#125; &#125; return res;&#125;int main()&#123; m=read(),f=read(),n=read(); for(int i=1;i&lt;=n;++i) &#123; a[i].p=read(); a[i].s=read()+1; &#125; sort(a+1,a+1+n); for(int i=1;i&lt;=n;++i) &#123; while(cnt &amp;&amp; a[i].p&lt;=b[cnt].p) --cnt; b[++cnt]=a[i]; &#125; ll L=1,R=m/(f+b[1].p),ans=0; while(L&lt;=R) &#123; ll k=(R-L+1),l=L+k/3,r=L+k*2/3; ll vl=calc(l),vr=calc(r); if(vl&lt;vr) &#123; L=l+1; ans=vr; &#125; else &#123; R=r-1; ans=vl; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3995 道路修建]]></title>
    <url>%2F2019%2F11%2F21%2Fbzoj-3995-%E9%81%93%E8%B7%AF%E4%BF%AE%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[线段树维护区间信息. 利用线段树维护每个区间的答案. 合并两个区间时,把连接处的两条横边都连上,会和两边的竖边形成一个矩形的环,再把这个环的最大边断掉. 对于一个区间,需要维护它的答案,这棵生成树的最左/右的竖边,竖边内横边的最大值,所有横边的最大值. 合并时大力讨论删掉的是哪条边,把参数转移一下,时间复杂度 $O(n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=6e4+10;int n,m;int rval[2][MAXN],cval[MAXN];struct node&#123; int l,r,ans,lc,rc,lmx,rmx,mx; node()&#123;ans=lmx=rmx=0;&#125; friend node operator + (const node &amp;lson,const node &amp;rson) &#123; node root; root.l=lson.l,root.r=rson.r; root.mx=max(max(lson.mx,rson.mx),max(rval[0][lson.r],rval[1][lson.r])); root.ans=lson.ans+rval[0][lson.r]+rval[1][lson.r]+rson.ans; int mx=max(max(rval[0][lson.r],rval[1][lson.r]),max(lson.rmx,rson.lmx)); if(cval[lson.rc]&lt;mx &amp;&amp; cval[rson.lc]&lt;mx) &#123; root.ans-=mx; root.lc=lson.lc,root.lmx=lson.lmx; root.rc=rson.rc,root.rmx=rson.rmx; &#125; else &#123; root.ans-=max(cval[lson.rc],cval[rson.lc]); if(cval[lson.rc]&lt;cval[rson.lc]) &#123; if(rson.lc==rson.rc) &#123; root.rc=lson.rc; root.rmx=max(max(lson.rmx,rson.mx),max(rval[0][lson.r],rval[1][lson.r])); &#125; else &#123; root.rc=rson.rc; root.rmx=rson.rmx; &#125; root.lc=lson.lc; root.lmx=lson.lmx; &#125; else &#123; if(lson.lc==lson.rc) &#123; root.lc=rson.lc; root.lmx=max(max(lson.mx,rson.lmx),max(rval[0][lson.r],rval[1][lson.r])); &#125; else &#123; root.lc=lson.lc; root.lmx=lson.lmx; &#125; root.rc=rson.rc; root.rmx=rson.rmx; &#125; &#125; return root; &#125; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1]void pushup(int o)&#123; root=lson+rson;&#125;void BuildTree(int o,int l,int r)&#123; if(l==r) &#123; root.ans=cval[l]; root.l=root.r=l; root.lc=root.rc=l; root.mx=root.lmx=root.rmx=0; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o);&#125;void upd(int o,int l,int r,int pos)&#123; if(l==r) &#123; root.ans=cval[l]; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(o&lt;&lt;1,l,mid,pos); else upd(o&lt;&lt;1|1,mid+1,r,pos); pushup(o);&#125;node query(int o,int l,int r,int L,int R)&#123; if(L&lt;=l &amp;&amp; r&lt;=R) return root; int mid=(l+r)&gt;&gt;1; if(R&lt;=mid) return query(o&lt;&lt;1,l,mid,L,R); if(L&gt;mid) return query(o&lt;&lt;1|1,mid+1,r,L,R); return query(o&lt;&lt;1,l,mid,L,R)+query(o&lt;&lt;1|1,mid+1,r,L,R);&#125;char op[10];int main()&#123; n=read(),m=read(); for(int i=1;i&lt;n;++i) rval[0][i]=read(); for(int i=1;i&lt;n;++i) rval[1][i]=read(); for(int i=1;i&lt;=n;++i) cval[i]=read(); BuildTree(1,1,n); for(int i=1;i&lt;=m;++i) &#123; scanf("%s",op); if(op[0]=='C') &#123; int x0=read(),y0=read(),x1=read(),y1=read(),w=read(); if(y0&gt;y1) &#123; swap(x0,x1); swap(y0,y1); &#125; if(y0==y1) &#123; cval[y0]=w; upd(1,1,n,y0); &#125; else if(x0==x1) &#123; rval[x0-1][y0]=w; upd(1,1,n,y0); upd(1,1,n,y1); &#125; &#125; else &#123; int L=read(),R=read(); node tmp=query(1,1,n,L,R); printf("%d\n",tmp.ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSP2019游记]]></title>
    <url>%2F2019%2F11%2F13%2F%E7%BD%AE%E9%A1%B6-CSP2019%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[雨后青空 $Day\ -\infty$又双叒叕感冒了啊,记得 NOIP2018 和 SCOI2019 考前也是感冒来着? 这次考试一定要用虚拟机测一测程序… 考前一天的时候感冒差不多好了,感觉还不错. $Day\ 1$开考后看了看题,感觉不太对劲. T1 还算比较顺利,花了几分钟,写完之后测了测样例就扔着了. T2 感觉十分诡异,自己一直在一个奇奇怪怪的二分 + 主席树和一个更奇奇怪怪的 dfs 乱搞中纠结. 先写了乱搞,改了一会,发现还是过不去样例,跑过去写主席树,写到一半的时候发现它假掉了. 此时已经 10:40 左右,赶紧写了一个 $50$ 分暴力打底,感觉自己差不多已经退役了. 然后开始苦苦挣扎,对着代码一通乱改,此时脑子基本是糊的,乱改了半个小时,它突然把所有样例都过了. 自己随便手捏了几个感觉可能出错的小样例试了试,感觉没问题就扔在那了. 去做 T3 ,自然是喜提 $10$ 分的好成绩,最后开了虚拟机测了下样例,就下机了. 下午时听说 T2 两个大样例都很水,有几个大爷写的和我差不多的做法,在回溯时挂掉了,紧张得不行,感觉自己回溯时也没写对,由于自己都记不清 T2 怎么写的了,就没去自测,下午和晚上都在颓隔膜. $Day\ 2$开考后看了看题,看到了熟悉的 $998244353$ ,感觉稍微对劲了一点. 开 T1 ,很快编出了 $84$ 分的做法,过了样例之后,想到了记差的做法,但感觉不可做,决定先看后面的题. 开 T2 ,很快编出了 $64$ 分的做法,过了样例之后决定先看后面的题. 开 T3 ,很快编出了 $55$ 分的做法,过了样例之后,花了些时间打表找出了完美二叉树的规律,把那 $20$ 分也写了. 此时还剩一个小时左右,结果自己啥也没编出来,感觉像个弱智,用虚拟机测了一下样例,就下机了. 感觉考场降智挺严重的. 后记考完的那天下午就回家了,第二天吃午饭的时候突然收到了源代码,发现自己 D1T2 没挂,真是虚惊一场. 似乎拿了个大众分,在家里颓了几天隔膜,然后就投入文化课的怀抱了. 12.2 终于出分了,没有挂分,发现和昨年 noip 考完时的估分一样,只不过昨年挂了 100 多分.]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191112]]></title>
    <url>%2F2019%2F11%2F12%2Ftest20191112%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX18u6AsHwqYNkg7VlXTmDL8L+fCci0Nofb+e1Q51K2RYSsswOfVGH3BG4WF54NkDxk83JZj2jPj8JAr4mShWu8CaSBETHJtvX7qdbGEDS464+sKn+JpUG5TtZq4FpT+tFz/07MPR6TI6A3Q7e5Uaw/wRGw5sHwnA0TyjEh3rwVovsYw2WWqk9AkiAMeBlDEJaCAUlEvX+vg4tbD06v2h58mQOEPY7rAiSgboh/aJqt5vNR+pcV4tmO5DmYBM5T8Rcs1KVvuHV7nuQkClovQ5efX24yurozdA2QVHYiyRJLaEqugjTNmDvYDpFXdEWXG+IKH2nPjncF936Ddxx0CVvCMrav1DR3nrzHS5Cv5WNadBCaIXeHvLOt+uMhdi7jMN7mjOtMBm5c597fNDV4C4ZpciwzEboHHyR5GEkyB8QuisbH9uN+jbN1DyhAqJMdWpF58Kst3XB9KDeDDOY6JbgHsEPbHjIIK45pFCiMhsCvg72M80r/8qTbx1uMwXed6zmIBgu7q4rw9EFMh86c9Trzq4L6ik3+PmuirJIRrsD6/tLk2+Ciqi6N/0T8gc0/hl+CQ+u+s0MU+z0Khzs1FkE+zPkkiCfflZ3+TEYZ8t2LtLDeUAIkuZ78JcXx5IlMgM4mPv79VqMXO/bR89+pGGm0bJHSK4Pd1qXhXHCFsGAUy2OVP2QwpZfwRmHpwCpT8CeVfJ3QXO64lm1JKafLDC5iVRLYB0JifHYUgFbbAZgK2nQLHV9m/6CqEc7xKEVNDfWX5svOX5y8a1DFeJgWVgm42+fxSfLKhqduZ3vgdZGVDYc1EUVsFMwbYVDTfuoiImxSYPmRJaqKlo+xYSYSqugX1LNFPqGPC2aFA5UOiVDASeFPVsrKFNoXwgeml23kybl9MFAc7kyYiLnSjxWxxR61AXmt2uyoDthCaQLmfJRqSopnS4GOIfPLAbn9HGNzu1AocHzJJHQJHj6diruqs84okYWQ4pZlm56mkNdkDUX1MKgAhtcnAlmm7yoS5q65p2oiwjfjNCWb5pWN+rIiJlVz7PKy6cieSiczp3rBcszKQsfMzQS1PB/KE3OZVQv8BM91uDwUPFenFPSKCx2BhUxSm4czm48H3Rf6cT2x1iSJqdMFd2ZbVE7Ef05lN9fmpgIiVcivg787AlmD9GRuH/8hDkpiBPhdHTSpjT1xHCb6T0KxIYm4VuVF//PpC/lliqATu39yYhCPS0Jpgze/xhZiHW2uTJs1fE62emaQ3f2Q17zIWsyAanR3bOXIVtIA9ezd/sAFSualdEHpS9fKw+DcHvzYAFXZbjzfFQnVpymPAh41CX3TpCsGF6sIaxMfhbh4Hs51fjVkCXN6n1ypWzdcnum99lrLo4nksZ1q3vBYQ/rsEwVb1KdaunyutPSqakiQHBSLE2lhxJEBOMjbO+NjVUXrxJlB8r75AAdaST0ew2oxMlo07yXsX4kHpfvjQ7a9hVenPGnSfKeWjeH2B7n7IbXPoigfzzpzmnAsNuEzICatszUz/zuAiKgexjAJdnpme6JjJr2K923g1LKu5r00floAbJ/injF5loSjkcW1Sbps3QSw85HX8go0BHQK+4TNC1VVda84Z8fjGhf+fFoc/aPj+auuGDcBM= var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>构造</tag>
        <tag>线段树</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3709 Bohater]]></title>
    <url>%2F2019%2F11%2F11%2Fbzoj-3709-Bohater%2F</url>
    <content type="text"><![CDATA[贪心. 首先可以对于 $d\le a$ 的怪物,按照 $d$ 从小到大的顺序,能打的都打掉. 对于剩下的怪,如果能打完,那么最后剩下的血量是确定的,与顺序无关. 倒着看,相当于是撤销掉血药的恢复,再撤销掉受到怪物的伤害,即先 $-a$ ,再 $+d$ . 那么把剩下的怪按照 $a$ 从大到小排序,能打的都打掉就可以了,前后两个阶段其实是对称的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,p=0,q=0;ll cur;struct Monster&#123; int a,d,id; bool type; bool operator &lt; (const Monster &amp;rhs) const &#123; return type?d&lt;rhs.d:a&gt;rhs.a; &#125;&#125;x[MAXN],y[MAXN];int ans[MAXN];bool check()&#123; sort(x+1,x+1+p); sort(y+1,y+1+q); for(int i=1;i&lt;=p;++i) if(cur&lt;=x[i].d) return false; else cur+=x[i].a-x[i].d,ans[i]=x[i].id; for(int i=1;i&lt;=q;++i) if(cur&lt;=y[i].d) return false; else cur+=y[i].a-y[i].d,ans[i+p]=y[i].id; return true;&#125;int main()&#123; n=read(),cur=read(); for(int i=1;i&lt;=n;++i) &#123; Monster tmp; tmp.d=read(),tmp.a=read(),tmp.id=i; if(tmp.d&lt;=tmp.a) tmp.type=true,x[++p]=tmp; else tmp.type=false,y[++q]=tmp; &#125; bool f=check(); puts(f?"TAK":"NIE"); if(f) for(int i=1;i&lt;=n;++i) printf("%d ",ans[i]); puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191111]]></title>
    <url>%2F2019%2F11%2F11%2Ftest20191111%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>线段树</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3990 排序]]></title>
    <url>%2F2019%2F11%2F09%2Fbzoj-3990-%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[爆搜乱搞. 首先可以注意到,操作的顺序是没有影响的. 从小到大考虑每个操作,若操作了 $k$ 次,且最后合法,则这种方案对答案的贡献为 $k!$ . 在第 $i$ 次操作时,我们把序列分成 $2^{n-i}$ 段,每段长度为 $2^i$ ,则可以交换两个 “半段” . 考虑那些不是连续递增的段,必须在当前这次操作处理,否则之后就被合在一起,无法处理了. 若没有这样的段,则不执行操作. 若有 $1$ 个这样的段,就将该段的前后两部分交换,若合法则继续,否则这种情况没有贡献. 若有 $2$ 个这样的段,则一共有 $4$ 个 “半段” 可以用于交换,枚举 $4$ 种交换情况,若合法,则继续 $dfs$ . 若这样的段 $&gt;2$ 个,则一定没有贡献. 最坏情况下每次都要枚举 $4$ 种交换情况,时间复杂度 $O(4^n\cdot n)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=(1&lt;&lt;12)+10,K=12+1;ll fac[K],pw[K],ans=0;int n,a[MAXN];bool invalid(int p,int k)&#123; for(int i=1;i&lt;pw[k];++i) if(a[p+i]!=a[p+i-1]+1) return true; return false;&#125;void swap_part(int x,int y,int k)&#123; for(int i=0;i&lt;pw[k];++i) swap(a[x+i],a[y+i]);&#125;void dfs(int k,int cnt)&#123; if(k&gt;n) return (void)(ans+=fac[cnt]); int t1=0,t2=0; // invalid parts for(int i=1;i&lt;=pw[n];i+=pw[k]) if(invalid(i,k)) &#123; if(!t1) t1=i; else if(!t2) t2=i; else // more than 2 invalid parts return; &#125; if(!t1) // 0 invalid part dfs(k+1,cnt); else if(!t2)// 1 invalid part &#123; swap_part(t1,t1+pw[k-1],k-1); if(!invalid(t1,k)) dfs(k+1,cnt+1); swap_part(t1,t1+pw[k-1],k-1); &#125; else // 2 invalid parts &#123; for(int a=0;a&lt;2;++a) for(int b=0;b&lt;2;++b) &#123; swap_part(t1+a*pw[k-1],t2+b*pw[k-1],k-1); if(!invalid(t1,k) &amp;&amp; !invalid(t2,k)) dfs(k+1,cnt+1); swap_part(t1+a*pw[k-1],t2+b*pw[k-1],k-1); &#125; &#125;&#125;int main()&#123; n=read(); fac[0]=pw[0]=1; for(int i=1;i&lt;=n;++i) &#123; fac[i]=fac[i-1]*i; pw[i]=pw[i-1]*2; &#125; for(int i=1;i&lt;=(1&lt;&lt;n);++i) a[i]=read(); dfs(1,0); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XJOI 开放模拟赛Day2 paint]]></title>
    <url>%2F2019%2F11%2F09%2FXJOI-%E5%BC%80%E6%94%BE%E6%A8%A1%E6%8B%9F%E8%B5%9BDay2-paint%2F</url>
    <content type="text"><![CDATA[min-max 容斥 + 树形背包. 有一棵 $n$ 个节点的树,初始每个节点都是白色的. 每次操作会从 $n$ 个节点中等概率随机选出一个点,将这个点以及与它相邻的点染为黑色. 问期望多少次操作后所有点都变成黑色.在模 $998244353$ 意义下求解. $n\le 1000$ . 记 $\max(S)$ 表示集合 $S$ 中的点都变成黑色的期望需要的时间. 记 $\min(S)​$ 表示集合 $S​$ 中的点至少有一个变成黑色的期望需要的时间. 则根据 min-max 容斥,有$$\max(S)=\sum_{T\subseteq S,T\neq \emptyset }(-1)^{|T|-1} \cdot \min(T)$$点数比较大,暴力去算每个 $\min(S)​$ 不可取,但可以注意到 $\min(S)​$ 只与集合 $S​$ 中的点覆盖的点的数目有关. 即,若记 $p(S)=\sum_{i} [\exists j\in S,dis(i,j)\le 1]$ 表示集合 $S$ 能覆盖的点的数目,则 $\min(S)=\frac{n}{p(S)}$ . 而 $p(S)$ 有效的取值只会有 $n$ 种,尝试对于每个 $x$ 求出 $p(S)=x$ 的方案数,再统计答案. 可以用树形背包来求,具体地,设 $f(i,j,0/1,0/1,0/1)$ 表示考虑了子树 $i$ 内的点,覆盖了 $j$ 个点,集合 $S$ 的大小是偶数/奇数,根节点 $i$ 在 $S$ 中/不在 $S$ 中,根节点 $i$ 被覆盖了/没被覆盖 时的方案数. 合并 $u$ 和它的某个儿子 $v$ 的信息后,被覆盖的点数是两棵子树中被覆盖的点数之和,还可能加上 $u$ 或者 $v$ .$$f(u,x,a,b,c)\times f(v,y,A,B,C)\\\to f(u,x+y+[c=0\land B=1]+[C=0\land b=1],a\oplus A,b,c\lor B)$$时间复杂度 $O(n^2)$ .]]></content>
      <tags>
        <tag>树形dp</tag>
        <tag>概率/期望</tag>
        <tag>min-max 容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191108]]></title>
    <url>%2F2019%2F11%2F08%2Ftest20191108%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19lO/Sqw4/8C2Ni3nhbuJzdcR11lxLaUe4bEDmoxPbkZybLIbL/Ra5FVLCCprehlqssucZR+mh7Q9SH/JvfzIO8d5WhV71c5/OPza3oT1K7DTHp+YwgvO5KNAnYohkS5+uxOEhrH2ClYdFPwksDIJU0k7W5r23LZdvhhm2FHddt4Axtv4KBKWfAqVZWAOCSefFe1eWslArRrB5jWjJXgFnt20QYsk0/0gBHuAgB1UTj1n6ycShp/vHYl0tlrYlyQ5I/DcdkEDCmO+eOzNsi69KExYMKyYbBmVlDT55r1yN7o4MhGxmoeBq7lnvUshuaK8A38rEDSejckeHyWtIoR4v8ImHVMjAoMPq1ADnA/0bl7Qo/5tG9Hkz83soPWv104sUP4Vq6ylN0VpmRr2k8myEBNpkr7MQ+nJx5cow9MWA4FefVhIrxnE51LniN0neZxJYkmpV7p/QgSCmIVt3Mnz9UaMpwv3N4sE6wJ4SCWEYvtKhThbmwVw64SB2MnljYAwe4ep3CHj4YN1/Euw+ZaVDn3bkaDB8m0uV12CEc/mZknFBYG+XLzsqF17rWYvxlWl68RwgWry2VhsQZBNghJXu0koVJ/kHAEH8lY9lQVwDpfQPpeONTwRGXlGfcxrra7gLVd5z1R2ubzBiz6Z/uw673FcCCTXTuxgcH015Div4IzAb67w5ErwDEIHoy1t+VrYOw1ektJHxrIwDx2Rip9/0hBuXFVlEi3YH/AdSTB5IytgLho/Qd7hWKeVxBhNQoA4WIY0QZ36JlW8sq8s0ZKPLdfImGBSZS+F4aaj3XfAzt5xFpmluBU3qCtyv+ZMuMQHqdk9aLJ3N2flMC8NecaDxp/d7petg5f7eB7PbB4k6oXQA6oUBDFm/tbnUc1x+pGn4+uQroFq9q/PAgeDxGg22dNIb9ZenTGBFkHRQ5nFDewIKTK3OuApaTLc/l9Ed/uJ8/M2EXgq7kWvLEXRqKaENfmoXv5QIaE0PDleekk9pNaVm0dY/E4Q575JDZf53AFt55Uzc2YJZRlzz/6jqefgcCgPttdJJQNxeTfesS7A6AIRLhG2Cc/kqW5N5Ja/P1rjd55tNFfiAf8483PURND+Tqe3JSatowspk5O6WidkuhsQ2EIXmUZVeODtwM+U4SANfzt0QsfHaTddRr5Udz+S0tLlCeZfvtJ8KR1H8BC6u2QfeGsJnNOtzmflow8be7CSZg5ivJ+6EgUS/fZG/9CYW1sNHBLIVmQBREzWuN0pdDlhpP8kVJKPe50RjymtXZNhgwEyyANeX/Ek6yhXbY1LyZE8IK3B98bRUY2umdWgRTl/QWq4Ez9wOn1eo2oJoB+iRs+TYp6tJ5Bm3yOIVoKCK8jvREFx/Km94dhjV0toDkVvPDo0iOZxSdW+AnR+6fX3fnD3OOMEfRisk0ATLuPPJXBTmlhK9iZ6YQW4+OWPMHNYqvb2jG86geKiAps/L3GfVTvRB6MJiPezrRgGK4ec2rIo37ts+mFNV7y2EO19N+RzvhFX9IRHttz7nWrRClUQNdBOCfTidGiv2rDJDBW11H6aCaORj1Y++QQkCwiO2zafDJkToj+RmkejM/9agCAUJBANNgyd4C+cV5klwrFMPSAPjtQbjUvJlFD3/g/ydfcfqyYtuUfjwr8jt3BGQyEcByjvdXEEAD3x20Sy439I99bRqyovjzKxGZf/Qc6/pa6LROiCMM+AxDKWpEFoPC0UlpBSQh1x18kOcTdJYbvrmpol3ek8KHGbC2OsgwOP2Ohap6T9Hai46TfnxwqOj/WlN6IsP4WmSFxg== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>二分</tag>
        <tag>启发式合并</tag>
        <tag>test</tag>
        <tag>权值线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF888G Xor-MST]]></title>
    <url>%2F2019%2F11%2F07%2FCF888G-Xor-MST%2F</url>
    <content type="text"><![CDATA[$Boruvka$ 算法求解最小生成树. 有一张 $n$ 个点的完全图,其中第 $i$ 个点有一个权值 $a_i$ ,两个点 $i,j$ 之间的边权为 $a_i\oplus a_j$ . 需要求出这张完全图的最小生成树的权值. $n\le 2\times 10^5,0\le a_i&lt;2^{30}$ . 利用 $Boruvka​$ 算法求解. 这个算法需要进行若干轮,初始时每个点是一个独立的连通块. 每一轮中,对于每个连通块,找到边权 $w$ 最小的边 $e=(u,v,w)$ ,满足 $u$ 在该块内,而 $v​$ 不在该块内. 将这些边都加入图中,利用并查集维护连通性. 当加入了 $n-1$ 条边后,就得到了一棵最小生成树. 每轮暴力枚举每条边,而每做一轮,连通块数目至少减少为原来的一半,所以时间复杂度为 $O((m+n)\log n)$ . 这个算法的瓶颈在于对于每个连通块找出连出去的边中,边权最小的那条边. 可以利用 $Trie$ 树优化这个找边过程,时间复杂度优化到 $O(n\log a\log n)$ . 这类套路题大概是每个点有点权,任意两点之间的边权由二者的点权决定,需要求最小生成树. 做法大致都和这道题类似,尝试去优化找最优边的过程. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10,K=30;const int inf=0x7fffffff;struct Trie&#123; int idx; Trie()&#123;idx=1;&#125; int ch[MAXN*K][2],val[MAXN*K],id[MAXN*K]; void ins(int x,int v,int k) &#123; int u=1; for(int i=K-1;i&gt;=0;--i) &#123; int c=(x&gt;&gt;i)&amp;1; if(!ch[u][c]) ch[u][c]=++idx; u=ch[u][c]; val[u]+=v; &#125; id[u]=k; &#125; int query(int x) &#123; int u=1; for(int i=K-1;i&gt;=0;--i) &#123; int c=(x&gt;&gt;i)&amp;1; if(val[ch[u][c]]) u=ch[u][c]; else u=ch[u][c^1]; &#125; return id[u]; &#125;&#125;T;int n,m=0,a[MAXN],fa[MAXN],p[MAXN];int Find(int x)&#123; return fa[x]==x?x:fa[x]=Find(fa[x]);&#125;bool cmp(int x,int y)&#123; return fa[x]&lt;fa[y];&#125;void init()&#123; for(int i=1;i&lt;=n;++i) &#123; p[i]=fa[i]=i; T.ins(a[i],1,i); &#125;&#125;pair&lt;int,int&gt; mi[MAXN];int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); sort(a+1,a+1+n); n=unique(a+1,a+1+n)-a-1; init(); ll ans=0; while(m&lt;n-1) &#123; for(int i=1;i&lt;=n;++i) fa[i]=Find(i); sort(p+1,p+1+n); for(int i=1;i&lt;=n;++i) mi[i]=make_pair(i,inf); int Fa; for(int l=1,r;l&lt;=n;++l) &#123; Fa=fa[p[l]]; r=l; while(r+1&lt;n &amp;&amp; fa[p[r+1]]==Fa) ++r; for(int i=l;i&lt;=r;++i) T.ins(a[p[i]],-1,p[i]); for(int i=l;i&lt;=r;++i) &#123; int x=p[i]; int y=T.query(a[x]); if((a[x]^a[y])&lt;mi[Fa].second) mi[Fa]=make_pair(y,a[x]^a[y]); &#125; for(int i=l;i&lt;=r;++i) T.ins(a[p[i]],1,p[i]); l=r; &#125; for(int i=1;i&lt;=n;++i) &#123; int x=Find(i),y=Find(mi[i].first); if(x==y) continue; fa[x]=y; ans+=mi[i].second; ++m; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>Trie</tag>
        <tag>Boruvka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191106]]></title>
    <url>%2F2019%2F11%2F06%2Ftest20191106%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>概率/期望</tag>
        <tag>博弈论</tag>
        <tag>高斯消元</tag>
        <tag>test</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1246]]></title>
    <url>%2F2019%2F11%2F05%2FCF1246%2F</url>
    <content type="text"><![CDATA[$Div.1$ A p-binary考虑从小到大枚举答案 $k$ ,则需要满足$$n-k\cdot p=\sum_{i=1}^{k} 2^{b_i}$$其中每个 $b_i$ 表示选择了数字 $2^{b_i}+p$. 判断这个 $k$ 是否有解,只需要判断 $popcount(n-kp)\le k$ 是否成立. 若 $n-kp$ 二进制下的 $1$ 的个数比 $k$ 大,则这个 $k$ 无解. 否则,当 $n-kp$ 二进制下的 $1$ 的个数 $\le k$ 时,总可以把 $2^i$ 拆成 $2^{i-1}+2^{i-1}$ ,而凑够 $k$ 个数,即找到一组解. 当 $n\le kp$ 时,就可以退出了,若此时仍未找到解,则一定无解. 1234567891011121314151617181920212223242526272829303132333435363738//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;#define lowbit(x) x&amp;(-x)int popc(int x)&#123; int s=0; while(x) ++s,x-=lowbit(x); return s;&#125;int n,p;int solve()&#123; for(int k=1;k&lt;=31;++k) if(n-k*p&gt;=k &amp;&amp; popc(n-k*p)&lt;=k) return k; return -1;&#125;int main()&#123; n=read(),p=read(); cout&lt;&lt;solve()&lt;&lt;endl; return 0;&#125; B Power Products把每个数质因数分解,得到$$x=\prod p_i^{b_i}$$这个指数 $b_i$ 可以对 $k$ 取模. 那么对于一个 $a_j$ 来说,找到的 $a_i$ 需要满足,对于每个质因子 $p_i$ ,两者的指数相加在模 $k$ 意义下为 $0$ . 用 $hash$ 去压缩每个数的每个质因子的次数. 在 CF 上写 hash 一定要写双进制模数啊. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,k;typedef pair&lt;int,int&gt; pii;#define mp make_pairmap&lt;pii,int&gt; cnt;struct Hash&#123; int P,Base; int add(int a,int b) &#123; return (a+b&gt;=P)?(a+b-P):(a+b); &#125; int mul(int a,int b) &#123; return 1LL * a * b % P; &#125; int pw[MAXN]; void init(int p,int base) &#123; P=p,Base=base; pw[0]=1; for(int i=1;i&lt;=100000;++i) pw[i]=mul(pw[i-1],Base); &#125; pii calc(int x) // (x,-x) &#123; int a=0,b=0; for(int i=2;i*i&lt;=x;++i) if(x%i==0) &#123; int t=0; while(x%i==0) x/=i,++t; t%=k; a=add(a,mul(pw[i],t)); t=(k-t)%k; b=add(b,mul(pw[i],t)); &#125; if(x&gt;1) &#123; int t=1,i=x; a=add(a,mul(pw[i],t)); t=(k-t)%k; b=add(b,mul(pw[i],t)); &#125; return mp(a,b); &#125;&#125;A,B;int main()&#123; A.init(1e9+7,137); B.init(998244353,37); n=read(),k=read(); ll ans=0; for(int i=1;i&lt;=n;++i) &#123; int x=read(); pii upd,query; pii t=A.calc(x); upd.first=t.first,query.first=t.second; t=B.calc(x); upd.second=t.first,query.second=t.second; ans+=cnt[query]; ++cnt[upd]; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; C Rock Is Push 从那几张样例解释的 GIF 图中大概就能看出做法了. 每次进行 $dp$ 转移时考虑连续移动一段,直到改变移动方向. 设 $f(i,j,k=0/1)$ 表示从 $(1,1)$ 出发,走到 $(i,j)​$ ,且当前应该向 右/下 走的方案数. 由于每次移动之后都会切换方向,所以 一行/一列 只会被走一次,那么每次移动之间就不会互相影响了. 当 $k=0$ 时,往右边走,若 $(i,j+1)\sim (i,m)$ 这些位置共有 $x$ 个空位,那么往右最多可以走 $t$ 步. 当 $k=1$ 时,往下面走,若 $(i+1,j)\sim (n,j)$ 这些位置共有 $y$ 个空位,那么往下最多可以走 $t$ 步. 转移需要优化,如果直接上二维树状数组,时间复杂度是 $O(n^2\log^2 n)$ 的,不是很优. 可以利用前缀和的方式进行优化. 计算 $f(i,j,1)$ 时,考虑在 $f(i,j-1,1)$ 的基础上,减掉那些恰好只能到达 $j-1$ 这个位置的贡献,这可以用桶存起来. 如果合法,还需要加上 $f(i,j-1,0)$ 对 $f(i,j,1)$ 的贡献. 计算 $f(i,j,0)$ 同理. 时间复杂度 $O(n^2)$ . 特判 $n=m=1$ 的情况,否则因为根本上没有移动,导致 $f(1,1,0)$ 和 $f(1,1,1)$ 都被算入答案了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=2e3+10;char buf[MAXN];int n,m,Free[MAXN][MAXN];int x[MAXN][MAXN],y[MAXN][MAXN],f[MAXN][MAXN][2];void init()&#123; for(int i=1; i&lt;=n; ++i) &#123; scanf("%s",buf+1); for(int j=1; j&lt;=m; ++j) Free[i][j]=(buf[j]=='.'); &#125; for(int i=1; i&lt;=n; ++i) &#123; int tmp=0; for(int j=m; j&gt;=1; --j) &#123; x[i][j]=tmp; tmp+=Free[i][j]; &#125; &#125; for(int j=1; j&lt;=m; ++j) &#123; int tmp=0; for(int i=n; i&gt;=1; --i) &#123; y[i][j]=tmp; tmp+=Free[i][j]; &#125; &#125;&#125;int sum[2][MAXN][MAXN];int solve()&#123; if(n==1 &amp;&amp; m==1) return Free[n][m]; for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=m; ++j) &#123; if(i==1 &amp;&amp; j==1) f[i][j][0]=f[i][j][1]=1; else &#123; if(j==1) f[i][j][1]=0; else if(i==1) f[i][j][1]=(x[1][1]&gt;=j-1); else &#123; f[i][j][1]=f[i][j-1][1]; inc(f[i][j][1],P-sum[1][i][j-1]); if(x[i][j-1]&gt;=1) inc(f[i][j][1],f[i][j-1][0]); &#125; if(i==1) f[i][j][0]=0; else if(j==1) f[i][j][0]=(y[1][1]&gt;=i-1); else &#123; f[i][j][0]=f[i-1][j][0]; inc(f[i][j][0],P-sum[0][i-1][j]); if(y[i-1][j]&gt;=1) inc(f[i][j][0],f[i-1][j][1]); &#125; &#125; if(y[i][j]) inc(sum[0][i+y[i][j]][j],f[i][j][1]); if(x[i][j]) inc(sum[1][i][j+x[i][j]],f[i][j][0]); &#125; return add(f[n][m][0],f[n][m][1]);&#125;int main()&#123; n=read(),m=read(); init(); cout&lt;&lt;solve()&lt;&lt;endl; return 0;&#125; D Tree Factory考虑倒着来实现这个过程,即从给出的树开始,不断操作,用最少的操作次数将它变成一条链. 若一个节点 $u$ 有 $v,w$ 两个儿子,则操作一次可以将子树 $v$ 接在子树 $w$ 下面. 不难发现,每次选择可操作的子树中,最大深度最大的那一颗,将它接在其他子树下面,会使最大深度 $+1​$ . 而当最大深度 $=n-1$ 时,就成了一条链了. 那么总操作次数一定是 $n-1-maxdep$ ,其中 $maxdep$ 表示初始时树中节点最大的深度. 对操作过程进行模拟即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;vector&lt;int&gt; G[MAXN];int n,dep[MAXN],fa[MAXN],mxson[MAXN];vector&lt;int&gt; ans,op;void dfs(int u)&#123; if(u) &#123; int cnt=dep[ans.back()]-dep[fa[u]]; while(cnt--) op.push_back(u); &#125; ans.push_back(u); for(auto v:G[u]) if(v^mxson[u]) dfs(v); if(mxson[u]) dfs(mxson[u]);&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;++i) &#123; fa[i]=read(); G[fa[i]].push_back(i); dep[i]=dep[fa[i]]+1; &#125; int p=max_element(dep,dep+n)-dep; while(p) &#123; mxson[fa[p]]=p; p=fa[p]; &#125; dfs(0); for(auto x:ans) printf("%d ",x); puts(""); printf("%llu\n",op.size()); for(auto x:op) printf("%d ",x); puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191105]]></title>
    <url>%2F2019%2F11%2F05%2Ftest20191105%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>状压dp</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3999 旅游]]></title>
    <url>%2F2019%2F11%2F04%2Fbzoj-3999-%E6%97%85%E6%B8%B8%2F</url>
    <content type="text"><![CDATA[树链剖分 + 线段树. 先写一个树链剖分. 再用线段树维护信息,每个区间需要维护最大值,最小值,前面某个数减后面某个数的最大值,最小值. 修改操作比较简单,对于询问操作,先用分割出的线段树区间的最值更新答案,再将所有分割出的区间按照经过的顺序排序,暴力枚举两个区间,用前一个区间的最小值减去后一个区间的最大值更新答案. 在线段树上处理时,需要注意移动的方向. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int inf=1e9;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e4+10;int n,m,ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int val[MAXN],dfn[MAXN],rnk[MAXN],idx=0;int siz[MAXN],dep[MAXN],mxson[MAXN],fa[MAXN],top[MAXN];void dfs1(int u,int f)&#123; siz[u]=1; fa[u]=f; for(int i=head[u]; i; i=nx[i]) &#123; int v=to[i]; if(v==f) continue; dep[v]=dep[u]+1; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; top[u]=tp; dfn[u]=++idx; rnk[idx]=u; if(mxson[u]) dfs2(mxson[u],tp); for(int i=head[u]; i; i=nx[i]) &#123; int v=to[i]; if(v!=fa[u] &amp;&amp; v!=mxson[u]) dfs2(v,v); &#125;&#125;struct node&#123; ll tag; ll v[2],delta[2]; int tim; bool operator &lt; (const node &amp;rhs) const &#123; return tim&lt;rhs.tim; &#125;&#125; Tree[MAXN&lt;&lt;2];int lt,rt,tot;ll ans;node tmp[MAXN];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1]void pushup(int o)&#123; root.v[0]=max(lson.v[0],rson.v[0]); root.v[1]=min(lson.v[1],rson.v[1]); root.delta[0]=max(lson.delta[0],rson.delta[0]); root.delta[0]=max(root.delta[0],rson.v[0]-lson.v[1]); root.delta[1]=max(lson.delta[1],rson.delta[1]); root.delta[1]=max(root.delta[1],lson.v[0]-rson.v[1]);&#125;void BuildTree(int o,int l,int r)&#123; root.tag=0; if(l==r) &#123; root.v[0]=root.v[1]=val[rnk[l]]; root.delta[0]=root.delta[1]=0; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o);&#125;void modify(int o,int c)&#123; root.tag+=c; root.v[0]+=c; root.v[1]+=c;&#125;void pushdown(int o)&#123; if(root.tag) &#123; modify(o&lt;&lt;1,root.tag); modify(o&lt;&lt;1|1,root.tag); root.tag=0; &#125;&#125;void query(int o,int l,int r,int L,int R,int dir,int c) // dir=0 left-&gt;right dir=1 right-&gt;left&#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; ans=max(ans,root.delta[dir]); tmp[++tot]=root; if(!dir) tmp[tot].tim=rt--; else tmp[tot].tim=lt++; modify(o,c); return; &#125; pushdown(o); int mid=(l+r)&gt;&gt;1; if(R&gt;mid) query(o&lt;&lt;1|1,mid+1,r,L,R,dir,c); if(L&lt;=mid) query(o&lt;&lt;1,l,mid,L,R,dir,c); pushup(o);&#125;ll solve(int x,int y,int c)&#123; ans=tot=0; lt=0,rt=inf; while(top[x]!=top[y]) &#123; if(dep[top[x]]&gt;dep[top[y]]) //jump x &#123; query(1,1,n,dfn[top[x]],dfn[x],1,c); x=fa[top[x]]; &#125; else //jump y &#123; query(1,1,n,dfn[top[y]],dfn[y],0,c); y=fa[top[y]]; &#125; &#125; if(dep[x]&gt;dep[y]) //jump x query(1,1,n,dfn[y],dfn[x],1,c); else //jump y query(1,1,n,dfn[x],dfn[y],0,c); sort(tmp+1,tmp+1+tot); for(int i=1; i&lt;tot; ++i) for(int j=i+1; j&lt;=tot; ++j) ans=max(ans,tmp[j].v[0]-tmp[i].v[1]); return ans;&#125;int main()&#123; n=read(); for(int i=1; i&lt;=n; ++i) val[i]=read(); for(int i=1; i&lt;n; ++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs1(1,0); dfs2(1,1); BuildTree(1,1,n); m=read(); for(int i=1; i&lt;=m; ++i) &#123; int x=read(),y=read(),c=read(); printf("%lld\n",solve(x,y,c)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191104]]></title>
    <url>%2F2019%2F11%2F04%2Ftest20191104%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1/Kv7AeQeKiqfYgBvsiGnl6i2wBZ7tWOvTHInRkaoUPhWe9h2QRBQ2JZ1XwoxlNP9PAmqvn/tavWa8+gGUr7RoMZv9cj/KXeEKtFBhi0Mi10mz4QuneVK1rM0NPToEKusMjMvZc9UpfYcQeNUrmZDkAvmoDUp1fAFTnC3lDsKKE3eJzN1M9GPoqoy9EpnL0djZ20jPHI+dhKRZ3YGn1D55zegaXfx9oaa0XAe2JSOEiN8pznwC18qotAGf34yl0D7QLxBGBMgGNQ78tJA25Cmir2hu3f6P5FjpLM1aDZXJiIH8yd5EV9o90c2C0sfwIhSorWQtLxmQzgAnXmqskMqkU/zJ8nbVMpwPzpEEqII9iqZY91bALXKEAGIWOCcZ/YpxJjQ7r3MIWiazJS3Gdu/OiX9rD1QFrSgX7D3iXY11CVrIHZCx8QEuBSulpajPKV6uOslM9FsM9A2PyY1A7ZdGU7TsIk05+6YjEDOFmKKTzJUnNucW0a+8O3zptkPINMJU9OP/Bc5IjSN8Cmag7tD742CXxEVrPrVyoRXd0Bpahfn99RP2mz/8qFQ1Y3gpjAg1PSkObEF3F9qdMrTMhU3ywmCnwIRkZG4k+aNpIlCrFFnNlZlPsoZwRFiPFqga2RKzJ3XjFu/52C6SzgAq6sPnTyAYIbGdEpw1iRiGjB7VfLs9b4NMXBsJuYAnucEIL7uwLXyElFRI8a5KdrEBnDIJGLsSC5f/O6vnW+mg/dPBow55dzWvn/wZPx+PxrAyn/RXUpbG9SbfuwcBfKPDVoOQaGDsBA2pRA2fuqCifNy5G8G/T/7Rmj2YjeR0FJiKGxUJnlMDCsujZYznzwKK5Oe9Ya+UFOb9rAOc6MSol0vu/kIWScCuYoT1h2B88jcmzOwbqZRWqxA1LwKoBGU5T4dk46ypCgqtVYnZbw0MWIfJdS6KbMOVmDaC4/Ak1Jozz69iwn4IRj/5ZDlMKmPiEfI7iPKQAYvXJcHuRia5ID6LA46/MyfH5uxBhvba/GCAf8DIWmDgSX9ehnbGddI/uovoKm9MT/x+pZRmuyxHL4B8zaAfRfZ0BAOW5zOgU+ro0g4HjPbVeN33CgEIenNFYVkewYUrcTjMJY5MvHOnJbsV4a6ezzggrRF5Iy7NFpifJXQIi+YfeECTcUU5+FxP0/7kg7E/oJIHwu3RKVXrnGE9yTGIu4JU/H3ZrtpNfaZgU0gv2phB7xFyAQuyhdUkoS/lBDsmlHbTkF0Hk+ZEI7/UnoWKuufav1J760yLShUfzigb867ZBh80M0spFngh0BuDTlO7l3v+ijkvoDdAW8+OfQy1EMuNZXXkdIC66t6X2U3/hONZB7V7gaRzE9glJr/bpu5U5YXpAZBJxThraP+Mo18rTsi9N6FS/gS5x/oZQpdxFY5XADEzO7JVRa/OR5C+wMhZAxjQGfiMHL9g2tttQZ7IVEYJoGMER+nbyd/CNoe4CObNUHbc0CjvGKvsNxjG5M6XefhfsZlgdpZBQOAY9zjMMlt6gNpRepJ1YkCPSo6QX2Qq55BwvSICcc8EsEWaW+lIV4lQioEH+2FlGcrONpy7B80pOlPiep6Ya9bnqHVFVHpfvCLaRyJhho8YSSmsf4I2KQODSAIj65aEqAQ1HKyzEcnteJ+72x3LhDPYT21KaMfYFxqa7YzC6CvWe7nZbkVryrXRhNdOkWyAa3Pznd6mu8+wDAgORh81QVgj1cKE2n83NswHw5kFEFfQGhKbOYqnpYgGJU3Kw9WN/WIb9MwZH7CaI/FO2m3aoyH3RKUx3gIrLZmkdB/TYAtNWzpxbRJ6FB3vSWnNOqLhN0dlA8+9FQ5P7DU1AdwGz453ZxGcx+AuarynanQXYb5OOXHZFqCyqas0pzCnEVtZFBKsSXCiBFKc121l4f0DleDfyqTLQV3Fvn1C1VGDAiZdJwVvwrgm6Ic8EY5ShFRJG5fJlHvgzy9OTfSl713rOjlXa2zbCBkSgC+GPh41sIGcEPVVsX8oCtJgHJV0YLl5f0qkXIWqvhgslWJ7O9NrFKJqrs1crBQA+iNiuNo8v16nESonXNuE0oMkmaNBOBrbK7PbHwJo+IFWUU+w9LVJ213YBR8fwZ9MSnP4AQw== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>概率/期望</tag>
        <tag>线段树</tag>
        <tag>博弈论</tag>
        <tag>计算几何</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1050 旅行]]></title>
    <url>%2F2019%2F11%2F03%2Fbzoj-1050-%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[并查集. 边的数目比较小,可以尝试枚举每一条边作为最小权值的边时的答案. 先将所有边按照权值大小从小到大排序. 假设一条边 $(u,v,w)$ 是路径上权值最小的边. 用并查集维护图的连通性,按权值从小到大不断加入权值 $\ge w$ 的边. 当 $s$ 与 $t$ 连通时,得到当 $(u,v,w)​$ 作为权值最小的边的最优解. 时间复杂度 $O(m^2\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e5+10;int n,m,fa[MAXN];int Find(int x)&#123; return x==fa[x]?x:fa[x]=Find(fa[x]);&#125;void init()&#123; for(int i=1;i&lt;=n;++i) fa[i]=i;&#125;struct Edge&#123; int u,v,w; bool operator &lt; (const Edge &amp;rhs) const &#123; return w&lt;rhs.w; &#125;&#125;E[MAXN];typedef pair&lt;int,int&gt; pii;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; E[i].u=read(); E[i].v=read(); E[i].w=read(); &#125; sort(E+1,E+1+m); int s=read(),t=read(); pii ans; ans.first=0,ans.second=1; // max/min for(int i=1;i&lt;=m;++i) &#123; init(); pii tmp; tmp.first=0; tmp.second=E[i].w; for(int j=i;j&lt;=m;++j) &#123; int u=Find(E[j].u),v=Find(E[j].v); if(u==v) continue; fa[u]=v; if(Find(s)==Find(t)) &#123; tmp.first=E[j].w; break; &#125; &#125; if(!tmp.first) break; if(!ans.first || tmp.first*ans.second&lt;tmp.second*ans.first) ans=tmp; &#125; if(!ans.first) puts("IMPOSSIBLE"); else &#123; int g=__gcd(ans.first,ans.second); if(g==ans.second) printf("%d\n",ans.first/ans.second); else printf("%d/%d\n",ans.first/g,ans.second/g); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2140 稳定婚姻]]></title>
    <url>%2F2019%2F11%2F03%2Fbzoj-2140-%E7%A8%B3%E5%AE%9A%E5%A9%9A%E5%A7%BB%2F</url>
    <content type="text"><![CDATA[$tarjan$ 求 $scc$ . 考前复习板子. 用大写字母代表女性,小写字母代表男性. 当 $A-a$ 的感情不和时,若能找到一条路径 $A\to a\to B\to b\to \dots\to K\to k\to A$ ,则这对婚姻不安全. 可以发现,女性向男性连的边都是夫妻关系,男性向女性连的边都是情人关系. 于是只把这两种有向边建出来,用 $tarjan$ 求出强连通分量,判断每对夫妻是否在同一个强连通分量中. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2.5e4+10;map&lt;string,int&gt; mp;int n,m,tot=0;int id(string s)&#123; if(mp.find(s)!=mp.end()) return mp[s]; return mp[s]=++tot;&#125;string female,male;int a[MAXN],b[MAXN],ecnt=0,head[MAXN],to[MAXN],nx[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int dfn[MAXN],low[MAXN],idx=0,in[MAXN],stk[MAXN],tp=0,scc[MAXN],t=0;void dfs(int u)&#123; dfn[u]=low[u]=++idx; stk[++tp]=u; in[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(!dfn[v]) &#123; dfs(v); low[u]=min(low[u],low[v]); &#125; else if(in[v]) low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u]) &#123; int v=-1; ++t; while(u!=v) &#123; v=stk[tp--]; scc[v]=t; in[v]=0; &#125; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;female&gt;&gt;male; a[i]=id(female); b[i]=id(male); addedge(a[i],b[i]); &#125; m=read(); for(int i=1;i&lt;=m;++i) &#123; cin&gt;&gt;female&gt;&gt;male; addedge(id(male),id(female)); &#125; for(int i=1;i&lt;=tot;++i) if(!dfn[i]) dfs(i); for(int i=1;i&lt;=n;++i) &#123; if(scc[a[i]]==scc[b[i]]) puts("Unsafe"); else puts("Safe"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2054 疯狂的馒头]]></title>
    <url>%2F2019%2F11%2F03%2Fbzoj-2054-%E7%96%AF%E7%8B%82%E7%9A%84%E9%A6%92%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[并查集. 线段树的做法不够优秀. 只询问一次,每个点只受最后一次染色影响,考虑倒着做,将一段区间染色后,就将这些位置全部删掉. 用并查集维护从每个位置开始,右边第一个还没有被删掉的位置. 123456789101112131415161718192021222324252627282930313233343536373839404142//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e7+10;int n,m,p,q,fa[MAXN],col[MAXN];int Find(int x)&#123; return fa[x]==x?x:fa[x]=Find(fa[x]);&#125;int main()&#123; n=read(),m=read(),p=read(),q=read(); for(int i=1;i&lt;=n+1;++i) fa[i]=i; for(int i=m;i&gt;=1;--i) &#123; int l=(i*p+q)%n+1,r=(i*q+p)%n+1; if(l&gt;r) swap(l,r); for(int j=Find(l);j&lt;=r;j=Find(j)) &#123; col[j]=i; fa[j]=j+1; &#125; &#125; for(int i=1;i&lt;=n;++i) printf("%d\n",col[i]); return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3895 取石子]]></title>
    <url>%2F2019%2F11%2F03%2Fbzoj-3895-%E5%8F%96%E7%9F%B3%E5%AD%90%2F</url>
    <content type="text"><![CDATA[博弈论. 对于若干堆石子来说,能操作的次数为 石子数目 + 堆的数目 - 1. 如果这些石子中不存在单独一个石子一堆的情况,则答案只与操作次数的奇偶性有关. 证明:当操作次数为 $0$ 时,当前的先手就败了. 若先手从数目 $=2$ 的堆中拿了一个石子,后手可以把剩下那个石子与其他的合并. 若先手从数目 $\ge 3$ 的堆中拿了一个石子,后手可以再从那个堆中拿一个石子,或是将这堆与其他的合并. 操作次数的奇偶性不会变化,最后一定会变成只有一堆石子的情况,正确性就显然了. 而总堆数 $n$ 比较小,可以暴力把单独一个石子的数目记在状态里面. 设 $f(i,j)$ 表示当前有 $i$ 个单独的石子,其余石子的操作次数为 $j$ 时的胜负情况, $1$ 表示先手必胜, $0$ 表示先手必败. 边界为 $i=0$ ,此时可以直接判断胜负情况.转移时,可以进行以下几种操作: 拿走一个单独的石子,会使 $i$ 减少 $1$ . 从石子数目 $&gt;1$ 的堆中拿走一个石子,或者合并两个石子数目 $&gt;1$ 的堆,都只会使 $j$ 减少 $1$ . 合并一个单独的石子和一个石子数目 $&gt;1$ 的堆, 会使 $i$ 减少 $1$ ,而 $j$ 增加 $1$ . 合并两个单独的石子,会使 $i$ 减少 $2$ , $j$ 增加 $3​$ . 注意特判全都是单独的石子的情况,此时合并两个单独的石子, $j$ 只会增加 $2$ . 利用记忆化搜索实现,不同组数据也可以共用记录的 $f$ . 时间复杂度 $O(n\cdot \sum a_i)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=51,MAXM=1e3+10;int f[MAXN][MAXN*MAXM];int dfs(int i,int j)&#123; if(i==0) return j&amp;1; if(j==1) return dfs(i+1,0); if(f[i][j]!=-1) return f[i][j]; int &amp;res=f[i][j]; if(!dfs(i-1,j)) res=1; else if(j&gt;0 &amp;&amp; !dfs(i,j-1)) res=1; else if(j&gt;0 &amp;&amp; !dfs(i-1,j+1)) res=1; else if(i&gt;=2 &amp;&amp; !dfs(i-2,j+(j?3:2))) res=1; else res=0; return res;&#125;int main()&#123; memset(f,-1,sizeof f); int T=read(); while(T--) &#123; int n=read(); int x=0,y=-1; for(int i=1;i&lt;=n;++i) &#123; int v=read(); if(v==1) ++x; else y+=v+1; &#125; if(y==-1) y=0; puts(dfs(x,y)?"YES":"NO"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3894 文理分科]]></title>
    <url>%2F2019%2F11%2F03%2Fbzoj-3894-%E6%96%87%E7%90%86%E5%88%86%E7%A7%91%2F</url>
    <content type="text"><![CDATA[最小割. 最小割经典模型,一个集合中的元素全选时会产生一个额外收益. 先把所有的收益和额外收益都加入答案,然后对于每个人 $x$ ,连边 $S\to x,x\to T$ ,权值分别为选文,选理的收益. 对于每个人,再新建一个点 $y$ ,将自己以及与它四连通的点向 $y$ 连边,权值为 $\infty$ . 将 $y$ 向 $T$ 连边,权值为这些人都选理的收益,表示这些人中只要有一个人选了文,都选理的收益就没有了. 都选理的处理方法同理. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=1e3+10;int art[MAXN][MAXN],sci[MAXN][MAXN],same_art[MAXN][MAXN],same_sci[MAXN][MAXN],id[MAXN][MAXN];int n,m,tot=0,ans=0;void Read(int a[MAXN][MAXN])&#123; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) ans+=(a[i][j]=read());&#125;const int N=3e4+10,M=2e6+10;int head[N],ecnt=1;struct Edge&#123; int nx,to,flow; Edge(int nx=0,int to=0,int flow=0):nx(nx),to(to),flow(flow) &#123;&#125;&#125;E[M];void addedge(int u,int v,int w)&#123; E[++ecnt]=Edge(head[u],v,w); head[u]=ecnt;&#125;void ins(int u,int v,int w)&#123; addedge(u,v,w); addedge(v,u,0);&#125;int cur[N],dep[N];queue&lt;int&gt; q;bool bfs(int S,int T)&#123; for(int i=1;i&lt;=tot;++i) dep[i]=-1,cur[i]=head[i]; dep[S]=0; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u];i;i=E[i].nx) &#123; int v=E[i].to; if(E[i].flow&gt;0 &amp;&amp; dep[v]==-1) &#123; dep[v]=dep[u]+1; q.push(v); &#125; &#125; &#125; return dep[T]!=-1;&#125;int dfs(int u,int T,int limit)&#123; if(u==T || !limit) return limit; int f,flow=0; for(int &amp;i=cur[u];i;i=E[i].nx) &#123; int v=E[i].to; if(E[i].flow&gt;0 &amp;&amp; dep[v]==dep[u]+1 &amp;&amp; (f=dfs(E[i].to,T,min(limit,E[i].flow)))) &#123; E[i].flow-=f; E[i^1].flow+=f; flow+=f; limit-=f; &#125; if(!limit) break; &#125; return flow;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) id[i][j]=++tot; Read(art); Read(sci); Read(same_art); Read(same_sci); int S=++tot,T=++tot; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) &#123; int x=id[i][j],y=++tot; ins(S,x,art[i][j]); ins(x,T,sci[i][j]); ins(y,T,same_sci[i][j]); ins(x,y,inf); if(i&gt;1) ins(id[i-1][j],y,inf); if(i&lt;n) ins(id[i+1][j],y,inf); if(j&gt;1) ins(id[i][j-1],y,inf); if(j&lt;m) ins(id[i][j+1],y,inf); y=++tot; ins(S,y,same_art[i][j]); ins(y,x,inf); if(i&gt;1) ins(y,id[i-1][j],inf); if(i&lt;n) ins(y,id[i+1][j],inf); if(j&gt;1) ins(y,id[i][j-1],inf); if(j&lt;m) ins(y,id[i][j+1],inf); &#125; while(bfs(S,T)) ans-=dfs(S,T,inf); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191103]]></title>
    <url>%2F2019%2F11%2F03%2Ftest20191103%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>概率/期望</tag>
        <tag>矩阵加速</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191102]]></title>
    <url>%2F2019%2F11%2F02%2Ftest20191102%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>主席树</tag>
        <tag>test</tag>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1245]]></title>
    <url>%2F2019%2F11%2F02%2FCF1245%2F</url>
    <content type="text"><![CDATA[$Div.2$ 感觉这场的 E,F 都偏简单了啊. A Good ol’ Numbers Coloring只需要判断 $a,b$ 是否互质. 证明可以参考小凯的疑惑. 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int main()&#123; int T=read(); while(T--) &#123; int a=read(),b=read(); if(__gcd(a,b)==1) puts("Finite"); else puts("Infinite"); &#125; return 0;&#125; B Restricted RPS先判断能否赢,若能,就先把需要赢的位置确定好,剩下的随便放即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=128;char buf[MAXN],ans[MAXN];int main()&#123; int T=read(); while(T--) &#123; int n=read(),r=read(),p=read(),s=read(); int x=(n+1)&gt;&gt;1,R=0,P=0,S=0; scanf("%s",buf); for(int i=0;i&lt;n;++i) &#123; if(buf[i]=='R') ++R; else if(buf[i]=='P') ++P; else ++S; &#125; x-=min(R,p)+min(P,s)+min(S,r); if(x&gt;0) puts("NO"); else &#123; puts("YES"); for(int i=0;i&lt;n;++i) ans[i]='#'; for(int i=0;i&lt;n;++i) &#123; if(buf[i]=='R' &amp;&amp; p) ans[i]='P',--p; else if(buf[i]=='P' &amp;&amp; s) ans[i]='S',--s; else if(buf[i]=='S' &amp;&amp; r) ans[i]='R',--r; &#125; for(int i=0;i&lt;n;++i) if(ans[i]=='#') &#123; if(p) ans[i]='P',--p; else if(s) ans[i]='S',--s; else ans[i]='R',--r; &#125; for(int i=0;i&lt;n;++i) putchar(ans[i]); puts(""); &#125; &#125; return 0;&#125; C Constanze’s Machine先特判掉存在字符 $w$ 或 $m$ 的情况,答案为 $0$ . 剩余情况,对于各段连续的 $u$ 串, $n$ 串,方案数是互不影响的,可以用乘法原理乘起来. 设计一个 $dp$ 计算长度为 $i$ 的 $u​$ 串的方案数,可以发现它就是斐波那契数. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=1e5+10;char buf[MAXN];int n,f[MAXN];int main()&#123; scanf("%s",buf); n=strlen(buf); f[0]=f[1]=1; for(int i=2;i&lt;=n;++i) f[i]=add(f[i-1],f[i-2]); int ans=1; for(int i=0,j;i&lt;n;++i) &#123; if(buf[i]=='m' || buf[i]=='w') ans=0; j=i; while(j+1&lt;n &amp;&amp; buf[j+1]==buf[i]) ++j; if(buf[i]=='n' || buf[i]=='u') ans=mul(ans,f[j-i+1]); i=j; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D Shichikuji and Power Grid设置一个虚拟节点 $n+1$ ,每个点与这个虚拟节点之间连边,权值为向这个点直接供电的花费,即 $c_i$ . 任意两个点之间连边,权值为在它们之间修电线的花费,跑一颗最小生成树即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const ll inf=9e18;const int MAXN=2019;struct node&#123; int c,k,x,y,id; bool operator &lt; (const node &amp;rhs) const &#123; return c&gt;rhs.c; &#125;&#125;p[MAXN];ll calc(node i,node j)&#123; return 1LL*(i.k+j.k)*(abs(i.x-j.x)+abs(i.y-j.y));&#125;struct Edge&#123; int u,v; ll c; Edge(int u=0,int v=0,ll c=0):u(u),v(v),c(c)&#123;&#125; bool operator &lt; (const Edge &amp;rhs) const &#123; return c&lt;rhs.c; &#125;&#125;E[MAXN*MAXN+MAXN];int n,m=0,s=0,t[MAXN],e=0,ea[MAXN],eb[MAXN];int fa[MAXN];int Find(int x)&#123; return x==fa[x]?x:fa[x]=Find(fa[x]);&#125;ll ans=0;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; p[i].id=i; p[i].x=read(); p[i].y=read(); &#125; for(int i=1;i&lt;=n;++i) p[i].c=read(); for(int i=1;i&lt;=n;++i) p[i].k=read(); for(int i=1;i&lt;=n;++i) &#123; fa[i]=i; E[++m]=Edge(i,n+1,p[i].c); for(int j=i+1;j&lt;=n;++j) E[++m]=Edge(i,j,calc(p[i],p[j])); &#125; fa[n+1]=n+1; sort(E+1,E+1+m); int tot=0; for(int i=1;i&lt;=m &amp;&amp; tot&lt;=n;++i) &#123; int u=E[i].u,v=E[i].v; if(Find(u)!=Find(v)) &#123; fa[Find(u)]=Find(v); if(v==n+1) t[++s]=u; else &#123; ++e; ea[e]=u; eb[e]=v; &#125; ++tot; ans+=E[i].c; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; printf("%d\n",s); for(int i=1;i&lt;=s;++i) printf("%d ",t[i]); printf("\n%d\n",e); for(int i=1;i&lt;=e;++i) printf("%d %d\n",ea[i],eb[i]); return 0;&#125; E Hyakugoku and Ladders设 $f(x,y)$ 表示当前在位置 $(x,y)$ ,走到终点的最小期望步数. 终点处的 $f$ 值为 $0$ ,对于距离终点的步数 $&lt;6$ 的位置, $f$ 值为 $6$ . 其余位置直接枚举转移到哪个位置即可,记忆化搜索时还要记录上一步是不是用了梯子,因为不能连续用两次. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=11;double f[MAXN][MAXN][2];typedef pair&lt;int,int&gt; pii;#define mp make_pairpii nxt(int x,int y)&#123; if(y==10 &amp;&amp; x%2==0) return mp(x-1,y); if(y==1 &amp;&amp; x%2) return mp(x-1,y); if(x%2==0) return mp(x,y+1); return mp(x,y-1);&#125;int h[MAXN][MAXN];double dfs(int x,int y,bool ladder)&#123; if(x==1 &amp;&amp; y==1) return 0.0; if(x==1 &amp;&amp; y&lt;=6) return 6.0; if(f[x][y][ladder]&gt;0) return f[x][y][ladder]; double &amp;res=f[x][y][ladder]; res=0; int a=x,b=y; for(int i=1;i&lt;=6;++i) &#123; pii tmp=nxt(a,b); a=tmp.first,b=tmp.second; res+=dfs(a,b,true); &#125; res/=6.0; res+=1.0; if(ladder &amp;&amp; h[x][y]) res=min(res,dfs(x-h[x][y],y,false)); return res;&#125;int main()&#123; for(int i=1;i&lt;=10;++i) for(int j=1;j&lt;=10;++j) h[i][j]=read(); printf("%.10f\n",dfs(10,1,true)); return 0;&#125; F Daniel and Spring Cleaning设 $f(x,y)$ 表示 $0\le a\le x,0\le b\le y$ 时的合法方案数. 在二维平面上简单容斥,可以发现答案为 $f(r,r)-2\cdot f(l-1,r)+f(l-1,l-1)$ . 而 $a\oplus b=a+b$ 的充要条件为 $a\&amp;b=0$ ,所以直接数位 $dp$ 计算方案数即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int K=32;ll f[K][2][2];int x,y;int kp(int s,int i)&#123; return (s&gt;&gt;i)&amp;1;&#125;ll dfs(int k,bool lx,bool ly)&#123; if(k&lt;0) return 1LL; if(f[k][lx][ly]!=-1) return f[k][lx][ly]; ll &amp;res=f[k][lx][ly]; res=0; int maxx=lx?kp(x,k):1; int maxy=ly?kp(y,k):1; for(int i=0;i&lt;=maxx;++i) for(int j=0;j&lt;=maxy;++j) if(i+j&lt;2) res+=dfs(k-1,lx&amp;&amp;i==maxx,ly&amp;&amp;j==maxy); return res;&#125;ll calc(int l,int r)&#123; memset(f,-1,sizeof f); x=l,y=r; if(x&lt;0 || y&lt;0) return 0; return dfs(31,true,true);&#125;void solve()&#123; int l=read(),r=read(); ll ans=calc(r,r)-2LL*calc(r,l-1)+calc(l-1,l-1); cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>数学</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191101]]></title>
    <url>%2F2019%2F11%2F01%2Ftest20191101%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>贪心</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191031]]></title>
    <url>%2F2019%2F10%2F31%2Ftest20191031%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19TjagGw3pJ6Fm+MfZpUoYy9Izgu2PKnFAtg1SdRKqUryEYwISMDLCnEQlhpZgVVa0F2/3O1zRGkRAj0EvWGnljhqJkRU/9ny++dRXX5oo9+V1CvfzTrJ3WG/dvWBWOauYM485dwVVabGD94CnJFPKpMmb+eYY8+OrXBNkpclJ/pCOCG8tVY0lmgfHlb/ekM8leP9ls4eaiJp4LljZ7QjEruFoXqVxtazxIgkVJfPka38qQ4TwBFmq/yuFMcXIJCLdMCgKrmpdHBdGWJdC9/KmFoDZakEYfhtCbOkt4Rxa2wn+4z7PpNKL/1vbGgUr3DPXeqeZ15Y/EhvZAFuecQD4lIAOUiSa7BrhaVQP+l2QnGM3h2AoDqMtQd+Tnk2MrRt9cP7PFhZ5gamSpQyAKRMOSs7lRq14kRXUsEvQixejJsAXXFyxLwrJyL4C021uQqbyK4kTjjrDyBxDb30zq3tytyJxXgRv3rwQlMLEOmUpzOoPaIUpyrOnX5vt+QtCj1PtVcEYK2SE7YoeUEGG3i34TEIhaSHIU1XGFqxtIa9MR7y35pyv4xY06pnhMjsiTHCQZtRiu/p4UUXCRiW2GedXeX569yb19ARiwnso4bPuG5gx5KIXKXmHZ5pbukVGxX89dPRD0VnL+S8gMqFjmX6aILS3o2wqqsmaeSDxtkZByuxR6TyuzpBrbcWzbfZMPxw/ZoTvhbJ3XLsUVdoU+Pz7U3AAjTCveF8AD+1Ly1L/V4eVjypKSkHdF4C7hAWjTyzQcJz3AOI4htjDc1ZeRyN0j1AKRxdHKFkBUREEA94t2V4e2MrSbuCwnvIw+Z3JUcsElxfMYW7wN9iAnsVg2CjCYNxVp80BwC1wdypAATGAJYSq09VbNVN4s5qALCfAYIM+dW85T9Zu2JVAUKGU3VqOH38RMbtAy7/bZVIW2TxhbKYqf1lwYYuH8B9kE1hKXN+8C1APVNfViLjGFAuml3kykJm2r8uzh4Dfn6JO96V6goo8EGMf2t4dwDQLm8JOPdieUTiyPrlIKj9FnbZhQqgbIKq5YMPEKQEFjaYUnn8ZzpNQbYplkaW0OlV5iRov0giCsTOHDbUFlHwJVWiY3uc/C23LLE5J2AphGLLAB5wEfTE1I3RMbRbcJ2KSb1owzF8jlBqh7L3Z17wCb9feyagPCxO7ayAUbbTf/+zqJkjrm1ZVH2xxODgr8MwuCQ2bx8e/2u7C1/jYGXAsZfIFt4KHgDZOZDFhsPIWmRd2PK8Hdxxf7c7AFGrv6bLz8ifrQ3qAbbJPHRC8khTBtSnnrtXB5GO/I1dHMfyOrSMFQEBRZk30Y0syyfA56NkMxQ4VfOctWCAo4dUU17f6tL1SRH61xn0d3009mx5F9Ms/NgP33f562x7lD7ZmnU7XU4EY3rxgSWQ7B9tPnFX5S8ZqO5nAkcusqsNUtaWdYqzmbg7rWPAMiCuyvx7qwpVchGvDy4as2kmy/vua3LHWXrWTse4FClW8390h5q/e1XT+/s5lmQybjNi5MlmmCO28BZP3n/7PzNWlkfNcP7u6ScLxBftBS2FvKlwlr9PeenzQSec5B25GV/aeuFxLr+hVT7JYy7JgwpV0f/yq/6BNDLiK+rjibCsavDP2DZdNKJKtMQIe4d9B+f8XFtzVY var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>容斥原理</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4566 找相同字符]]></title>
    <url>%2F2019%2F10%2F30%2Fbzoj-4566-%E6%89%BE%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[$SAM$ . 对一个串建 $SAM$ ,把第二个串放到 $SAM$ 上去匹配. 到达一个状态 $x$ 时, $x$ 和它的所有祖先的匹配次数都会 $+1$ ,最后从下到上去更新就可以了. 匹配成功时,对每个祖先贡献为 $cnt\cdot |Right|\cdot (maxlen-minlen)​$ . 但需要注意对自己的贡献,串长不一定能取到 $maxlen$ ,需要记录当前的串长. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=4e5+10,S=26;int idx=1,lst=1,ch[MAXN][S],fa[MAXN],len[MAXN],siz[MAXN];int cnt[MAXN],f[MAXN];void Extend(int c)&#123; int p=lst,np=++idx; lst=np; siz[np]=1; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125;&#125;int t[MAXN],A[MAXN];void topsort()&#123; for(int i=1;i&lt;=idx;++i) ++t[len[i]]; for(int i=1;i&lt;=idx;++i) t[i]+=t[i-1]; for(int i=1;i&lt;=idx;++i) A[t[len[i]]--]=i; for(int i=idx;i&gt;=1;--i) siz[fa[A[i]]]+=siz[A[i]];&#125;char buf[MAXN];int n;int main()&#123; scanf("%s",buf+1); n=strlen(buf+1); for(int i=1;i&lt;=n;++i) Extend(buf[i]-'a'); topsort(); scanf("%s",buf+1); n=strlen(buf+1); int u=1,tmp=0; ll ans=0; for(int i=1;i&lt;=n;++i) &#123; int c=buf[i]-'a'; if(ch[u][c]) ++tmp,u=ch[u][c]; else &#123; while(u &amp;&amp; !ch[u][c]) u=fa[u]; if(!u) u=1,tmp=0; else tmp=len[u]+1,u=ch[u][c]; &#125; ++cnt[u]; ans+=1LL*siz[u]*(tmp-len[fa[u]]); &#125; for(int i=idx;i&gt;=1;--i) &#123; int x=A[i]; f[fa[x]]+=f[x]+cnt[x]; ans+=1LL*siz[x]*f[x]*(len[x]-len[fa[x]]); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191030]]></title>
    <url>%2F2019%2F10%2F30%2Ftest20191030%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1/GxiNcrqzEE0eyzFukRJpfIL1SwBdUWTDYbiAav4uImSGoky3BbYOyfMrfrwg2RT1r+5x8XKJu1+UPQFDl5DcRFL4pLKF9KeBy17ZRky6vzNhjmn5S8MoTIGYAc2+RiFLnNBd3Pzl2qm9MFy3tYCwMs962YZy8+qS+28B0i9zQNugx9y9ZHQWc1Kszdh45opxkdajGyvFGNASfSuZE/MEHugzLhI4cg1LqTIzQVSJTIF+qtq96uujuj3LaA7qpRU8tmljlgnedA3Ua1/MGZ1SD1avcuJG88wyqxekAaq9IXOaaG9FFC+9/HitQF3Ys6vLJZZp4TgRQb/voGr7QFcvrGDdXMT8MUbOii+JrGNr4LUxY6/hJvoQCIBuFxbcoB3rP3W2Zto/O5h1R1/LGDmKOY575D/YMp8grKH0Ty4bpIsy0QrQUCvPmMITFLyI8X+BsxppSx9j9HpxVXLrXpuBxMkY9m+I5FD+Q9XCkjxv3484kKbld+4+jtwKRq6FXWFrQWAWQyiIeX1f+pvmcHxJSvtlC4JItJ44jDcTXAmqfiYkCSAQL9cmdeju37i/02fCV/znie5at9FVEdWrFx/hqMVVJ9w8g6pf7+6sliNHU5MF7xtYlPpdTDnMXAnREqVevZcwCF/Cbvj4pJWhTdiPOSwS/jeL8okUenwjJFssbro94/k5JA8RxwtQ4hUR/dxtowVZkDem8LxpAHCRvOJ+VgxV1hasZsBZ57Rf26oqY9b24fTEpZGLCDtFyGIkbPAaQEb4XoVNpWwwV9JqSA1TZTMYQaL7dGnJRtlk/v74VU2FhkBHjvu1pa7oTI4230UHlJkuc690OWXpda/s+WW8NctpYqoEwhKzEwY/2KOoc68FcXGNmvLRrU6jwzYwMt0F5gBia7+QRsSHDEiFCpbgctvvDfbSQYwlReNpS01HSo1wZwttnIfuZe4Q4U4NGEeWeG9tHkuavR15G0GorjlgVm+9V9yZNNh30CMLO7KEBvdnrIkua8iwU/IGLSYfG3bgpmn+HM6zgEH4C+JegR5RfNSd0pRFEGjE0yHbw5HXWT+95LVC7pt8+K0F7KN8SO7JzWXSbgljH056hLvNIeMiHoRZTdjkSB6n521ZcNMXgsif+AP3xIDT8fIIceIjiuBdmBFLWlERYvIyLGeDC2/qnQR7Y0ieUeexmrm5EFyP0NF4KwXkx4Nt+VIfyNDmCa0W3Lu4Tg3Zdduth6TMOb381OkRYfhCEsY3w/KLFQuFYz/1uQqjnQzEBlTgX5sdol0VBZxeo4bJfPMPWYzgAaciwS+/RxO5HKfmss0SwL9HbUvCiiwMcwIKZIyz82A9ss7rMNvqbCKM5al87RTPYl3sKg9ylLYtwWUaVBDjesew+67tvoqw2pVOPZSw8+X7P2YnvPci5TL0THxSm40vNPnR7p4jAOOePRZA= var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>线段树</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4032 最短不公共子串]]></title>
    <url>%2F2019%2F10%2F30%2Fbzoj-4032-%E6%9C%80%E7%9F%AD%E4%B8%8D%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[$SAM$ + 子序列自动机. 对于两个串,建出它们各自的后缀自动机和子序列自动机. 对于每种询问,就将两个对应的自动机取出来,跑 $bfs$ . 某个状态 $(a,b)$ ,接受了一个字符 $c$ 后,若 $A$ 的自动机上有出边,而 $B$ 没有,则当前状态的深度 $+1$ 就是答案. 若两者都有出边,就将转移到的新的状态入队. 记忆化一下,时间复杂度 $O(n^2|S|)$ ,其中 $S$ 表示字符集大小. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=4e3+10,S=26;struct AutoMaton&#123; int ch[MAXN][S],fa[MAXN],len[MAXN],idx,lst; int st; AutoMaton()&#123;idx=lst=1;&#125; void init_seq(char *buf,int n) &#123; st=0; int cur[S]=&#123;0&#125;; for(int i=n;i&gt;=1;--i) &#123; memcpy(ch[i],cur,sizeof ch[i]); cur[buf[i]-'a']=i; &#125; memcpy(ch[0],cur,sizeof ch[0]); &#125; void Extend(int c) &#123; int p=lst,np=++idx; lst=np; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[nq]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125; void init_SAM(char *buf,int n) &#123; st=1; for(int i=1;i&lt;=n;++i) &#123; int c=buf[i]-'a'; Extend(c); &#125; &#125;&#125;A[2],B[2];struct node&#123; int a,b,dep; node(int a=0,int b=0,int dep=0):a(a),b(b),dep(dep) &#123;&#125;&#125;;queue&lt;node&gt; q;bool vis[MAXN][MAXN];int solve(const AutoMaton &amp;A,const AutoMaton &amp;B)&#123; while(!q.empty()) q.pop(); memset(vis,0,sizeof vis); q.push(node(A.st,B.st,0)); vis[A.st][B.st]=1; while(!q.empty()) &#123; node tmp=q.front(); q.pop(); int a=tmp.a,b=tmp.b; for(int i=0;i&lt;S;++i) &#123; if(A.ch[a][i] &amp;&amp; !B.ch[b][i]) return tmp.dep+1; else if(A.ch[a][i] &amp;&amp; B.ch[b][i] &amp;&amp; !vis[A.ch[a][i]][B.ch[b][i]]) &#123; q.push(node(A.ch[a][i],B.ch[b][i],tmp.dep+1)); vis[A.ch[a][i]][B.ch[b][i]]=1; &#125; &#125; &#125; return -1;&#125;char buf[MAXN];int main()&#123; scanf("%s",buf+1); int n=strlen(buf+1); A[0].init_SAM(buf,n); A[1].init_seq(buf,n); scanf("%s",buf+1); n=strlen(buf+1); B[0].init_SAM(buf,n); B[1].init_seq(buf,n); for(int i=0;i&lt;2;++i) for(int j=0;j&lt;2;++j) printf("%d\n",solve(A[i],B[j])); return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2746 旅行问题]]></title>
    <url>%2F2019%2F10%2F30%2Fbzoj-2746-%E6%97%85%E8%A1%8C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[$AC$ 自动机. 插入串的时候同时记录一下每个前缀在自动机上的编号以及 $Hash$ 值. 询问时,要求的公共后缀就是那两个前缀在 $fail$ 树上的 $LCA$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=1e6+10,S=26,K=22;int n,ch[MAXN][S],fail[MAXN],Hash[MAXN],idx=0;int fa[MAXN][K],dep[MAXN];vector&lt;int&gt; pos[MAXN];char buf[MAXN];queue&lt;int&gt; q;void getfail()&#123; for(int i=0;i&lt;S;++i) if(ch[0][i]) &#123; q.push(ch[0][i]); dep[ch[0][i]]=1; &#125; while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=0;i&lt;S;++i) if(ch[u][i]) &#123; q.push(ch[u][i]); int x=ch[u][i],y=ch[fail[u]][i]; fail[x]=fa[x][0]=y; dep[x]=dep[y]+1; for(int j=1;(1&lt;&lt;j)&lt;=dep[x];++j) fa[x][j]=fa[fa[x][j-1]][j-1]; &#125; else ch[u][i]=ch[fail[u]][i]; &#125;&#125;int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=K-1;i&gt;=0;--i) if((1&lt;&lt;i)&lt;=dep[x]-dep[y]) x=fa[x][i]; if(x==y) return x; for(int i=K-1;i&gt;=0;--i) if((1&lt;&lt;i)&lt;=dep[x] &amp;&amp; fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0]; &#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; int x=scanf("%s",buf); pos[i].push_back(0); int u=0,m=strlen(buf); for(int j=0;j&lt;m;++j) &#123; int c=buf[j]-'a'; if(!ch[u][c]) ch[u][c]=++idx; Hash[ch[u][c]]=add(mul(Hash[u],S),c); u=ch[u][c]; pos[i].push_back(u); &#125; &#125; getfail(); int m=read(); for(int i=1;i&lt;=m;++i) &#123; int x=read(),px=read(),y=read(),py=read(); px=pos[x][px],py=pos[y][py]; int pz=LCA(px,py); printf("%d\n",Hash[pz]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3991 寻宝游戏]]></title>
    <url>%2F2019%2F10%2F29%2Fbzoj-3991-%E5%AF%BB%E5%AE%9D%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[$set$ . 考虑如果已经给出了所有有宝物的点,如何计算总距离. 可以将这些点按照 $dfs$ 序排序,按照这个顺序不断去走,总距离为相邻两点距离的总和(首尾也算) . 现在需要支持加点和删点,用一个 $set$ 维护所有有宝物的点,每次更新点时也更新答案. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10,K=17;int n,m,ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN&lt;&lt;1];void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;ll dist[MAXN];int dep[MAXN],dfn[MAXN],rnk[MAXN],fa[MAXN][K],idx=0;void dfs(int u,int f)&#123; fa[u][0]=f; for(int i=1;(1&lt;&lt;i)&lt;=dep[u];++i) fa[u][i]=fa[fa[u][i-1]][i-1]; dfn[u]=++idx; rnk[idx]=u; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==f) continue; dep[v]=dep[u]+1; dist[v]=dist[u]+val[i]; dfs(v,u); &#125;&#125;int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=K-1;i&gt;=0;--i) if((1&lt;&lt;i)&lt;=dep[x]-dep[y]) x=fa[x][i]; if(x==y) return x; for(int i=K-1;i&gt;=0;--i) if((1&lt;&lt;i)&lt;=dep[x] &amp;&amp; fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;ll dis(int x,int y)&#123; int z=LCA(x,y); return dist[x]+dist[y]-2*dist[z];&#125;bool vis[MAXN];set&lt;int&gt; s;typedef set&lt;int&gt;::iterator sit;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; dfs(1,0); ll ans=0; for(int i=1;i&lt;=m;++i) &#123; int x=dfn[read()]; if(!vis[x]) // insert &#123; if(!s.empty()) &#123; sit r=s.lower_bound(x); if(r==s.end()) r=s.begin(); sit l; if(r==s.begin()) &#123; l=s.end(); --l; &#125; else &#123; l=--r; ++r; &#125; ans-=dis(rnk[*l],rnk[*r]); ans+=dis(rnk[*l],rnk[x]); ans+=dis(rnk[x],rnk[*r]); &#125; s.insert(x); &#125; else //delete &#123; s.erase(x); if(!s.empty()) &#123; sit r=s.lower_bound(x); if(r==s.end()) r=s.begin(); sit l; if(r==s.begin()) &#123; l=s.end(); --l; &#125; else &#123; l=--r; ++r; &#125; ans+=dis(rnk[*l],rnk[*r]); ans-=dis(rnk[*l],rnk[x]); ans-=dis(rnk[x],rnk[*r]); &#125; &#125; vis[x]^=1; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
        <tag>dfs序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3925 地震后的幻想乡]]></title>
    <url>%2F2019%2F10%2F28%2Fbzoj-3925-%E5%9C%B0%E9%9C%87%E5%90%8E%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%2F</url>
    <content type="text"><![CDATA[$dp$ 计数. 只需要对于每个 $k$ ,算出从小到大加入第 $k$ 条边后图仍未连通的概率 $p_k$ ,则答案为 $\frac 1 {m+1}\sum_{i=1}^m p_k$ . 设 $cnt(S)$ 表示两端都在点集 $S$ 中的边的数目. 设 $f(S,i)$ 表示点集为 $i$ ,在点集中选了 $i$ 条边,使得这个点集不连通的方案数, $g(S,i)$ 表示连通的方案数. 显然有 $f(S,i)+g(S,i)={cnt(S)\choose i}$ . 计算 $f(S,i)$ 的做法相当经典,枚举 $S$ 中包含某个定点 $p$ 所在的连通块的点集 $T$ 进行转移. 为了方便,可以规定 $p$ 表示 $S$ 中编号最小的点.$$f(S,i+j)=\sum_{T\subset S,p\in T} g(T,i)\cdot {cnt(S-T)\choose j}$$概率就是合法的方案数除以总方案数. 通过枚举子集即可做到 $O(3^n\cdot m)$ 的复杂度. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;bool in(int S,int x)&#123; return (S&gt;&gt;x)&amp;1;&#125;#define lowbit(x) x&amp;(-x)const int MAXN=10,MAXM=45+1;int n,m,cnt[1&lt;&lt;MAXN];double C[MAXM][MAXM],f[1&lt;&lt;MAXN][MAXM],g[1&lt;&lt;MAXN][MAXM];int main()&#123; n=read(),m=read(); for(int i=0;i&lt;=m;++i) C[i][0]=1; for(int i=1;i&lt;=m;++i) for(int j=1;j&lt;=i;++j) C[i][j]=C[i-1][j-1]+C[i-1][j]; for(int i=0;i&lt;m;++i) &#123; int a=read()-1,b=read()-1; for(int S=0;S&lt;(1&lt;&lt;n);++S) if(in(S,a) &amp;&amp; in(S,b)) ++cnt[S]; &#125; for(int S=1;S&lt;(1&lt;&lt;n);++S) &#123; int p=lowbit(S); for(int T=(S-1)&amp;S;T;T=(T-1)&amp;S) if(T&amp;p) for(int i=0;i&lt;=m;++i) &#123; g[T][i]=C[cnt[T]][i]-f[T][i]; if(g[T][i]) for(int j=0;i+j&lt;=m;++j) f[S][i+j]+=g[T][i]*C[cnt[S-T]][j]; &#125; &#125; double ans=0; for(int i=0;i&lt;=m;++i) ans+=f[(1&lt;&lt;n)-1][i]/C[cnt[(1&lt;&lt;n)-1]][i]; ans/=m+1; printf("%.6f\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>概率/期望</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3993 星际战争]]></title>
    <url>%2F2019%2F10%2F28%2Fbzoj-3993-%E6%98%9F%E9%99%85%E6%88%98%E4%BA%89%2F</url>
    <content type="text"><![CDATA[二分答案 + 最大流. 二分答案 $t$ ,则每个武器最多输出 $t​$ 秒,需要对这些输出进行恰当分配,可以利用网络流. 建出源点 $S$ ,汇点 $T$ , $S$ 向每个武器 $i$ 连边,流量为 $t\cdot B_i$ . 每个武器向它可以攻击的机器人连边,流量为 $\infty$ . 每个机器人 $i$ 向汇点 $T$ 连边,流量为 $A_i$ . 若最大流恰好等于所有机器人的血量之和,则说明 $t$ 秒内能将它们全部打死,否则不能. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const double eps=1e-8,inf=1e9;const int MAXN=1e3+10;int n,m,ecnt=1,head[MAXN],a[MAXN],b[MAXN],tot,G[MAXN][MAXN];double sum;struct Edge&#123; int to,nx; double flow; Edge(int to=0,int nx=0,double flow=0):to(to),nx(nx),flow(flow)&#123;&#125;&#125;E[MAXN&lt;&lt;4];void addedge(int u,int v,double val)&#123; ++ecnt; E[ecnt]=Edge(v,head[u],val); head[u]=ecnt;&#125;void ins(int u,int v,double val)&#123; addedge(u,v,val); addedge(v,u,0);&#125;int dep[MAXN],cur[MAXN];queue&lt;int&gt; q;bool bfs(int S,int T)&#123; for(int i=1;i&lt;=tot;++i) &#123; cur[i]=head[i]; dep[i]=-1; &#125; dep[S]=0; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u];i;i=E[i].nx) &#123; int v=E[i].to; if(dep[v]==-1 &amp;&amp; E[i].flow&gt;0) &#123; dep[v]=dep[u]+1; q.push(v); &#125; &#125; &#125; return dep[T]!=-1;&#125;double dfs(int u,int T,double limit)&#123; if(u==T || limit&lt;=eps) return limit; double f,flow=0; for(int &amp;i=cur[u];i;i=E[i].nx) if(E[i].flow&gt;0) &#123; int v=E[i].to; if(dep[v]==dep[u]+1 &amp;&amp; (f=dfs(v,T,min(limit,E[i].flow)))) &#123; E[i].flow-=f; E[i^1].flow+=f; flow+=f; limit-=f; &#125; if(!limit) return flow; &#125; return flow;&#125;bool check(double t)&#123; int S=n+m+1,T=n+m+2; ecnt=1; for(int i=1;i&lt;=tot;++i) head[i]=0; for(int i=1;i&lt;=m;++i) &#123; ins(S,i,t*(double)(b[i])); for(int j=1;j&lt;=n;++j) if(G[i][j]) ins(i,j+m,inf); &#125; for(int i=1;i&lt;=n;++i) ins(i+m,T,(double)a[i]); double maxflow=0; while(bfs(S,T)) maxflow+=dfs(S,T,inf); return fabs(sum-maxflow)&lt;=eps;&#125;int main()&#123; n=read(),m=read(); double L=0,R=0,res; for(int i=1;i&lt;=n;++i) R+=(a[i]=read()); sum=R; for(int i=1;i&lt;=m;++i) b[i]=read(); for(int i=1;i&lt;=m;++i) for(int j=1;j&lt;=n;++j) G[i][j]=read(); tot=n+m+2; for(int i=1;i&lt;=50;++i) &#123; double mid=(L+R)/2.0; if(check(mid)) R=mid,res=mid; else L=mid; &#125; printf("%f\n",res); return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3992 序列统计]]></title>
    <url>%2F2019%2F10%2F28%2Fbzoj-3992-%E5%BA%8F%E5%88%97%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[原根 + $NTT$ . $M$ 是奇质数,可以先求出它的一个原根 $g_M$ ,将 $S$ 中的每个元素以及 $x$ 都转化为以 $g_M$ 为底的对数. 找 $M$ 的原根时,先预处理出 $M-1$ 的每个质因数 $p_i$ . 从 $2​$ 开始枚举每个数,检验它是否为原根. 只需要对于每个 $i$ ,依次算出 $g^{(M-1)/p_i}$ ,若这些数中有 $1$ ,则 $g​$ 不是原根,否则是原根. 于是 $\prod a_i\bmod M=x$ 就变成了 $\sum a_i’\bmod (M-1)=x’$ . 利用生成函数计算,就是要求多项式 $A(x)^n \bmod x^{M-1}$ 第 $x’$ 项的系数. 系数模数是 $NTT$ 模数,由于 $m$ 比较小,用不着多项式快速幂,可以直接写倍增快速幂. 时间复杂度 $O(m\log n\log m)$ . 注意 $x$ 不可以为 $0$ ,要将集合中为 $0$ 的元素忽略掉. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3.3e4+10;const ll P=1004535809,G=3;ll add(ll a,ll b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;ll mul(ll a,ll b)&#123; ll res=a*b-(ll)((long double)a/P*b+1e-8)*P; return res&lt;0?res+P:res;&#125;ll fpow(ll a,ll b)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;ll omega[MAXN],inv[MAXN];int rev[MAXN],curn=0;void init(int n)&#123; if(curn==n) return; for(int i=0;i&lt;n;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(n&gt;&gt;1)); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; omega[l]=fpow(G,(P-1)/l); inv[l]=fpow(omega[l],P-2); &#125; curn=n;&#125;void DFT(ll *a,int n,bool invflag)&#123; init(n); for(int i=0;i&lt;n;++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=(l&gt;&gt;1); int gi=omega[l]; if(invflag) gi=inv[l]; for(ll *p=a;p!=a+n;p+=l) &#123; int g=1; for(int i=0;i&lt;m;++i) &#123; int t=mul(g,p[i+m]); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int invn=fpow(n,P-2); for(int i=0;i&lt;n;++i) a[i]=mul(a[i],invn); &#125;&#125;ll NTT_A[MAXN],NTT_B[MAXN];int n,m,x,s,gm,Log[MAXN];void NTT(ll *A,ll *B,ll *C,int lenA,int lenB)&#123; int lenC=lenA+lenB-1,n=1; while(n&lt;lenC) n&lt;&lt;=1; for(int i=0;i&lt;lenA;++i) NTT_A[i]=A[i]; for(int i=lenA;i&lt;n;++i) NTT_A[i]=0; for(int i=0;i&lt;lenB;++i) NTT_B[i]=B[i]; for(int i=lenB;i&lt;n;++i) NTT_B[i]=0; DFT(NTT_A,n,false); DFT(NTT_B,n,false); for(int i=0;i&lt;n;++i) C[i]=mul(NTT_A[i],NTT_B[i]); DFT(C,n,true); for(int i=m;i&lt;2*m;++i) &#123; C[i-m]=add(C[i-m],C[i]); C[i]=0; &#125;&#125;int fpow_m(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=res*a%m; a=a*a%m; b&gt;&gt;=1; &#125; return res;&#125;int pr[MAXN],pcnt=0;int Find_gm()&#123; int t=m-1; for(int i=2;i*i&lt;=t;++i) if(t%i==0) &#123; pr[++pcnt]=i; while(t%i==0) t/=i; &#125; if(t!=1) pr[++pcnt]=t; for(int i=2;i&lt;m;++i) &#123; bool flag=true; for(int j=1;j&lt;=pcnt &amp;&amp; flag;++j) if(fpow_m(i,(m-1)/pr[j])==1) flag=false; if(flag) return i; &#125; return -1;&#125;ll a[MAXN],b[MAXN];void fpow_poly()&#123; while(n) &#123; if(n&amp;1) NTT(b,a,b,m,m); NTT(a,a,a,m,m); n&gt;&gt;=1; &#125;&#125;int main()&#123; n=read(),m=read(),x=read(),s=read(); gm=Find_gm(); int pw=1; Log[1]=0; for(int i=1;i&lt;m-1;++i) &#123; pw=pw*gm%m; Log[pw]=i; &#125; --m; x=Log[x]; for(int i=1;i&lt;=s;++i) &#123; int k=read(); if(k) ++a[Log[k]]; &#125; b[0]=1; fpow_poly(); printf("%lld\n",b[x]); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AGC031B Reversi]]></title>
    <url>%2F2019%2F10%2F28%2FAGC031B-Reversi%2F</url>
    <content type="text"><![CDATA[$dp$ 计数. 设 $f(i)$ 表示前 $i$ 个位置的方案数. 转移时,若能找到上一个与 $i$ 颜色相同的位置 $j$ ,并且 $i,j$ 中间还有数,那么将这段染色是有贡献的. 注意此时应当加上 $f(j)$ 而不是 $f(j-1)$ ,因为 $i,j$ 同色,将 $j\sim i$ 这段染色不会影响以 $j$ 为右端点向前面染色.$$f(i)=f(i-1)+f(j)\cdot [i-j&gt;1]$$ 123456789101112131415161718192021222324252627282930313233343536373839404142//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=2e5+10;int n,f[MAXN],lst[MAXN];int main()&#123; n=read(); f[0]=1; for(int i=1;i&lt;=n;++i) &#123; f[i]=f[i-1]; int c=read(); if(lst[c] &amp;&amp; i-lst[c]&gt;1) f[i]=add(f[i],f[lst[c]]); lst[c]=i; &#125; cout&lt;&lt;f[n]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>atcoder</tag>
        <tag>dp计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Beginner Contest 144]]></title>
    <url>%2F2019%2F10%2F28%2FAtcoder-Beginner-Contest-144%2F</url>
    <content type="text"><![CDATA[被 $D$ 卡了一会. D Water Bottle分两种情况做. 第一种情况,初始的水没有达到容器体积的一半. 第二种情况,初始的水达到了容器体积的一半. 利用反三角函数求出角度. 1234567891011121314151617181920212223242526272829303132//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const double pi=acos(-1.0);int main()&#123; double a=(double)(read()),b=(double)(read()),x=(double)(read()); if(x/a/a/b&lt;0.5) &#123; double s=x/a; printf("%.10lf\n",atan(b*b/2/s)/pi*180.0); &#125; else &#123; double s=a*b-x/a; printf("%.10lf\n",atan(2*s/a/a)/pi*180.0); &#125; return 0;&#125; E Gluttony可以二分一个答案 $mx$ . 检验时,贪心去匹配,让 $a$ 最小的人去吃 $f$ 最大的食物. 限定 $a\cdot f\le mx$ ,可以算出每个人的权值至少要减少几次,判断这个总和是否超过 $k$ 即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;ll n,k,a[MAXN],f[MAXN];bool check(ll mx)&#123; ll t=k; for(int i=1;i&lt;=n;++i) &#123; int j=n+1-i; ll x=mx/f[j]; t-=max(0LL,a[i]-x); if(t&lt;0) return false; &#125; return true;&#125;int main()&#123; n=read(),k=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=1;i&lt;=n;++i) f[i]=read(); ll L=0,R=(ll)(1e12),res; sort(a+1,a+1+n); sort(f+1,f+1+n); while(L&lt;=R) &#123; ll mid=(L+R)&gt;&gt;1; if(check(mid)) res=mid,R=mid-1; else L=mid+1; &#125; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125; F Fork in the Road设 $f(i)$ 表示点 $i$ 到 $n$ 的期望步数,设 $S_i={j|(i,j)\in E }$ ,则转移有$$f(n)=0,f(i)=\frac{1}{|S_i|} \sum_{j\in S_i} f(j)$$暴力做法是枚举每条边,计算出删掉它之后的答案,时间复杂度是 $O(m^2)$ 的. 其实对于所有以 $i$ 为起点的边 $(i,j)$ ,只需要贪心删去 $f(j)$ 最大的那条边去更新答案即可. 这样只用删 $O(n)$ 次边,时间复杂度 $O(nm)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const double inf=1e18;const int MAXN=601;vector&lt;int&gt; G[MAXN];int n,m;double f[MAXN];double calc(int x)&#123; f[n]=0; for(int i=n-1;i&gt;=1;--i) &#123; f[i]=0; int siz=G[i].size(); double mx=0; for(auto j:G[i]) &#123; f[i]+=f[j]; mx=max(mx,f[j]); &#125; if(i==x &amp;&amp; siz&gt;1) --siz,f[i]-=mx; f[i]/=(double)siz; f[i]+=1; &#125; return f[1];&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); G[u].push_back(v); &#125; double ans=calc(n); for(int i=1;i&lt;n;++i) ans=min(ans,calc(i)); printf("%.10lf\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>atcoder</tag>
        <tag>二分</tag>
        <tag>贪心</tag>
        <tag>概率/期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 409]]></title>
    <url>%2F2019%2F10%2F27%2FProject-Euler-409%2F</url>
    <content type="text"><![CDATA[$dp$ 计数. 记 $p(i)=\prod_{j=2^n-i}^{2^n-1} j$ ,即不考虑胜负情况的所有合法方案. 记 $f(i)=p(i)-W(i)$ ,即先手必败的状态数,考虑如何求出 $f(i)$ . 让前 $i-1​$ 个数随便选,共有 $p(i-1)​$ 种情况,最后一个数通过恰当的选法使得所有数的异或和为 $0​$ . 考虑将不合法的情况减掉,由于不能选 $0​$ ,所以前 $i-1​$ 个数异或和为 $0​$ 时,就不合法. 由于不能选相同的元素,所以当前 $i-1​$ 个数中,有 $i-2​$ 个数异或和为 $0​$ 时,剩下一个数怎么选都不合法. 剩下的这个数有 $i-1$ 个的可能的位置,由于前面的数没有重复,所以每个位置有 $2^n-i+1$ 个可能的值. 将这两种情况减掉,得到$$f(i)=p(i-1)-f(i-1)-(i-1)\cdot (2^n-i+1) \cdot f(i-2)$$边界有 $f(1)=f(2)=0$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=1e7+10;int n=10000000,m,p[MAXN],f[MAXN];int main()&#123; m=add(fpow(2,n),P-1); p[1]=m,p[2]=mul(m,add(m,P-1)); f[1]=f[2]=0; for(int i=3;i&lt;=n;++i) &#123; f[i]=add(p[i-1],P-f[i-1]); inc(f[i],P-mul(mul(i-1,add(m+2,P-i)),f[i-2])); p[i]=mul(p[i-1],add(m+1,P-i)); &#125; cout&lt;&lt;add(p[n],P-f[n])&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>Project Euler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 638]]></title>
    <url>%2F2019%2F10%2F27%2FProject-Euler-638%2F</url>
    <content type="text"><![CDATA[算两次的思想. 一条路径的权值定义为 $k^s​$ ,其中 $s​$ 表示路径下方的面积. 设 $f(i,j)$ 表示从 $(0,0)$ 走到 $(i,j)$ 的所有路径的权值和,边界有 $f(i,0)=f(0,j)=1$ . 若上一步是从下方走过来的,面积不会变,若是从左边走过来的,面积就会加上 $i$ . 即$$f(i,j)=f(i-1,j)+f(i,j-1)\cdot k^i$$而从另一个方向上来考虑,这个面积 $s$ 也可以看做是路径右边的面积. 那么同理可以得到$$f(i,j)=f(i-1,j)\cdot k^j+f(i,j-1)$$比较两个方程,可以得出,当 $k\neq 1$ 时,$$f(i-1,j)=\frac{k^i-1}{k^j-1}\cdot f(i,j-1) \\f(i,j)=\frac{k^{i+1}-1}{k^j-1}\cdot f(i+1,j-1)$$用这个式子递归下去算,直到 $j=0$ . 当 $k=1$ 时,求的就是路径条数,即 ${i+j\choose j}$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int calc(int a,int b,int k)&#123; int res=1; if(k==1) &#123; for(int i=a+1;i&lt;=a+b;++i) res=mul(res,i); for(int i=1;i&lt;=b;++i) res=mul(res,fpow(i,P-2)); &#125; else &#123; for(int i=a+1;i&lt;=a+b;++i) res=mul(res,add(fpow(k,i),P-1)); for(int j=1;j&lt;=b;++j) res=mul(res,fpow(add(fpow(k,j),P-1),P-2)); &#125; return res;&#125;int main()&#123; int ans=0,pw=1; for(int k=1;k&lt;=7;++k) &#123; pw*=10; inc(ans,calc(pw+k,pw+k,k)); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>Project Euler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191026]]></title>
    <url>%2F2019%2F10%2F26%2Ftest20191026%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19I5Aq2PcyfRih3gtXMuTRTvhzzYjop2LRTitUCXpz+V9JxL+ce+F21wBBGF+bipvMTw+MMtXlIWtaUVdQk8pXfa6oyA4XuJ599VwR6JNOpL6fuio0jduN4LlhM+0RyNLPwtOfqWYMjYsrXf1NJLWhmihRR4guvwDk6R5XIr9UuBXk5JqQCF3nO0Elev/5tX4TB474B+JbvRx+d+oOrlc0fms7E/HGeP6zOtX2BZItW5Js8yIIo17iJLBYQPpIdW1EVwyTmxj5Ke4/2cq+enitGRIp4A2leFMGogG+Kw2DiysqqPp3skjx5B0IGL24MwrjNcmt2zZQe628jNjUH6Q2983tFk+FmCQWtglBTvPZCkuVY5E9bb5oA6q99jb88b10vyz0+hWO4jcNlGuz0prWkY5Hpp0jGyi/Q1OufXK68Pv8eSOo3d/cTAV6EiiG6pILpapsIJBwhJfrik1zOpp2OabUViUsd8h6Xp2znCnthQYgRBuLxpt+XVsjPzC06GcRy9qnmiejIApY0qvYtPxVz3mFem1frfPIH4WSwhkdiVcm4BsZIdTmiypk07xsUA7uDxm6PhLGsR7//xl4UkzsalE6DdJqHrVPCcBVNfUt4Q7qIDJNJ7ClgSKd/8ZjbyuaS//WH8ldojzbgitom5G6Ok+NmyXWlzyRN5cs7vws7qgAuGACfjhNfXLHUJHoPIzJHy4Kmgv53hySooOXlMLVnreuDMMKXNqLtADay3vKRzMbJ+o4rLaWCAXBKX2s/kBulCulHhIkHXu+PVCIGijTyGUXuxRuPmLdc3aQDnc4CCQUnfKZmsWiZP3t2nxuEKmhREk8ZOx5RC2cMX4SALi15NJEfQ1lSLXcT6G891yepORIYyaLez76MefxqVFkPYrJSNIMd2Z49IGceIBMQkDulgMPhoHziy5evHFUwgDHLGooo492yfbipfKqR6N9Qetau27YVV1moQEyh30j2jgulSF6nVGZd+ghn9Q6ivs/k/BQuFRurzdwFbov4398syExbwceh4BNIWRjg0fMegzqIcTwJFoIrCZOSjHu2UCvRw3zYJy+mSZNVV/gX6n9vM+lwIj5op8rDY26hvmVe5jU0n61v2KJsVfdrNqaQLLwdOPs/1HzeJgSidsbilIfgdAUegElT4kMGsGcI/Fv1VGTa3MOaBvnrzIG0oUyjbri5AHQsBsbmr/eU4YySN5wPmSaIj8u561xcQxxBZ4fRTEU9826l/FfrMuBs5pM7bEdsAYafWiFY9WLSx0Jgoc/X5oXK0gbcFHMs8pQEp+5mxngNnr2EWhQI8+NqppwYXUvbqiw4cgDZgH5Kv4TJIYxPhoJ/hj5D3dgWYdxe1trHAYRWHEbGYJtz1YVG/zGqSFxa3hbOsrVUB0U1Ejx1xZH/Kfgnf/YxUx3Z0A== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>二分</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1251]]></title>
    <url>%2F2019%2F10%2F25%2FCF1251%2F</url>
    <content type="text"><![CDATA[$Div.2$ A Broken Keyboard若某段连续出现这个字符 $c$ 的次数为奇数,则字符 $c$ 一定没有坏掉. 时间复杂度 $O(n)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=512;char buf[MAXN];int n,t,ans[26];void solve()&#123; scanf("%s",buf); n=strlen(buf); memset(ans,0,sizeof ans); for(int l=0,r;l&lt;n;l=r+1) &#123; r=l; while(r+1&lt;n &amp;&amp; buf[r+1]==buf[r]) ++r; if((r-l+1)&amp;1) ans[buf[l]-'a']=1; &#125; for(int i=0;i&lt;26;++i) if(ans[i]) putchar('a'+i); puts("");&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125; B Binary Palindromes由于对交换的次数不作限制,那么任意一个 $0,1$ 个数都不变的方案,都可以得到. 于是答案只与 $0,1$ 的个数,以及每个串的长度有关. 统计出 $0,1​$ 的个数后,对于每个长度确定的字符串,依次构造. 这里可以贪心来放,若串长为偶,就任意选出 $\frac {len} {2}$ 个对子放入. 若串长为奇,此时若 $0,1$ 的个数有一个为奇,就让它去作为中心的数,否则就任意选一个填在中心. 剩下的部分仍然任意选对子放入,时间复杂度 $O(n)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=51;int n,len[MAXN],cnt[2];char buf[MAXN];int solve()&#123; n=read(); cnt[0]=cnt[1]=0; for(int i=1;i&lt;=n;++i) &#123; scanf("%s",buf); len[i]=strlen(buf); for(int j=0;j&lt;len[i];++j) ++cnt[buf[j]-'0']; &#125; for(int i=1;i&lt;=n;++i) &#123; if(len[i]&amp;1) &#123; if(cnt[0]+cnt[1]==0) return i-1; else if(cnt[0]==0) --cnt[1]; else if(cnt[1]==0) --cnt[0]; else if(cnt[0]&amp;1) --cnt[0]; else --cnt[1]; &#125; len[i]&gt;&gt;=1; if((cnt[0]&gt;&gt;1)&gt;=len[i]) cnt[0]-=len[i]&lt;&lt;1; else &#123; len[i]-=cnt[0]&gt;&gt;1; cnt[0]&amp;=1; if((cnt[1]&gt;&gt;1)&gt;=len[i]) cnt[1]-=len[i]&lt;&lt;1; else return i-1; &#125; &#125; return n;&#125;int main()&#123; int T=read(); while(T--) printf("%d\n",solve()); return 0;&#125; C Minimize The Integer从前往后考虑每一位,根据数的比较方式,只需要贪心地让当前这一位尽可能的小. 注意到一个奇数往前换,如果它的前面还有奇数,则它一定会被挡住,不能来到当前的这位,偶数同理. 于是当前的这位就只能取剩下的第一个奇数或者第一个偶数. 这就是一个归并排序的过程,时间复杂度 $O(n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;char buf[MAXN];int n,pos[2][MAXN],t[2];void solve()&#123; scanf("%s",buf); n=strlen(buf); for(int i=n-1;i&gt;=0;--i) &#123; int x=buf[i]-'0'; pos[x&amp;1][++t[x&amp;1]]=x; &#125; while(t[0]+t[1]) &#123; if(!t[0]) putchar(pos[1][t[1]--]+'0'); else if(!t[1]) putchar(pos[0][t[0]--]+'0'); else if(pos[0][t[0]]&lt;pos[1][t[1]]) putchar(pos[0][t[0]--]+'0'); else putchar(pos[1][t[1]--]+'0'); &#125; puts("");&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125; D Salary Changing二分答案 $k$ ,则需要算出至少有 $\frac{n+1}{2}$ 个人的薪水 $\ge k$ 时,最小的总薪水是否 $\le s$ . 每个人的薪水区间 $[l,r]$ 要么满足 $l&gt;k$ ,要么满足 $r&lt;k$ ,要么满足 $l\le k\le r$ . 对于前两种区间,显然都选它们的左端点作为薪水. 若薪水 $\ge k$ 的人数还不够,则还要将一部分 $l\le k\le r$ 的区间选取的薪水从 $l$ 调整为 $k$ . 实现时,可以先将所有区间按照 $l,r$ 为两个关键字排序,从后往前扫一遍即可验证. 时间复杂度 $O(n\log n+n\log \max r)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;const int inf=1e9;int n,m;ll s;struct Interval&#123; int l,r; bool operator &lt; (const Interval &amp;rhs) const &#123; return l==rhs.l?r&lt;rhs.r:l&lt;rhs.l; &#125;&#125;p[MAXN];bool check(int k)&#123; ll tot=0; int cnt=0; for(int i=n;i&gt;=1;--i) &#123; if(cnt==m) &#123; tot+=p[i].l; continue; &#125; if(p[i].l&gt;k) tot+=p[i].l,++cnt; else if(p[i].r&gt;=k) tot+=k,++cnt; else tot+=p[i].l; &#125; return cnt==m &amp;&amp; tot&lt;=s;&#125;void solve()&#123; n=read(),s=read(); m=(n+1)&gt;&gt;1; for(int i=1;i&lt;=n;++i) p[i].l=read(),p[i].r=read(); sort(p+1,p+1+n); int L=1,R=inf,res; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid)) res=mid,L=mid+1; else R=mid-1; &#125; printf("%d\n",res);&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125; E Voting将所有人按照 $m_i$ 从小到大排序,依次考虑. 记录一个 $cnt$ ,表示当前已经投了票的人数,到第 $i$ 个人时,若 $n-i+cnt&lt;m_i$ ,则在 $[1,i]$ 中必须有人要投票. 用一个小根堆维护还没有投票的所有人的 $p$ ,需要投票时,就弹出堆顶,更新答案和 $cnt$ . 一个人最多只会被弹出一次,时间复杂度 $O(n\log n)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n;struct node&#123; int m,p; bool operator &lt; (const node &amp;rhs) const &#123; return m&gt;rhs.m; &#125;&#125;a[MAXN];priority_queue&lt;int&gt; q;void solve()&#123; while(!q.empty()) q.pop(); n=read(); for(int i=1;i&lt;=n;++i) a[i].m=read(),a[i].p=read(); sort(a+1,a+1+n); ll ans=0; int cnt=0; for(int i=1;i&lt;=n;++i) &#123; q.push(-a[i].p); while(cnt+(n-i)&lt;a[i].m) &#123; ++cnt; ans-=q.top(); q.pop(); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125; F Red-White Fence容易得出一个图形的周长为 $2(mx+1+w)$ ,其中 $w$ 表示使用的白色板子数目. $k$ 很小,可以直接去枚举用的红色板子的高度 $mx$ ,尝试将每个 $w$ 的方案数都算出来,加入对应贡献. 从高到低考虑每种长度的白色板子,从高度 $&lt;mx$ 的白色板子开始计算. 若这种长度只有 $1$ 块,则只能选择不加,或者加在某一边,生成函数表示为 $(1+2x)$ . 若 $&gt;1$ 块,则可以选择不加,或者加在某一边,或者两边都加,生成函数表示为 $(1+2x+x^2)=(x+1)^2$ . 那么这些生成函数之积就是 $(1+2x)^a\cdot (x+1)^{2b}$ 的形式,用二项式定理算出两个多项式,再用 $NTT$ 将它们乘起来. 最后利用维护的贡献 $O(1)$ 回答每个询问. 时间复杂度 $O(kn\log n+q)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353,G=3;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=1.8e6+10;int omega[MAXN],inv[MAXN],rev[MAXN],curn;void NTT_init(int n)&#123; if(curn==n) return; for(int i=0;i&lt;n;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((n&gt;&gt;1)*(i&amp;1)); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; omega[l]=fpow(G,(P-1)/l); inv[l]=fpow(omega[l],P-2); &#125; curn=n;&#125;void DFT(int *a,int n,bool invflag)&#123; NTT_init(n); for(int i=0;i&lt;n;++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=(l&gt;&gt;1); int gi=omega[l]; if(invflag) gi=inv[l]; for(int *p=a;p!=a+n;p+=l) &#123; int g=1; for(int i=0;i&lt;m;++i) &#123; int t=mul(g,p[i+m]); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int invn=fpow(n,P-2); for(int i=0;i&lt;n;++i) a[i]=mul(a[i],invn); &#125;&#125;int NTT_A[MAXN],NTT_B[MAXN];void NTT(int *A,int *B,int *C,int lenA,int lenB)&#123; int lenC=lenA+lenB-1,n=1; while(n&lt;lenC) n&lt;&lt;=1; for(int i=0;i&lt;lenA;++i) NTT_A[i]=A[i]; for(int i=lenA;i&lt;n;++i) NTT_A[i]=0; for(int i=0;i&lt;lenB;++i) NTT_B[i]=B[i]; for(int i=lenB;i&lt;n;++i) NTT_B[i]=0; DFT(NTT_A,n,false); DFT(NTT_B,n,false); for(int i=0;i&lt;n;++i) C[i]=mul(NTT_A[i],NTT_B[i]); DFT(C,n,true);&#125;int n,k,fac[MAXN],invfac[MAXN],pw2[MAXN];void init()&#123; int m=n&lt;&lt;1; fac[0]=pw2[0]=1; for(int i=1;i&lt;=m;++i) &#123; fac[i]=mul(fac[i-1],i); pw2[i]=mul(pw2[i-1],2); &#125; invfac[m]=fpow(fac[m],P-2); for(int i=m-1;i&gt;=0;--i) invfac[i]=mul(invfac[i+1],i+1);&#125;int binom(int M,int N)&#123; if(M&lt;N || N&lt;0 || M&lt;0) return 0; return mul(fac[M],mul(invfac[N],invfac[M-N]));&#125;int h[MAXN],ans[MAXN];int A[MAXN],B[MAXN],tmp[MAXN];void solve(int mx)&#123; int a=0,b=0; //(1+2x)^a \cdot (1+2x+x^2)^b for(int l=0,r;l&lt;n &amp;&amp; h[l]&lt;mx;l=r+1) &#123; r=l; while(r+1&lt;n &amp;&amp; h[r+1]==h[r]) ++r; if(l==r) ++a; else ++b; &#125; for(int i=0;i&lt;=a;++i) A[i]=mul(binom(a,i),pw2[i]); for(int i=0;i&lt;=2*b;++i) B[i]=binom(2*b,i); NTT(A,B,tmp,a+1,2*b+1); int len=a+2*b+1; for(int i=0;i&lt;len;++i) ans[i+1+mx]=add(ans[i+1+mx],tmp[i]);&#125;int main()&#123; n=read(),k=read(); init(); for(int i=0;i&lt;n;++i) h[i]=read(); sort(h,h+n); for(int i=0;i&lt;k;++i) &#123; int x=read(); solve(x); &#125; int q=read(); while(q--) printf("%d\n",ans[read()&gt;&gt;1]); return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
        <tag>二分</tag>
        <tag>贪心</tag>
        <tag>codeforces</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191025]]></title>
    <url>%2F2019%2F10%2F25%2Ftest20191025%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19neaviS6/8nWOzBWhZp0w41manNnK1TQttVgFvd7rO0ohd90/r8+LzDEBKebpX9MS7T66c0glPgu1NwCdzuB3ZMnWLaXcS2BVku0LTEY6Cm2LVakmdbKs7SIOi47N8tpVu70Vl5ZuYcoJpgLw4toJpunN7hyENbZ8QjHA9tifQafyVYX55qEGIao92xkC0749OSZ5Kug7LzMS47Xr+WqklkG2V9XYLoNg6BgOvnA5rJ/V97A1UwtqAcN1+vSPYGFT5DFPfgvzBgoW9dbRpLWEN8CBQ8Bu7YbKX8U+OJMvnQEjG4ND7KC0tLDcHl9eLh0oN4GgnXgrMMeB9buv6c2BDz7QXSmUDdStqHdHVYtUi4I9QMasapuHRv0mdIwrFMxb+Aepo6+yY0n2CuhI/CaX61NJNie4JfzeT4l15poFgwJ5YKG+YWgwum5dNND3cQO8d96FpMLjxCQ6yEZA9UL5QhxR7o9iZRp4TzgB1dZVkOEdbsyZL4oMgcQ1TaY4smASA8MWoB+0RYJf/yIeKbav/FOC+WVVQuVloJCM1GPELqxE800qTaxn0GwPcbuyKlQxYzw27xmyVxMC/WOoRHnGx2XItssfalwwNSXfVpeFvkh+nw2c584oc5TZrbQY+QBJsrvgyKMK31ggMg1dXFuCw0NldcpNO8x97Qe8WlSOB+LnoIvgpkKs+LvxL3vGC7B2XziXLZlAJQ3GF30Rvzy0e9Y80epAVaITx8ABRdYfdkjDMFbiiT8C7AfZkN/ujCQcOTW0fSAIXAXtkrvulb1zY0H/+wXpW/ifDVtPSp58myNmIEo/gF5xxgyyKXYg8KdwYt/7JEWvOoXXSv4CoYqn7ibCgZeR8QlpDbmiyJ3yLubyyQCAod9UMD1yDx5ycX0NShQUNzPCcP/32R/fdt+M39WksDK8NPUgfAO1deuqsqew7iXKOyBH7UzjqiDTo0uQV3oXK14uYpuWZfb0IaA5+Q1+8VUDky7t+ulJSX1RoxKAEmJ11o1uU/h8u0rSHgOHCQaI/DythJZ91gD4QBhqV5j+s4CJWXXf6zCSyfmUPtusohrt8G+lrKBnlx9L9jchWlS4R+ock6YIXhidg1FjoEGcQMRTeTnQrfhXolc6Xjzt3ir4tV4gRJ44k4nHpRMqzMND4LndOthmqsLLKiiwPBqtzBHtk7ZpzSuEK4qm1ozsj8ydMDNa8axcLghHEU1OhxuFwxR+pN8lyMfHS+mIxJQRmBmzwKIOTEzWN8X1dHaysL1A/pBeZLEXIkMwcpKjH49JI8caLcBtKFdtzLeQyGJjFmYFNen5TLSjxkFnnndEW6ClWXUc0K5bJMeFFtR+HXwXCSSstRTAIHx685BuVSX3DhmbvOmbbOvhFwPdISVtzlWySjOo9jHWOva9Y5pY2AWeMtzmjTyEOf7r7Noj8TD6E4817NrAAEFqu9jvn7V1Z6ufm+Jtgt/+MkVY/FVkmPulj3TRJQ6tNriRKJN4+AeC5PaIogMw= var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>STL</tag>
        <tag>启发式合并</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191024]]></title>
    <url>%2F2019%2F10%2F24%2Ftest20191024%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
        <tag>树状数组</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191023]]></title>
    <url>%2F2019%2F10%2F23%2Ftest20191023%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>博弈论</tag>
        <tag>STL</tag>
        <tag>test</tag>
        <tag>笛卡尔树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191022]]></title>
    <url>%2F2019%2F10%2F22%2Ftest20191022%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+Su6VPOZnjj98x0AhV4CvAoCbNZWKcbFAmRZjYpnRGXUYhUd7IZowfVMzE+f/JAaDGey86UUWrJLSInFtCzCUBsDmJT+zkBCK6uCFgW+7aebgh3eEj2ayALfBmAKJtfGHvSFBMsCYrpinArhbnyGUVL05SdHroi9/RzB2YS3ej0M+68dzRpgfq/cLC7cO/n8/LCazb2KHAibPQLQGP5/TmP9c7bkZ6VFS6yezPrGWl3XWcC/6OsGuf7191kRdpxjGocdkYAMBXhy2iDjgEwUtNXpLSoFpTvGHN0RGAajPwHJqNtR0WAu0ZdonuQmSiafYXYCKh7f+d9mhG5Mnkgpi84XUfvbuiX6odfcXZVtaRQpiQF/gsdwG3BO9qpe2wiYDh3smyov8Nw7yPZ2bzwkry49R7JQswPvTlP9XHN+DBRqoP3D3JcmUHFXbm302o21N61CjtBlINuZl1WQK7ziEAZroZFa2XdJ+DC1As4ucvA2zvgoeb3jb9JqrlBMpL2H3/KXhQ8QlbwkxEIy+INSppMhSPfLSek4q+EgVd8lYqFwYZbIFi/kqmxe0294ADgbfs/5vjQnEUCKotF+TnnhF8Z0gVof6rjDZ9jhFFjBToATltB1P9vi/Y8TqAfB3k1kZibNqZrMUeK/kb1GGe1svg/Dat2x4v1qplybOw4ek3k/afXJn4uofv6Rwn7LYdZYM4CouHo8PUKcanzA6QgsKxeNirYOcpvdm4SlAUMQFm+L7H41BL1yTXOnlcvCa6VLeJ+hdvgcpfFTikdMhUeJPMo/ghZBDglV4NcnUy7JK5ohfgqOdg2pdvXkZXw5/GeGUGPei4SimUm9qVTMO1yt99o+wj4sTm1TdXL7u5wNzGnZX5k4tH4lRlNjjXQ0PGxNK7m0Ft4LnO3GI4q1Kax3+6oz+fxhVVas37BOO8AyWyW/21pUI7SLtmkQw+FKGuGisaYSKElJQbUaPBRJ0iVdNFUhDDoovCFHsksPnBj1o8CM44YQ5sDYKNbsxRfpnuOtxEYZLjL/ys6oC2xsgbcwKkss7kvTFkx8jrFoIkusY6IugX2inm0fhF1/nVHuRpbOnnLcGN1eOqYQXkHjlCAEM2eWXHgGfP/r+KgdvHdQ5SqaCwkjS0WZOfy3bK+/tE8Uin6rc32rKa+8jLj+JLickgb72yIoRuasKLbGASuJTBee0hfS0K9QPbp0+uoNRu8hPIYB78HLC93dLJwj1PIk8gZf+X22JNdmEdEDXTqAEnKGwshq0OqJAkE3gaMF4VRJsIv/nsxpOjmsgiCDaS2NeU8Pw4r51M3GYzNKd4KW3M0KeGEOo+W43jyGWLqlDX95R7ZJ8JehdJlY+/bjBN+7iMiBp44vsyyR6NiJG2qEmXMSmmpcqHslS8MQzbC1wQBSJ3q2B+NA0JVA== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>test</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3932 任务查询系统]]></title>
    <url>%2F2019%2F10%2F21%2Fbzoj-3932-%E4%BB%BB%E5%8A%A1%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[主席树. 将每个任务视作在时刻 $S_i$ 插入,时刻 $T_i+1$ 删除. 用主席树维护每个时刻存在的所有任务,查询时在主席树上二分. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,m,val[MAXN],tot=0;struct opt&#123; int pos,c,tp; opt(int pos=0,int c=0,int tp=0):pos(pos),c(c),tp(tp) &#123;&#125; bool operator &lt; (const opt &amp;rhs) const &#123; return pos&lt;rhs.pos; &#125;&#125;p[MAXN&lt;&lt;1];int rt[MAXN],idx=0;struct node&#123; int ls,rs,cnt; ll sum;&#125;Tree[MAXN*40];#define root Tree[o]#define lson Tree[root.ls]#define rson Tree[root.rs]void upd(int &amp;o,int lst,int l,int r,int pos,int tp)&#123; o=++idx; root=Tree[lst]; root.cnt+=tp,root.sum+=1LL*tp*val[pos]; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(root.ls,Tree[lst].ls,l,mid,pos,tp); else upd(root.rs,Tree[lst].rs,mid+1,r,pos,tp);&#125;ll query(int o,int l,int r,int k)&#123; if(root.cnt&lt;=k) return root.sum; if(l==r) return 1LL*val[l]*k; int mid=(l+r)&gt;&gt;1; if(lson.cnt&gt;=k) return query(root.ls,l,mid,k); else return query(root.rs,mid+1,r,k-lson.cnt)+lson.sum;&#125;int main()&#123; m=read(),n=read(); for(int i=1;i&lt;=m;++i) &#123; int L=read(),R=read(),c=read(); val[++tot]=c; p[2*i-1]=opt(L,c,1); p[2*i]=opt(R+1,c,-1); &#125; sort(val+1,val+1+tot); tot=unique(val+1,val+1+tot)-val-1; sort(p+1,p+1+2*m); for(int i=1,j=0;i&lt;=n;++i) &#123; int tmp=rt[i-1],nxt; while(j&lt;2*m &amp;&amp; p[j+1].pos==i) &#123; ++j; p[j].c=lower_bound(val+1,val+1+tot,p[j].c)-val; upd(nxt,tmp,1,tot,p[j].c,p[j].tp); tmp=nxt; &#125; rt[i]=tmp; &#125; ll lastans=1; for(int i=1;i&lt;=n;++i) &#123; int x=read(); int k=1+(lastans*read()+read())%read(); lastans=query(rt[x],1,n,k); printf("%lld\n",lastans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3931 网络吞吐量]]></title>
    <url>%2F2019%2F10%2F21%2Fbzoj-3931-%E7%BD%91%E7%BB%9C%E5%90%9E%E5%90%90%E9%87%8F%2F</url>
    <content type="text"><![CDATA[最大流. 先跑最短路,求出可以用的边. 边没有流量限制,但点有流量限制,可以将每个点拆成入点和出点,两者间连流量为原来那个点的流量的边. 对于可以用的边 $(u,v)$ ,就将 $u$ 的入点和 $v$ 的出点连起来, $u$ 的出点和 $v$ 的入点连起来,容量均为 $\infty$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const ll INF=1e18;const int MAXN=1024,MAXM=3e5+10;int n,m,vis[MAXN];typedef pair&lt;ll,int&gt; pli;#define mp make_pairpriority_queue&lt;pli&gt; q;queue&lt;int&gt; Q;struct Graph&#123; struct Edge &#123; int u,v,w; Edge(int u=0,int v=0,int w=0):u(u),v(v),w(w) &#123;&#125; &#125;E[MAXM&lt;&lt;1]; int tot,ecnt,cur[MAXN],head[MAXN],to[MAXM&lt;&lt;1],nx[MAXM&lt;&lt;1],flow[MAXM&lt;&lt;1]; Graph()&#123;tot=0;ecnt=1;&#125; void addedge(int u,int v,int w) &#123; E[++tot]=Edge(u,v,w); ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; flow[ecnt]=w; head[u]=ecnt; &#125; void ins(int u,int v,int w) &#123; addedge(u,v,w); addedge(v,u,0); &#125; void Dijkstra(ll *dis,int S) &#123; for(int i=1;i&lt;=n;++i) dis[i]=INF,vis[i]=0; dis[S]=0; q.push(mp(-dis[S],S)); while(!q.empty()) &#123; int u=(q.top()).second; q.pop(); if(vis[u]) continue; vis[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(dis[v]-dis[u]&gt;flow[i]) &#123; dis[v]=dis[u]+flow[i]; q.push(mp(-dis[v],v)); &#125; &#125; &#125; &#125; int dep[MAXN]; bool bfs(int S,int T) &#123; for(int i=1;i&lt;=2*n;++i) dep[i]=-1,cur[i]=head[i]; dep[S]=0; Q.push(S); while(!Q.empty()) &#123; int u=Q.front(); Q.pop(); for(int i=head[u];i;i=nx[i]) if(flow[i]&gt;0) &#123; int v=to[i]; if(dep[v]==-1) &#123; dep[v]=dep[u]+1; Q.push(v); &#125; &#125; &#125; return dep[T]!=-1; &#125; ll dfs(int u,int T,int limit) &#123; if(u==T || !limit) return limit; int f,Flow=0; for(int &amp;i=cur[u];i;i=nx[i]) &#123; int v=to[i]; if(dep[v]==dep[u]+1 &amp;&amp; (f=dfs(v,T,min(limit,flow[i])))) &#123; Flow+=f; limit-=f; flow[i]-=f; flow[i^1]+=f; if(!limit) break; &#125; &#125; return Flow; &#125; ll Maxflow(int S,int T) &#123; ll res=0; while(bfs(S,T)) res+=dfs(S,T,inf); return res; &#125;&#125;G1,G2;ll ds[MAXN],dt[MAXN];int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(),w=read(); G1.addedge(u,v,w); G1.addedge(v,u,w); &#125; G1.Dijkstra(ds,1); G1.Dijkstra(dt,n); int S=1,T=n+n; for(int i=1;i&lt;=n;++i) &#123; int c=read(); G2.ins(i+n,i,c); G2.ins(i,i+n,c); &#125; for(int i=1;i&lt;=2*m;++i) &#123; int u=G1.E[i].u,v=G1.E[i].v,w=G1.E[i].w; if(ds[u]+w+dt[v]==ds[n]) G2.ins(u,v+n,inf); &#125; ll ans=G2.Maxflow(S,T); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191021]]></title>
    <url>%2F2019%2F10%2F21%2Ftest20191021%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1/HD0xmqEHTLmWEW6Qt3/z5IZFjtkMIYo6HW+k/v7B1IRjOEkUS1xK9bKx9tFb+Pcdwq9F6GQ+4mz19SEOAlR21VLrfFcHo03T4vumCSLm7F/xaC8+a1TFBfP0IG2ssAu5eqcPJbVmPcaet27sVBS0iLbaLernBFRl8uZHNC7toubEXBQwEFExGVQgbpChAcRblGSKSJc5iUoRbl2KikomZ2cCv/Cjb/FF6phji/5Mdl2uP4voL3kXHzHesY/JzOF3zugl9t8huCEZmfOpPc5F+hYq6vhwyKM3m6Jjk2ZZB9g/AH3ji8AOgcCKf+yF+zYzJcrtFpV1WvWKKZz7lTggK3TtgspOc0SEv19w8xRsOTW2yOyjYdiCjXvZsK7UBrixDgYVjYjOG0pnd05FOSoJhgRt3jdV2C3rgegXEnLm6Ho7QREdItuqzGQWeUBQtdE1mgV2SFIs6ES596kQg1yqf4D4m8ecJoSYSGSs80D9EUkAoDrP654ICoe8HqbOO/vD5hHHrmM7Fnd+G8ynlBocfCo5f05FRFefkP53xcTNSMDf62ZlQ1gSclyBVGrSkTlOeHGP9JcXWQLF3uYh+XUnCh7r+Nu6oKYhqYUqiznQ8dseFcYB6cl2JljQLRG4tFCzt9Z2hyXLFtlRkBKrvi8Wb1/yFxmw4fX+mSJKIiAWVZV+e5RCNyc4Z0sIkG+bmE+fnsW5CUcyo2y4eBjHYVrju24IAket/SjBGdiIMcua4cJbpKeCz4jlhxnO3tlSIc56mRhIBxQFrcX4VIQV93+YN1nJgpeiYoVKo4gBtnNGpwNGfBddhtUrdD4K1WDlCfTXy/WdYpmraUy15z3Xkbif5JgZPHRK1eCJYCNpRcCSeLZDXkjOr70vlqQZbacG8e3FMA+MHiP15LV0650fy97/Sf6KxA67kYwslEeVf2E6orQION/W92T/Z1FGsjU+/joNhQIFEKfiLXmBrEy/tn2R5oZYrn40IFKjcxpEGmFKn0k5TpC7o+1c/D47aHCRsiWaOwXpO6rFHqm4GezPDnGRGu5YkrsUFtBtkn3ce/Gq/3Mrymnj2HO5X7bNaI3Qca6YJC5OkESMpdMsYGrNW6WWNLzsNs4AT+Zm5YFKy/iIoYWru4mxnkj8cnrl7PSgdmfvnXgAjeYIkZ2pksEGTkhOezksJkZw/QI6twTeAQ1Er5Z/o7QeauDKKkDrnkeA84v5WAQaFNzEBgrJkJmFL1N3pcx1Z85LaOKUPsflJSP7uFCeNKZ/QHzhMkZHIom6yTzwkaw6yWns1zqjPdzER75T0u34F7QrnoIKSwJxUWnlw/OYyxWXn4NKPBCkVQDHYMh7mRJolwtlBH4tzsrI7kTQlUjfNAtmCptqRS2nqQjLhqCtrIllIQCxYeDBQU4JOm0VTMtsOHnpZm6U1EJ6YcRsW6X0unxxZeyLvcHFAiCHAhVfWtt2awfg7QTRUEn/hPjj+dZLFFnjxuIDOdKEMeqOKESoF+FP3XUvQd/80l63oWO8for9OIBU+vwxRVKyg/0DOQDmIb5g9wlrco+WaM8SoS3nmYzQJkjK/bXC/m7nw8LPfAKvnp9F6Z6p7x7FvT2xxyBJJ/MlYid11SM+oR7pgs2OcURsG3EOrUwVvE6iMOrtE7VHHcS53e8VwugNiXkdtO4ZAUaJbHI+YXnki4dk2c/+UzAnL4M1nmAZue9iI0jEf68qCm8RWj17C79zXBHNMefaSX60DZKQdL5gModehHKuBxoHGFDpS2Dp5eHwNKwJHzA9vijxrfUCry915auF0Uhx6XXTmKfx3nueo6beF7+zBIflAabSlQqa/mwA2ovKgcM6Z/lyJkhvPm1UodWhRb6wYINCOT4aGpRsMeHQ7YyDunoCzUZeZ/89zdFiODHtAalPkCnIvR/THBdAIIOUz5GnYZDH+1tPhc1/m/5XanOv8Y3rTpWlUGwj6KGij2CqPUXrSiuzZD3zgLnqSdGYTEx0B0z6s5JIgzCB+bBNHaPAFhDhs4rp5z9SY4pv0mNFR+RCqu/IbNpq78UAvJLcGqXuD1SLCbZDlj/IzNmgMv7TilChTJds5cNX4DLnQaU66lm2TB48gC7fUZaBcokEvfo4Ebo10t4TFzJwEEqyHmC1n2nippkxe/MGjR1fa2wIwMTiWN1r+aDPPT9uDiiHmy62kEbO/VMqERjsvdZo3cc9c6QjFWQn/RdRHt6NveSKdSPHE/uORORjA7kGwAU9yrVT7XtUyBZwH47ypTDRLCnocdhYszSI/2RsOwMh//qxRrs7RnRVQmrh15DrPgabP6SuTnIWP+w8FvmNFkOjOxgj/TWU8BxhteE1PXEvupwW64aCODHjsgJWnhpksfkQIyokRyNitsyBcHo2e7cJfXFDf6LekFNFhTP34we0/Lu32RYAN4jOvokPJ22PRctFbeTgojD+oruqHsHHbKb0LYzYMqoiHvnCWzw3SVGLqZIitiytzzVROOxX6E74z/EdupaM5R1ePWOM4jWQSRQGxnJyo0ABi3pLxkVYFKCadn5mgXGgSlcJKTNZqWMJeFGhvxq5zB6NVsPPD6csso3YlVW6CgHGzT31ryYuxyeNTopCh2X4E/qgDocyPOOlvJlLg7Kq+7jGUyfOxscxWWgyryox8BcBH/b2gKzdWxEDrlW2aL3Nxhix61yqGNPEviquB4/rrb/dlXA== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>线段树</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3930 选数]]></title>
    <url>%2F2019%2F10%2F20%2Fbzoj-3930-%E9%80%89%E6%95%B0%2F</url>
    <content type="text"><![CDATA[$\gcd$ 的性质. 首先可以转化为在 $[\lceil \frac L k\rceil,\lfloor \frac R k\rfloor]$ 中取出 $n$ 个数,满足它们的 $\gcd$ 为 $1$ . 接下来的 $L,R$ 都是转化后的. 若取的 $n$ 个数不完全相同,那么它们的 $\gcd$ 一定会 $\le R-L$ . 计算出 $f(i)$ 表示取出 $n$ 个数,它们的 $\gcd$ 是 $i$ 的倍数的方案数,这个 $i$ 只用枚举到 $R-L$ . 再从大到小将 $f(2i),f(3i)\dots$ 减掉,得到的 $f(i)$ 就表示 $\gcd$ 恰好是 $i$ 的方案数了. 时间复杂度 $O((R-L+1)\cdot \log (R-L+1))$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=1e5+10;int n,k,l,r;int f[MAXN];int main()&#123; n=read(),k=read(),l=read(),r=read(); l+=k-1,l/=k,r/=k; for(int i=1;i&lt;=r-l;++i) &#123; int x=r/i-(l-1)/i; f[i]=add(fpow(x,n),P-x); &#125; for(int i=r-l;i&gt;=1;--i) &#123; for(int j=2*i;j&lt;=r-l;j+=i) f[i]=add(f[i],P-f[j]); &#125; if(l==1) f[1]=add(f[1],1); cout&lt;&lt;f[1]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4036 按位或]]></title>
    <url>%2F2019%2F10%2F20%2Fbzoj-4036-%E6%8C%89%E4%BD%8D%E6%88%96%2F</url>
    <content type="text"><![CDATA[min-max 容斥. 记 $\max(S)$ 表示集合 $S$ 中的位置全部变成 $1$ 的期望次数,即每一位变成 $1$ 的期望次数的最大值. $\min(S)$ 表示集合 $S$ 中至少有一个位置变成 $1$ 的期望次数,即每一位变成 $1$ 的期望次数的最小值. 记 $U$ 为全集. 则根据 min-max 容斥,有$$ans=\max(U)=\sum_{S\neq \emptyset} (-1)^{|S|-1}\cdot \min(S)$$ 考虑 $S$ 中每个元素对 $\min(S)$ 的贡献,有$$\min(S)=\frac{1}{\sum_{T\cap S= \emptyset}p(T)}$$其中 $p(T)$ 表示每次选中 $T$ 中某个元素的概率. 而$$\sum_{T\cap S= \emptyset}p(T)=1-\sum_{T\subseteq(U-S)} p(T)$$暴力预处理每个集合的所有子集贡献之和是 $O(3^n)$ 的. 利用 ​$\rm FWT$ 处理,时间复杂度优化到 $O(n\cdot 2^n)$ . 注意判断无解的情况. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const double eps=1e-6;#define lowbit(x) (x&amp;(-x))const int MAXN=20;int n,conf[1&lt;&lt;MAXN];double p[1&lt;&lt;MAXN];int main()&#123; n=read(); int U=0; for(int i=0; i&lt;(1&lt;&lt;n); ++i) &#123; scanf("%lf",&amp;p[i]); if(p[i]&gt;eps) U|=i; &#125; if(U!=(1&lt;&lt;n)-1) return puts("INF")&amp;0; conf[0]=-1; for(int i=1; i&lt;(1&lt;&lt;n); ++i) conf[i]=-conf[i-lowbit(i)]; for(int i=1; i&lt;(1&lt;&lt;n); i&lt;&lt;=1) //FWT or &#123; for(int j=0; j&lt;(1&lt;&lt;n); j+=(i&lt;&lt;1)) for(int k=j; k&lt;j+i; ++k) p[k+i]+=p[k]; &#125; double ans=0; for(int i=0; i&lt;(1&lt;&lt;n); ++i) &#123; double tmp=1-p[U^i]; if(tmp&gt;eps) tmp=1/tmp; else tmp=0; ans+=tmp*(double)conf[i]; &#125; printf("%.10lf\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>min-max 容斥</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[min-max 容斥学习笔记]]></title>
    <url>%2F2019%2F10%2F20%2Fmin-max%E5%AE%B9%E6%96%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[$$\max(S)=\sum_{T\subseteq S,T\neq \emptyset} (-1)^{|T|-1}\cdot \min(T) \\\min(S)=\sum_{T\subseteq S,T\neq \emptyset} (-1)^{|T|-1}\cdot \max(T)$$ 其中 $\min(S)$ 表示非空集合 $S$ 中元素的最小值, $\max(S)$ 表示非空集合 $S$ 中元素的最大值. 只用证第一个等式,将所有元素取反即可得到第二个等式. 假设这个容斥系数是 $f(|T|)$ ,则需要证明 $f(x)=(-1)^{x-1}​$ . 考虑集合 $S$ 中第 $x+1​$ 大的元素,它对等式左右两边的贡献应当是相等的.$$[x=0]=\sum_{i=0}^{x}{x\choose i}\cdot f(i+1)$$对这个等式二项式反演.$$\begin{aligned}f(x+1)&amp;=\sum_{i=0}^x(-1)^{x-i}{x\choose i}\cdot [i=0]\\&amp;=(-1)^x\end{aligned}$$得证. 这个式子对于概率/期望同样成立,常用于将期望中的 $\max$ 转化为 $\min​$ 进行处理.]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>min-max 容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191020]]></title>
    <url>%2F2019%2F10%2F20%2Ftest20191020%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+a5V+VtQv53A/DHu4LPWPoH2Uw+UsrC15fCm5Oqmo97t57reswVy6v3V0YSfNz5N+qHr18VF8RAYiIphJa15uSQ7xwXQ52F1iL5flkeqljvUQmAtXG0k5RsC0UABxILuJD4Fn8gbnHlSzaL0q3C/ztc2Sn9cHRmf4IiB2Qo8rsvlHq02MHmguuk2mVe5jsgwzfNNPLAUanvWsOOLu4b/cCDGfb7+JINjWpB5Z0pJk7Svhqqj6jC0zUihbDIBicdDav+BVh6a/2wVcLklbzTeElXALOMbEygfFcAdDkMQxwld5qQYConsmpIepfxjH84pJtjaMzlKJeuBKtxi4E6VRUYaeSSeMaa0/+47we6xLU99UnB1bfx6t+X3p/sV7nTogs8tIi8z4bmvIfK6SGUOE0X7bls4QklbVqykLLNWMsHcX+fZavWSg9qtiNVlgjVk0Mb9OermDGcqCqHweqOPP9+TWyS5mRioegM17ZW0FoXyVXBUTwyFr/iVwlCpWXwpTbdr0wAnC1UfLTLUVrnqcHgER5DNOLJexNl/d9iV0P04Vy5iCD1SdT0jSpxpYM6uJrJVnlBwTfyiC5pVLt60b5/vUy1xURGmgyuTkzvjeLZDbZRGBdyJzeKW7XXRDX5ss5b+mQJKPKm7KGe13Pv1nsq7/P/YtjwdBGdjjbl07vwtTB3LOu4V2Divdm3vl8MmLDWsdjNU1yDVnamFDvtUykyLFQHl0gcfzggRfnVnNUd5P5ajDzvVPaVULJaMrQQtx/n80yX4y3bj2Hh2C7lydFsXfn1xreoB7ltB/Qn0byz0LjxZhn45QXhTIYxJcfeZEDzsmhGgbwo8EZVRNesvaaHxJn1eTHe1rgADtX0ceernWvTN004PvNFUjCDFuMFydOBHRJAMRXC2G/NpDho+W1EgIZ7Qp5CKd/Eu1oje2A/QDoLfj25ihygSl81fYryfv6MA7JxVnBTrxD6VZbnPiLLtsxbSCKjjaVzNMkemEdZhKFK/7L+8f32eQfh1LhYuzdZP//OCDgPXieXdbO6LXH012DpQ3P2mbdv74PI7Eblf1Q6EblFI9KfwtFYYp9pVl9T8WrHW7MjDVIQ3zsArPfnDu14/4MDGHvULZ64nAfhHJfZXnCkCqbKgJk5ijhkjRfSUSuRlVdd5cvccEb58WyTRR9kxs4jSCn/kCkyMOIQOqIWoNORqIQEZz16IPb8YW6xn+wzIq1Mx7yYcZbXsNthN5ynAt40h/zoYKLNuDOxJiXlvf8pz7D+IDmCzPhP5e0g0l6pp1M6z/I1BAeFKT9o6gw1YAXkbzFIrvUu7ptM+znCeRrjZHoDnhm4gaDkXQD5cGDtNeLpAP2wcb6r21p+n2V1Vr2JvxTOvrmbJriCBn+MmOx0poaeO2tqWyplTyVLYT9qm5FhvF0oPpSINFrBKzHZyrHI4KmSOpC2wLo9PDctjZ40kWLP1Ww04wasXNXGrkrSYO9ePWWtqo4rRSwz5OEUgDRjwej8HGSTswPxEPtkeL9yuuIxkajcm2ZaXJEaeZPfPd2hvp0ctjqfuK7newa+RO8TvVF+D8tw6j5CAyycSBaBWA5jqa+UaJV09dTLUEFmAzWWvHxfwiUzFuII5oY5sj/EV855nt0EM4EZCrRRthgEhJdEh76EJjetew2cOlqprRYy6BF7EyrVr2TpTnxPkrXh/vTzr36HGs+s+2aO5cGt0oETtDoC4+qNapuOdvG/+sETGXa46VeEsEgN8Vd5shh+UYSjhPlv/ATiuvPPApZspdsvQq0qg8w1ASvIIvyulCF4w== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>STL</tag>
        <tag>矩阵加速</tag>
        <tag>打表</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3884 上帝与集合的正确用法]]></title>
    <url>%2F2019%2F10%2F19%2Fbzoj-3884-%E4%B8%8A%E5%B8%9D%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[拓展欧拉定理. 拓展欧拉定理 $a^b\equiv a^{b\bmod \varphi(p)+\varphi(p)} \bmod p$ ,并不要求 $b$ 与 $p$ 互质. 则 $2^{2^{2^{\dots}}}\equiv (2)^{2^{2^{2^{\dots}}}}\equiv (2)^{2^{2^{2^{\dots}}}\bmod \varphi(p)+\varphi(p)}\bmod p$ . 求出 $\varphi(p)$ 后递归求解,边界是当 $p=1$ 时,答案为 $0$ . 打表发现,对于 $10^7$ 之内的任何 $p$ ,最多递归 $3$ 次后就会变成 $1$ ,这样做速度是有保证的. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e7+1;int mul(int a,int b,int P)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b,int P)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a,P); a=mul(a,a,P); b&gt;&gt;=1; &#125; return res;&#125;int getphi(int x)&#123; int res=x; for(int i=2;i*i&lt;=x;++i) if(x%i==0) &#123; res/=i; res*=(i-1); while(x%i==0) x/=i; &#125; if(x!=1) res/=x,res*=(x-1); return res;&#125;int calc(int p)&#123; if(p==1) return 0; int x=getphi(p); return fpow(2,calc(x)+x,p);&#125;/*int prime[MAXN],cnt=0,phi[MAXN],f[MAXN],ism[MAXN];void init(int n)&#123; int ans=0; f[1]=0; phi[1]=ism[1]=1; for(int i=2;i&lt;=n;++i) &#123; f[i]=f[phi[i]]+1; ans=max(ans,f[i]); if(!ism[i]) &#123; prime[++cnt]=i; phi[i]=i-1; &#125; for(int j=1;j&lt;=cnt &amp;&amp; n/i&gt;=prime[j];++j) &#123; int x=prime[j]*i; if(i%prime[j]==0) &#123; phi[x]=phi[i]*prime[j]; break; &#125; phi[x]=phi[i]*(j-1); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;*/int main()&#123;// init(MAXN-1); int T=read(); while(T--) &#123; int p=read(); int ans=calc(p); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4001 概率论]]></title>
    <url>%2F2019%2F10%2F18%2Fbzoj-4001-%E6%A6%82%E7%8E%87%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[小水题. 感觉和那次考试的题差不多啊. 答案等于所有情况的叶子数目之和 除以 不同构的二叉树数目. 后者显然是卡特兰数 $C_n$ . 前者的计算也很简单,考虑有 $n-1$ 个点的时候,剩下的一个点可以有 $n$ 个位置插入作为叶子. 于是答案为$$ans=\frac{nC_{n-1}}{C_n}=\frac{n(n+1)}{2(2n-1)}$$ 1234567891011121314151617181920212223//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int main()&#123; double n=(double)read(); double ans=n*(n+1)/2/(2*n-1); printf("%.9lf\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4066 简单题]]></title>
    <url>%2F2019%2F10%2F18%2Fbzoj-4066-%E7%AE%80%E5%8D%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[$kd$ 树 + 定期重构. 由于这道题强制在线 + 卡空间,其它时间效率上比较优秀的二维数点方法不太适用. 利用 $kd$ 树维护所有点, $kd​$ 树的本质是高维的二叉搜索树,所以插入的时候就在上面选方向走. 需要定期重构保证树的形态平衡一些,也可以像替罪羊树一样,维护一个因子判断是否需要重构. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=2e5+10;int n,lastans,D;struct node&#123; int ch[2],v[2],mx[2],mi[2]; node() &#123; ch[0]=ch[1]=0,mx[0]=mx[1]=-inf,mi[0]=mi[1]=inf; val=sum=0; &#125; bool operator &lt; (const node &amp;rhs) const &#123; return v[D]==rhs.v[D]?v[D^1]&lt;rhs.v[D^1]:v[D]&lt;rhs.v[D]; &#125; int val,sum;&#125; Tree[MAXN];#define root Tree[o]#define lson Tree[root.ch[0]]#define rson Tree[root.ch[1]]void pushup(int o)&#123; root.sum=lson.sum+rson.sum+root.val; for(int i=0; i&lt;2; ++i) &#123; root.mx[i]=max(root.mx[i],max(lson.mx[i],rson.mx[i])); root.mi[i]=min(root.mi[i],min(lson.mi[i],rson.mi[i])); &#125;&#125;int xl,xr,yl,yr;void ins(int o,int d)&#123; int k=Tree[n].v[d]&gt;root.v[d]; if(root.ch[k]) ins(root.ch[k],d^1); else root.ch[k]=n; pushup(o);&#125;int BuildTree(int l,int r,int d)&#123; D=d; int mid=(l+r)&gt;&gt;1; int o=mid; nth_element(Tree+l,Tree+mid,Tree+r+1); for(int i=0;i&lt;2;++i) root.mx[i]=root.mi[i]=root.v[i]; if(l&lt;=mid-1) root.ch[0]=BuildTree(l,mid-1,d^1); else root.ch[0]=0; if(mid+1&lt;=r) root.ch[1]=BuildTree(mid+1,r,d^1); else root.ch[1]=0; pushup(o); return o;&#125;bool check(int o)&#123; if(!o || root.mx[0]&lt;xl || root.mi[0]&gt;xr || root.mx[1]&lt;yl || root.mi[1]&gt;yr) return 0; return 1;&#125;int query(int o)&#123; if(xl&lt;=root.mi[0] &amp;&amp; root.mx[0]&lt;=xr &amp;&amp; yl&lt;=root.mi[1] &amp;&amp; root.mx[1]&lt;=yr) return root.sum; int res=0; if(xl&lt;=root.v[0] &amp;&amp; root.v[0]&lt;=xr &amp;&amp; yl&lt;=root.v[1] &amp;&amp; root.v[1]&lt;=yr) res+=root.val; if(check(root.ch[0])) res+=query(root.ch[0]); if(check(root.ch[1])) res+=query(root.ch[1]); return res;&#125;int main()&#123; read(); int rt=0; while("RLDAKIOI") &#123; int tp=read(); if(tp==1) &#123; ++n; Tree[n].v[0]=Tree[n].mx[0]=Tree[n].mi[0]=read()^lastans; Tree[n].v[1]=Tree[n].mx[1]=Tree[n].mi[1]=read()^lastans; Tree[n].val=Tree[n].sum=read()^lastans; if(n==1) rt=n; else ins(rt,0); if(n%5000==0) rt=BuildTree(1,n,0); &#125; else if(tp==2) &#123; xl=read()^lastans; yl=read()^lastans; xr=read()^lastans; yr=read()^lastans; if(check(rt)) lastans=query(rt); else lastans=0; printf("%d\n",lastans); &#125; else if(tp==3) break; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>kdtree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4031 小Z的房间]]></title>
    <url>%2F2019%2F10%2F18%2Fbzoj-4031-%E5%B0%8FZ%E7%9A%84%E6%88%BF%E9%97%B4%2F</url>
    <content type="text"><![CDATA[矩阵树定理. 把每个房间看成一个点,每堵可以打的墙看成一条边,不难发现就是要求这张无向图的生成树个数. 使用矩阵树定理计算,但模数不是质数,需要用辗转相除法来消元. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=100;int n=0,a[MAXN][MAXN],id[MAXN][MAXN];void addrow(int x,int y,int k)&#123; for(int i=1;i&lt;=n;++i) inc(a[x][i],mul(a[y][i],k));&#125;int ans=1;void Euclid(int x,int y)//最后使x不为0,y为0 &#123; if(!a[y][x]) return; else if(!a[x][x]) &#123; swap(a[x],a[y]); ans=add(P,-ans); return; &#125; if(a[x][x]&gt;a[y][x]) addrow(x,y,P-a[x][x]/a[y][x]); else addrow(y,x,P-a[y][x]/a[x][x]); Euclid(x,y);&#125;void Det()&#123; for(int i=1;i&lt;=n;++i) &#123; for(int j=i+1;j&lt;=n;++j) Euclid(i,j); ans=mul(ans,a[i][i]); if(!ans) return; &#125; &#125;int N,M;char buf[MAXN];int main()&#123; N=read(),M=read(); for(int i=1;i&lt;=N;++i) &#123; scanf("%s",buf+1); for(int j=1;j&lt;=M;++j) if(buf[j]=='.') &#123; id[i][j]=++n; if(id[i-1][j]) &#123; int x=id[i-1][j],y=id[i][j]; a[x][y]=a[y][x]=P-1; ++a[x][x],++a[y][y]; &#125; if(id[i][j-1]) &#123; int x=id[i][j-1],y=id[i][j]; a[x][y]=a[y][x]=P-1; ++a[x][x],++a[y][y]; &#125; &#125; &#125; --n; Det(); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>高斯消元</tag>
        <tag>矩阵树定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1236]]></title>
    <url>%2F2019%2F10%2F18%2FCF1236%2F</url>
    <content type="text"><![CDATA[$Div.2$ A Stones贪心地拿,先拿 $b,c$ 组合的,不能拿时再拿 $a,b$ 组合. B Alice and the List of Presents显然答案为 $(2^m-1)^n$ . C Labs进行 $n$ 轮填数,第 $i$ 轮将 $(i-1)\cdot n+1\sim i\cdot n$ 这 $n$ 个数分配给 $n$ 组. 每轮中,若给某组填入该轮的第 $x$ 个数,则该组的 $sum$ 加上 $x$ . 每轮填数前将所有组按照 $sum$ 从大到小排序,依次从小到大填入 $n$ 个数. D Alice and the Doll模拟走的过程,只有撞上障碍点或者边界时才拐弯. 用 $set$ 将所有障碍点和边界存下来,每次根据当前方向,二分出下个拐弯的位置,走的时候记录访问过的格子数目. 若某个时刻,走过的格子数目达到了 $n\cdot m-k$ ,就说明找到了一组合法解. E Alice and the Unfair Game可以发现,以某个确定的起点出发,可能的终点一定是一段连续的区间. 只需要找出这段区间的左,右端点. 若能向左走,就走,否则留在原地,可以找出左端点,同理可找出右端点,但这样暴力找是 $O(n^2)$ 的. 考虑遍历数组 $a$ ,当前的第一个元素只会对某个位置的起点有影响,将它们全部移开. 若当前在找左端点,就移到右边,否则移到左边,用并查集实现. 需要特判 $n=1$ 以及 $a_i=1$ 或 $a_i=n$ 的情况. F Alice and the Cactus对于一棵仙人掌,每个点最多在一个环上,删掉某些点后,每个点仍然在最多一个环上. 记点数为 $a$ ,边数为 $b$ ,环的数目为 $c$ ,于是连通块数目 $X=a-b+c$ . 方差可以看做 $E(X^2)-E(X)^2$ ,而 $X^2$ 可以拆成 $a^2+b^2+c^2-2ab-2bc+2ac$ . 根据期望的线性性,答案为$$E(a^2)+E(b^2)+E(c^2)-E(2ab)-E(2bc)+2E(ac)-(E(a)+E(b)-E(c))^2$$把这 $9​$ 种情况的贡献都统计进去,需要计算逆元,时间复杂度 $O(n\log P)​$ .]]></content>
      <tags>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1237]]></title>
    <url>%2F2019%2F10%2F17%2FCF1237%2F</url>
    <content type="text"><![CDATA[$Global\ Round\ 5$ A Balanced Rating Changes只需要保证向上取整的次数和向下取整的次数相同就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int n,t=0,sum=0;int trans(double x,bool f)&#123; int k=x&lt;0?-1:1; f^=(x&lt;0); x=fabs(x); return (f?k*floor(x):k*ceil(x));&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; int x=read(); if(x%2==0) &#123; printf("%d\n",x&gt;&gt;1); continue; &#125; if(t) &#123; printf("%d\n",trans((double)(x)/2.0,0)); --t; &#125; else &#123; printf("%d\n",trans((double)(x)/2.0,1)); ++t; &#125; &#125; return 0;&#125; B Balanced Tunnel按照进入的顺序依次遍历,判断一下有没有先进入的车在它之后出去. 123456789101112131415161718192021222324252627282930313233343536373839//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,a[MAXN],pos[MAXN];int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=1;i&lt;=n;++i) &#123; int x=read(); pos[x]=i; &#125; int mx=0,ans=0; for(int i=1;i&lt;=n;++i) &#123; int x=a[i]; if(mx&gt;pos[x]) ++ans; mx=max(mx,pos[x]); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; C Balanced Removals把所有点以 $x,y,z$ 坐标分别为第一,二,三关键字排序. 构造方案时,对于 $x$ 坐标相同的一段,递归进去通过比较 $y,z$ ,将它们删到只剩一个点或者没有点. 于是剩下所有点的 $x$ 都互不相同,从前往后,相邻的作为一对删掉即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e4+10;struct node&#123; int v[3],id; bool operator &lt; (const node &amp;rhs) const &#123; for(int i=0;i&lt;3;++i) if(v[i]!=rhs.v[i]) return v[i]&lt;rhs.v[i]; return false; &#125;&#125;p[MAXN];int solve(int L,int R,int k)&#123; if(L==R) return p[L].id; int head=L,cur=0; for(int i=L;i&lt;=R+1;++i) &#123; if(i==R+1 || p[i].v[k]!=p[head].v[k]) &#123; int x=solve(head,i-1,k+1); if(x &amp;&amp; !cur) cur=x; else if(x &amp;&amp; cur) &#123; printf("%d %d\n",cur,x); cur=0; &#125; head=i; &#125; &#125; return cur;&#125;int main()&#123; int n=read(); for(int i=1;i&lt;=n;++i) &#123; p[i].id=i; for(int j=0;j&lt;3;++j) p[i].v[j]=read(); &#125; sort(p+1,p+1+n); solve(1,n,0); return 0;&#125; D Balanced Playlist可以将链复制两份,接在后面. 复制两份而不是一份,是为了方便判断答案为无穷大的情况. 只考虑这 $3n$ 个点,若某个点答案 $&gt;2n$ ,则实际答案一定为无穷大,否则就是该答案. 考虑第 $i$ 个点对前面哪些点有贡献,这可以在线段树上二分出来,还要和所有前缀的限制取 $\max$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int n,m,a[MAXN];struct Segtree&#123; int mx[MAXN&lt;&lt;2];#define root mx[o]#define lson mx[o&lt;&lt;1]#define rson mx[o&lt;&lt;1|1] void pushup(int o) &#123; root=max(lson,rson); &#125; void BuildTree(int o,int l,int r) &#123; if(l==r) return (void)(root=a[l]); int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; int query(int o,int l,int r,int L,int R) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) return root; int mid=(l+r)&gt;&gt;1; int res=0; if(L&lt;=mid) res=max(res,query(o&lt;&lt;1,l,mid,L,R)); if(R&gt;mid) res=max(res,query(o&lt;&lt;1|1,mid+1,r,L,R)); return res; &#125;&#125;T;#define lowbit(x) x&amp;(-x)int bit[MAXN];void add(int x,int c)&#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=c;&#125;int sum(int x)&#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x]; return s;&#125;int main()&#123; m=n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=n+1;i&lt;=2*n;++i) a[i]=a[i-n]; for(int i=2*n+1;i&lt;=3*n;++i) a[i]=a[i-n]; n*=3; T.BuildTree(1,1,n); int lst=0; for(int i=1;i&lt;=n;++i) &#123; int L=1,R=i,pos; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; int mx=T.query(1,1,n,mid,i); if(2*a[i]&gt;=mx) R=mid-1,pos=mid; else L=mid+1; &#125; pos=max(pos,lst); add(pos,1); add(i+1,-1); lst=pos; &#125; for(int i=1;i&lt;=m;++i) &#123; int ans=sum(i); if(ans&gt;2*m) ans=-1; printf("%d ",ans); &#125; puts(""); return 0;&#125; E Balanced Binary Search TreesF Balanced Domino PlacementsG Balanced DistributionH Balanced Reversals]]></content>
      <tags>
        <tag>构造</tag>
        <tag>线段树</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初赛试题选做]]></title>
    <url>%2F2019%2F10%2F17%2F%E5%88%9D%E8%B5%9B%E8%AF%95%E9%A2%98%E9%80%89%E5%81%9A%2F</url>
    <content type="text"><![CDATA[马上初赛了,假装准备一下. 主定理假设有递推关系式 $T(n)=aT(\frac n b)+f(n)$ . 三种情况分别对应了 $f(n)=O(n^d)$ 的 $d$ 较小,适中,与较大的情况. Case 1若 $f(n)=O(n^{\log_b a-\epsilon}),\epsilon &gt;0$ ,则 $T(n)=\Theta(n^{\log_b a})$ . 此时复杂度由 $a,b$ 决定. Case 2若 $f(n)=\Theta(n^{\log_b a}\log^k n)$ ,则 $T(n)=\Theta(n^{\log_b a}\log^{k+1} n)$ . 此时两者均衡,复杂度在共同决定的基础上还要乘上一个 $\log n$ . Case 3若 $f(n)=\Omega(n^{\log_b a+\epsilon}),\epsilon&gt;0$ ,对于某个常数 $c&lt;1$ 和所有充分大的 $n$ 有 $af(\frac n b)&lt;cf(n)$ ,则 $T(n)=\Theta(f(n))$ . 此时复杂度由 $f(n)$ 决定. 例一若某算法的计算时间表示为递推关系式 $T(n)=2T(\frac n 2)+n\log n,T(1)=1$ ,求解该算法的时间复杂度. 观察发现是 Case 2 ,其中 $a=b=2,k=1$ . 于是时间复杂度为 $T(n)=\Theta(n\log^2 n)$ . 例二若某算法的计算时间表示为递推关系式 $T(n)=2T(\frac n 4)+\sqrt n,T(1)=1​$ ,求解该算法的时间复杂度. 观察发现是 Case 2 ,其中 $a=2,b=4,k=0$ . 于是时间复杂度为 $T(n)=\Theta(\sqrt n\log n)$ . 例三若某算法的计算时间表示为递推关系式 $T(n)=9T(\frac n 3)+n,T(1)=1$ ,求解该算法的时间复杂度. 观察发现是 Case 1 ,其中 $a=9,b=3$ . 于是时间复杂度为 $T(n)=\Theta(n^2)$ . 例四若某算法的计算时间表示为递推关系式 $T(n)=T(\frac n 2)+n,T(1)=1$ ,求解该算法的时间复杂度. 观察发现是 Case 3 ,其中 $a=1,b=2$ ,常数 $c$ 可取 $(\frac 1 2,1)$ 中的任意实数. 于是时间复杂度为 $T(n)=\Theta(n)$ . 杂题整理NOIP2018 提高组初赛 T17求出当 $a, b$ 都取 $[0, 31]$ 中的整数时,方程 a*b = (a or b) * (a and b) 一共有多少组解. 首先可以注意到 (a or b) + (a and b) = a + b . 证明方式是把每个二进制位分开考虑. 若两个都是 $1$ ,贡献为 $2$ ,只有一个 $1$ ,贡献为 $1$ ,都是 $0$ ,贡献为 $0$ ,不难发现等式两边都满足以上性质. 记 x = (a or b),y = (a and b) ,则有 $a+b=x+y,ab=xy$ . 而 $x\ge y$ ,所以只可能是 $x=\max(a,b),y=\min(a,b)$ . 那么也就是求满足 (a and b) = b 或者 (a and b) = a 的数对个数. 先假设 $a&gt;b$ ,求出答案后 $\times 2$ ,再加上 $a=b$ 的 $32​$ 组解,就是答案. 枚举 $a$ 有几个二进制位是 $1$ 即可求出 $a&gt;b​$ 部分的答案. $$ans=32+2\times \sum_{i=0}^5 {5\choose i}\cdot(2^i-1)=454$$ NOIP2017 提高组初赛 T8求出由 $4​$ 个有标号的点构成的无向简单连通图的数目. 这个就是 bzoj 3456 城市规划 ,于是可以手算 NTT . 用那个暴力 $dp$ 手算一下. 设 $f(i)$ 表示 $i$ 个有标号的点构成的无向简单连通图的数目,边界有 $f(1)=1$ . 转移时用所有图的数目减去不连通的图的数目, 为了计算不连通的图的数目,可以枚举 $1$ 号点所在连通块的大小为 $j$ . 其它的点内部任意连边,但不与这个连通块内的点连边,这样就不连通了.$$f(i)=2^{i\choose 2} -\sum_{j=1}^{i-1}{i-1\choose j-1}\cdot f(j)\cdot 2^{i-j\choose 2}$$前 $3$ 项可以口算, $f(1)=1,f(2)=1,f(3)=4$ ,代入得到 $f(4)=38$ . NOIP2017 提高组初赛 T9将 $7$ 个名额分给 $4$ 个不同的班级,允许有的班级没有名额,求分配方案的数目. 设 $f(i,j)$ 表示 $i$ 个班级分 $j$ 个名额的方案数. 转移时枚举最后一个班级得到了 $k$ 个名额.$$f(i,j)=\sum_{k=0}^j f(i-1,j-k)$$用前缀和优化一下,得到 $f(i,j)=f(i,j-1)+f(i-1,j)$ ,边界有 $f(i,0)=1,f(0,j)=0$ . 这等价于从 $(1,0)$ 出发,每次向右或向上走一步,走到 $(4,7)$ 的方案数. 则答案为 ${4-1+7\choose 4-1}=120$ . NOIP2017 提高组初赛 T22删除一条细边代价是 $1$ ,删除一条粗边代价是 $2$ . 需要以最小的代价使得 $A$ 与 $B$ 不连通,求出这个代价,以及有多少种删边方案的代价是最小的. 平面图转对偶图,对偶图中的最短路长度以及最短路数目就是答案.]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4007 战争调度]]></title>
    <url>%2F2019%2F10%2F16%2Fbzoj-4007-%E6%88%98%E4%BA%89%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[状压 $dp$ . 设 $f(i,j,S)$ 表示考虑了前 $i$ 个平民,其中有 $j$ 个人去打仗,且第 $i$ 个人所有祖先去打仗/管理的状态为 $S$ 时最大收益. 转移时需要限制当前的节点与上一个节点的 $LCA​$ 到根的部分状态相同. 需要把第一维滚掉来优化空间. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=9;int n,m,val[(1&lt;&lt;MAXN)+1][1&lt;&lt;MAXN][2],tmp[MAXN];int f[2][(1&lt;&lt;MAXN)+1][1&lt;&lt;MAXN];int dep(int x,int y)&#123; int s=-1; while(x^y) ++s,x&gt;&gt;=1,y&gt;&gt;=1; return s;&#125;void upd(int &amp;x,int y)&#123; x=max(x,y);&#125;int main()&#123; n=read(),m=read(); for(int k=1;k&gt;=0;--k) &#123; for(int i=1;i&lt;=1&lt;&lt;(n-1);++i) &#123; for(int j=0;j&lt;n-1;++j) tmp[j]=read(); for(int S=0;S&lt;1&lt;&lt;(n-1);++S) for(int j=0;j&lt;n-1;++j) if(((S&gt;&gt;j)&amp;1)==k) val[i][S][k]+=tmp[j]; &#125; &#125; int id=0; for(int k=0;k&lt;=1;++k) for(int S=0;S&lt;1&lt;&lt;(n-1);++S) f[id][k][S]=val[1][S][k]; int ans=0,base=(1&lt;&lt;(n-1))-1; for(int i=2;i&lt;=1&lt;&lt;(n-1);++i) &#123; id^=1; memset(f[id],0,sizeof f[id]); int d=dep(base+i-1,base+i); for(int k=0;k&lt;=1;++k) for(int l=0;l&lt;=i &amp;&amp; l+k&lt;=m;++l) &#123; for(int a=0;a&lt;(1&lt;&lt;(n-1-d));++a) for(int b=0;b&lt;(1&lt;&lt;d);++b) for(int c=0;c&lt;(1&lt;&lt;d);++c) &#123; upd(f[id][l+k][c^(a&lt;&lt;d)],f[id^1][l][b^(a&lt;&lt;d)]+val[i][c^(a&lt;&lt;d)][k]); if(i==(1&lt;&lt;(n-1))) upd(ans,f[id][l+k][c^(a&lt;&lt;d)]); &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191016]]></title>
    <url>%2F2019%2F10%2F16%2Ftest20191016%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>博弈论</tag>
        <tag>容斥原理</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4005 骗我呢]]></title>
    <url>%2F2019%2F10%2F15%2Fbzoj-4005-%E9%AA%97%E6%88%91%E5%91%A2%2F</url>
    <content type="text"><![CDATA[$dp$ 计数 + 容斥原理. 容易发现,每一行填的数都是从 $0\sim m$ 这 $m+1$ 个数中去掉一个数,将剩下的从小到大依次填进去形成的. 设 $f(i,j)$ 表示考虑了前 $i$ 行,第 $i$ 行去掉的数是 $j​$ 的方案数. 为了满足第二个条件,观察可以得出 $f$ 的转移$$f(i,j)=\sum_{k=0}^{j+1} f(i-1,k)$$则答案为 $\sum_{j=0}^m f(n,m)= f(n+1,m-1)$ . 考虑将 $f(i,j)$ 与 $f(i,j-1)$ 做差,可以得出递推式$$f(i,j)=f(i,j-1)+f(i-1,j+1)$$直接 $dp$ 是 $O(n^2)$ 的,不能接受. 发现 $f$ 的转移形式与组合数比较像,尝试转化到坐标系中. $f(n+1,m-1)$ 就表示从 $(0,0)$ 出发,每次可以向右走一步,或者向上与左走一步,走到 $(n+1,m-1)$ 方案数. 向上与左走的步数是确定的,要走 $n+1$ 步,那么向右走的步数就是 $n+m$ 步. 再转化一步,就变成从 $(0,0)$ 出发,只能向右走一步,或向上走一步,走到 $(n+1,n+m)$ 的方案数. 但现在向上走一步,对应的是原来向上,左各走一步,若原来的 $j&lt;0$ 或者 $j&gt;m$ 了,就不合法了. 也就是说,从 $(0,0)$ 走到 $(n+1,n+m)$ 时,还不能穿过直线 $y=x$ 和 $y=x-m$ . 记穿过 $y=x$ 再穿回来的事件为 $A$ ,穿过 $y=x-m$ 再穿回来的事件为 $B$ . 考虑容斥,考虑交错子序列 $ABABAB\dots$ ,则至少发生了前 $i$ 次事件的方案数 $s_i$ 对答案的贡献就是 $(-1)^i\cdot s_i$ . 将终点 $(n+1,n+m)$ 不断沿着两条直线对称,每对称一次就更新答案. 对另一个交错子序列 $BABABA\dots$ 也同样计算一遍贡献. 不断对称的时间复杂度是 $O(\log n)$ ,瓶颈在预处理阶乘及其逆元,时间复杂度 $O(n)$ .]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4004 装备购买]]></title>
    <url>%2F2019%2F10%2F15%2Fbzoj-4004-%E8%A3%85%E5%A4%87%E8%B4%AD%E4%B9%B0%2F</url>
    <content type="text"><![CDATA[求解最小权值极大线性无关组. 根据拟阵的那套理论,只需要将所有向量按照权值从小到大排序. 然后依次尝试加入,能加入就加入,维护一个上三角矩阵来进行判断. 精度上可能会有问题.可以开 long double 并加入 eps 进行判断,也可以用 $\gcd$ 消元法,会多一个 $\log$. 写的时候比较偷懒,就模了个大质数来做. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=512;int n,m;struct Vector&#123; int v[MAXN],cost; bool operator &lt; (const Vector &amp;rhs) const &#123; return cost&lt;rhs.cost; &#125;&#125;a[MAXN];int tot=0,matrix[MAXN][MAXN];int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) a[i].v[j]=read(); for(int i=1;i&lt;=n;++i) a[i].cost=read(); sort(a+1,a+1+n); int cnt=0,ans=0; for(int t=1;t&lt;=n;++t) &#123; for(int i=1;i&lt;=m;++i) &#123; if(!a[t].v[i]) continue; if(!matrix[i][i]) &#123; for(int j=i;j&lt;=n;++j) matrix[i][j]=a[t].v[j]; ++cnt; ans+=a[t].cost; break; &#125; int tmp=mul(a[t].v[i],fpow(matrix[i][i],P-2)); for(int j=i;j&lt;=m;++j) inc(a[t].v[j],mul(P-tmp,matrix[i][j])); &#125; &#125; cout&lt;&lt;cnt&lt;&lt;' '&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>拟阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191015]]></title>
    <url>%2F2019%2F10%2F15%2Ftest20191015%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>概率/期望</tag>
        <tag>容斥原理</tag>
        <tag>test</tag>
        <tag>Pollard-Rho</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4003 城池攻占]]></title>
    <url>%2F2019%2F10%2F14%2Fbzoj-4003-%E5%9F%8E%E6%B1%A0%E6%94%BB%E5%8D%A0%2F</url>
    <content type="text"><![CDATA[可并堆. 如果对于每个骑士,我们都求出他在哪个城池牺牲,那么两个问题都可以解决. 对于树上的每个节点,开一个可并堆,维护当前这个点上所有骑士的战斗力. 对树进行 $dfs$ . 先将堆中的战斗力修改,然后弹出在当前节点牺牲的骑士,更新答案,再将剩余的骑士合并到父亲上去. 加或者乘一个正数是不会改变战斗力的大小关系的,所以修改时在根节点处打标记就可以了,堆的形态不会变化. 最后还要处理攻占根节点后仍未牺牲的骑士. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int n,m,ecnt=0,head[MAXN],to[MAXN],nx[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int dep[MAXN],st[MAXN],a[MAXN];ll h[MAXN],v[MAXN];struct node&#123; int ls,rs; ll addtag,multag,val; node()&#123;addtag=0,multag=1;ls=rs=0;&#125;&#125;Heap[MAXN];int rt[MAXN];void upd_mul(int x,ll c)&#123; Heap[x].val*=c; Heap[x].multag*=c; Heap[x].addtag*=c;&#125;void upd_add(int x,ll c)&#123; Heap[x].val+=c; Heap[x].addtag+=c;&#125;void pushdown(int x)&#123; if(Heap[x].multag!=1) &#123; if(Heap[x].ls) upd_mul(Heap[x].ls,Heap[x].multag); if(Heap[x].rs) upd_mul(Heap[x].rs,Heap[x].multag); Heap[x].multag=1; &#125; if(Heap[x].addtag) &#123; if(Heap[x].ls) upd_add(Heap[x].ls,Heap[x].addtag); if(Heap[x].rs) upd_add(Heap[x].rs,Heap[x].addtag); Heap[x].addtag=0; &#125;&#125;int merge(int x,int y)&#123; if(!x || !y) return x+y; if(Heap[x].val&gt;Heap[y].val) swap(x,y); pushdown(x); Heap[x].rs=merge(Heap[x].rs,y); swap(Heap[x].ls,Heap[x].rs); return x;&#125;void pop(int &amp;x)&#123; pushdown(x); x=merge(Heap[x].ls,Heap[x].rs);&#125;int ans1[MAXN],ans2[MAXN];void dfs(int u)&#123; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; dep[v]=dep[u]+1; dfs(v); rt[u]=merge(rt[u],rt[v]); &#125; while(rt[u] &amp;&amp; Heap[rt[u]].val&lt;h[u]) &#123; ++ans1[u]; ans2[rt[u]]=dep[st[rt[u]]]-dep[u]; pop(rt[u]); &#125; if(a[u]==0) upd_add(rt[u],v[u]); else upd_mul(rt[u],v[u]);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) h[i]=read(); for(int i=2;i&lt;=n;++i) &#123; int f=read(); addedge(f,i); a[i]=read(); v[i]=read(); &#125; for(int i=1;i&lt;=m;++i) &#123; Heap[i].val=read(); st[i]=read(); rt[st[i]]=merge(rt[st[i]],i); &#125; dfs(1); while(rt[1]) &#123; ans2[rt[1]]=dep[st[rt[1]]]+1; pop(rt[1]); &#125; for(int i=1;i&lt;=n;++i) printf("%d\n",ans1[i]); for(int i=1;i&lt;=m;++i) printf("%d\n",ans2[i]); return 0;&#125;]]></content>
      <tags>
        <tag>可并堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191014]]></title>
    <url>%2F2019%2F10%2F14%2Ftest20191014%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>概率/期望</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191013]]></title>
    <url>%2F2019%2F10%2F13%2Ftest20191013%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>数学</tag>
        <tag>数位dp</tag>
        <tag>test</tag>
        <tag>crt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4002 有意义的字符串]]></title>
    <url>%2F2019%2F10%2F13%2Fbzoj-4002-%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[数学套路题. 考虑将 $\frac {b+\sqrt d}{2}$ 写成某个递推数列的特征方程的根. 设数列 $a_i=A\cdot (\frac{b+\sqrt d}{2})^i+B\cdot (\frac{b-\sqrt d}{2})^i$ . 可以根据韦达定理得出该数列的递推式 $a_i=b\cdot a_{i-1}+\frac{d-b^2}{4}\cdot a_{i-2}$ . 令 $A=B=1$ ,得到这个数列的前两项 $a_1=b,a_2=\frac{b^2+d}{2}$ . 由于 $b\bmod 2=1,d\bmod 4=1$ ,所以 $\frac {d-b^2}{4},\frac{b^2+d}{2}$ 一定是个整数. 于是可以用矩阵快速幂求出 $a_n$ . 而 $(\frac{b+\sqrt d}{2})^n=a_n-(\frac{b-\sqrt d}{2})^n$ ,答案需要向下取整. 有限制 $0&lt;b^2\leq d&lt;(b+1)^2$ ,所以有 $(\frac {b-\sqrt d}{2})^n\in(-1,0]$ . 于是当且仅当 $b^2&lt;d,n\bmod 2=0​$ 时,答案为 $a_n-1​$ ,其余情况为 $a_n​$ . 时间复杂度 $O(\log n)​$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const ll P=7528443412579576937;ll add(ll a,ll b)&#123; return (P-a&lt;=b)?(a-P+b):(a+b);&#125;ll mul(ll a,ll b)&#123; ll res=a*b-(ll)((long double)a/P*b+1e-8)*P; return res&lt;0?res+P:res%P;&#125;struct Matrix&#123; ll v[2][2]; Matrix()&#123;memset(v,0,sizeof v);&#125; Matrix operator * (const Matrix &amp;rhs) const &#123; Matrix res; for(int i=0;i&lt;2;++i) for(int k=0;k&lt;2;++k) if(v[i][k]) for(int j=0;j&lt;2;++j) res.v[i][j]=add(res.v[i][j],mul(v[i][k],rhs.v[k][j])); return res; &#125;&#125;st,trans,I;Matrix fpow(Matrix a,ll b)&#123; Matrix res=I; while(b) &#123; if(b&amp;1) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; I.v[0][0]=I.v[1][1]=1; ll b=read(),d=read(),n=read(); if(n==0) return printf("1\n")&amp;0; if(n==1) return printf("%lld\n",floor((double)((b+sqrt(d))/2)))&amp;0; st.v[0][0]=((b*b+d)/2)%P,st.v[1][0]=b; trans.v[0][0]=b,trans.v[0][1]=((d-b*b)/4)%P,trans.v[1][0]=1; st=fpow(trans,n-2)*st; ll ans=st.v[0][0]; if(n%2==0 &amp;&amp; b*b&lt;d) --ans; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>矩阵优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191012]]></title>
    <url>%2F2019%2F10%2F12%2Ftest20191012%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19YkBOhl7YKb6Kh3qfxjse1OxQgI61/oZ9jxBUKIekODRz/rGLuQQXbUi9ozL7CrMp8bAe+/OrZx9wvQeNfIQb11PlrcCA+TbA6qcV5rtlIQ9IcHII53IoW2Xu4pivPNR292/NV2INYVkOA9xNklUvQZtVrxaRVdg3C4JFvEcF37tySS6xIdjqOet1AwMTtAcWpYwKb191ZWT2BlR6Es+89OlAi3FWDc81fEBuFYeZlDAZNl9YP361POPjsagIEZ5T8XB6DZPWKMslbYMaPjp+kEiEUP5VbhWHZG7gPXO28988BlQb/oxdpAKZU576APF9d+zWEQwmCoUCIRnq+0pV3Z9/GMZeawuUtetvKUEOmJr/vi88llsFMxdsVjYkfxc/r5w9VweUThsytV6P8n89+hda23/N1Lar3RiC7REmkjlArNq7AE6BllKcsaOBopHb6jgJ5yh2/XBsQC7qAxl5Xcm+4FpVorgFd2tn3IW4K83y4OM6Vz+VuU5kQMefiJiwHNPNFaWkpPgeY6ZQS/EGGdMgl6vYZGofFlIgGPg/FGzs/KyWx84mhQ3orfOz2Vg6DYdQuJc39z+fRIuQw+Wq8vp6jylNBsKiUoFcSh3jmFYlom16n+lAKLaFd8pgsNSUPXMH1x7dyNZPGKMurTbresGYXDeCRp/qQFg1hE0CA/5rJsC6vv2PfZ97PnLehbExolT9pkIoSkVdu5ftXnuZxIiLc+uk5zRuAqXFG4dWLAngby+8NDZmkgMrJTbigGv3blp11TSOmb6SeETIP2SRXUv+cVSe6UtNGX7tocBYLMKfDrC+NV7p1MfPsbPcZ6aWmyw9jSmMfTdDI1CJY1YKMxODlPiWv9ae/GMJjf8DLeN9WFZGTZytKfDtLMFd6a4B+i9RMYtiliciGB8vGpvzn/1kBFM51CfftvMHijvdU4NsbDtkIZupc26KKflAV+s8Omuzk13PfCoukFPH78FX20lcEjLSeG5IGQ4Vo4h2+6/9+UWpMYZo+O9hPN06WQOQ9c5MnTpR3ATplQVfIlLaW5so94pnWVi8psGUAFJjCtXx7alsVB4tGJ7iYEbAPEQqk4lJf0ON3m9JNi9uKY4R2dEZ5/lndjlWLxwPS2RM2L060Hr5rjZ0eA61RUZ6I1Ha5Zvwmdy31qsArDI6HwF/A7G4KSjLU0TVbW2Hqv6fUTrE3gup91IV6UHrESQDJNw2QTPqBnOKxngOdxQC9iXIG+PxJHJ/nLQcFBWYTtgcsHexWPfdZwaN3jO1tlZVzwkKYU1I2AGK1cBKEqaCc/sFwjl8mPcvJ4TC5ISL2fiZlq85XOO6boGqnYREgLVdaVXg49G2wFkEN6st/HsD1BsfB/wk6sHBEBuOxzWlATcbe7FPOkrPRIbzMP1T0bqdIbrurrKdjiRYtrsPRpNTJBzgjB7k+1ryfQRC/FvPeCIOaEAI3QCl7aUYG3sMKIgCiUKWTw9Nu56kYe9d0DqGW30pRCkv+KXxWmluIyOWZbD/BwWTEiA4RnQMd2D2BuTSEjPFWXvRsRpqtafgx2J8vnMK0Igq6JnPzBYYb9YgLrQT352BZf7PHNZm1POwTcPgz8jVR321WQxUzt2vSmjQjdbV1P7G78NfqaOE3ii2F1b1/cvTpww789C7qVuVR4yWgLDf57DCKvSGjFS7qAkJdOaQ0htasMcmorNhed/BB+XiwmmUx1JvhMjfOwYexUgcicLKSl8pBIVbS9OelEWLH7+BOvnOM06N6XsnXfwDXVaJIjkIEv6yr5bhROb+MkTNMMRnT/FQhZNVbz8K2p1oEC/WMPFld1JHifJOM5RLCFpgkrCqlPjqrA3WSbHtlmya07gowKLwDBr8O8u+NDbzI4qabUkco3cWMuEp1aJeerk2rLr7+fVHdn1Ka8r/pfdpJoyJLJTzafIxir/IyIr7m6//UuEoPkXbVSAYS4QASd88m3GTgK8xhoyrOi6LyrEirHkEzwbbTPQuS9l77ua0xF3jyOUxn8V37c6g1AUSk0fraWloc27ePXfKnVuKQjWrNp3feed/c4wbXgz9H/joN7owexY7DjonafFCqkhVN11IAhyBX9V3dwyD3Xe2x5IS+d702t3rOCSrIpSLZcTCq+C6loNXwsQeRmiZEgsZPUIUwh2GBKp6JZTys0DKWom3rg+zG3W/qWeVGGTD26+vOFv+cD68ETM9/I6ULc3mjYOSdhCzj20ftGPJJmc5wWpUAbwk18gc0oGWFuoyCQt1McJgCAHVvLJy0Skl+SX+M0QpIosLCk05Inrjribrao4YaKiGRSmN4DRxX6Z4BYVPREBxphLWf6aaOoAij68YEhNmxr9+ePaRDJ9rptz7XxBZj7bdGP09mPDr43WE93jO4Bg0kfb8Mpfzqf4CYY/U5MMTe9jPyZba3rRiQOEQf4VUh9XYKFRjruBmBTtireTPoKXGJxW1yiqdtudwV750QTxOGqELyOm7Jp18tj2goVICoFtNLnpWbft+7OGkkg3V83Au2+qqDTz2nTm7WOI4tbhkPWr5G//Tn1ujD22dUWgHn2EyTsKm6Tygbg4RPOpSVxUwOWSxkMK02RE3Q+mbDxn6pDJY8JXGeZeYEL6heX+UcaiQjqNUoSjN9YVE3lppgCdNNq3Js+AVb0JkM9URs/C+yzHaVI7EM6ZTSmhCyZ6lRctjJApUA5QkSPifvwV09v6vWEiiyc2XJdRHhOqTC8aJgwqJjJwcUxqLdddeEFIGQfsXuRU+yzQKsUrVqB1CJyk9YDzEjqeTfENHLz8Dglg82Jbg3HYedt9p3N4yBLUlqQaSGYieZCtTPxFx64XsBJLFv2WgKImJN90M4P9V9LezxG9DY8V2qZOB8UWvmr2VJzbkUT2ulY3ntGChpMT5vfTrrNTxPjphwIE1WPh648JLwaKXm7A8EQJhA+SDPDFNf34c4Qxr0BrxH0hOKC3Wx5JiE5dx03fparnC9AD8Dug7lAMgZmtX/98j8j3nfMZsKvl29uzsasGiHZtOgbj+eHj4UrNxBqBrwo2LqkYrGFdonxPsrAoS/obzIzhVHGSNTmrp1+EyBEl1mZwsC1XoQgrxlu0fd4mgYCKYgVMtjXS1FupKNk4rQ5TzuT8cUu+soGPjsi5wfNvOTCYjxJvCdwg8YEMjjV6D98Nae/67V13dCNrfr4rSIAt2m06qxVMF554IGFSRKKSGJOrUGUc1ILGLqQrEWAUfxWbQztJNHOBDgjTqvvZu0fHvvnPDzBwNZdAcWHwNrNg2n914nTl4fFqdU7NVD9mljMSSOXf6EdlH0lK7fYSH+qkvmWTjcM3oNcEBs1uL7uPFCRbjKIJETWTZLDDcMHCCzDDNAsfDxh0kNKOV3jVaeSsWBaVOfIL1pAcDMACYTsejomGdW4XPyk9W7jlM+nAxGzX7f+WrCYNKLmFmMfP0peOGsCIUUsqHSXLlcRQYOmSrNKrLZ9UO+R169Ec5vWBPZbUjHCv2TqByOFE5Ie/6hE/TrXGz1THsZUFliHuR7k3kCHH4JWWOjOtWEUSDEN48QCQ7EH/x8e1PQDQ4qInvETwNhJh/AwzaY7E1LXrVEN+48KYZsRwbdBny7d3+JZ0JbZ7CKfik+cP+zwLHcNi+tsu3VjYtVXSUVoaDKax0tYofa23z+u6R7xiwdePSj5HhvKzC5YQ4bBCuX8wZH3Sh7/ktu71io3iMAl8//qjZ1BRJt5v7Wl+it3WTrh+I4RW19S1ABOTXVA2hvD961GDbGC6vJdTuHGk7jGevdacxuIi5zlMfUY+h6kIPI8Tl0CRU9mchmU9juOa6qzFzN11DAW53Wg5BUvlIeQtHUb6rcFVuRpUiEmA0s3ovGjs7tZEqrQ/ubkIvo0GAtFkwh1lPg3EmbBvFzGtnrA3J2+rGOLSAj5bmBcLozcE+0Jcjm4BQcBVSGGfJYgnxKtv1Kidf8O+3eJJ13BZ7KpKd0wHlNS4m06cx5cxX97jSzy7Y4LCGEj9qxFYjrCyq+OFM//MxGOLkiFZdlSs+GgfxgqyNsREKEegvsRG+0abtkum+nylWwb4d6dJqzJ7MOsdYKEfm3lbplcHSpD8ilaPOcS3lKZqeQLtE/9x/3bfXDvFABwOPdHzZTXsAlUm9zh81d/Dusgz/hmfFCWY+f4IyZ4v4Qi11C7pJpxaIGPEDs+0MkBb+NVC6D7tyFKIapqe6fXiuCEJoN4fLE9QdpUnZUULu2RdQmpCxXCouWLXwSRLpC3R3llPAfWqvd5LSwARVP9QnAtV0Z var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>数学</tag>
        <tag>树状数组</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191011]]></title>
    <url>%2F2019%2F10%2F11%2Ftest20191011%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+5Vs3plSatq2dFsEFK8NDqnhgaLzDHNna2SeHmY4n2m6NNEZsWNsyvMpLX1+1v3iXp57YJ5JfQsloYzphApeecM/F0HYNNEgwk1Jz2RdVhuv7AS7y9eZC9JpfQru+0mtLG4Yqlgo+uRjhxG6U/6UQDdZfp/HRxi3EtOl7a1+e2vf+kqogCgFFQkPiDs4aikoYK47Ql97v2R39c5jMVeVGMVt8dkF7ylkPenRFq2PQvXvnHVsVvFnpNiAoH/HKIXC53tfWUl66AP1JDv1ZOonwlDAXinvz1D8JlHRS7l1wF7hdlYiKFaBB13oFQscSjD7V3HLiLi2NAg2iTsNXytNVJJ2VuQeX8VLeM6MQJQprdTh0C52QH9oZfvXiKGQ1Geg/Ch4V/HpgHBmTdjlj98CQx+Bmb9hl0XvsIK3s2d7BLlJ0YHeneGoYN3zeHW5pecFQ895ME9d7bjRg3t9PUseA81rTBdEqJgT2x111OLH0Nzs+YzSpXF2La2rDMOHx0+t1rs7hgtvFnlGIEVxyxqOp4HUj5SEdIqRlXu+/TsQC+bCN99GZ2/gGjm+Ti8muUw9yafkSgxlGwRVSnN4MEzqFkoRbHC//WTO1UzrGyJrEpV7mfcm0v6ryfFt1ayEY0cpqVeeAVlxcF7ZNUGWKQlq0UegcrPlCDzXCWAIDiEs0++9luKSaEqBhHIRWixwMk+Lji+e+1joH7nB7Zv/LO5JS1rV5MVQ/0ML8G6fbp63z9YJwldmntsCvSoSVVYinSA7oFc7MyBw7dC6Hw3m2oPkiH0LXe3nF2hVtfsRliQj/SimF8IvBw1hqB1UIQv2m7YokOTWk9e/f9YRpp0PptFl2zXb5BuDLNWLCr1MpZw7wnsVycK7uLZVMEQxFAnIlyBfkZXc3/ewaE/0z9+MhK+B4NGAlxdQz+X8PvJmaVIruQoNbSu4vqgLVQvQT6ZENxYNiXrBjk1MkaLDFlA6LwS1DZ6dxOjkHfFnrhBK0CT2jIijQfU1eqtgP3Q1yfXRt5+NaKuNEg0mjmOc9gD6WMD9CzifKKgQnl+ggGqFSozslj1+h7NbuMWwfgQwvsf3YQWQsLBQMErTSTEMw4cUyr/Uc1TyCVLUNiFYqsfoXWnYGmiGOToBLp+wydTw2nRt7YJiYF7HnHPh/SroT3XoiCTmDXDD5zoh4h8tA= var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
        <tag>倍增</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF985D Sand Fortress]]></title>
    <url>%2F2019%2F10%2F10%2FCF985D-Sand-Fortress%2F</url>
    <content type="text"><![CDATA[二分答案. 把 $n$ 个物品摆成一排,一个位置上可以放多个物品,但要满足两个限制. 第一个位置上放的物品数目不能超过 $H$ . 任意两个相邻位置上放的物品数目之差必须 $\le 1$ ,这个规则对于最后一个位置也适用,即最后一个位置必须恰好放 $1​$ 个物品. 求出摆下这 $n$ 个物品至少需要的位置数目. 首先需要注意到答案是可以二分的,因为差值可以为 $0$ ,所以多出来的位置总可以通过调整得到合法解. 考虑二分一个答案 $k$ ,于是需要求出 $k$ 个位置最多能放下的物品数目. 由于最后一个位置必须是 $1$ ,且第一个位置的所以 $k$ 个位置最优的方案一定是先上升,再下降到 $1$ . 感性理解一下. 判断一下直接这样放,第一个元素的位置是不是 $\le H$ 的,否则就只能从 $H$ 开始依次递减摆放. 如果二分答案的上界设为 $n$ ,对等差数列求和时会爆掉 $\rm long\ long$ . 可以对称的放,即高度从 $1$ 到某个 $x$ ,再到 $1$ .于是可以将上界设到 $2\sqrt n$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;ll n,H;ll sum(ll l,ll r)&#123; if(l&gt;r) swap(l,r); return (l+r)*(r-l+1)/2;&#125;bool check(ll k)&#123; if(k&lt;=H) return sum(1,k)&gt;=n; ll tot=sum(1,H-1); k-=H; if(k&amp;1) tot+=2*sum(H,H+k/2); else tot+=sum(H,H+k/2)+sum(H+k/2-1,H); return tot&gt;=n;&#125;int main()&#123; n=read(),H=read(); ll L=1,R=2*sqrt(n),ans; while(L&lt;=R) &#123; ll mid=(L+R)&gt;&gt;1; if(check(mid)) ans=mid,R=mid-1; else L=mid+1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3997 组合数学]]></title>
    <url>%2F2019%2F10%2F10%2Fbzoj-3997-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[$Dilworth$ 定理. 图是一张 $DAG$ ,根据 $Dilworth$ 定理,它的最小链覆盖数就等于最长反链长度. 一条反链中的任意两点间都不存在边,所以一定是从左下到右上的一条链. 设 $f(i,j)$ 表示用了以 $(i,j)$ 为右上角的矩阵中的点,最长反链的长度. 从左下到右上进行 $dp$ 即可. 1234567891011121314151617181920212223242526272829303132333435363738394041//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e3+10;int n,m,val[MAXN][MAXN];ll f[MAXN][MAXN];int main()&#123; int T=read(); while(T--) &#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) val[i][j]=read(); memset(f,0,sizeof f); for(int i=n;i&gt;=1;--i) for(int j=1;j&lt;=m;++j) &#123; f[i][j]=0; f[i][j]=max(f[i][j],f[i+1][j]); f[i][j]=max(f[i][j],f[i][j-1]); f[i][j]=max(f[i][j],f[i+1][j-1]+val[i][j]); &#125; printf("%lld\n",f[1][m]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>DAG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1168A Increasing by Modulo]]></title>
    <url>%2F2019%2F10%2F10%2FCF1168A-Increasing-by-Modulo%2F</url>
    <content type="text"><![CDATA[二分答案 + 贪心. 给出一个长度为 $n$ 的自然数序列 $a$ ,满足 $a_i\in [0,m)$ . 每次操作可以选出任意个元素进行修改,元素 $x$ 在修改后会变为 $(x+1)\bmod m$ . 需要求出至少操作几次,可以使得整个序列单调不降. 可以二分一个答案 $k$ ,则只需判断在 $k$ 次操作内能否达到要求. 贪心一下,如果一个数能在 $k​$ 次操作内变成上一个数,就把它变过去. 否则不变,若此时它比上个数小,就不合法了. 一个比较显然的答案上界是 $m$ ,因为操作 $m$ 次一定可以让所有数变成 $0$ . 时间复杂度 $O(n\log m)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int n,m,a[MAXN];bool check(int k)&#123; int lst=0; for(int i=1;i&lt;=n;++i) &#123; int x=a[i]; if((x&lt;=lst &amp;&amp; x+k&gt;=lst) || (x&gt;lst &amp;&amp; x+k-m&gt;=lst)) continue; else &#123; if(x&lt;lst) return false; lst=x; &#125; &#125; return true;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); int L=0,R=m,ans; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid)) ans=mid,R=mid-1; else L=mid+1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF360E Levko and Game]]></title>
    <url>%2F2019%2F10%2F10%2FCF360E-Levko-and-Game%2F</url>
    <content type="text"><![CDATA[最短路 + 贪心. 有一张 $n$ 个点, $m+k$ 条边的有向图,可能存在重边与自环. 前 $m$ 条边的长度是给定的,你需要为后 $k$ 条边分别钦定长度,其中第 $i$ 条边的长度必须在区间 $[l_i,r_i]$ 中. 给出三个点 $s_1,s_2,f$ ,求一种钦定的方案,使得 $s_1\to f$ 的最短路长度小于 $s_2\to f$ 的最短路长度. 如果不能达到上述要求,就给出一种使两者相等的钦定方案. 若两个要求都无法达到,输出 LOSE . 首先可以确定,对于这 $k$ 条边,每条边的权值只可能是 $l_i$ 或者 $r_i$ . 因为权值取在中间时,可以往两边调整,至少有一边不会更劣. 于是可以先将它们的权值都设为 $r_i$ ,分别以 $s_1,s_2$ 作为起点跑一遍 $Dijkstra$ . 对于一条可以改的边 $u\to v$ ,若 $dis(s_1,u)\le dis(s_2,u)$ ,就把它的权值改为 $l_i$ . 因为它更可能出现在 $s_1\to f$ 的最短路上. 最简单的想法是,每次改了一条边之后,重新计算一遍距离,再去找需要改的边. 但实际上可以一次将所有的边改完,再去重新计算距离,这样做是等价的. 用三角形不等式,可以证明每次修改后,没有 $dis(s_1,u)\le dis(s_2,u)$ 变成 $dis(s_1,u)&gt;dis(s_2,u)$ 的情况. 时间复杂度 $O(k(m+k)\log n)$. 用链表删掉已经改过的边,否则复杂度会退化. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const ll inf=9e18;const int MAXN=1e4+10;int n,m,k,s1,s2,f;typedef pair&lt;ll,int&gt; pli;#define mp make_pairpriority_queue&lt;pli&gt; q;struct Graph&#123; int ecnt,to[MAXN],nx[MAXN],head[MAXN],val[MAXN]; void addedge(int u,int v,int w) &#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt; &#125; int vis[MAXN]; ll dis[MAXN]; void Dijkstra(int S) &#123; for(int i=1;i&lt;=n;++i) dis[i]=inf,vis[i]=0; dis[S]=0; q.push(mp(-dis[S],S)); while(!q.empty()) &#123; int u=(q.top()).second; q.pop(); if(vis[u]) continue; vis[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(dis[v]-dis[u]&gt;val[i]) &#123; dis[v]=dis[u]+val[i]; q.push(mp(-dis[v],v)); &#125; &#125; &#125; &#125;&#125;G1,G2;int id[MAXN],x[MAXN],y[MAXN],l[MAXN],r[MAXN];int ans[MAXN];int pre[MAXN],nxt[MAXN];void del(int x)&#123; int l=pre[x],r=nxt[x]; pre[r]=l; nxt[l]=r;&#125;int main()&#123; n=read(),m=read(),k=read(); s1=read(),s2=read(),f=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(),w=read(); G1.addedge(u,v,w); G2.addedge(u,v,w); &#125; nxt[0]=1; for(int i=1;i&lt;=k;++i) &#123; pre[i]=i-1,nxt[i]=i+1; x[i]=read(),y[i]=read(); l[i]=read(),r[i]=read(); G1.addedge(x[i],y[i],r[i]); G2.addedge(x[i],y[i],r[i]); id[i]=G1.ecnt; ans[i]=r[i]; &#125; pre[k+1]=k; while("RLDAKIOI") &#123; G1.Dijkstra(s1); G2.Dijkstra(s2); bool flag=false; for(int i=nxt[0];i!=k+1;i=nxt[i]) if(G1.val[id[i]]!=l[i] &amp;&amp; G1.dis[x[i]]&lt;=G2.dis[x[i]]) &#123; G1.val[id[i]]=l[i]; G2.val[id[i]]=l[i]; ans[i]=l[i]; flag=true; del(i); &#125; if(!flag) break; &#125; G1.Dijkstra(s1); G2.Dijkstra(s2); if(G1.dis[f]&lt;=G2.dis[f]) &#123; if(G1.dis[f]&lt;G2.dis[f]) puts("WIN"); else puts("DRAW"); for(int i=1;i&lt;=k;++i) printf("%d ",ans[i]); puts(""); &#125; else puts("LOSE"); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>codeforces</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2289 在美妙的数学王国中畅游]]></title>
    <url>%2F2019%2F10%2F09%2FLoj-2289-%E5%9C%A8%E7%BE%8E%E5%A6%99%E7%9A%84%E6%95%B0%E5%AD%A6%E7%8E%8B%E5%9B%BD%E4%B8%AD%E7%95%85%E6%B8%B8%2F</url>
    <content type="text"><![CDATA[$LCT$ + 泰勒展开. 如果只有类型 $3$ 的函数,就直接用 $LCT$ 维护路径上的 $\sum a,\sum b$ . 对于前两种函数,题面都明示你了,进行麦克劳林展开,就变成多项式函数了.$$\sin(ax+b)=\sin (b)+\frac{a\cos(b)\cdot x}{1!}-\frac{a^2\sin(b)\cdot x^2}{2!}-\frac{a^3\cos(b)\cdot x^3}{3!}+\frac{a^4\sin(b)x^4}{4!}+\dots \\e^{ax+b}=e^b+\frac{ae^b\cdot x}{1!}+\frac{a^2e^b\cdot x^2}{2!}+\frac{a^3e^b\cdot x^3}{3!}+\frac{a^4e^b\cdot x^4}{4!}$$拆到 $12$ 项,精度差不多就够用了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10,L=12;double fac[L];struct node&#123; int fa,ch[2]; double poly[L],a,b; int rev,f;&#125;Tree[MAXN];#define root Tree[x]#define lson Tree[root.ch[0]]#define rson Tree[root.ch[1]]bool isroot(int x)&#123; return Tree[root.fa].ch[0]!=x &amp;&amp; Tree[root.fa].ch[1]!=x;&#125;void reverse(int x)&#123; if(!x) return; swap(root.ch[0],root.ch[1]); root.rev^=1;&#125;void pushup(int x)&#123; for(int i=0;i&lt;L;++i) root.poly[i]=lson.poly[i]+rson.poly[i]; if(root.f==1) &#123; double Sinb=sin(root.b),Cosb=cos(root.b),pw=1.0; for(int i=0;i&lt;L;i+=4) &#123; root.poly[i]+=Sinb*pw/fac[i],pw*=root.a; root.poly[i+1]+=Cosb*pw/fac[i+1],pw*=root.a; root.poly[i+2]+=-Sinb*pw/fac[i+2],pw*=root.a; root.poly[i+3]+=-Cosb*pw/fac[i+3],pw*=root.a; &#125; &#125; else if(root.f==2) &#123; double Expb=exp(root.b),pw=1.0; for(int i=0;i&lt;L;++i) &#123; root.poly[i]+=Expb*pw/fac[i]; pw*=root.a; &#125; &#125; else if(root.f==3) &#123; root.poly[1]+=root.a; root.poly[0]+=root.b; &#125;&#125;void pushdown(int x)&#123; if(root.rev) &#123; reverse(root.ch[0]); reverse(root.ch[1]); root.rev=0; &#125;&#125;void rotate(int x)&#123; int y=Tree[x].fa; int z=Tree[y].fa; int k=(Tree[y].ch[1]==x); if(!isroot(y)) Tree[z].ch[Tree[z].ch[1]==y]=x; Tree[x].fa=z; Tree[y].ch[k]=Tree[x].ch[k^1]; Tree[Tree[x].ch[k^1]].fa=y; Tree[x].ch[k^1]=y; Tree[y].fa=x; pushup(y);&#125;int stk[MAXN],tp=0;void Splay(int x)&#123; stk[++tp]=x; for(int pos=x;!isroot(pos);pos=Tree[pos].fa) stk[++tp]=Tree[pos].fa; while(tp) pushdown(stk[tp--]); while(!isroot(x)) &#123; int y=Tree[x].fa,z=Tree[y].fa; if(!isroot(y)) (Tree[y].ch[0]==x)^(Tree[z].ch[0]==y)?rotate(x):rotate(y); rotate(x); &#125; pushup(x);&#125;void Access(int x)&#123; for(int y=0;x;y=x,x=Tree[x].fa) &#123; Splay(x); Tree[x].ch[1]=y; pushup(x); &#125;&#125;void makeroot(int x)&#123; Access(x); Splay(x); reverse(x);&#125;int findroot(int x)&#123; Access(x); Splay(x); while(Tree[x].ch[0]) x=Tree[x].ch[0]; return x;&#125;void split(int x,int y)&#123; makeroot(x); Access(y); Splay(y);&#125;void Link(int x,int y)&#123; makeroot(x); Tree[x].fa=y;&#125;void Cut(int x,int y)&#123; split(x,y); Tree[y].ch[0]=0; Tree[x].fa=0;&#125;int n,m;char buf[20];int main()&#123; fac[0]=1.0; for(int i=1;i&lt;L;++i) fac[i]=fac[i-1]*(double)(i); n=read(),m=read(); scanf("%s",buf); for(int i=1;i&lt;=n;++i) &#123; Tree[i].f=read(); scanf("%lf%lf",&amp;Tree[i].a,&amp;Tree[i].b); pushup(i); &#125; for(int i=1;i&lt;=m;++i) &#123; scanf("%s",buf); if(buf[0]=='a') &#123; int u=read()+1,v=read()+1; Link(u,v); &#125; else if(buf[0]=='d') &#123; int u=read()+1,v=read()+1; Cut(u,v); &#125; else if(buf[0]=='m') &#123; int c=read()+1; makeroot(c); Tree[c].f=read(); scanf("%lf%lf",&amp;Tree[c].a,&amp;Tree[c].b); pushup(c); &#125; else if(buf[0]=='t') &#123; int u=read()+1,v=read()+1; double x; scanf("%lf",&amp;x); if(findroot(u)!=findroot(v)) puts("unreachable"); else &#123; split(u,v); double ans=0; for(int i=L-1;i&gt;=0;--i) ans=ans*x+Tree[v].poly[i]; printf("%.8e\n",ans); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>LCT</tag>
        <tag>泰勒展开</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4198 荷马史诗]]></title>
    <url>%2F2019%2F10%2F08%2Fbzoj-4198-%E8%8D%B7%E9%A9%AC%E5%8F%B2%E8%AF%97%2F</url>
    <content type="text"><![CDATA[贪心. $k$ 叉 $Huffman$ 树编码问题,可以等价为每次最多合并 $k$ 个果子的合并果子问题. 这是因为两者的合并树是相同的. 于是就像合并果子那样贪心,维护一个小根堆,每次取出前 $k$ 小的元素合并,需要先补 $0$ ,使得每次都恰好合并 $k$ 个. 这道题还需要让最大的长度最小,所以在权值相同时,按照深度从小到大排序,优先合并深度小的. 时间复杂度 $O(n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef pair&lt;ll,int&gt; pli;#define mp make_pairint n,k,mx=0;ll ans=0;priority_queue&lt;pli&gt; q;int main()&#123; n=read(),k=read(); for(int i=1;i&lt;=n;++i) q.push(mp(-read(),-1)); while((n-1)%(k-1)) &#123; q.push(mp(-0,-1)); ++n; &#125; while(q.size()&gt;1) &#123; ll val=0; int mxd=0; for(int i=1;i&lt;=k;++i) &#123; val-=(q.top()).first; mxd=max(mxd,-(q.top()).second); q.pop(); &#125; q.push(mp(-val,-mxd-1)); ans+=val; mx=max(mx,mxd); &#125; cout&lt;&lt;ans&lt;&lt;endl&lt;&lt;mx&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3211 花神游历各国]]></title>
    <url>%2F2019%2F10%2F08%2Fbzoj-3211-%E8%8A%B1%E7%A5%9E%E6%B8%B8%E5%8E%86%E5%90%84%E5%9B%BD%2F</url>
    <content type="text"><![CDATA[线段树. 对于修改操作,若区间内全为 $1$ ,就跳过,否则就暴力开根. 利用线段树维护区间和. 因为每个数是不会增大的,所以每个数最多被开 $\log \log a_i$ 次根号就被开成 $1$ 了. 时间复杂度 $O(m\log n+n\log \log a)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//%std#include&lt;bits/stdc++.h&gt;#define rg registerusing namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;inline int Sq(int x)&#123; return (int)(sqrt(x));&#125;const ll inf=9e18;const int MAXN=1e5+10;int n,m,a[MAXN];struct node&#123; int mx; ll sum;&#125; Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1]void pushup(int o)&#123; root.mx=max(lson.mx,rson.mx); root.sum=lson.sum+rson.sum;&#125;void BuildTree(int o,int l,int r)&#123; if(l==r) &#123; root.sum=root.mx=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o);&#125;int query_mx(int o,int l,int r,int L,int R)&#123; if(L&lt;=l &amp;&amp; r&lt;=R) return root.mx; int res=0; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res=max(res,query_mx(o&lt;&lt;1,l,mid,L,R)); if(R&gt;mid) res=max(res,query_mx(o&lt;&lt;1|1,mid+1,r,L,R)); return res;&#125;ll query_sum(int o,int l,int r,int L,int R)&#123; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; ll res=0; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res+=query_sum(o&lt;&lt;1,l,mid,L,R); if(R&gt;mid) res+=query_sum(o&lt;&lt;1|1,mid+1,r,L,R); return res;&#125;void Rebuild(int o,int l,int r,int L,int R)&#123; if(root.mx&lt;=1) return; if(l==r) &#123; root.mx=root.sum=Sq(root.mx); return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) Rebuild(o&lt;&lt;1,l,mid,L,R); if(R&gt;mid) Rebuild(o&lt;&lt;1|1,mid+1,r,L,R); pushup(o);&#125;void Sqrt(int L,int R)&#123; int mx=query_mx(1,1,n,L,R); if(mx&lt;=1) return; Rebuild(1,1,n,L,R);&#125;int main()&#123; n=read(); for(rg int i=1; i&lt;=n; ++i) a[i]=read(); BuildTree(1,1,n); m=read(); for(rg int i=1; i&lt;=m; ++i) &#123; int op=read(),L=read(),R=read(); if(op==1) printf("%lld\n",query_sum(1,1,n,L,R)); else Sqrt(L,R); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1229]]></title>
    <url>%2F2019%2F10%2F08%2FCF1229%2F</url>
    <content type="text"><![CDATA[$Div.1$ A Marcin and Training Camp 有 $n$ 个人,每个人有一个集合,用二进制数 $a_i$ 表示,以及一个能力值 $b_i$ . 现在需要选出一些人形成一个大小 $\ge 2$ 的集合 $S$ ,满足 $\forall i\in S,\exists j\not=i,a_i \&amp; a_j=a_i$ . 需要求出最大的 $\sum_{i\in S}b_i$ ,无解输出 $0$ . 容易发现,选出的人中至少有两个人的 $a_i$ 是相同的,即形成自环.否则就会存在拓扑序,至少存在一个不合法的元素. 可以先将有相同的元素都选上. 对于其他元素,只需要判一下能否被那些有相同的元素限制,即找到 $a_i \&amp; a_j=a_i$ 的 $j$ ,内部不需要判断. 这是因为 $a_i \&amp; a_j=a_i$ 这个关系是可以传递的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=7777;int n,m;struct node&#123; ll first; int second; bool operator &lt; (const node &amp;rhs) const &#123; return first&lt;rhs.first; &#125; bool operator == (const node &amp;rhs) const &#123; return first==rhs.first; &#125; &#125;a[MAXN],p[MAXN],q[MAXN];unordered_map&lt;ll,bool&gt; vis;int main()&#123; n=read(); int t=0; if(n==1) return puts("0")&amp;0; for(int i=1;i&lt;=n;++i) a[i].first=read(); for(int i=1;i&lt;=n;++i) a[i].second=read(); sort(a+1,a+1+n); for(int i=1;i&lt;=n;++i) &#123; if(vis[a[i].first]) q[++t]=a[i]; else p[++m]=a[i]; vis[a[i].first]=true; &#125; for(int i=1;i&lt;=t;++i) p[m+i]=q[i]; ll ans=0; for(int i=1;i&lt;=m;++i) &#123; bool f=false; for(int j=m+1;j&lt;=n &amp;&amp; !f;++j) if((p[i].first&amp;p[j].first)==p[i].first) f=true; if(f) ans+=p[i].second; &#125; if(!ans) return puts("0")&amp;0; for(int i=m+1;i&lt;=n;++i) ans+=p[i].second; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; B Kamil and Making a Stream 给一棵以 $1$ 为根的有根树,每个点有一个权值 $x_i$ . 设 $f(x,y)$ 表示从 $x$ 到 $y$ 的路径上所有权值的 $\gcd$ . 需要求出$\sum_{\text {u is an ancestor of v}} f(v,u)$ ,答案对 $10^9+7$ 取模. 一个点到根的路径上,不同的 $\gcd$ 最多只有 $\log x$ 种,因为 $\gcd$ 每次改变时至少会 $/2$ . 于是倍增处理每个点向上跳 $2^i$ 步这段的 $\gcd$ 进行处理. 或者 $dfs$ 时直接把 $\gcd$ 的 $vector$ 数组传下来,相同的数合并,只记录次数. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;ll gcd(ll a,ll b)&#123; return b?gcd(b,a%b):a;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=1e5+10,L=17;int n,ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;struct node&#123; ll v; int t; bool operator &lt; (const node &amp;rhs) const &#123; return v&lt;rhs.v; &#125; node(ll v=0,int t=0):v(v),t(t) &#123;&#125;&#125;;int ans=0;ll val[MAXN];vector&lt;node&gt; G[MAXN],tmp;void dfs(int u,int f)&#123; G[u].push_back(node(val[u],1)); for(auto x:G[f]) G[u].push_back(node(gcd(x.v,val[u]),x.t)); sort(G[u].begin(),G[u].end()); ll cv=-1; int ct=0; for(auto x:G[u]) &#123; if(cv!=x.v) &#123; if(cv!=-1) tmp.push_back(node(cv,ct)),ans=add(ans,mul(cv%P,ct)); cv=x.v; ct=x.t; &#125; else ct+=x.t; &#125; tmp.push_back(node(cv,ct)); ans=add(ans,mul(cv%P,ct)); G[u]=tmp; tmp.clear(); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==f) continue; dfs(v,u); &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) val[i]=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs(1,0); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; C Konrad and Company Evaluation 有 $n$ 个人,每个人有一个工资,初始时等于他的编号. 给出一张图,对于一条边 $(u,v)$ ,若 $u$ 的工资比 $v$ 高,则从 $u$ 连向 $v$ ,否则从 $v$ 连向 $u$ . 有 $q$ 次询问,第 $i$ 次询问给出一个 $x$ ,表示将第 $x$ 个人的工资改为 $n+i$ ,再求出图中长度为 $3$ 的链的数目. 将 $a$ 向 $b$ 炫耀看成一条有向边 $a\to b$ . 记录每个点的入度 $indeg_i$ 和出度 $outdeg_i$ ,答案为 $\sum_i indeg_i\cdot outdeg_i$ . 每次将 $v$ 的工资调到最大,就是将所有 $u\to v$ 的边全部反向. 只要将这些边一条条的暴力反向的同时维护答案就可以了. 通过一些势能分析,可以得出每次修改时均摊反向 $O(\sqrt m)$ 条边. 时间复杂度 $O(n+m+q\cdot \sqrt m)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;ll gcd(ll a,ll b)&#123; return b?gcd(b,a%b):a;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=1e5+10,L=17;int n,ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;struct node&#123; ll v; int t; bool operator &lt; (const node &amp;rhs) const &#123; return v&lt;rhs.v; &#125; node(ll v=0,int t=0):v(v),t(t) &#123;&#125;&#125;;int ans=0;ll val[MAXN];vector&lt;node&gt; G[MAXN],tmp;void dfs(int u,int f)&#123; G[u].push_back(node(val[u],1)); for(auto x:G[f]) G[u].push_back(node(gcd(x.v,val[u]),x.t)); sort(G[u].begin(),G[u].end()); ll cv=-1; int ct=0; for(auto x:G[u]) &#123; if(cv!=x.v) &#123; if(cv!=-1) tmp.push_back(node(cv,ct)),ans=add(ans,mul(cv%P,ct)); cv=x.v; ct=x.t; &#125; else ct+=x.t; &#125; tmp.push_back(node(cv,ct)); ans=add(ans,mul(cv%P,ct)); G[u]=tmp; tmp.clear(); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==f) continue; dfs(v,u); &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) val[i]=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs(1,0); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D Wojtek and Card Tricks 给出 $n$ 个长度为 $k$ 的置换, $n\le 2\times 10^5,k\le 5$ . 定义 $f(l,r)$ 表示只用第 $l$ 个到第 $r$ 个置换对排列 $1,2,3,\dots,k$ 进行若干次操作,最多能得到的排列的数目. 需要求出 $\sum_{l=1}^n \sum_{r=l}^n f(l,r)$ . 对于每个左端点 $l$ ,先预处理出从 $l$ 向后走,哪些置换是第一次出现的,这可以从后往前扫一遍完成. 枚举左端点 $l$ ,只用考虑从 $l$ 开始第一次出现的置换,最多只有 $k!$ 个,其它地方答案不变,可以直接计算. 加入一个新的置换时,如果它能被已经加入的置换组合出,就没有用,直接跳过. 否则,直接大力 $bfs$ 出所有已经加入的有用的置换能操作出的排列,若答案改变,说明这个排列有用. 状态数最多为 $k!$ ,而有用的置换不会超过 $O(\log k!)$ 个,所以每加入一个有用的置换复杂度为 $O(k!\log k!)$ . 时间复杂度 $O((k!)^2+nk!k)$ . 常数没卡过去,不想卡了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10,MAXS=120;typedef vector&lt;int&gt; perm;map&lt;perm,int&gt; id;int n,k,idx=0;int calc(perm p)&#123; if(id.find(p)==id.end()) id[p]=idx++; return id[p];&#125;perm p[MAXN];perm lst,pos[MAXN];perm rep;int S,vis[MAXS],tid;queue&lt;int&gt; Q;int ts=0,pt;int G[MAXS][MAXS];perm p1,p2,p3;void init()&#123; p1.resize(k),p2.resize(k),p3.resize(k); for(int i=0;i&lt;k;++i) p1[i]=p2[i]=i; for(int i=0;i&lt;S;++i) &#123; for(int j=0;j&lt;S;++j) &#123; for(int t=0;t&lt;k;++t) p3[t]=p2[p1[t]]; G[calc(p1)][calc(p2)]=calc(p3); next_permutation(p2.begin(),p2.end()); &#125; next_permutation(p1.begin(),p1.end()); &#125;&#125;int bfs()&#123; ++tid; int res=ts; int st,newst; if(vis[0]&lt;=pt) res++; vis[0]=tid; Q.push(0); int tot=rep.size(); while(!Q.empty()) &#123; st=Q.front(); Q.pop(); if(vis[st]==tid) &#123; for(auto trans:rep) &#123; newst=G[st][trans]; if(vis[newst]&lt;=pt) &#123; ++res; vis[newst]=tid; Q.push(newst); &#125; &#125; &#125; else &#123; int trans=rep[tot-1]; newst=G[st][trans]; if(vis[newst]&lt;=pt) &#123; ++res; vis[newst]=tid; Q.push(newst); &#125; &#125; &#125; return ts=res;&#125;int main()&#123; n=read(),k=read(); for(int i=0; i&lt;n; ++i) &#123; S=1; for(int j=0; j&lt;k; ++j) p[i].push_back(read()-1),S*=(j+1); &#125; init(); lst.resize(S); for(int i=0; i&lt;S; ++i) lst[i]=n; for(int i=n-1; i&gt;=0; --i) &#123; int x=calc(p[i]); lst[x]=i; pos[i]=lst; sort(pos[i].begin(),pos[i].end()); &#125; ll ans=0; for(int l=0; l&lt;n; ++l) &#123; rep.clear(); ts=0; pt=tid; int tmp=1,head=-1; for(auto x:pos[l]) &#123; if(x==n) break; if(head!=-1) ans+=1LL*tmp*(x-head); head=x; if(vis[calc(p[x])]&gt;pt) continue; rep.push_back(calc(p[x])); int newtmp=bfs(); if(newtmp==tmp) rep.pop_back(); else tmp=newtmp; &#125; ans+=1LL*tmp*(n-head); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191007-eve]]></title>
    <url>%2F2019%2F10%2F08%2Ftest20191007-eve%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1/HiUihuNq2Dl9oOxmnwwpRVrKE8ct9/w/XH4BhXJQV5YhpTUeUtAuYMk4yihPTao84cTTrftLawcWxOX7GZkemOGHxX2gIAhl5IoVySQ2bzzqblE5lxpjUdAkbwDh5Nxg+/JA2t9oeuuuRBC40uBCpZfZVCDaZjwKdS4EsPbwtwh0dXO8tomtqutbEeIbWeBLgTXn9f/WXBerRw/V8rfQS0janOnKreugS0oR3MfrztN/M54f7FEBqlx3IGk3vRNb9fe6Gl5hiLxKQkC8DZrOeVPaixngGUPm2tfkx9Xc3w363VCWbIVXwIVhCIxfF6dNuFrl2v5E+ElOJgS/O1ZPPlssj4jDuAeOQsrgQrfzPqxRH3sj+FQTJ1WNs7e1GcSquZDqJbrnZZgSmKdQ1I5iuu7x8WVgd7O3/lCD2O3GtWxCGU/l37gmBNPbQrCdRIXR5Jr42AXMj15nwTTYrTwBcVkS543rGtpEgT2uH3JXItaYhcWB6JWIMsMOMYlT0h/MMV0TWjTcIOFL3+ZzxSmakxAM7HB6+YJ7KdH6yTjLtt0JO27cTu3rKKDKitMisA26y3gUwRo9qAKm3o5YCUw2tu2OGVrtajOLWwS6WLTYFVWRzuiXI/eJJWzCY1n4ASFlQd+4gZL23lmJy35Ec5ccMpP6tYTCdpUwbJcNSdqjPcWBazaRInmfeNaIZ2aMpSn0Xvs6m/HjRUGx+gpIE7Te2upyrBwPaf7S8gYapW69cWifk80RfnAIu8z24Fa5Y0SyLhGLl5w76YEw9qqxHhkqQGq512htkW/Q7PLB+GIGRyR0hhhm6xdk31U6269poen764P8mpID2TxyQ/nJ6b0L2ecaezf5+swUz+V7JUMv3pLL1SOPWjOBGJpwQuAdywQJarWJRMRVBQYdKjfTm/JIx/HhT7vwUAfHmNCCMTVMOKMfdsicjm1N/E5HJ/IvFArKxm79qr6bMEcUAlaLiTBNqWFZkiMtCHAAyt//n+AO5GG/mMpwV9PjtNhzzyNy0z7TJmjJ3un6NOJZKC3w0Tbe2yyHoB+JWlcGhqXGdiZaHQwurLEBMbYRYNI4D64Lq2Iw2xzkzhgQkuA55Bp+EZ7PqNKKTFyESG4FnnAzBZuaPo6xUMw53JYvdEEvYgEZq03+8BuggLQg62O9s3nV3JzjaUiUmQffHKKXD4FxnsggZjwh6qdmiPO3Bi05VZZbkJ6mLqoKrFBP+1Lg06UyD8BetqRsmsaBTq3Z+dYlOJsNwKIuBRTZQ63J/h5d8H2CedLuM6lmMQclSQ8YOB5pN0VFxe0HOfXckqVGwuGSLRKFO24FPRFYZ2urGI1bdsEmWDJ+ceKM68nnyCWkuYf8atJtAgCnpu2xCopD5k4g5iCz3rtWAFA7JkmXfwWa65Ga/L6+NVRcVgTAih94fpJpHHofAfy6y9QLY6Lmh5aeoCsCVkLedTECia6Q/e4tFOSTueVkv/6thXiz6ktFs2Y2dgSLVMmiZ9VzOhoR9/uNufkqovKofCNx1saktsqbLZu/7T9MqKIt4v2abVx4ZBSEwThBGeNGYjJXGbd/DAI2FnM2bll58AdTBFwI0uch/krvETy+gX0AHkJ+0+qUAxKdhh0KHaW02onIO59K4PERR3cMctPGhJGjkLa2IMGofWEPQiEqhkem9uS06CsU2NCIBVg5Gn9jYc+hEF7yBwClGgG+gV024jaYObn6UOehLyGPbFOao97hf/DWRaA== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>线段树</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191007-am]]></title>
    <url>%2F2019%2F10%2F07%2Ftest20191007-am%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>构造</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5416 冒泡排序]]></title>
    <url>%2F2019%2F10%2F06%2Fbzoj-5416-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[观察结论 + $dp$ 计数. 通过提示,可以发现一个排列合法,当且仅当它的最长下降子序列长度 $&lt;3$ . 否则,若存在 $\ge 3$ 的下降子序列,中间的元素需要先与左边的交换,再与右边的交换,就存在了冗余的步数,不合法. 而根据 $Dirworth$ 定理,该条件又等价于这个排列能被 $2$ 个上升子序列覆盖. 从前往后依次填入所有数,设 $f(i,j)$ 表示还有 $i$ 个数没填,且这 $i$ 个数中有 $j$ 个数大于已经填入的最大值的方案数. 转移时,枚举填的数是这 $j$ 个数中的第 $k$ 小,若 $k=0$ ,则表示填入的数不在这 $j$ 个数中.$$f(i,j)=\sum_{k=0}^j f(i-1,j-k)$$容易发现它是个前缀和,$$f(i,j)=f(i,j-1)+f(i-1,j)$$而 $f(i,i)=0$ ,即不合法,那么可以看出 $f(i,j)$ 的组合意义. 它表示从 $(0,0)$ 出发,每次可以向右方或上方走一步,在中途不触碰直线 $y=x$ ,到达 $(i,j)$ 的方案数. 于是预处理阶乘及其逆元后,可以 $O(1)$ 求 $f(i,j)$ . 还有一个限制是字典序必须大于给出的排列 $p$ ,就像数位 $dp$ 那样做就可以了,时间复杂度 $O(n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b); &#125; int mul(int a,int b)&#123; return 1LL * a * b % P; &#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=6e5+10;int fac[MAXN&lt;&lt;1],invfac[MAXN&lt;&lt;1];void init(int N)&#123; fac[0]=1; for(int i=1;i&lt;=N;++i) fac[i]=mul(fac[i-1],i); invfac[N]=fpow(fac[N],P-2); for(int i=N-1;i&gt;=0;--i) invfac[i]=mul(invfac[i+1],i+1);&#125;int C(int M,int N)&#123; if(M&lt;0 || N&lt;0 || M&lt;N) return 0; return mul(fac[M],mul(invfac[N],invfac[M-N]));&#125;int f(int i,int j)&#123; return add(C(i+j-1,j),P-C(i+j-1,j-2));&#125;int n,a[MAXN],val[MAXN],pre[MAXN],suf[MAXN];struct FenwickTree&#123; int bit[MAXN];#define lowbit(x) x&amp;(-x) void init() &#123; memset(bit,0,sizeof bit); &#125; void add(int x,int c) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=c; &#125; int query(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x]; return s; &#125;&#125;T;void solve()&#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); T.init(); for(int i=n;i&gt;=1;--i) &#123; suf[i]=n-i-T.query(a[i]); T.add(a[i],1); pre[i]=i-1-(n-a[i]-suf[i]); &#125; int cnt=n,ans=0; for(int i=1;i&lt;=n;++i) &#123; if(!suf[i]) break; bool flag=(suf[i]&lt;cnt); cnt=min(cnt,suf[i]); ans=add(ans,f(n-i+1,cnt-1)); if(!flag &amp;&amp; pre[i]!=a[i]-1) break; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123; init(MAXN-10&lt;&lt;1); int T=read(); while(T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191004]]></title>
    <url>%2F2019%2F10%2F06%2Ftest20191004%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19tYkaxPKkgkMPRVOCOwk4kRYxxrjNTf+/ZdudtvF71ljxxjggCsXuke8/AX4SMf4ptCtXmfT/Jm1vch7UlLZNLEjlV6BPOhoocJDRQ+0p+9JWjzULKfezhrVxRM58TN5DjQCcQCCbyzWPUU3ppQzGTXp79M3NLZdOWBRu6sFH3X1p4ksL5XWdpEX2h/3mlQqsqNqO6c9LSDZF7Y1b1kV1yF2RgRgFM7Hb+V5m1TEIXiDehrdnXL20OaAoaQGezuEssbvV9QGWhnRIoBjNgrb1B5dZ6P1SG4P57LlAJI5xMk0Juj5sjGbcPgiP9jEy5CZ8boGh3YdrIRMXIIKyTeBZuZ+n2yORmNtFXl/sfw7ENgTZEDHwE0ZWSZvmteFH2g9aIoqMUCmiGY8gcW7M7kV1zmRXcuV/r06Bdzg+fr2JajLVYTSHx+pxc3UDyR2P/7I0oxEwuq/H3MuFG95BMgIocreHQKL7UYPCL5oBvpuowZLXHNGnqgzFmYWQsfK+o3VInHOynDp6shDLcSXOnz7jON29ZpyTETyx9kH5/i80hhQJyuCXUmKJzqNwUFcqKRCBOfVWQfNiZETORDXFQyaAz0jMLfRsG5ISYaXDf0/GjHBgZ15wIl15q17+PVXYlQ8CjsSNqUkYZOLE+nRWxj3R0Xpf8E7plfnxxkxGYdfKbWSpnnyhi6A1XfIS6PPndtw030kmrfZpHwtezqXxsgXGt0mMgROu5ILm/F5/AWtB/yFcj6jvx5R68b2DdoR6gxFtVSmIBSvH8aipFiooQKxdjCz48Uwo8QQWCITt9HeKjpifHZ3nipY4HQx4qU4ic3fPqxnDpO+CJAyqXESat+kDDY7+3fpbHY6hNnplYvFSD1sYyRG2+Ce98BzSuBRej/vkabs1wQJEkMaLwcKYm6XS5AdGDbPJKtVG2m4hPKRECp6GTIpo/mTMD98YOl95zV9bzJxpPiMC5225+OsKLorBvaxoSk83QPNpBWyG4tycJ3pEynqfLpGjkMZU5XKB39nNGwEOwdsDxV5zoKX+UulaBZ5UTMfqiAxixoCCrSwrSap/1uRAcEmaz4s4/br0B4jJZnchGovE10U5XJPnyP8S7dLokncPWatvsTWsOnW6uqRe8uhGEbsgr+P8yUIMrNb8Gr7hn+vnx6ik6XddhyG5s6441kb5nOTjA5BIOtMVs4vOAX8pQI0T5 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>meet in the middle</tag>
        <tag>test</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191001]]></title>
    <url>%2F2019%2F10%2F06%2Ftest20191001%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>概率/期望</tag>
        <tag>矩阵加速</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1228]]></title>
    <url>%2F2019%2F09%2F30%2FCF1228%2F</url>
    <content type="text"><![CDATA[$Div.2$ A Distinct Digits$l,r$ 比较小,不需要数位 $dp$ ,直接按照题意模拟即可. B Filling the Grid每个 $r,c$ 都可以确定一些格子的颜色.如果出现矛盾,答案为 $0$ . 否则没有被确定颜色的 $k$ 个格子可以任意选颜色,答案为 $2^k$ . 写完直接测第三个样例,就交上去了,把 $C$ 写了才发现 $B$ 没过,没判无解的情况… C Primes and Multiplication$x$ 的各个质因子之间贡献独立,分开计算. 一个质因子 $p$ 的贡献显然是 $\prod p^{n/p^k}$ ,注意判断是否令 $k$ 增加 $1$ 继续循环时,需要用除法判断,否则会爆 $\rm long\ long$ . D Complete Tripartite先随便选一个点 $x$ ,尝试将所有点划分成两个集合. 将 $x$ 加入第一个集合,若 $y$ 与 $x$ 有边,则加入第二个集合,否则加入第一个集合. 然后再在第二个集合中选一个点 $x$ ,将第二个集合划分成两个集合. 若划分后出现了空集,则无解.最后需要判断一下集合内的点是否没有边,以及跨越集合的点对都有边. 可以枚举每一个点 $u$ 和它的邻居 $v$ ,判断所有的 $v$ 是否恰好覆盖了 $u$ 所在集合外的所有点. E Another Filling the Grid直接容斥,枚举有 $x$ 行 $y$ 列一定没有 $1$ . $x=n$ 或者 $y=n$ 的贡献只能算一次,因为它们都是覆盖了整个矩形,而其他情况显然都是互异的. F One Node is Gone注意到删掉一个点后,根节点一定是直径最中间的两个点之一. Case 1若删掉的点是根节点的儿子,直径会 $-1$ ,就可能产生两个答案,且根节点为直径最中间的那两个点之一. 还需要判断它们的子树是否都是满二叉树. Case 2删掉的点不是根节点的儿子,此时直径不变,为偶数,只可能有一个答案,且根节点为直径最中间的那一个点. 可以将剩下的树遍历一次,对于度数异常的点进行判断. 若度数为 $1$ 或 $3$ ,那么这个节点是正常的. 若度数为 $2$ ,那么被删的是它的儿子.只需判断它剩下的那个儿子是不是叶子. 若度数为 $4$ ,那么被删的是它的儿子.需要判断它的三个儿子的子树是否都是满二叉树,且高度为 $h,h,h+1​$ . 若度数 $&gt;4$ ,显然不合法. 若有多个度数异常的点,显然也不合法. 判断某个子树是否为满二叉树,可以对树 $dfs$ 处理. 这颗子树为满二叉树,当且仅当它是叶子,或左右儿子的子树都是满二叉树,且高度相同.]]></content>
      <tags>
        <tag>构造</tag>
        <tag>codefoces</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190929]]></title>
    <url>%2F2019%2F09%2F29%2Ftest20190929%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Comet OJ 模拟赛Day2]]></title>
    <url>%2F2019%2F09%2F28%2FComet-OJ-%E6%A8%A1%E6%8B%9F%E8%B5%9BDay2%2F</url>
    <content type="text"><![CDATA[昨天忘打了,就只打了今天这一场. $reorder$像归并排序那样直接贪心就可以了. $prefix$把 $n$ 个串搞到 $Trie$ 树上,利用 $dfs$ 求出每个串的排名. 然后就是个类似于康拓展开的东西,用树状数组搞一搞. $monotony$ 一上来就口胡了个做法,写到最后一步的时候发现不会做了. 暂时先咕了.]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>树状数组</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190928]]></title>
    <url>%2F2019%2F09%2F28%2Ftest20190928%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19OFprFsC1MDN8YZvnXSelo8WrMfzqHb3J+xoxuxVp9qgT10W3ctN9JqoOhVMkr0UUXllA3BGFpp8pb9MNUDW3hJ9fF+B5RmTO2eoe30H8X0MY8Dv/fPdzmtxFHyusM5Bdu9KbXiRgANu+VmfuT9KVekuqYrqdtwCpWaKJlmYAVXsBN5IyivC2t8QSKWVd2wi1dEsEpkZ08GfjPXCE7Gt60+yHEGDZjo/7Jk1OenAAKcBVeOBsuMGxX8cNB8/BOsT5edV1tloNcWIBQhu+sxFA3Al0gdu+uShcXyGoGW0SDh9yTzQbcRnsSNTPLGFKkXdLxfu+/94KxRUIs86PzU0jcmclzBMaGohKOd674COqLNduCdJ/F8b2pAAppItL3A2OiDDHbI2CqBEIwjTmzbq/9GJ128Ath/XnA5qvstkoVy1VnWQ2uhFmrMkZJYA8UF8YDV9MYwQpCQuQGmaZM84nfE7UkjdSQ/rY7ButjID7mVk2Ju/Cy22+E3WjgG5Xw9aVLDeAtMl0pHZp79UfeeY86VJ4zuHv94hU4xYTrN8xYiH1jgv6vVbGX88VUD5i9EAtGLHwFoDmj2yJhZ9mpCT3hjmrsAHKgzuSvZ5nwbjT0n91lISuE+9Pei4s/5FdA8jyfp/e5fwKRa7CAks60nkLaffNWdSWsafdeaa2DUeOkuFbMwq+bSYtZO+GtVUD+yg2ljxn3tigDKlhpN20nE3y+LHWm7dHRCgZPUgNA65+myYABpqX5KJsZqDdwIu6u7mc2bBWW66fedh4u6IToGm0644u9qhLqG/5MDZ8HwyZ9dG9nGy5lBMzPsiYj/tvIR3DIgsPYE/wbsqel5iNj7MFPkh36tEJkhFMOCiIL4pxlucSrLCjqTYQnxfqr8spoUqix6ja7gzQlIrKaGxlaxN9C83rqXczY8d9HleQVF4hXLFzkxPoE1Go1adEAQjNvWwYGohnTWmZUUCbhDFltC5JvNiWBowrXVytrBsLksaGr3M+MAg38vuUwGmka4TxQ+etex2oRSQ6AkCVT0KCNOk0qQugbQpjr/doIw1i8a4EMOyYNxEkcFgMLpSWcmI3JK+660f3EZTol7MbewvvAnKhTZiYGS2uzztH3ZqPGNJgo2k9z49Nk2lRBkegw0/PDJh+CsIM9HT79lYJzKqSFhxGSzikg7AIpeTv6Vby/Ti06GtdN380ToGcOBx90cJAYrHa6HOkjQT52dlxqMl7CO55VszM8+G9J2uwt0pPkZIyWZ+/RuP5Dwqvwi58juV0psW1y8GFF4i0EIdH5UL60Uhzw1aILxTNKhYKHhUAvz4bz1DXBwbOwBCi7AJ1A3oGM+jONA//QOe7WQQsHMbLsHDQVOlIgh00nbaHb8wE5dwxv+VYHUTM6e6LmHZQckK/ap4sXAgvg6TqJGz+7LunEURbfiTdXgBledry8veZKwJKX6thkDhttaHd4szts0+AbsDXX1D9O+whC/R1kDbEZPYKMjrb+F+PUBt2bMB0Df87cLAJH/dWFZ+pu1JkONMbLQ/rRzhQMhmLjYSNxMwU2s6F2yYfPQCLZ+Uo9+/QXQ+3a0osUOR5lCHt3qOKf7m42c2h1zqTidpJLmafHGmJo9BVffF0SeLijlLQ2Fe2u4Yid6pYSOf0+XSrN5GE0Cts2HO9T+HP1NJq9qfbRK+4Ue/Th472SIaH4eCW6CGUABOgZBsDl3Za3rMGME7/LegOUQaUdFzn57uzwKkwWJF0WxfDV7cOAlEuiXtUJ4ZLkpH3D/+gVo/0wxgPPelJqJjLPbF4nWP4+MRyHEi1Xy4UDqFFRj0AicNeIHgGy2xNYhUHKpScbcNm7ta7jUvUhE4YHbYBo4HX+YcZk9rXJxgmtmVFHKmmGPPKZi99UNMMxVCpIJ63sTS8fY8SEfFZ3q9d7mWDqpy5nbLwvWNAYCd5NseDXW9F1T98dyGwan7XU39g55q69IULFSVEvy4puExhU7TheC5y/U9pEY9HhiDLmpVR/Su6tDbxwsOoXR9lHximpsKo1T8cjy1XUwNH5GwI3Po27eQLyk4NlB1iSXTFDIiTxcWO24Ol9oyxFcWnjhsfriIRYtG4DyOhLi2uNda2NXwvnnx/U7Dw0O6p7p3aRUiz0kWXfUtO36dW5+pSviZMz2GcgGj6OmIqqLzNFXFFtrWt8b22VTafhdJ8EALidSUWj9nScDRSfAmUi3LzaW3F+balvvYzkAIE2K4RLmwmyAI+KCik0WrtJBFNFEbvPf3/pJZ+5OxNJgZyITdz71vP5FMXrmhwzwxEbNVswrlkkb70J/0j+pueKxSXxtwMB5OXRMsPAE8F17GkzpcuZPpEfksm75hMk96OWDQl30sVSdk8reqCtD7pgK8rZbHgZKwi+Xi9KFFkVmi8xHf25ytaX5UlmuGhK3LwRmftKoaCCbD321DBLP0bwB29vjWvvKlRHsxJVoEZC5EmJ/38F44eKVprEsezzMcyDg9sNpRgtLCYiFzsjyz8q9TEAgEzB7mBLw6uGXt5UchaS8ZEJry+0ogzaKFl66r7XI2yd87T0MVx3FfRVGPr0i4n+LZKk60m2uK1azhXXDncACsYhrhQTy0NH4kcyVnBmVfGamXcbPWEdCOobPHBiHhEHlWiaML1gm0EF7LddMoFP0OXqIuMdD8qFMG5fRp/qldgJma0Qncpc1SCot4+rYGzPFIirzYQ/2O89APJ6zHK86GHyMmH4lPHp7qf7ryGsrfUwNdI6dvZQXMuskKifw03Tu6tgIQFPp1GrOgr8EwFuifcMNjew5DOa/mFxPrKzi2ITY0FfvRXU25p1ZZkZ9BTDZM4FJXKcN6Wx81f2vnaLM36Y6HijiEGO6WImmYIHAosKXHL8tehSQK9FdT73zbTMHjb53LRf3ebjvQUmqeOLntoh2zW7B9Re+rUwg9Bo var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>线段树分治</tag>
        <tag>高斯消元</tag>
        <tag>暴力</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190927]]></title>
    <url>%2F2019%2F09%2F27%2Ftest20190927%2F</url>
    <content type="text"><![CDATA[修数据场. $decoration$对单调不降,单调不增分别用树状数组维护 $dp$ 值. 转移时注意相邻两个元素相等时对两种序列都可以产生贡献. $path$从高位到低位贪心即可,用并查集判断只用当前这位为 $0$ 的边能否让 $1$ 与 $n$ 连通. $multiplication$判掉无解的情况,然后 $tarjan$ 缩点后在 $DAG$ 上 $dp$ 计数.]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>树状数组</tag>
        <tag>tarjan</tag>
        <tag>并查集</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190926]]></title>
    <url>%2F2019%2F09%2F26%2Ftest20190926%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190925]]></title>
    <url>%2F2019%2F09%2F25%2Ftest20190925%2F</url>
    <content type="text"><![CDATA[$CF\ vp$ 场. $per$用所有的方案 $n!$ 减去 $a$ 单调不减的方案,再减去 $b$ 单调不减的方案,再把 $a,b$ 都不减的方案加回来. $medium$记 $pr=\frac a b$ ,单场概率确定的情况下,答案只与点的个数有关. 设 $f(x)$ 表示有 $x$ 个点时,游戏总场次的期望.边界有 $f(0)=f(1)=0$ . 强连通分量在缩成一个点后,最终会形成一个 $\text{DAG}$ ,所以缩点前,一定存在一个出度为 $0$ 的强连通分量. 枚举这个出度为 $0$ 的强连通分量的大小进行转移.$$f(n)=\sum_{i=1}^n p(i)\cdot g(n,i)\cdot (f(i)+f(n-i)+i\cdot(n-i)+{i\choose 2})$$其中 $p(i)$ 表示 $i$ 个点形成强连通分量的概率, $g(n,i)$ 表示从 $n$ 个点中选出 $i$ 个点,被其他 $n-i$ 个点打败的概率. 注意到枚举时有 $f(n)$ 转移到自己的情况,所以要移项解方程来计算. 考虑如何计算 $g(n,i)$ ,枚举 $n$ 是被打败的 $i$ 个点中的一个,还是 $n-i$ 个点中的一个.$$g(n,i)=pr^{n-i}\cdot g(n-1,i)+(1-pr)^i \cdot g(n-1,i-1)$$考虑如何计算 $p(i)$ ,仍然像计算 $f(i)$ 那样,枚举出度为 $0$ 的强连通分量大小.$$p(n)=1-\sum_{i=1}^{n-1}p(i)\cdot g(n,i)$$时间复杂度 $O(n^2)$ . $easy$把每个套娃看成一个点, $a​$ 能套住 $b​$ 看做一条边 $a\to b​$ ,权值是产生的空隙大小,即 $a_{in}-b_{out}​$ . 直接连边的复杂度是 $O(n^2)$ ,把套娃按 $out$ 排序,每个套娃能连向的点是一段区间,可以线段树优化连边. 从 $S$ 向每个入度为 $0$ 的点连边权为 $0$ 的边,从每个出度为 $0$ 的点向 $T$ 连边权为 $x_{in}$ 的边. 那么要求的方案数就是从 $S$ 到 $T$ 的最短路数目,图是 $\text{DAG}$ ,可以直接记忆化搜索求出.]]></content>
      <tags>
        <tag>概率/期望</tag>
        <tag>test</tag>
        <tag>线段树连边</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190924]]></title>
    <url>%2F2019%2F09%2F24%2Ftest20190924%2F</url>
    <content type="text"><![CDATA[乱搞场. $func$考虑推式子.当 $n&gt;m$ 时,有$$a_n=n-1+\frac 2 n \cdot S_{n-1} \\S_n=n-1+\frac {n+2}{n} S_{n-1} \\\frac{S_n}{(n+1)(n+2)}=\frac {n-1}{(n+1)(n+2)}+\frac {S_{n-1}}{n(n+1)}$$记 $f(n)=\frac {S_n}{(n+1)(n+2)}$ ,得到$$f(n)=f(n-1)+\frac{n-1}{(n+1)(n+2)}$$分块打表处理 $\frac{n-1}{(n+1)(n+2)}$ 的前缀和即可. $ill$考虑写出一个集合 $S$ 的答案.$$\sum_{i\in S}\frac{p_i}{1-p_i} \cdot \prod_{i\in S}(1-p_i)$$记 $x=\sum_{i\in S}\frac{p_i}{1-p_i},y=\prod_{i\in S}(1-p_i)$ . 考虑加入一个 $p_x$ ,答案会增加 $p_x\cdot y\cdot (1-x)$ . 可以贪心地将所有 $p_x$ 从大到小加入,当 $x\ge 1$ 时退出,得到最优解. $mask$经典题目. 带修莫队,二维数点,分块 + 树状数组都比较可做.]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>莫队</tag>
        <tag>打表</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4151 The Cave]]></title>
    <url>%2F2019%2F09%2F23%2Fbzoj-4151-The-Cave%2F</url>
    <content type="text"><![CDATA[结论题. 以 $1$ 为根,预处理出每个点的深度 $dep$ . 对于一条限制 $(a,b,d)$ ,满足限制的点中,深度最小的点一定在 $a,b$ 的 $lca$ 到根的路径上. 设这个点为 $x​$ ,则 $x​$ 需要满足 $dep_a+dep_b-2dep_x\le d​$ ,可得 $dep_x\ge \lceil \frac{dep_a+dep_b-d}{2} \rceil​$ . 考虑所有的 $m​$ 条限制,可得 $dep_x\ge \max \lceil \frac{dep_a+dep_b-d}{2} \rceil​$ . 记点 $p$ 为所有 $m$ 条限制中, $\lceil \frac{dep_a+dep_b-d}{2} \rceil$ 最大的那条限制对应的点 $x$ . 有结论,若 $p$ 点不能满足所有限制,则一定无解.于是判断 $p$ 是否合法即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int ecnt=0,head[MAXN],nx[MAXN&lt;&lt;1],to[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int n,m,dep[MAXN],fa[MAXN];void dfs(int u)&#123; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa[u]) continue; fa[v]=u; dep[v]=dep[u]+1; dfs(v); &#125;&#125;int a[MAXN],b[MAXN],d[MAXN];void solve()&#123; ecnt=0; memset(head,0,sizeof head); n=read(),m=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dep[1]=fa[1]=0; dfs(1); int mx=0,p; for(int i=1;i&lt;=m;++i) &#123; a[i]=read(),b[i]=read(),d[i]=read(); int tmp=dep[a[i]]+dep[b[i]]-d[i]; if(tmp&gt;mx) mx=tmp,p=i; &#125; if(!mx) return (void)(puts("TAK 1")); mx=(mx+1)/2; int x=a[p]; for(int t=dep[x]-mx;t&gt;0;--t,x=fa[x]); dep[x]=fa[x]=0; dfs(x); bool flag=true; for(int i=1;i&lt;=m &amp;&amp; flag;++i) if(dep[a[i]]+dep[b[i]]&gt;d[i]) flag=false; if(flag) printf("TAK %d\n",x); else puts("NIE");&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4195 程序自动分析]]></title>
    <url>%2F2019%2F09%2F23%2Fbzoj-4195-%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[并查集. 把所有 $x_i=x_j$ 的 $(i,j)$ 用并查集合并在一起,再对于所有 $x_i\not= x_j$ 的 $(i,j)$ ,查询是否在同一个并查集中即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;struct edge&#123; int u,v,tp;&#125;E[MAXN];int n,val[MAXN&lt;&lt;1],tot=0;int fa[MAXN];int Find(int x)&#123; return x==fa[x]?x:fa[x]=Find(fa[x]);&#125;bool solve()&#123; tot=0; n=read(); for(int i=1;i&lt;=n;++i) &#123; val[++tot]=E[i].u=read(); val[++tot]=E[i].v=read(); E[i].tp=read(); &#125; sort(val+1,val+1+tot); tot=unique(val+1,val+1+tot)-val-1; for(int i=1;i&lt;=tot;++i) fa[i]=i; for(int i=1;i&lt;=n;++i) &#123; E[i].u=lower_bound(val+1,val+1+tot,E[i].u)-val; E[i].v=lower_bound(val+1,val+1+tot,E[i].v)-val; if(E[i].tp &amp;&amp; Find(E[i].u)!=Find(E[i].v)) fa[Find(E[i].u)]=Find(E[i].v); &#125; for(int i=1;i&lt;=n;++i) if(!E[i].tp &amp;&amp; Find(E[i].u)==Find(E[i].v)) return false; return true;&#125;int main()&#123; int T=read(); while(T--) &#123; if(solve()) puts("YES"); else puts("NO"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4543 Hotel加强版]]></title>
    <url>%2F2019%2F09%2F23%2Fbzoj-4543-Hotel%E5%8A%A0%E5%BC%BA%E7%89%88%2F</url>
    <content type="text"><![CDATA[长链剖分经典题目. 设 $f(i,j)$ 表示子树 $i$ 中距离 $i$ 为 $j$ 的点的数目. 设 $g(i,j)$ 表示子树 $i$ 中点对 $(x,y)$ 的数目,其中点对满足 $x,y$ 的 $lca$ 与它们的距离都为 $d$ ,而与 $i$ 的距离为 $d-j$ . 借用一下 $\text{Bill Yang}$ 的图片. 直接暴力合并 $u$ 与它的儿子节点 $v$ 的信息,时间复杂度是 $O(n^2)$ 的,只能通过原题. 注意到维护的下标是以深度为下标,利用长链剖分即可做到 $O(n)$ . 合并 $u$ 当前信息与它的儿子 $v​$ 的信息时,转移有,$$ans+=f(u,j-1)\cdot g(v,j)+g(u,j+1)\cdot f(v,j) \\g(u,j+1)+=f(u,j+1)\cdot f(v,j)\\g(u,j)+=g(v,j+1) \\f(u,j)+=f(v,j-1)$$利用指针移动实现空间的高效分配,以及继承重儿子信息. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,ecnt=0,nx[MAXN&lt;&lt;1],to[MAXN&lt;&lt;1],head[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int mxdep[MAXN],mxson[MAXN];void dfs_init(int u,int fa)&#123; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa) continue; dfs_init(v,u); mxdep[u]=max(mxdep[u],mxdep[v]); if(!mxson[u] || mxdep[v]&gt;mxdep[mxson[u]]) mxson[u]=v; &#125; mxdep[u]=mxdep[mxson[u]]+1;&#125;ll *f[MAXN],*g[MAXN],tmp[MAXN&lt;&lt;2],*id=tmp,ans=0;void dfs(int u,int fa)&#123; if(mxson[u]) &#123; f[mxson[u]]=f[u]+1; g[mxson[u]]=g[u]-1; dfs(mxson[u],u); &#125; f[u][0]=1; ans+=g[u][0]; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa || v==mxson[u]) continue; f[v]=id,id+=mxdep[v]&lt;&lt;1,g[v]=id,id+=mxdep[v]&lt;&lt;1; dfs(v,u); for(int j=0;j&lt;mxdep[v];++j) &#123; if(j) ans+=f[u][j-1]*g[v][j]; ans+=g[u][j+1]*f[v][j]; &#125; for(int j=0;j&lt;mxdep[v];++j) &#123; g[u][j+1]+=f[u][j+1]*f[v][j]; if(j) g[u][j-1]+=g[v][j]; f[u][j+1]+=f[v][j]; &#125; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs_init(1,0); f[1]=id,id+=mxdep[1]&lt;&lt;1,g[1]=id,id+=mxdep[1]&lt;&lt;1; dfs(1,0); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>长链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190922]]></title>
    <url>%2F2019%2F09%2F22%2Ftest20190922%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>贪心</tag>
        <tag>树状数组</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190921]]></title>
    <url>%2F2019%2F09%2F21%2Ftest20190921%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+QyLbEXhbFnOQlXpcPyUIa6E6Mvd6mXhTEhsftCbrXhTts5qT7dmBIBRLlMjm6o7ozlyaiS+JKA1omZ8E+pus2xP1nHK7T50f462XRgzttqWIYr618pzc03nvOIQQaPg8hS+JgNKH6iSSgCAqm6pyreRFrQPJ8CjAn6iVR68elYEU/upySHxj+/7UVdFuRS0KNgCl58/3qtSD9bRBCmbusvwroyH5/EltdDpkqbn9Z73t8Wclgf8wXysKr6kyUiwfTHTur6qJfoca3CBUCs5GkWNPCTMsu70srhYjr4U5YdiKnxlE60ytY+wPfnZhSR8sbAIaJ0pC7TehuiLDckMUoHAqR/vIRpqN8RtCIb/d+NcIQ/BOMAB6kEbIHw7JtVyIJ1dURAEIdiCYoTnZi5hBEnnbLQfigWJN+OwS+VKBq0aCTHo2HJam7PcedR9M2sPisLsE+72CDdp3eWCNtq3W2iJVXkEtebcZdjk35ZiZ3iJL1M0Pm0R32IJNUw2jkCewuFGrunabvUSBpE3aehi1OWr284NyGLGBtOMsomlD/H8yhIBJw7DkkAfx3C0lZiyerg3tR3nOA8TSYXTGxEJPF28hz5ue1lBIagA5k47Z0f0YSmWU07Mwfgv9b2jME9A6Bb3aD8k5MmOUiAaSbUx9PXMDax6D+ubT5Sx2TuKf+3QjI0mbeoHPdsTeR6kaMPZiYt+9L/jxuIlUgeENizCAXtPZzQUCzBoU6zi+kqmvVxUTLhz+vxR8VufZgaDaiXB4UGAaVDsNGcpMofAmL9KeV+es3xMm2lr0k1H8iSff7GS+Aeh1tSPm5vMu2amFHbFwdNCuODBWkjidy0PvluPdlmkdNzNNlHJbod4wk/XTmDGpcUyEo3EZeoCRUkSZX7IG5j1GSUy1I04fJ2vjtHIkt92qiJ/RB32hNTVVCayI9empiy3I2mqTdqguljaSw6U2ZUgFJoKYCqtE5QpWHZiQQ7LLK++WHDk1OSzs4MlfVn1ICWbxq76eD+tz23H9cM9Ic0/Srl3c8zTa+YKjIn9pnu5AVeLrY99FAfvRX6G3Y0pi4G/MHcB1Aeus+Q3ybyeibLpqzCH8rrzeBLh28BEbgHir4CBJhXD9Flr2tC5CTtdbrQ3Q9ohacQI/gnhy6yRkA1KIJhW0NQ61VRqKQi/HCsIHJoThVhCOJlZxbm/l5ISSRi0eiuxzJdNubiPvq2dcIq8n2s5NElMTzlyAFg6YaW5SXisn23jt86QhNLssACZ8+pk7GE9J0L8FnOzNuwABFtqdx0wRkgZ3FJ/WeMzDrL8Qn6DU2LCtNJdtZ5ocBNR5dLdyBT5yGEL7l7w1zAkwZYnlqznLJPvzxQ3zD+IklxaSGl/VI7fEVbkdXO5x/Ev5RXol5MUfWe6XNSGCPPP1psmVGpGmywA== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>树形dp</tag>
        <tag>dp计数</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190920-pm]]></title>
    <url>%2F2019%2F09%2F20%2Ftest20190920-pm%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>树状数组</tag>
        <tag>容斥原理</tag>
        <tag>数位dp</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190920-am]]></title>
    <url>%2F2019%2F09%2F20%2Ftest20190920-am%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+1OI2mLiunUeUHvepbvzMBxshDp5pCw5fVxRsIZWjhZn7PcY53pikICzlGQf79XgjLA9m40L7/CE41fTxHjfe+Jg3TbWDFGbBdJyB+WB8ZExZuUePtpAEWg/fDhN9jXwVHyP/k+uAk2dDrcHZNQQwuONSNVkxg8LIhTpQTciSu4RS4dPQt+nJ28viSfDFUQEwvb0Nt8wD5Bg4lIl4cph66Na0i6Gcjh05uULRZ7daBP7GbpZ4BSfEZiFrzejwnQx9A8u06v0PW2iPnx5KfXwBL6ngsW2tjaAalGg6fk+U7ZWLiHBT/Z7Edw1Ngl1jHRd4eYRKNwDAdFxJyREZGCOaxS29NOSuwrh4KWA1sSISpEU3gAfiWaWXUrteeeLshsVqfNLiUfiJB9HqjwGMISaQ2BcJuj/ZWD2dSzNFUdOkTBQeV3r6RhFI/z45Xhu5wzLDkYKnnoTuAyGZSZqTlWbKfTM0PAAXXdUl0UhgNRkFXNkjyyiV4QzCX62iW1oyG+FVhtRd/NJf6az7ImRzcOp97OLJ+07cI/U/C+iRy5PB6GLQRsBL3quk0udR7vH/ecHFAQmyiANh2KVbfji9efprYQR6xvnzNAeXKwOzg22uM7Uoq/FNI1Lw/ var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190919-pm]]></title>
    <url>%2F2019%2F09%2F19%2Ftest20190919-pm%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>test</tag>
        <tag>李超线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190919-am]]></title>
    <url>%2F2019%2F09%2F19%2Ftest20190919-am%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+3kx7lytwxAAcMQKuQU/kGrz8eMzUkfRI10gS5WCM2ZI40EeKFocHnOpYrTiBMcsi82k1wmwaXJgmZiB4ll3UnoRCtuAR+4dfqCNnpKBpOmdBqxvD3zPrXlf15hzKicnIAk381xqqPCtIfsDxdSX8dJcwNRWx/lGmKj39X/6+rhEjc2mF1X1MzIZ7Q3MFfoxzelKJAs/EaO2J9dvWuEeRnFQUNWSQrtPcpKEuUjDiQpGlG7xbjQ+jOFDbUC1wYK6o8jgaoDaNHu3VsvBuzKPksHVxOWmns7tK8sYK82ux/Il6jZZkxS+LaWGic/hMlBymHb/IiLodaB/8xxHswOwhQq+vID4z2uHDb+bMpFBGear0UOhqflwJj5xHPqvYWhfAJEiwhLK1dPs32u3+TEaU7cPn6Xt/Z8fwThCsBfx+kaem6Vjotgp9VmkGVM33DB4EOn3H+4BjWi7kEGBoTA6s9EjZVd/HoQy7pjWtAA5UUr052pLjy+oOW41o6wW1bhmnn3jd0nJAyU0ujVSpKP8n2wbWoYHqysWI9foyeSeELlpbns+Q3jJPG8MuCRcVobCCneiXSkNnWIJGokEG6TI/0aYolHnH8GqbIY+tqBusRk5GVEo3Je7Mp+ttNwW+lYNo2D3bDUN3MXkSEqDFLdHSJYJAIli/honfyEnjFCj+qIcMPu38JD7bYQMiX+p3tJQfMRwIFmrxWLIsvosaPliOaCbkxEebUDKIr+U+xhaoFx9bUjqJxnxCpZmXELe/vdE6LvLCIQYk/Ew1rl9qTm3EbYiVZuLSfnCufuAiA7lBtl6ZMAEhtwxDkgLXSWoZayu/wzcRcPVZmZyErV1dKwm/wFmUZ6W98uqhF3vdRvNwv2In8FDHA1+dc4CoLNc7DqIybCLJRehBVoRg8QzuSgj35NBuiq8MDWC+sq5QXRM1do2dRS0Cpdr+YX6KdwcPv98yaftZ2qSgj3ecHmwN87nghmdkySpc5vXYYzfhnmfRGI76kSsiae65bTC0rM6fQVFQLhG0lodfBZsWpmNHfnzXQsJGLWWaMs+l4MCrfve5G4X40iANtEmsuVc4bojkgWS81OG+dvB518l8WIBeurab0jYmIZDIH4qX7RPgKCiNy+XyTemF5UyEWxk9grQ7jjbJGKt+BWs0EqTUVZg6DXtnEQQ5pJoGYa+UD3IYZgzWPDZ/95zLRKDR+BW5bct1Fm3ngR7ILd+d1TWA5wygADM5RtsBdBDhygekOBySI7zzPu9/8dq3dUhlNEGxOPFA5Fwg2hLC5MEbkZ/oaV/AKq72LGV2kSqsv/D/Ukdsa4KIHcOUr95Kqs7IQcgMJ2vPlwLQTSnd5Tj8hWJ6PPXHscA3UkxBujCMcxwtGr5EjuZ5/RtRT7j52N5PZBwlRHH4PY/wF7sWWj6/qka0IK/xXX9yT3rrUuHAiRRGHbR+3BZQURYm7FNCNztTNBUvfrnSV70WEaHmeRHidOOuZMqNpo7ibUDuvRZB5FQ4skAKVoxcGvmi851aUiJZ+P5EQNhZ0HFTO8Tz7lBQ1wnBqx+42k4rs2/k2Pfq7WA4aYR36amF4tdr+qJPXzlx9RIjTJ8Vzh97jKYH5GOhmb89LTmaUXYXTxqrIGU4z82gCFs0RQAOttO1/VnyE5agYwbZJfuZ07k53yQiugdX3BRRFRKhSd8CXPZIyNChz5bT7B4RUKWooxvVuyz02cpyhOzM3rTkU7YbPsbNcLbnV4CfHQcdLnpQU5bQ+A9up3SXhdO0sZTA53HYddSetSwJI5JJrvhkf7rjOinkXof9e6iJDuQJdE0Mo821+d3cDyv2YVYnLFP4awbA6uFlotr1n41UL4rt4AMsU1MfvtoMTZNpVV+xwyHuCtqhXWC3XukY= var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>贪心</tag>
        <tag>博弈论</tag>
        <tag>树状数组</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4897 成绩单]]></title>
    <url>%2F2019%2F09%2F18%2Fbzoj-4897-%E6%88%90%E7%BB%A9%E5%8D%95%2F</url>
    <content type="text"><![CDATA[巧妙的区间 $dp$ . 设 $f(i,j,l,r)$ 表示最后一次操作将 $j$ 删掉,且最后一次操作的最小值为 $l$ ,最大值为 $r$ ,删掉区间 $[i,j]$ 的最小代价. 设 $g(i,j)$ 表示以任意顺序删掉区间 $[i,j]$ 的最小代价. $g$ 的转移是枚举最后一次操作.$$f(i,j,l,r)+g(j+1,k)+A+B\cdot(r-l)^2 \to g(i,k)$$$f​$ 的转移是枚举用来更新最值的数.$$f(i,j,l,r)+g(j+1,k-1)\to f(i,k,\min(l,w_k),\max(r,w_k))$$需要注意两个 $dp​$ 数组的初始化以及权值的离散化. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;void upd(int &amp;x,int y)&#123; x=min(x,y);&#125;int sqr(int x)&#123; return x*x;&#125;const int MAXN=51;int tot,val[MAXN];int n,w[MAXN],A,B,inf;int f[MAXN][MAXN][MAXN][MAXN],g[MAXN][MAXN];int main()&#123; n=read(); A=read(),B=read(); for(int i=1;i&lt;=n;++i) val[i]=w[i]=read(); sort(val+1,val+1+n); tot=unique(val+1,val+1+n)-val-1; for(int i=1;i&lt;=n;++i) w[i]=lower_bound(val+1,val+1+tot,w[i])-val; memset(f,0x7f,sizeof f); memset(g,0x7f,sizeof g); inf=f[0][0][0][0]; for(int i=1;i&lt;=n;++i) &#123; f[i][i][w[i]][w[i]]=0; g[i+1][i]=0; &#125; g[1][0]=0; for(int i=n;i&gt;=1;--i)for(int j=i;j&lt;=n;++j) for(int l=1;l&lt;=tot;++l)for(int r=l;r&lt;=tot;++r) if(f[i][j][l][r]&lt;inf) &#123; for(int k=j+1;k&lt;=n;++k) upd(f[i][k][min(l,w[k])][max(r,w[k])],f[i][j][l][r]+g[j+1][k-1]); for(int k=j;k&lt;=n;++k) upd(g[i][k],f[i][j][l][r]+g[j+1][k]+A+B*sqr(val[r]-val[l])); &#125; cout&lt;&lt;g[1][n]&lt;&lt;endl; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[test20190918-pm]]></title>
    <url>%2F2019%2F09%2F18%2Ftest20190918-pm%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX18wPzUzy/k/NrOQg7XJ7ONIVRusqfGKrXRLSCa0d9M+oJQ+sfUSlRNI37rtMkPrnplT/YA/Qjw8GzN5kE3yO60zkXoWNUC5pVSr4UoZ1nMyQv7Y9vF9MjpGC7JOgwgb3gClgsbxSe/oWgF5QRzflTkvIgIif/1N+KLvT+OIx7kHC13nPsNc9WDrxy1p7D6SUqGgkLeyoOXxYrc+UYsC1A7GvHkWKbs1+hjpAePxEmVCSz+XJ0LLnrYt8HEl20zPEhuvI87qa8k21RRCvqcqMOCbzU7ssn342KIUFqQ67htOB6t3FZvaq7k62MPaivWXc4gEBMOMxiaZqXvk4i20R8hiCmYGP2us82fOOcylyUObUg2JM95oIOZyjuFYhg6BS64EVb9KxSYu7rZq83VESKfEVfjBQVC66xeN9As3wSY29L8xJj9SoCYMdc5nxgQbPYfoFuk9yRCiL65TUjhIk+UhCfOunDDiVvC/9OQOqXChgH8C85Km/sTtT/jhyQoJAxfPe2GSj7lxRKRM/wb9xNlpJTohcwUk6eeIX31l8bKvQRu2XIN45rtnpGJOQq2P3bv03nIbP0vapjtXiftQcC8gqdH+pdvTSx96KOwDeS4rv353UosOB77vJ0wSOWps7kj2iIB/sRiiaA6Ljbr9ckK0nRpRL9cCk5etcdeswPhT+dCOsdfV1Tb63YAY7xNjxfNoM4TW4APjjq6Ti0Q/ir93WMFCPmyow1d6EJCB7VbStx331Q4OudkDJzHrzP0g0wEfpSErKGkh7FVfTi1QbRkZ3E0Kp0kcCVC7qU7PXBXW+ZZ7Gszdqo33xquM8b7PlssYwKodH4kAAclRHkAQIy+Irzt2dMekAzIyGpk1YKc580fQQrYzs92YHlLLPiQpVJEa/WdY7jafWysLjm6VmnpOSZ12fOb/QALfJ8NGJrSy7Wrh1EKhzcCj5zKvXmSMnnIJV2y6dZj0lp5/F0UZUPVS98M0DkUbV2SkQQazFR9LwaRlrw71m42Vz2wSRgoyDqqs0yRlckg6boMqb4x7YqCxqCoNS1vonu4jSqcSkdQur71/eOGKCzrI0fe+zKLTEE1I2iJ97AJWLmgA+GlQdBV4aJKI+zj8f9gSr840e0WubleoiFmiTVlQcgAqS21+e9PgdxhsnXBXgUG3N58SlC3KwbCemJUhldhcOpSRce/vnNSXZYas9ftB53jVHAnu/iQry8H+h3or02HWfhh+MkfY5CzAZyzcy4vW5Do2nzDdMGUci92MYf9yu9lImZv/Oyc1M4YH/m/3zIgQHoIyeN/Ez/VuvNHxZ8fgR6HRwMZTdhwZP0btni+1okk1SukQP4GvBGfeoMlwhxjbbtHSa+DprohJt4XrERpv+i2lgoRrz/DPzGIlazUucm+pqouyaKiNVXlUXN4ZWa4qDZw5FpHcvvkUG7hoJfMGecUk/ks9NSEyZ6seqMcBkfH2UK5whcU75waa4F6jLqncpyePHKnuyTUhZlV4c1U/ib8Y+9h0+QmfcbVF3HkGUsChAT25hvIKg6xsD6IC09s6FLavraS/A6fsLsIpkfvU04kmxo5M2hNKCAajvQeNJvSG9rYJhzmFJkUqVb0xliN8jum1voN163907YLieydpfA/oFIYO3RSl4Dr9un00DaHTtWf706/eDz0dsX7+ce2N9bdwKETQfd4CXLSIIII+olhphUb85R+b0AoNl+BP5EqNAu8W+5KrhL6RYMCPrrgsMGzGuSXz8KDsQQPyS7Z6G/OH2LYxx9fB3bJ+1wyC6LDh6+UEGPa9W4eUaUgVzAZwHsvsecsv6kgXNWaiOkqbqtOAY3sqqfQQ7BpdqeFHIhlPiavL1Mf+meM0koR5DMJQWYC0BjIUdqgZf8K5U5YkRK7APep4/TEHK1RZo2Fnyu9kXLhMUqMY9kw4fsaVCw== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>数学</tag>
        <tag>位运算</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190918-am]]></title>
    <url>%2F2019%2F09%2F18%2Ftest20190918-am%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>线段树</tag>
        <tag>树状数组</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190917-pm]]></title>
    <url>%2F2019%2F09%2F17%2Ftest20190917-pm%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>拓扑排序</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190917-am]]></title>
    <url>%2F2019%2F09%2F17%2Ftest20190917-am%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19xHW+2kPKwVKgYOcPP33IOTT5mu5Al2S6QCKM92Y3fNGHiVoRL9O0fnvl0cgeW1cS+twkhWSqIj6eYa9UeAdqPRUJC+w47jfN8qcPTKcqjX4oiy9eisgvFZKB/RRaemmx0ZLE7jl2ZNrk68DIzdgPBCtluLqZDahNgMyXFBLex914oaVk5mJwIAOfrBNE24hHahvMS1HmlaqsGrpB8qtL3CgwZzbxFpvgiyV/ktxHKnaGp/CHUbL1Idna2/YKLuhF5lJ7xdndc6joGP7vrNHD7B6njwC5gbxPmsNodGMLyLXAbhaufw9Z4hH2CLfAWr1bW6ZOuQ6jSLJbPUbJhhaYpUaoYlzuf2geRe0sYFHyrxuocCIw0WHT3cQO/I+wigYo13pJonS1kSOEvFXcTtRxQzlCu7w7FoUpOQYP59lUrGgjJkkEGqZmuv23sIdj1xo5MgbEkNdAOciranOgCnpVwOhLTfwIucCTEM9I2bKjF6td8bPOEa2BPPNpBqOcIaPi9gtseXdFD177Jbxkko1jmZ9vBZNktWl3v/Xkv7H9gQG2icAGcoDffVMe9rqLUK0c3xuLW0HPSURLsEiD0OKqmRTAfTMIT4Wn3wuIE+wdjLLGbTgNbF+IH5XyS8E4b+clcB3/eWx9g32+XYNhnrimTAfVcuMTXWmfVMQmC60XCVycDFQKEtEyfJ7sS1zEEIG78m/+qcwA4BOcEJsWZMGYZCFaubIRnpv09+3Ax594QhdEeLJsKxUxZf08XLtEyzXNv7KaBszg+CtZVAO42oSnmKR/cLDJHeAz4iwj7nMKT7elfp7zY+eikHpgvejkUaViKyJxT7Qh/50YAd3TrEGXLMMkYEAvUJTPZz2lRruv0vVLooBIscSACMHrfmKH2mWETW3NYHcMAGGTOJRwubGMM+EO65JAr56T8B1J2zn394YpeiuhbPBCwoEk/+7Fe9O5aTjd8BvZjHjr85ADksVEiaC0rX7j+yWTW3FYBLV0jx3gvgsdaqZkK6s3JNzIL8oxIIVhLkHnjkmBerJlSP2tkbOczZRKPT6/amga/VcsmHU70BRBzLbBzu1elrlTNteVCjIwhZySeKB8zJd0ap/1WMuyHVlP5fPwN0hBii4BXJuUoZElzP3Rx3z9UiKNRFm3fpSlxYHe+Qn4zav+imQUOcbiag9BdO/18ZHPMaHqSDDjR6SXTsW4zfIv7suJC84zt9GDn9YnnVDVWvVuV9YqRVPSIP0QRSIWUxJ/rMhSf6EHtxes3sqfqmR+8Hr5kWOAKodaKVGKhN/Eme0IxwujLUlWjsmRJx50VVCKagQ4R75XYFE1cQrAnopZ0agQxYKrA+wvUPe14eq6H1/FXlezYJe4pXVM2EAxEi5OD383t5OqJ7KGKYf3zb0C09YgJ7wqUz2Lz518aIvRUqWkiBHyOgq6sWWSp4J0bEO1RKjC+daEnu3zGoB81z+uCsBfS+RpffJAKmGvD/9ROkKBacY8ixrlyAyGb2PrvGvKIeVObAlyFGe5VORmqTdC2Rcr130mCqKogrxQxjH4EMqSM7kImBYazBniup+/EEPPvIGj8k4S+nBXKosXtUnpoCW74qtAt5s25+8FH/Y9GaHsPK+G6BXzss48iJZ+qzilduR6Kd7vXkvXNxPoCTdWPBovoowzo8SDomFny4U6dibYzke6PonQ1KgU/DgHL0QSfA+0glUdWxXI17mtYjL6A1n+JwEIyNoc8RuFyV77pmPD1eMg5U8fXln6qoTm2BbFFEbwnpkZHT0OujNvGh0sGCDLQadbdCJOqAPm50MMJWVQmQ9rpl56b2bMX/jHyU/NMPF5PQlDTOfQrjD78rtiXyX95249Mid9j8TRGBpEmemWefwsx3Gu3qR7vPeUdkkTRClp74guhlnmJ7C3dx5wkr+SULDtUT27sEKh/72QmBqI3xQH5CVfz5j5dGXE0ay9L1qTsHcZpswU6LKJs var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>数位dp</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190916-pm]]></title>
    <url>%2F2019%2F09%2F16%2Ftest20190916-pm%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19Y+8gzPz+CsYRbYBzKlEHNCqmxj7ffmugk9LOeRBTXbAFq3G3nVJjqX+aEVlXgjAQVh+MKW1JJxbMuSBu9OLBTf02xF2501lliueYAjTy9eXu+LQCscv+Acizan26rDqdkjpMsL5PrMVjeEemtGbtKv5LNAoK9W3ixzbrCkFTSQUBOyGfSWhcY5cnK1exjwDIxP+8lpnF/zGwEVmWgW1pxSHVA4R2E+9S5/j6NqmLShtxMmt95ht3ZQLVOodHbjH1GK4pLRVe6bSJqW3gOA4bNAjoR/kuHw/jKXva3PYNi8QFvhlDVfuNqBmzEdGJ78z/Y171+FK7udACk9N0IEpULirWQnJLtwh+NM/7FGUChChdwIvzeAQFRt1JH3UzwDKQrWs9OVbgiMgzDnw07FzOQZs90PUEpQbKdobxGeKyQBuNojm/xoYCWI7x2CEFLzmA+r+sxB4qrHlqT/0U1pmIG7tcFsUXPzQ8wxLkriu6Nx16q6j9KTIgoXDxnjai7cBh0Bd4pAbO3VUYNAu7Mt3fcvvk7kb9/uCoVcBG6qlFX+f+p83VY86IU1q7egN/aq3o+pwMf1C6804VY5EZ+RawxkjbLhBs0/1yvlxJnNgijvv3MWIa3fWyDErQnQx1Y5noF+Xzmj7lQfQwNSGQhpPNTzxiXkNm36umz71EM8evG0GhFC/Eo/bYZq1JMr8SK+IBLqDx0/ioQomMIgWV9fM+RtHF2V8Gj6XjNQojA0Ao46Eanqywqk4xpQKm9FcLM2bZmCOoFsiVdGgPXSdEgZ5T7UxG9UwexwZo5Vjt+nCVWpvzxSH1Mc+7kPB5DZxpTIhkSAu/IZ/Rj7/gSh7pdorG8O9HnE7uyenGInLvjSUmADu4RWPV/xKrTwyw1dZ42OtpQGScaHACgJHaiB9LfrclY2W5A7zb3GQRGOk6Z1rASDCooyW+O6i8CkYzZJ9rIJXI49ZzkzZ6Ps2SKhyHH0YAPJ8pKRkbKu53ZVYpXMFi3KJdHrNsX2+dgxS0N2+5UfOrXDi+yP3TQkQ== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>二分</tag>
        <tag>并查集</tag>
        <tag>dsu on tree</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190916-am]]></title>
    <url>%2F2019%2F09%2F16%2Ftest20190916-am%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+68WKbj3RVF8duXQMlOUcqZRnd24DnceCn0Md+dBLP3F5b8xOggilayjGXvwvxg5bANxMsESUrOX4CK0+Rrs62XxxMpG2ePYbb0WUiwqeMIjpJm84R1jgIeC8nGQ2SE9Xvvh26LoJUW/n+111wmSBIG2dbeGseg9tBTI9x0f0bbosUsTQJ5J0nuaAOin3JxQ2H5G86Wnt2lzsXTQXldMArFEug/TideE/fbyZKcLSyUbeRd6nbpz9c36kjoEg9ocSK6Q5VfmhDWgm4JVVPbCUFHYaCcOAd0m3tV4Ho96Y9iXoCblBcalflW1ruOhC9xPVcWoIKsOUp7SF1vLXiblYiVgPuvsDjJv6JqnDkjnsso/WCrRfltJYxDglKtpIyjrtgBu3QAslwHd5pWtO2WfEOxtBPZobeInO1EGZKRpSzzbioRWeiD+UDMfKxKjd1xjyTkKbSi1h9hyIyLmZYLlT3jGzj2NDZz/LAYrvTEASCT5IdY60G5X3Ku46W2PL7RyGczeF622MwJKIhtfd/ikaDvXF1UWZqIuwy+eTpgprK+fp8vOwZ2zs0IgrnvZ8Q3kx8ojMrUwwYOqYcYV8TjZO1TX4uW7A8mLwiBwxh4XeRBcM25vCbXJja8ZkkVq5Odbx3FbbJnHlh0FfjUtVLFEDkU5+t5chFRZhnPyvw8Tr8uY74b7U8kdocPGcLONIkYhBl0DPGlrmz/kxHMWUBCSEH8el8tCGhgl8uwmYUhSfRCoqcQZ+ZUzBlj6oDxu+dyrhcYlnbMD9rdBMwu70bN7Ew5q4iHMe5ER1GGImfuq3ZrKlcMCxOZf8xZ/66pBSqiqPrFwq3cQXfGIPNnqYafmOcq/quuk8503GRsizzLO4mpILbYzB9vF9MCql2cXoOhg2KPILv5KsYiTqJpuGVU8FdOSi60Om70NCRt2le9zQ0lXjWfO3HCTVn7pEQJtg7XZVG6BYVM1x4apDv6ThYvEG3+JLDr96JETo= var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>多项式</tag>
        <tag>two pointer</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1215]]></title>
    <url>%2F2019%2F09%2F15%2FCF1215%2F</url>
    <content type="text"><![CDATA[$Div.2$ A Yellow Cards贪心,分类讨论一下牌是否够用. B The Number of Products维护一下两种符号出现次数的前缀和即可. C Swap Letters若同一个位置, $s,t$ 串相同,就不用考虑. 若分别是 $a,b$ ,就把这个位置权值当做 $1$ ,若分别是 $b,a$ ,就把这个位置权值当成 $0$ . 若有两个 $1$ ,就可以操作一次将它们都消去,两个 $0$ 同理. 也可以通过一次操作将一个 $1$ 变成 $0$ ,或者将一个 $0$ 变成 $1$ ,于是讨论一下即可. D Ticket Game判一个巴什博弈的模型. E Marbles其实就是给这 $20$ 个数自定义一个大小关系,求可能的最小逆序对数目. 考虑两个数 $i,j$ ,若规定 $i$ 比 $j$ 小,可以算出它们对逆序对的贡献 $t_1$ . 若规定 $j$ 比 $i$ 小,可以算出另一个贡献 $t_2$ . 若 $t_1\not= t_2$ ,则 $i$ 与 $j$ 的大小关系是确定的,可以用一条有向边表示. 做一次拓扑排序把自定义的大小顺序求出,再求一遍逆序对就是答案了.]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>拓扑排序</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190915]]></title>
    <url>%2F2019%2F09%2F15%2Ftest20190915%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1/TXq3Dk44mJLx5sYwk2xDb8tncwv21stX/GD0EiWGiZhjxgsunWsKZ5YO5c/ZX2xrsT/qYw7a+6o2itQxorf/g0hrT8IXnaN1hqZlHDw5h/I4Bhedr+jn5Vzpphap+w0ktlokhT1RFyAeuej/P2LEHBCKRbEd/ECN30/GvVuaQfnXcPRZy236vfgGG1YLpG577ielh0k5zx5nhzTVRy4G0NDi4Pa9pal3fS+xi1UIL/Nt8j8xckMAlJZgGeY7ynjAe32nq74SGXt7dYDtslZPeRtxf/Of123/8xX9LqxewNUzjvDQ/MerqIHI8qZzZ42Vdpxy3Z4NGjUF8WLuHizBTbt729XbNreG//ziZXUSFy64tfoCd6CC0yyPFEiqQo1MoD4Pugr0bUsj82fm04VzbMVrW+0Cit2VDmVFaUoZn6aJz2RAJaaQlR6gk11D4bCowvQpewLV0alO2L9mk1abpBhrv/+2nKaRdC9wWC6Ce9KUcyilcSdmasrmKppcbxRFudKC5eitBoL0iMMCCpjZHtT8LggTAR1IFP0joiuDEXJ/QZOmrBla8ewCPS5nQj3V7GhHNMo5qLum3gEdN8UrPAukFuddJcXbAxlUWK2VuyHor6UuMqrn+megn0JpYM0Yme40mMOAIN1gelNLulAE8gA4uVwKj9O/f0bFhdz9i7ZnMsyRmN9nIZzmt607ESywyOlR0lUf47aFarsZQ8/FzzORvJ1LW+0sep0yx+JaVQ1gke1NuDDmbyymV56LdRP92BvC3hN9lYGCFZzoLdaOJSXcih1pFWGqBSxb8deiE8YpEjGV/vV6WSxLGcIZs6WsEP24J+y4r9Et7R18yna9PqBYRF30Zr58MXIb3oCDhHMU/euveWjfOy0wU8M/jHa3gxoCuLrVlueK/5hHmRnbbzkSc37xT0L3JbKwit4y6iCNXUWIWVEixOL/FYEtvDy+Q4jN3Se7BrDWd9G9ba6XMGtSKC27TIcFMSJPIsYhkute9cAJWhPcPT01kW0nynjMQ0S+X9sXJGqNiynOvdvTRXTWfG43w2zL4dT0sUmQZsyWFJRf1IA+CxbizKeixGqkSzFhxE2LbWsv4D55s3Bu9eONEI+g3gydlD1iXWfNYNqNDBtOAI0pOLttdvPENskzPBDPwmt5O61YeU3/WhKggkYOxalyeY7YWFKzB6uGv83V6VrcSENKQnYB4qz+3Zr/L+xJGtdR4EumW3pPl05bckRxgRJDByWs/dT+/YHW01eFzQlRND75xl8otxk5ncV0xW9LbQVFr7w0IUb2L6wK0zzVMjUrIp1sQEIUcQn2BE63z2sXukVx8nei+SGH8wKhAHVk9J3WVxStVJFZHow6SdrHvJaWDtW7RuTAAW9ouz046QIxN5+wiKaSTIWLkO4wdJ8wPKR6aJbx5ZwuC4MZ3hnbQ7hPevc7otEl+PH9u3bp07rOHVJwGtTUq8dyX5OLjhkncJcikG4m81p+b9d5dWL8RH2IYOfM= var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>Trie</tag>
        <tag>打表</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1209]]></title>
    <url>%2F2019%2F09%2F15%2FCF1209%2F</url>
    <content type="text"><![CDATA[$Div.1+Div.2$ A Paint the Numbers将所有元素排序,从小到大贪心处理,如果之前有它的因数,就不用新建一块. B Koala and Lights每盏灯的周期是 $2t$ ,所以整个系统的周期不会超过 $\mbox{LCM}(2,4,6,8,10)+5=125$ ,在这个范围内枚举时间即可. C Paint the Dights考虑从 $0$ 到 $9$ 枚举两个序列的分界值 $x$ . 若 $a_i&gt;x$ ,或 $a_i=x$ ,但之前没有比 $x$ 大的元素出现,就染成 $2$ ,否则染成 $1$ . D Cow and Snacks贪心,每次拿了一个 $(x,y)$ 后,就让含有 $x$ 或 $y$ 的人先来拿,这样最多挤掉一个人,所以是对的. E Rotate Columns把每一列按照该列的最大值从大到小排序,只把前 $n$ 列拿出来做状压 $dp$ .]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>codeforces</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190914]]></title>
    <url>%2F2019%2F09%2F14%2Ftest20190914%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树上差分</tag>
        <tag>单调栈</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190912]]></title>
    <url>%2F2019%2F09%2F12%2Ftest20190912%2F</url>
    <content type="text"><![CDATA[分块被卡成暴力. $road$预处理出 $S$ 到每个点的距离, $T$ 到每个点的距离. 加入一条边 $(u,v)$ 后,可能产生的路径是 $S\to u\to v\to T$ 和 $S\to v\to u\to T$ ,判断一下长度是否减小即可. $multiset$考虑对于所有 $x$ 相同的情况,相当于每次修改一段区间,若为 $0$ ,则 $+1$ ,否则 $\times 2$ . 用两棵线段树,一棵维护答案,另一颗维护每个位置是否为 $0$ . 修改时对状态相同的连续段一起操作,每次操作最多增加 $2$ 个连续段,操作次数仍为 $O(n)$ . 如果有很多种 $x$ ,就给每个 $x$ 开两棵线段树,利用动态开点进行处理. $tree$考虑链的部分,可以设 $f(i,j)$ 表示根节点的标号被继承到 $i$ , $i$ 的子树还有 $j$ 条边时,最后留下根节点标号的概率. 转移时分类讨论一下删掉哪条边以及被留下的标号. 从链上拓展到树上,只需要考虑如何合并两个子树的 $dp$ 值. 其实只要再乘上两个组合数表示删边的顺序就可以了.]]></content>
      <tags>
        <tag>概率/期望</tag>
        <tag>线段树</tag>
        <tag>最短路</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190911-night]]></title>
    <url>%2F2019%2F09%2F11%2Ftest20190911-night%2F</url>
    <content type="text"><![CDATA[$T_3$ 打了 $\mbox{5kb}$ ,前前后后打了 $7$ 个错误版本,还都过了大样例. $string$显然,答案与操作顺序无关,直接把所有 $a$ 移到最前面,这样 $b$ 的个数会翻倍,记录一下 $b$ 的数目即可. $number$直接数位 $dp$ ,注意特判 $k=0,1$ 的情况. $city$先跑一次 $dfs$ ,把环上所有点依次存下来. 考虑用环上的点把所有点分成若干块,每个点属于离它最近的环上的点. 答案分为两种情况,一种情况是两个端点在同一块,这部分贡献就是若干棵子树的直径最大值,仍然用 $dfs$ 求出. 另一种情况是两个端点在不同块,显然要经过环上点. 对环上的第 $i$ 个点,记录 $d(i)$ 表示这个点到它的那一块中的点距离最大值. 枚举断掉环上的哪一条边,环变成一条链,可以钦定一个起点,记 $H(i)$ 表示此时起点到环上第 $i$ 个点的路径长度. 如果此时选择了环上的第 $x,y$ 个点来更新答案,贡献就是 $d(y)+H(y)+d(x)-H(x)$ ,且必须 $x\not= y$ . 用线段树维护一下 $d+H,d-H$ 的最大值,最大值取到的位置 ,次大值,就可以计算出断掉某一条边的贡献. 当断边切换时,所有 $H$ 都会同时减少一个值,原端点的 $H$ 又加上所有环上边的长度,利用线段树可以维护. 时间复杂度 $O(n\log n)$ .]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190911-am]]></title>
    <url>%2F2019%2F09%2F11%2Ftest20190911-am%2F</url>
    <content type="text"><![CDATA[$\mbox{difficulty gap}$ 稍微有点大. $tree$树形 $dp$ 入门. 设 $f(u)$ 表示仅操作子树 $u$ 内的点,能获得的最大收益,转移时讨论删不删 $u$ 即可,时间复杂度 $O(n)$ . $xor$$x\mbox{ xor }2x=3x$ ,将 $\mbox{xor}$ 理解为二进制下不进位的加法. 注意到 $x+2x=3x$ ,可以得出, $x$ 与 $2x$ 在二进制下没有某一位都为 $1$ . 而 $2x$ 在二进制下可以视作 $x$ 所有数位左移了一位,于是限制等价于 $x$ 没有两位连续的 $1$ . 做一做数位 $dp$ 求出答案,注意减掉 $x=0$ 的情况. $equ$标准型线性规划,约束数目很少,但变量个数很多. 转成它的对偶线性规划,就变成了 $2$ 个变量和很多约束的线性规划. 写一个半平面交来处理.]]></content>
      <tags>
        <tag>树形dp</tag>
        <tag>数位dp</tag>
        <tag>test</tag>
        <tag>线性规划</tag>
        <tag>半平面交</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4896 补退选]]></title>
    <url>%2F2019%2F09%2F10%2Fbzoj-4896-%E8%A1%A5%E9%80%80%E9%80%89%2F</url>
    <content type="text"><![CDATA[$Trie$ 树 + $vector$ 暴力维护答案. 把串全部扔进 $Trie$ 树里面,对于 $Trie$ 树上的每个节点,开一个 $vector$ 维护出现过的值的答案. 即,若某个前缀出现次数最大为 $mx$ ,就只维护 $1\sim mx$ 的答案. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+1,L=60,S=10;char buf[L+10];int tid=0,len;struct Trie&#123; int idx; Trie()&#123;idx=0;&#125; struct node &#123; int mx,cur,ch[S]; vector&lt;int&gt; v; node()&#123;mx=cur=0;v.push_back(0);&#125; &#125;Tree[MAXN*L];#define root Tree[o] void ins(int val) &#123; int o=0; for(int i=0;i&lt;len;++i) &#123; int c=buf[i]-'a'; if(!root.ch[c]) root.ch[c]=++idx; o=root.ch[c]; root.cur+=val; if(root.cur&gt;root.mx) &#123; root.mx=root.cur; (root.v).push_back(tid); &#125; &#125; &#125; int query(int x) &#123; int o=0; for(int i=0;i&lt;len;++i) &#123; int c=buf[i]-'a'; if(!root.ch[c]) return -1; o=root.ch[c]; &#125; if(x&gt;root.mx) return -1; return root.v[x]; &#125;&#125;T;int lastans=0;int main()&#123; int m=read(); while(m--) &#123; ++tid; int op=read(); scanf("%s",buf); len=strlen(buf); if(op==1) T.ins(1); else if(op==2) T.ins(-1); else &#123; int a=read(),b=read(),c=read(); int x=(1LL*a*abs(lastans)%c+b)%c+1; lastans=T.query(x); printf("%d\n",lastans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190910]]></title>
    <url>%2F2019%2F09%2F10%2Ftest20190910%2F</url>
    <content type="text"><![CDATA[给题面点赞. $move$直接二分 + $hash$ . $cook$把反图建出来,跑一个最大字典序的拓扑序,再把这个序列反过来就是答案. $block$ 摘自原题的解题报告. 暴力来做的话,接口有 $12$ 个位置,状态数为$2^{12} = 4096$ . 这个状态维数显然不能矩阵乘法. 然后消掉所有等价的状态,即旋转,镜像,上下翻转. 比如 $100000000000$ 和 $000000000001$ 这两个的状态的 $dp$ 值,在每一轮都相等,不需要都存下来. 同样的,旋转,镜像,上下翻转都可以消除掉一些. 然后我们发现一些状态值一定是 $0$,比如接口有奇数个块的. 比如将所有块黑白染色,接口处黑色个数不等于白色个数的. 经过这些删除后,只剩下 $95$个状态. 然后直接矩阵乘法就可以了.]]></content>
      <tags>
        <tag>拓扑排序</tag>
        <tag>矩阵优化</tag>
        <tag>状压dp</tag>
        <tag>hash</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5368 真实排名]]></title>
    <url>%2F2019%2F09%2F10%2Fbzoj-5368-%E7%9C%9F%E5%AE%9E%E6%8E%92%E5%90%8D%2F</url>
    <content type="text"><![CDATA[分类讨论 + 简单组合计数. 题目描述可以等价为变化之后,分数严格小于 $A_i$ 的人数不变. 分两种情况讨论. 情况一, $A_i$ 没有翻倍. 若其它的某个翻倍的分数原来是 $x$ ,为了使排名不变,必须满足 $2x&lt;A_i$ 或 $x\ge A_i$ . 排序后二分,找出这样的 $x$ 有 $p$ 个,那么这种情况的方案数就是 $p \choose k$ . 情况二, $A_i$ 翻倍. 为了使排名不变,其余 $A_i\le x&lt;2A_i​$ 的数也必须翻倍,另外的数可以随意选择. 排序后二分,找出这样的 $x$ 一共有 $q$ 个,若 $q&lt;k-1$ ,则方案数为 $0$ ,否则为 $n-q-1\choose k-q-1$ . 根据加法原理,把两种情况的方案数加在一起就是答案. 时间复杂度 $O(n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=1e5+10;int n,k,fac[MAXN],invfac[MAXN];void init_fac()&#123; fac[0]=1; for(int i=1;i&lt;=n;++i) fac[i]=mul(fac[i-1],i); invfac[n]=fpow(fac[n],P-2); for(int i=n-1;i&gt;=0;--i) invfac[i]=mul(invfac[i+1],i+1);&#125;int C(int M,int N)&#123; if(M&lt;0 || N&lt;0 || M&lt;N) return 0; return mul(fac[M],mul(invfac[M-N],invfac[N]));&#125;int A[MAXN],a[MAXN],ans[MAXN];int Binary_Search(int val)&#123; int L=1,R=n,res=0; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(A[mid]&lt;=val) res=mid,L=mid+1; else R=mid-1; &#125; return res;&#125;int calc(int L,int R)//L&lt;=x&lt;=R&#123; if(L&gt;R) return 0; return Binary_Search(R)-Binary_Search(L-1);&#125;void solve()&#123; for(int i=1;i&lt;=n;++i) &#123; int val=A[i]; int p=calc(A[1],(val+1)/2-1)+calc(val,A[n])-1; int q; if(val&lt;=2*val-1) q=calc(val,2*val-1)-1; else q=0; ans[i]=add(C(p,k),C(n-q-1,k-q-1)); &#125;&#125;int main()&#123; n=read(),k=read(); init_fac(); for(int i=1;i&lt;=n;++i) A[i]=a[i]=read(); sort(A+1,A+1+n); solve(); for(int i=1;i&lt;=n;++i) &#123; int pos=lower_bound(A+1,A+1+n,a[i])-A; printf("%d\n",ans[pos]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4029 定价]]></title>
    <url>%2F2019%2F09%2F08%2Fbzoj-4029-%E5%AE%9A%E4%BB%B7%2F</url>
    <content type="text"><![CDATA[贪心. 乍一看像是数位 $dp$ ,仔细想一下其实只需要枚举每个数就可以了. 暴力枚举定价为 $x$ ,每次用 $x$ 更新答案后,把 $x$ 最低的不为 $0$ 的那一位 $+1$ ,继续枚举,中间的显然都没有 $x$ 优. 每一位最多被加 $10$ 次,时间复杂度 $O(T\cdot 10\log^2 R)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;int calc(int x)&#123; while(x%10==0) x/=10; int p=(x%10==5); int a=0; while(x) x/=10,++a; return 2*a-p;&#125;int nxt(int x)&#123; int cnt=0; while(x%10==0) x/=10,++cnt; ++x; while(cnt--) x*=10; return x;&#125;int main()&#123; int T=read(); while(T--) &#123; int L=read(),R=read(); int mi=inf,ans,x=L; while(x&lt;=R) &#123; int val=calc(x); if(val&lt;mi) mi=val,ans=x; x=nxt(x); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4035 数组游戏]]></title>
    <url>%2F2019%2F09%2F08%2Fbzoj-4035-%E6%95%B0%E7%BB%84%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[$SG$ 函数 + 整除分块. 假定可以选择黑点进行操作,可以发现,若选择黑点,不能直接胜利,而对方下一步可以选同样的位置翻转回来. 所以最优策略下仍不会选择黑点进行操作. 把每个白点看成一个子游戏,最后将它们的 $SG$ 函数值全部异或起来就是整个游戏的 $SG$ 异或值. 根据 $SG$ 函数的定义,转移有,$$SG(i)=\mbox{mex}_{j=2}^{\lfloor \frac n i \rfloor}\ SG(i\cdot j)$$简单归纳一下不难得出,若 $\lfloor \frac n x\rfloor=\lfloor \frac n y\rfloor$ ,则 $SG(x)=SG(y)$ . 于是只有 $O(\sqrt n)$ 个有用的值,整除分块进行计算. 时间复杂度 $O(n)$ ,但实际上是跑不满的,可以通过. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,m,SG[2][MAXN],stk[MAXN],tp;bool vis[MAXN];int nxt(int x,int y)&#123; return x==y?y+1:y/(y/(x+1));&#125;void init()&#123; for(int i=1;i&lt;=n;i=nxt(i,n)) &#123; tp=0; int tmp=0; for(int j=2;j&lt;=i;j=nxt(j,i)) &#123; int x=i/j; int val=(x&gt;m)?SG[1][n/x]:SG[0][x]; stk[++tp]=tmp^val; vis[stk[tp]]=1; if((i/x-i/(x+1))&amp;1) tmp^=val; &#125; tmp=1; while(vis[tmp]) ++tmp; if(i&gt;m) SG[1][n/i]=tmp; else SG[0][i]=tmp; for(int j=1;j&lt;=tp;++j) vis[stk[j]]=0; &#125;&#125;int main()&#123; n=read(); m=sqrt(n); init(); int T=read(); while(T--) &#123; int tot=read(),ans=0; while(tot--) &#123; int x=n/read(); ans^=(x&gt;m)?SG[1][n/x]:SG[0][x]; &#125; if(ans) puts("Yes"); else puts("No"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>博弈论</tag>
        <tag>整除分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4028 公约数数列]]></title>
    <url>%2F2019%2F09%2F08%2Fbzoj-4028-%E5%85%AC%E7%BA%A6%E6%95%B0%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[分块. $\mbox{xor}$ 显然就只是一个系数,用不上什么特殊性质. 考虑对序列分块,每个元素维护 $f(i)$ 表示从该块的 $l$ 到 $i$ 的前缀 $\gcd$ , $g(i)$ 表示从该块的 $l$ 到 $i$ 的前缀 $\mbox{xor}$ . 查询时依次处理每个块,记前面所有块的前缀 $\gcd$ 为 $pregcd$ ,前缀 $\mbox{xor}$ 为 $prexor$ . 前缀 $\gcd$ 是单调不升的,若加上这一块后, $pregcd$ 不变,则说明这一块的所有前缀 $gcd$ 都是 $pregcd$ . 此时只需要找一下这块内的第一个 $g(i) = \frac x {pregcd}\mbox{ xor } prexor$ ,这可以用 $map$ 预处理出来. 如果加上这一块后, $pregcd$ 会改变,就暴力枚举这个块内的每个位置,判断是否有解. 每次 $pregcd$ 减小时,都会至少减小到原来的一半,所以暴力枚举的位置最多 $O(\log a)$ 个. 修改时直接暴力重构所在的那一块即可. 时间复杂度 $O(m\cdot \sqrt n\cdot \log a)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;bits/stdc++.h&gt;#define rg registerusing namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int gcd(int a,int b)&#123; return b?gcd(b,a%b):a;&#125;const int MAXN=1e5+10,S=320;int n,m,blocksiz,tot=0,L[S],R[S],bel[MAXN];int a[MAXN],f[MAXN],g[MAXN];map&lt;ll,int&gt; mp[S];void init_block()&#123; blocksiz=sqrt(n); for(int i=1;i&lt;=n;++i) bel[i]=(i-1)/blocksiz+1; tot=bel[n]; for(int i=n;i&gt;=1;--i) L[bel[i]]=i; for(int i=1;i&lt;=n;++i) R[bel[i]]=i;&#125;void calc_block(int x)&#123; mp[x].clear(); f[L[x]]=g[L[x]]=a[L[x]]; for(int i=L[x]+1;i&lt;=R[x];++i) &#123; f[i]=gcd(f[i-1],a[i]); g[i]=g[i-1]^a[i]; &#125; for(int i=R[x];i&gt;=L[x];--i) mp[x][1LL*g[i]]=i;&#125;int query(ll x)&#123; int pregcd=0,prexor=0; for(rg int i=1;i&lt;=tot;++i) &#123; if(gcd(pregcd,f[R[i]])==pregcd) &#123; if(x%pregcd==0) &#123; ll val=(x/pregcd)^prexor; if(mp[i].find(val)!=mp[i].end()) return mp[i][val]-1; &#125; &#125; else &#123; for(rg int j=L[i];j&lt;=R[i];++j) if(1LL*(prexor^g[j])*gcd(pregcd,f[j])==x) return j-1; &#125; pregcd=gcd(pregcd,f[R[i]]); prexor=prexor^g[R[i]]; &#125; return -1;&#125;char op[10];int main()&#123; n=read(); init_block(); for(rg int i=1;i&lt;=n;++i) a[i]=read(); for(rg int i=1;i&lt;=tot;++i) calc_block(i); m=read(); for(rg int i=1;i&lt;=m;++i) &#123; scanf("%s",op); if(op[0]=='M')//Modify &#123; int id=read()+1,x=read(); a[id]=x; calc_block(bel[id]); &#125; else//Query &#123; ll x; scanf("%lld",&amp;x); int ans=query(x); if(ans!=-1) printf("%d\n",ans); else puts("no"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190908]]></title>
    <url>%2F2019%2F09%2F08%2Ftest20190908%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>构造</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Beginner Contest 140]]></title>
    <url>%2F2019%2F09%2F07%2FAtcoder-Beginner-Contest-140%2F</url>
    <content type="text"><![CDATA[心态炸裂. A Password直接输出 $n^3$ . B Buffet按照题意模拟. C Maximal Value贪心一下. D Face Produces Unhappiness对一个区间 $[a,b]$ 进行操作,只用考虑 $a$ 与 $b+1$ 处贡献是否改变. 只有 $”LR”$ 与 $”RL”$ 这两种串匹配时贡献才会增多,暴力匹配一下. E Second Sum二分 + 线段树找出每个元素左边第一个,第二个比它大的,右边第一个,第二个比它大的. 算一下哪些区间的次大值是这个元素,加入贡献即可. F Many Slimes贪心模拟,每次尝试用当前拥有的最大的去生成次大的,依次判断. 比赛时由于一些代码中的弱智问题没有过掉这道题.]]></content>
      <tags>
        <tag>atcoder</tag>
        <tag>二分</tag>
        <tag>贪心</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190907]]></title>
    <url>%2F2019%2F09%2F07%2Ftest20190907%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>构造</tag>
        <tag>树状数组</tag>
        <tag>差分</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190906]]></title>
    <url>%2F2019%2F09%2F07%2Ftest20190906%2F</url>
    <content type="text"><![CDATA[卡空间是真的毒瘤. $kanade$设那两个数为 $x,y$ .将所有数都异或起来,记得到的结果是 $z=x\mbox{ xor } y$ . $z\not= 0$ ,所以可以找出 $z$ 二进制上为 $1$ 的某一位. 将所有数分成两组,这一位上为 $0$ 的分在一组,这一位上为 $1$ 的分在另一组,那么 $x,y$ 就被分到了不同的组. 将某一组内的数全部异或起来,就得到了 $x,y$ 其中的一个,继而可以求出另一个. $sakura$设 $f(i)$ 表示将节点 $i$ 放上樱花所需要的樱花数目. 在 $dfs$ 时,显然将子节点按照 $f(i)-a(i)$ 从大到小排序,依次放就可以了. $chtolly$设 $f_i$ 表示当前在位置 $i$ ,走到终点的期望时间,则答案为 $f_0$ . 有 $f_0=f_1+1,f_1=f_1$ ,而方程都是线性的,所以可以将所有 $f_i$ 都表示成 $f_i=kf_1+b$ 的形式. 前两项的表达形式已知,一直往后递推,可以得到 $f_{n+1}=1$ 的表示形式,解出 $f_1$ ,也就得到了 $f_0$ .]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>概率/期望</tag>
        <tag>位运算</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4027 兔子与樱花]]></title>
    <url>%2F2019%2F09%2F06%2Fbzoj-4027-%E5%85%94%E5%AD%90%E4%B8%8E%E6%A8%B1%E8%8A%B1%2F</url>
    <content type="text"><![CDATA[贪心. 在合法的前提下,一定是在每棵子树中也删掉尽可能多的点,这样这个子树的根对它的父亲的贡献最小. 于是对树 $dfs$ ,处理完 $u$ 的所有子节点 $v$ 后,需要考虑删掉哪些 $v$ . 将每个 $v$ 被删掉后对 $u$ 的贡献从小到大排序,能删就删即可. 时间复杂度 $O(n\log n)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e6+10;int ecnt=0,nx[MAXN],to[MAXN],head[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int n,m,c[MAXN],ans=0,tmp[MAXN],tot;int sonsiz[MAXN];bool cmp(int x,int y)&#123; return c[x]+sonsiz[x]&lt;c[y]+sonsiz[y];&#125;void dfs(int u)&#123; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; dfs(v); &#125; tot=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; tmp[++tot]=v; &#125; sort(tmp+1,tmp+1+tot,cmp); for(int i=1;i&lt;=tot;++i) &#123; int v=tmp[i]; if(c[u]+sonsiz[u]+c[v]+sonsiz[v]-1&lt;=m) &#123; c[u]+=c[v]; sonsiz[u]+=sonsiz[v]-1; ++ans; &#125; &#125;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) c[i]=read(); for(int i=1;i&lt;=n;++i) &#123; sonsiz[i]=read(); for(int k=1;k&lt;=sonsiz[i];++k) &#123; int j=read()+1; addedge(i,j); &#125; &#125; dfs(1); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4026 dC Loves Number Theory]]></title>
    <url>%2F2019%2F09%2F05%2Fbzoj-4026-dC-Loves-Number-Theory%2F</url>
    <content type="text"><![CDATA[主席树. 区间 $[L,R]$ 的答案可以表示成 $\prod_{i=L}^R A_i\cdot \prod \frac {p_i-1}{p_i}$ . 前者容易维护,后者就是所有在 $[L,R]$ 区间内出现过的质数的贡献,做法比较经典. 从前往后依次加入元素,加入 $A_i$ 时,枚举 $A_i$ 的所有质因子 $p$ ,在第 $i$ 棵线段树中给位置 $i$ 乘上 $\frac {i-1} i$ . 若 $p$ 在之前出现过,且最后一个出现的位置是 $lst$ ,则还要在第 $i$ 棵线段树中给位置 $lst$ 乘上 $\frac i {i-1}$ ,即消除贡献. 询问时,后面那个 $\prod \frac {p_i-1}{p_i}$ 就是在第 $R$ 棵线段树中询问区间 $[L,R]$ 的连乘积. 用主席树来维护,时间复杂度 $O(P+n\log n\log P)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e6+777;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv[P+10],pcnt=0,prime[P+10],ism[P+10],minp[P+10];void init_pr()&#123; inv[1]=1; for(int i=2;i&lt;P;++i) inv[i]=mul(P-P/i,inv[P%i]); ism[1]=1; for(int i=2;i&lt;P;++i) &#123; if(!ism[i]) &#123; prime[++pcnt]=i; minp[i]=i; &#125; for(int j=1;j&lt;=pcnt &amp;&amp; i*prime[j]&lt;P;++j) &#123; int num=i*prime[j]; ism[num]=1; minp[num]=prime[j]; if(i%prime[j]==0) break; &#125; &#125;&#125;const int MAXN=5e4+10;int lastans=0;int n,m,preprod[MAXN],a[MAXN],rt[MAXN];struct PreSegtree&#123; int idx; PreSegtree()&#123;idx=0;&#125; struct node &#123; int ls,rs; int prod; node()&#123;ls=rs=0;prod=1;&#125; &#125;Tree[MAXN*100];#define root Tree[o] void upd(int &amp;o,int lst,int l,int r,int pos,int c) &#123; o=++idx; root=Tree[lst]; root.prod=mul(root.prod,c); if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(root.ls,Tree[lst].ls,l,mid,pos,c); else upd(root.rs,Tree[lst].rs,mid+1,r,pos,c); &#125; void query(int o,int l,int r,int L,int R,int &amp;res) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) return (void)(res=mul(res,root.prod)); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) query(root.ls,l,mid,L,R,res); if(R&gt;mid) query(root.rs,mid+1,r,L,R,res); &#125;&#125;T;int lst[P+10];void init_seg()&#123; for(int i=1;i&lt;=n;++i) &#123; int x=a[i]; int lsp=rt[i-1],cur; while(x!=1) &#123; int p=minp[x],cnt=0; if(lst[p]) &#123; T.upd(cur,lsp,1,n,lst[p],mul(p,inv[p-1])); lsp=cur; &#125; T.upd(cur,lsp,1,n,i,mul(p-1,inv[p])); lsp=cur; lst[p]=i; while(x%p==0) x/=p; &#125; rt[i]=cur; &#125;&#125;int solve(int L,int R)&#123; lastans=mul(preprod[R],inv[preprod[L-1]]); T.query(rt[R],1,n,L,R,lastans);&#125;int main()&#123; init_pr(); n=read(),m=read(); preprod[0]=1; for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); preprod[i]=mul(preprod[i-1],a[i]); &#125; init_seg(); for(int i=1;i&lt;=m;++i) &#123; int L=read()^lastans,R=read()^lastans; solve(L,R); printf("%d\n",lastans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190905]]></title>
    <url>%2F2019%2F09%2F05%2Ftest20190905%2F</url>
    <content type="text"><![CDATA[由 $ChitongZ$ 亲自出题. $game$考试时候的乱搞:求解最大权重独立子集, $bitset$ 暴力维护线性基. 最坏情况下复杂度为 $O(n^2\log n+\frac {n^3} {64})$ ,但在随机数据下,稍微优化下常数就过了. 正解:记前缀异或和为 $sum$ ,则每次询问区间 $(i,j)$ 相当于是获得了 $sum_{i-1}$ 与 $sum_j$ 的关系. 从 $sum_0$ 到 $sum_n$ 一共有 $n+1$ 个点,而 $sum_0$ 是已知的,所以做出一棵最小生成树就是答案. $matrix$模拟退火,先随机出一个状态,每次退火尝试交换两个数,并以一定概率接受较劣的解. $tree$考虑暴力 $dp$ ,设 $f(u,i)$ 表示在子树 $u$ 内选出若干点,乘积在模 $m$ 意义下为 $i$ 的方案数. 转移时,枚举 $u​$ 的子节点 $v​$ ,有 $f’(u,i)=\sum_{j\times k=i} f(u,j)\cdot f(v,k)​$ ,然后把 $f’​$ 复制到 $f​$ 里面. 这样做的时间复杂度是 $O(n\cdot m^2)$ . 转移形式很像卷积,求出 $m$ 的原根 $g​$ . 转移就变成了 $f’(u,i)=\sum_{j+ k=i} f(u,j)\cdot f(v,k)$ . 此时 $f(u,i)$ 表示在子树 $u$ 内选出若干点,乘积在模 $m$ 意义下为 $g^i​$ 的方案数. 这样就是卷积的形式了,利用 $NTT$ 进行优化,时间复杂度 $O(n\cdot m\log m)​$ .]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>最小生成树</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4018 小Q的幻想之乡]]></title>
    <url>%2F2019%2F09%2F04%2Fbzoj-4018-%E5%B0%8FQ%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%8B%E4%B9%A1%2F</url>
    <content type="text"><![CDATA[莫比乌斯反演 + 线性筛. 由于每次只能走一种路径,并且边是双向的,所以从 $i$ 到 $j$ 的边数就是 $\frac {|i-j|} {\gcd(i,j)}$ . 于是每次询问要求 $ans=\sum_{i=1}^n \sum_{j=1}^m \frac {|i-j|} {\gcd(i,j)}$ . 与 $\gcd$ 有关的式子,考虑用莫比乌斯反演那一套操作,假定 $n\le m$ ,开始推式子, 记 $A=\min(\lfloor \frac n d\rfloor,\lfloor \frac m d\rfloor),B=\max(\lfloor \frac n d\rfloor,\lfloor \frac m d\rfloor)$ . 则后面那个 $\sum_{i=1}^A \sum_{j=1}^B |i-j|=\frac {(A-1)A(A+1)} 3+\frac {AB(B-A)} 2$ ,大佬的推导过程 . 前面那一块,需要预处理 $f(d)=\sum_{k|d} k\cdot \mu(k)$ 的前缀和,这是个积性函数,直接线性筛处理. 然后整除分块计算答案,时间复杂度 $O(n+T\cdot \sqrt m)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P1=1e9+7,P2=1e9+9;struct Z&#123; int v1,v2; Z(int v1=0,int v2=0):v1(v1),v2(v2) &#123;&#125; Z operator + (const Z &amp;rhs) const &#123; return Z(v1+rhs.v1&gt;=P1?v1+rhs.v1-P1:v1+rhs.v1,v2+rhs.v2&gt;=P2?v2+rhs.v2-P2:v2+rhs.v2); &#125; Z operator - (const Z &amp;rhs) const &#123; return Z(v1-rhs.v1&lt;0?v1-rhs.v1+P1:v1-rhs.v1,v2-rhs.v2&lt;0?v2-rhs.v2+P2:v2-rhs.v2); &#125; Z operator * (const Z &amp;rhs) const &#123; return Z(1LL*v1*rhs.v1%P1,1LL*v2*rhs.v2%P2); &#125; void pr() &#123; printf("%d %d\n",v1,v2); &#125;&#125;;Z fpow(Z a,int b)&#123; Z res=Z(1,1); while(b) &#123; if(b&amp;1) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;const int N=2e6;int prime[N+10],ism[N+10],pcnt=0;Z f[N+10],inv2,inv3;void init()&#123; inv2=fpow(Z(2,2),P1-2)*Z(1,2)*Z(1,2); inv3=fpow(Z(3,3),P1-2)*Z(1,3)*Z(1,3); f[1]=Z(1,1); ism[1]=1; for(int i=2;i&lt;=N;++i) &#123; if(!ism[i]) &#123; prime[++pcnt]=i; f[i]=Z(1,1)-Z(i,i); &#125; for(int j=1;j&lt;=pcnt &amp;&amp; 1LL*i*prime[j]&lt;=N;++j) &#123; int num=i*prime[j]; ism[num]=1; if(i%prime[j]==0) &#123; f[num]=f[i]; break; &#125; f[num]=f[i]*f[prime[j]]; &#125; &#125; for(int i=1;i&lt;=N;++i) f[i]=f[i-1]+f[i];&#125;Z calc(int a,int b)&#123; if(a&gt;b) swap(a,b); Z A=Z(a,a),B=Z(b,b); Z I=Z(1,1); return (A-I)*A*(A+I)*inv3+A*B*(B-A)*inv2;&#125;void solve()&#123; int n=read(),m=read(); if(n&gt;m) swap(n,m); Z ans=Z(0,0); for(int l=1,r;l&lt;=n;l=r+1) &#123; r=min(n/(n/l),m/(m/l)); ans=ans+(f[r]-f[l-1])*calc(n/l,m/l); &#125; ans.pr();&#125;int main()&#123; init(); int T=read(); while(T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1214]]></title>
    <url>%2F2019%2F09%2F04%2FCF1214%2F</url>
    <content type="text"><![CDATA[$Div.1+Div.2$ A Optimal Currency Exchange第一种货币只有面值 $1$ 有用,第二种货币只有面值 $5$ 有用. 枚举换了多少个第二种货币,时间复杂度 $O(\frac n {5e})$ . B Badges读懂题后就是两个不等式,手动解一下. C Bad Sequence第一次遇到不合法的 $-1$ 时,将它忽略,最后再放回去,看能否合法. D Treasure Island显然答案 $\le 2$ ,因为我们可以去掉与出发点相邻的两个点. 于是只需要判断 $0$ 与 $1$ 是否合法. $0$ 就是判断起点能否到终点. $1$ 就是判断是否存在一个点 $x$ ,使得每条从起点到终点的路径都经过 $x$ . 设 $f(x),g(x)$ 分别表示起点到 $x$ 的路径数, $x$ 到终点的路径数,判断是否有 $f(x)\cdot g(x)$ 等于 起点到终点的路径数. E Petya and Construction Set可以假定 $d_i$ 是从大到小排好序的,否则可以先排序. 建出一条链,链上节点依次为 $1,3,5,\dots,2i-1$ . 然后再将偶数编号的节点 $2i$ 依次挂上去,找到链上的第 $i+d_i-1$ 个节点,将 $2i$ 挂在它的旁边即可. 因为 $d_i$ 是从大到小排好序的,且 $d_i\le n$ ,所以这样做总能构造出合法解. F Employment待更. G Feeling Good待更. H Tiles Placement待更.]]></content>
      <tags>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4017 小Q的无敌异或]]></title>
    <url>%2F2019%2F09%2F04%2Fbzoj-4017-%E5%B0%8FQ%E7%9A%84%E6%97%A0%E6%95%8C%E5%BC%82%E6%88%96%2F</url>
    <content type="text"><![CDATA[树状数组. 对于第一问,将每个二进制位分开计算贡献,变为 $0/1$ 数列,询问有几个区间的异或和为 $1$ ,随便做做. 对于第二问,仍然将每个二进制位分开算,只需要考虑所有的区间和的第 $i$ 位有奇数个 $1$ 还是偶数个 $1$ . 记前缀和 $sum(x)=\sum_{i=1}^x a_i​$ ,那么每个区间和都是 $sum(r)-sum(l-1)​$ 的形式. 从前往后枚举 $r$ ,若 $sum(r)-sum(l-1)$ 第 $i$ 位上为 $1$ ,则只有两种可能. 一种是 $sum(r)$ 与 $sum(l-1)$ 第 $i$ 位不同,且 $sum(r)\bmod 2^i\ge sum(l-1)\bmod 2^i$ ,即没有向第 $i$ 位借位. 另一种是 $sum(r)$ 与 $sum(l-1)$ 第 $i$ 位相同,且 $sum(r)\bmod 2^i&lt; sum(l-1)\bmod 2^i$ ,即有向第 $i$ 位借位. 将所有前缀和离散化,开两个树状数组进行维护,时间复杂度 $O(37\cdot n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=1e5+10;int n,a[MAXN];struct FenwickTree&#123; int bit[MAXN];#define lowbit(x) x&amp;(-x) void add(int x) &#123; for(;x&lt;=n+1;x+=lowbit(x)) bit[x]^=1; &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s^=bit[x]; return s; &#125; int query(int l,int r) &#123; return sum(r)^sum(l-1); &#125; void reset() &#123; memset(bit,0,sizeof bit); &#125;&#125;T[2];int mx;void solve1()&#123; int tot[2]; int ans=0; for(int k=0;(1&lt;&lt;k)&lt;=mx;++k) &#123; tot[0]=1,tot[1]=0; int sum=0; for(int i=1;i&lt;=n;++i) &#123; sum^=(a[i]&gt;&gt;k)&amp;1; ans=add(ans,mul(1&lt;&lt;k,tot[sum^1])); ++tot[sum]; &#125; &#125; printf("%d ",ans);&#125;ll s[MAXN],S;int tot;void solve2()&#123; ll t,sum,ans=0; for(int k=0;(1LL&lt;&lt;k)&lt;=S;++k) &#123; T[0].reset(); T[1].reset(); sum=tot=0; s[++tot]=sum&amp;((1LL&lt;&lt;k)-1); for(int i=1;i&lt;=n;++i) &#123; sum+=a[i]; s[++tot]=sum&amp;((1LL&lt;&lt;k)-1); &#125; sort(s+1,s+1+tot); tot=unique(s+1,s+1+tot)-s-1; sum=t=0; T[(sum&gt;&gt;k)&amp;1].add(lower_bound(s+1,s+1+tot,sum&amp;((1LL&lt;&lt;k)-1))-s); for(int i=1;i&lt;=n;++i) &#123; sum+=a[i]; int id=(sum&gt;&gt;k)&amp;1,p=lower_bound(s+1,s+1+tot,sum&amp;((1LL&lt;&lt;k)-1))-s; t^=T[id].query(p+1,tot); t^=T[id^1].query(1,p); T[id].add(p); &#125; ans+=t&lt;&lt;k; &#125; printf("%lld\n",ans);&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); mx=max(mx,a[i]); S+=a[i]; &#125; solve1(); solve2(); return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4154 Generating Synergy]]></title>
    <url>%2F2019%2F09%2F03%2Fbzoj-4154-Generating-Synergy%2F</url>
    <content type="text"><![CDATA[$kd$ 树. 将每个点的 $dfn,dep$ 视作 $x,y$ 坐标,那么每次修改就是给平面上一个矩形内的点染色. 用 $kd$ 树写一写,时间复杂度 $O(n\log n+q\sqrt n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=1e5+10;const int inf=1e9;int ecnt=0,head[MAXN],to[MAXN],nx[MAXN];inline void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int dfn[MAXN],idx=0,siz[MAXN],dep[MAXN];void dfs(int u)&#123; dfn[u]=++idx; siz[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; dep[v]=dep[u]+1; dfs(v); siz[u]+=siz[v]; &#125;&#125;int n,C,Q,Tp;struct node&#123; int v[2],mx[2],mi[2],fa,id; int col,tag,ls,rs; node()&#123;mx[0]=mx[1]=-inf,mi[0]=mi[1]=inf;&#125; bool operator &lt; (const node &amp;rhs) const &#123; return v[Tp]&lt;rhs.v[Tp]; &#125;&#125;Tree[MAXN];#define root Tree[o]#define lson Tree[root.ls]#define rson Tree[root.rs]inline void pushup(int o)&#123; for(int i=0;i&lt;2;++i) &#123; root.mx[i]=max(lson.mx[i],rson.mx[i]); root.mx[i]=max(root.mx[i],root.v[i]); root.mi[i]=min(lson.mi[i],rson.mi[i]); root.mi[i]=min(root.mi[i],root.v[i]); &#125;&#125;int pos[MAXN];int BuildTree(int l,int r,int tp)&#123; Tp=tp; int mid=(l+r)&gt;&gt;1; int o=mid; nth_element(Tree+l,Tree+mid,Tree+r+1); pos[root.id]=o; if(l&lt;=mid-1) &#123; root.ls=BuildTree(l,mid-1,tp^1); lson.fa=o; &#125; if(mid+1&lt;=r) &#123; root.rs=BuildTree(mid+1,r,tp^1); rson.fa=o; &#125; pushup(o); return o;&#125;inline void pushdown(int o)&#123; if(root.tag) &#123; if(root.ls) lson.col=lson.tag=root.tag; if(root.rs) rson.col=rson.tag=root.tag; root.tag=0; &#125;&#125;int Mx[2],Mi[2];void upd(int o,int c)&#123; if(root.mi[0]&gt;Mx[0] || root.mx[0]&lt;Mi[0] || root.mi[1]&gt;Mx[1] || root.mx[1]&lt;Mi[1]) return; if(Mi[0]&lt;=root.mi[0] &amp;&amp; root.mx[0]&lt;=Mx[0] &amp;&amp; Mi[1]&lt;=root.mi[1] &amp;&amp; root.mx[1]&lt;=Mx[1]) return (void)(root.col=root.tag=c); if(Mi[0]&lt;=root.v[0] &amp;&amp; root.v[0]&lt;=Mx[0] &amp;&amp; Mi[1]&lt;=root.v[1] &amp;&amp; root.v[1]&lt;=Mx[1]) root.col=c; pushdown(o); if(root.ls) upd(root.ls,c); if(root.rs) upd(root.rs,c);&#125;int stk[MAXN],tp;inline int query(int x)&#123; tp=0; int y=x; while(Tree[y].fa) &#123; stk[++tp]=Tree[y].fa; y=Tree[y].fa; &#125; while(tp) pushdown(stk[tp--]); return Tree[x].col;&#125;void solve()&#123; n=read(),C=read(),Q=read(); ecnt=0; idx=0; for(int i=1;i&lt;=n;++i) head[i]=0; for(int i=2;i&lt;=n;++i) addedge(read(),i); dfs(1); for(int i=1;i&lt;=n;++i) &#123; Tree[i].v[0]=dfn[i]; Tree[i].v[1]=dep[i]; Tree[i].ls=Tree[i].rs=0; Tree[i].col=1; Tree[i].tag=0; Tree[i].fa=0; Tree[i].id=i; &#125; int rt=BuildTree(1,n,0); int ans=0; for(int i=1;i&lt;=Q;++i) &#123; int x=read(),y=read(),c=read(); if(!c) //query ans=add(ans,mul(i,query(pos[x]))); else //update &#123; Mi[0]=dfn[x]; Mx[0]=dfn[x]+siz[x]-1; Mi[1]=dep[x]; Mx[1]=dep[x]+y; upd(rt,c); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>kdtree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4162 shlw loves matrix II]]></title>
    <url>%2F2019%2F09%2F03%2Fbzoj-4162-shlw-loves-matrix-II%2F</url>
    <content type="text"><![CDATA[拉格朗日插值求特征多项式 + 多项式取模. $k\times k$ 的方阵 $M$ 的特征多项式 $f(x)=|xI-M|$ ,它是个 $k$ 次多项式,首项系数为 $1$ . 可以随便选 $k+1$ 个 $x$ ,代到多项式里,用高斯消元算出对应的 $f(x)​$ . 然后利用拉格朗日插值得到特征多项式 $f(x)$ 的系数. 根据 $Cayley-Hamilton$ 定理, $f(M)=0$ , 那么我们给 $M^n$ 加上任意多个 $f(M)$ 都不会影响答案,即 $M^n=M^n\bmod f(M)$ . 只需计算 $M^n\bmod f(M)$ ,两者都是关于 $M$ 的多项式,模数不是 $NTT$ 模数,多项式快速幂 + 暴力取模. 最终得到的 $M^n\bmod f(M)$ 次数显然小于 $k$ ,将 $M$ 代进去暴力算即可. 时间复杂度 $O(k^4+k^2\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=51,L=1e4+10;char buf[L];int n,m,len,tmp[MAXN&lt;&lt;1],p[MAXN];void Mul(int *a,int *b,int *f)&#123; memset(tmp,0,sizeof tmp); for(int i=0;i&lt;=n;++i) for(int j=0;j&lt;=n;++j) tmp[i+j]=add(tmp[i+j],mul(a[i],b[j])); for(int i=m;i&gt;=n;--i) &#123; int inv=mul(tmp[i],fpow(p[n],P-2)); for(int j=0;j&lt;=n;++j) tmp[i-j]=add(tmp[i-j],P-mul(p[n-j],inv)); &#125; for(int i=0;i&lt;=n;++i) f[i]=tmp[i];&#125;int a[MAXN][MAXN],b[MAXN][MAXN];int Det()&#123; int res=1,sgn=1; for(int i=1;i&lt;=n;++i) &#123; for(int j=i;j&lt;=n;++j) if(b[j][i]) &#123; if(i!=j) swap(b[i],b[j]),sgn*=-1; break; &#125; int inv=fpow(b[i][i],P-2); for(int j=i+1;j&lt;=n;++j) &#123; if(!b[j][i]) continue; int t=mul(b[j][i],inv); for(int k=i;k&lt;=n;++k) b[j][k]=add(b[j][k],P-mul(b[i][k],t)); &#125; res=mul(res,b[i][i]); &#125; if(sgn==1) return res; else return add(P-res,0);&#125;int y[MAXN],c[MAXN],d[MAXN],mat[MAXN][MAXN],rmat[MAXN][MAXN];int main()&#123; scanf("%s%d",buf+1,&amp;n); len=strlen(buf+1); m=n&lt;&lt;1; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) a[i][j]=read(); for(int i=0;i&lt;=n;++i) &#123; memset(b,0,sizeof b); for(int j=1;j&lt;=n;++j) for(int k=1;k&lt;=n;++k) b[j][k]=(j==k)?(add(i,P-a[j][k])):(add(0,P-a[j][k])); y[i]=Det(); &#125; for(int i=0;i&lt;=n;++i) &#123; memset(tmp,0,sizeof tmp); tmp[0]=y[i]; for(int j=0;j&lt;=n;++j) if(i!=j) &#123; for(int k=n;k;--k) tmp[k]=add(tmp[k-1],P-mul(tmp[k],j)); tmp[0]=add(0,P-mul(tmp[0],j)); int inv=fpow(add(i,P-j),P-2); for(int k=0;k&lt;=n;++k) tmp[k]=mul(tmp[k],inv); &#125; for(int j=0;j&lt;=n;++j) p[j]=add(p[j],tmp[j]); &#125; c[0]=d[1]=1; for(int i=len;i;--i) &#123; if(buf[i]=='1') Mul(c,d,c); Mul(d,d,d); &#125; memset(b,0,sizeof b); for(int i=1;i&lt;=n;++i) mat[i][i]=1; for(int l=0;l&lt;=n;++l) &#123; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) b[i][j]=add(b[i][j],mul(c[l],mat[i][j])); memset(rmat,0,sizeof rmat); for(int i=1;i&lt;=n;++i) for(int k=1;k&lt;=n;++k) for(int j=1;j&lt;=n;++j) rmat[i][j]=add(rmat[i][j],mul(mat[i][k],a[k][j])); memcpy(mat,rmat,sizeof mat); &#125; for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=n;++j) printf("%d ",b[i][j]); puts(""); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>线性代数</tag>
        <tag>拉格朗日插值</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4128 Matrix]]></title>
    <url>%2F2019%2F09%2F03%2Fbzoj-4128-Matrix%2F</url>
    <content type="text"><![CDATA[$BSGS$ . 因为保证了矩阵 $A$ 在模 $p$ 意义下有逆,并且在 $p$ 以内有解,所以就直接像普通的 $BSGS$ 那样做就可以了. 可以手写一个 $hash$ 函数,来判断两个矩阵是否完全相等. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=70;typedef unsigned long long ull;const ull Base=137;int n,P;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;struct Matrix&#123; int v[MAXN][MAXN]; Matrix()&#123;memset(v,0,sizeof v);&#125; Matrix operator * (const Matrix &amp;rhs) const &#123; Matrix res; for(int i=0;i&lt;n;++i) for(int k=0;k&lt;n;++k)if(v[i][k]) for(int j=0;j&lt;n;++j) res.v[i][j]=add(res.v[i][j],mul(v[i][k],rhs.v[k][j])); return res; &#125; ull Hash() &#123; ull res=0; for(int i=0;i&lt;n;++i) for(int j=0;j&lt;n;++j) res=res*Base+(ull)(v[i][j]); return res; &#125;&#125;A,B,I;Matrix fpow(Matrix a,int b)&#123; Matrix res=I; while(b) &#123; if(b&amp;1) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;map&lt;ull,int&gt; mp;int BSGS()&#123; int m=sqrt(P); Matrix prod=B,tmp=A; for(int j=0;j&lt;m;++j) &#123; mp[prod.Hash()]=j; prod=prod*tmp; &#125; prod=tmp=fpow(A,m); for(int i=1;i&lt;=m;++i) &#123; ull t=prod.Hash(); if(mp.find(t)!=mp.end()) return i*m-mp[t]; prod=prod*tmp; &#125; return -1;&#125;int main()&#123; n=read(),P=read(); for(int i=0;i&lt;n;++i) I.v[i][i]=1; for(int i=0;i&lt;n;++i) for(int j=0;j&lt;n;++j) A.v[i][j]=read(); for(int i=0;i&lt;n;++i) for(int j=0;j&lt;n;++j) B.v[i][j]=read(); cout&lt;&lt;BSGS()&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>hash</tag>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4247 挂饰]]></title>
    <url>%2F2019%2F09%2F03%2Fbzoj-4247-%E6%8C%82%E9%A5%B0%2F</url>
    <content type="text"><![CDATA[贪心 + 记忆化搜索. 贪心,先考虑挂钩多的选不选,再考虑挂钩少的选不选,将物品按照挂钩数目从大到小排序. 设 $f(i,j)$ 表示可以选择 $i\sim n$ 的物品,有 $j$ 个挂钩,能获得的最大收益,枚举第 $i$ 个选还是不选来转移. 因为物品是按照挂钩数目从大到小考虑的,就没有后效性了. 挂钩数目可能很多,但有用的最多 $n$ 个,所以状态数是 $O(n^2)$ 的. 时间复杂度 $O(n\log n+n^2)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e3+10,inf=0x7fffffff;int n,f[MAXN][MAXN];pair&lt;int,int&gt; p[MAXN];int dfs(int i,int j)&#123; j=min(j,n); if(i&gt;n) return 0; if(f[i][j]!=-inf) return f[i][j]; f[i][j]=dfs(i+1,j); if(j&gt;0) f[i][j]=max(f[i][j],dfs(i+1,j-1+p[i].first)+p[i].second); return f[i][j];&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; p[i].first=read(); p[i].second=read(); &#125; sort(p+1,p+1+n); reverse(p+1,p+1+n); for(int i=0;i&lt;=n;++i) for(int j=0;j&lt;=n;++j) f[i][j]=-inf; cout&lt;&lt;dfs(1,1)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2124 等差子序列]]></title>
    <url>%2F2019%2F09%2F03%2Fbzoj-2124-%E7%AD%89%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[树状数组动态维护 $hash$ 值. 只需要判断是否存在长度为 $3$ 的等差子序列,即满足 $1\le i&lt;k&lt;j\le n,2a_k=a_i+a_j$ 的三元组 $(i,j,k)$ . 考虑从前往后枚举 $k$ ,记录一个 $vis$ 数组表示各个数当前是否出现过. 只需要检查 $a_k$ 两侧的字符串是否对称 (一侧超出的长度不计) ,若对称,说明不存在合法的 $(i,j,k)$ ,否则存在. 因为给出的序列是从 $1$ 到 $n$ 的一个排列,如果一个数 $x$ 当前没有出现,则一定会在之后出现,正确性就显然了. 用树状数组动态维护 $vis$ 正串与反串的 $hash$ 值,时间复杂度 $O(T\cdot n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e4+10;typedef unsigned long long ull;const ull Base=137;ull pw[MAXN];int n;struct FenwickTree&#123; ull bit[MAXN]; void reset() &#123; memset(bit,0,sizeof bit); &#125;#define lowbit(x) x&amp;(-x) void add(int x,int c) &#123; int p=x; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=pw[x-p]*c; &#125; ull sum(int x) &#123; int p=x; ull s=0; for(;x;x-=lowbit(x)) s+=bit[x]*pw[p-x]; return s; &#125; ull query(int l,int r) &#123; return sum(r)-sum(l-1)*pw[r-l+1]; &#125;&#125;T1,T2;bool solve()&#123; n=read(); T1.reset(); T2.reset(); bool flag=false; for(int i=1;i&lt;=n;++i) &#123; int x=read(); if(flag) continue; int len=min(x-1,n-x); if(len &amp;&amp; T1.query(x-len,x-1)!=T2.query(n-(x+len)+1,n-(x+1)+1)) flag=true; T1.add(x,1); T2.add(n-x+1,1); &#125; return flag;&#125;int main()&#123; pw[0]=1; for(int i=1;i&lt;=10000;++i) pw[i]=pw[i-1]*Base; int T=read(); while(T--) &#123; if(solve()) puts("Y"); else puts("N"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3531 旅行]]></title>
    <url>%2F2019%2F09%2F02%2Fbzoj-3531-%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[动态开点线段树. 先上个树链剖分,转化成序列上的问题. 只有 $10^5$ 种宗教,可以给每种宗教开一棵动态开点线段树维护信息. 修改宗教只有单点修改,比较容易处理,随便写一写就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;ll ans;int cnt=0;struct Segtree&#123; struct node &#123; int ls,rs; int mx; ll sum; node()&#123;mx=sum=0;&#125; &#125;Tree[MAXN*20];#define root Tree[o]#define lson Tree[root.ls]#define rson Tree[root.rs] void pushup(int o) &#123; root.mx=max(lson.mx,rson.mx); root.sum=lson.sum+rson.sum; &#125; void upd(int &amp;o,int l,int r,int pos,int c) &#123; if(!o) o=++cnt; if(l==r) return (void)(root.sum=root.mx=c); int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(root.ls,l,mid,pos,c); else upd(root.rs,mid+1,r,pos,c); pushup(o); &#125; void query(int o,int l,int r,int L,int R,int op) &#123; if(!o) return; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; if(!op) ans=max(ans,1LL*root.mx); else ans+=root.sum; return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) query(root.ls,l,mid,L,R,op); if(R&gt;mid) query(root.rs,mid+1,r,L,R,op); &#125;&#125;T;int rt[MAXN];int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int n,m,k;int idx=0,siz[MAXN],mxson[MAXN],dep[MAXN],top[MAXN],fa[MAXN],dfn[MAXN];int w[MAXN],c[MAXN];void dfs1(int u,int f)&#123; fa[u]=f; siz[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==f) continue; dep[v]=dep[u]+1; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; top[u]=tp; dfn[u]=++idx; T.upd(rt[c[u]],1,n,dfn[u],w[u]); if(mxson[u]) dfs2(mxson[u],tp); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v!=fa[u] &amp;&amp; v!=mxson[u]) dfs2(v,v); &#125;&#125;void solve(int x,int y,int op)&#123; int C=c[x]; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); T.query(rt[C],1,n,dfn[top[x]],dfn[x],op); x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y]) swap(x,y); T.query(rt[C],1,n,dfn[y],dfn[x],op);&#125;char op[10];int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) w[i]=read(),c[i]=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs1(1,0); dfs2(1,1); for(int i=1;i&lt;=m;++i) &#123; scanf("%s",op); if(op[0]=='C') &#123; if(op[1]=='C') &#123; int x=read(),y=read(); T.upd(rt[c[x]],1,n,dfn[x],0); T.upd(rt[y],1,n,dfn[x],w[x]); c[x]=y; &#125; else &#123; int x=read(),y=read(); T.upd(rt[c[x]],1,n,dfn[x],y); w[x]=y; &#125; &#125; else &#123; ans=0; int x=read(),y=read(); if(op[1]=='S') solve(x,y,1); else solve(x,y,0); printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>动态开点线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6690 灵梦的计算器]]></title>
    <url>%2F2019%2F09%2F02%2FLoj-6690-%E7%81%B5%E6%A2%A6%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[牛顿迭代求解方程. 令 $k=\lfloor n^a+n^b\rfloor,f(x)=x^a+x^b$ ,那么就是要求解 $f(n_0)=k$ 与 $f(n_1)=k+1$ 两个方程. 直接二分精度不够,利用牛顿迭代,这两个根都在 $n$ 附近,取 $x_0=n$ ,迭代一次精度即可达到要求. 发现常数比较大,跑不过去,其实并不需要把这两个根分别求出来,只需要求得两根之差,加入贡献即可.$$\begin{aligned}n_0&amp;=n-\frac{f(n)-k}{f’(n)} \\n_1&amp;=n-\frac{f(n)-k-1}{f’(n)} \\n_1-n_0&amp;=\frac {1} {f’(n)}=\frac {1} {an^{a-1}+bn^{b-1}}\end{aligned}$$发现这个贡献与 $k$ 无关,于是每次询问可以少调用 $4$ 次 $pow$ 函数. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;namespace Mker&#123;// Powered By Kawashiro_Nitori// Made In Gensokyo, Nihon #define uint unsigned int uint sd;int op; inline void init() &#123;scanf("%u %d", &amp;sd, &amp;op);&#125; inline uint uint_rand() &#123; sd ^= sd &lt;&lt; 13; sd ^= sd &gt;&gt; 7; sd ^= sd &lt;&lt; 11; return sd; &#125; inline double get_n() &#123; double x = (double) (uint_rand() % 100000) / 100000; return x + 4; &#125; inline double get_k() &#123; double x = (double) (uint_rand() % 100000) / 100000; return (x + 1) * 5; &#125; inline void read(double &amp;n,double &amp;a, double &amp;b) &#123; n = get_n(); a = get_k(); if (op) b = a; else b = get_k(); &#125;&#125;int main()&#123; int T=read(); Mker::init(); double n,a,b,k,ans=0; while(T--) &#123; Mker::read(n,a,b); ans+=1/(a*pow(n,a-1)+b*pow(n,b-1)); &#125; printf("%.3lf\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>牛顿迭代</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3881 Divljak]]></title>
    <url>%2F2019%2F09%2F02%2Fbzoj-3881-Divljak%2F</url>
    <content type="text"><![CDATA[$AC$ 自动机 + 树上小技巧. 对所有的 $s$ 串建出 $AC$ 自动机以及 $fail$ 树. $fail$ 树中的每个点都能表示一个串,并且在子树 $i$ 内的点,每个点表示的串都有节点 $i$ 对应的串作为后缀. 每次插入一个串 $p$ 时,就在 $AC$ 自动机上匹配它,匹配过程中经过的所有点都是 $p$ 的前缀,而子串可以看做是前缀的后缀,所以将经过的这些前缀都加上一种新颜色,询问时答案就是 $s_i$ 对应节点子树中所含颜色种类. 可以用 $dfs$ 序 + 树状数组进行维护,为了避免一种颜色贡献被算多次,每次染色时将所有需要染色的点按 $dfs$ 序排序,相邻的两个点权值 $+1$ ,它们的 $LCA$ 权值 $-1$ ,询问时直接询问子树内权值总和. 这样做是和构造虚树时的做法差不多的,正确性比较显然. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e6+10,S=26;int id[MAXN],ecnt=0,head[MAXN],to[MAXN],nx[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int dfn[MAXN],dfnidx=0,top[MAXN],siz[MAXN],mxson[MAXN],dep[MAXN],fa[MAXN];void dfs1(int u,int f)&#123; fa[u]=f; siz[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==f) continue; dep[v]=dep[u]+1; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; dfn[u]=++dfnidx; top[u]=tp; if(mxson[u]) dfs2(mxson[u],tp); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa[u] || v==mxson[u]) continue; dfs2(v,v); &#125;&#125;int LCA(int x,int y)&#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=fa[top[x]]; &#125; return dep[x]&lt;=dep[y]?x:y;&#125;struct FenwickTree&#123; int bit[MAXN];#define lowbit(x) x&amp;(-x) void add(int x,int c) &#123; for(;x&lt;=dfnidx;x+=lowbit(x)) bit[x]+=c; &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x]; return s; &#125;&#125;T;char s[MAXN];int len,tmp[MAXN],tot=0;bool cmp(int x,int y)&#123; return dfn[x]&lt;dfn[y];&#125;struct AhoCorasick_Automaton&#123; int ch[MAXN][S],fail[MAXN],vis[MAXN],idx; AhoCorasick_Automaton()&#123;idx=1;&#125; void ins(int x) &#123; int u=1; for(int i=1;i&lt;=len;++i) &#123; int c=s[i]-'a'; if(!ch[u][c]) ch[u][c]=++idx; u=ch[u][c]; &#125; id[x]=u; &#125; void getfail() &#123; queue&lt;int&gt; q; q.push(1); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=0;i&lt;S;++i) if(ch[u][i]) &#123; int v=ch[u][i]; q.push(v); int f=fail[u]; while(f &amp;&amp; ch[f][i]==0) f=fail[f]; if(f) fail[v]=ch[f][i]; else fail[v]=1; addedge(fail[v],v); &#125; &#125; &#125; void match() &#123; int u=1; tot=0; for(int i=1;i&lt;=len;++i) &#123; int c=s[i]-'a'; if(ch[u][c]) u=ch[u][c]; else &#123; while(u &amp;&amp; ch[u][c]==0) u=fail[u]; if(ch[u][c]) u=ch[u][c]; else u=1; &#125; tmp[++tot]=u; T.add(dfn[u],1); &#125; sort(tmp+1,tmp+1+tot,cmp); for(int i=1;i&lt;tot;++i) T.add(dfn[LCA(tmp[i],tmp[i+1])],-1); &#125; int query(int x) &#123; return T.sum(dfn[x]+siz[x]-1)-T.sum(dfn[x]-1); &#125;&#125;AC;int main()&#123; int n=read(); for(int i=1;i&lt;=n;++i) &#123; scanf("%s",s+1); len=strlen(s+1); AC.ins(i); &#125; AC.getfail(); dfs1(1,0); dfs2(1,1); int m=read(); for(int i=1;i&lt;=m;++i) &#123; int op=read(); if(op==1) &#123; scanf("%s",s+1); len=strlen(s+1); AC.match(); &#125; else &#123; int x=read(); printf("%d\n",AC.query(id[x])); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1204]]></title>
    <url>%2F2019%2F09%2F02%2FCF1204%2F</url>
    <content type="text"><![CDATA[$Div.2$ A BowWow and the Timetable判断一下读入的数是不是 $0$ 或者 $4$ 的幂次. B Mislove Has Lost an Array若首先放入 $1,2,4,\dots 2^{l-1}$ ,剩下的位置都放入 $1$ ,得到的和最小. 若首先放入 $1,2,4,\dots,2^{r-1}$ ,剩下的位置都放入 $2^{r-1}$ ,得到的和最大. C Anna, Svyatoslav and Maps如果上个点到下个点的所有最短路都不经过当前点,那么当前点必须选. $floyd$ 预处理两点间最短路长度后进行判断. D Kirk and a Binary String将原串中的 $10$ 子串全部删去,再把剩余的 $1$ 改成 $0$ ,将删掉的 $10$ 放回原位即得答案. 因为这样的子串对 $LIS$ 的贡献只可能是 $1$ ,所以删掉不会造成影响. E Natasha, Sasha and the Prefix Sums记 $sum$ 表示 $a$ 的前缀和. 考虑枚举 $x=f(a)$ ,并且枚举第一次得到这个前缀和时,用了 $y$ 个 $1$ . 即,若 $k$ 是第一个使得 $sum(k)=x$ 的位置,从 $1$ 到 $k$ 一共有 $y$ 个 $1$ ,那么从 $1$ 到 $k$ 一共有 $y-x$ 个 $-1$ . 求出这种数列的方案数 $t$ ,那么这些数列对答案的贡献就是 $t\cdot x$ . 由于位置 $k$ 一定是 $1$ ,所以只需要分别求出 $1\sim k-1$ 与 $k+1\sim n+m$ 这两段的方案数,相乘即为 $t$ . $1\sim k-1$ 的 $1,-1$ 的个数都是确定的,只要求每个位置从 $1$ 开始的前缀和都 $&lt;x$ . $k+1\sim n+m$ 的 $1,-1$ 个数也是确定的,只要求每个位置从 $k+1$ 开始前缀和都 $\le 0$ . 这两个问题都可以归纳为在二维平面上,从 $(0,0)$ 走到 $(X,Y)$ ,每次只能往右或上走一格,并且不能触碰到直线 $y=x+b$ 的方案数,注意不能跨越也可以转化为不能触碰,将直线向上平移一个位置即可. 设原点关于该直线的对称点为 $P$ ,答案就是从原点走到终点的方案数减去从 $P$ 走到终点的方案数,都不考虑限制. 因为从 $P$ 走到终点的每种方案都恰好对应了一种从原点走到终点,但触碰到了直线的方案. 时间复杂度 $O(n^2)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=4e3+10;const int P=998244853;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;int fac[MAXN],invfac[MAXN];void Init(int N)&#123; fac[0]=invfac[0]=1; for(int i=1;i&lt;=N;++i) fac[i]=mul(fac[i-1],i); invfac[N]=inv(fac[N]); for(int i=N-1;i&gt;=1;--i) invfac[i]=mul(invfac[i+1],i+1);&#125;int C(int M,int N)&#123; if(N&gt;M || N&lt;0 || M&lt;0) return 0; return mul(fac[M],mul(invfac[N],invfac[M-N]));&#125;int ans=0,n,m;int calc(int x,int y,int b)//(0,0)-&gt;(x,y),without touching y=x+b&#123; return add(C(x+y,y),P-C(x+y,y-b));&#125;int main()&#123; Init(4000); n=read(),m=read(); for(int x=1;x&lt;=n;++x) for(int y=x;y&lt;=n &amp;&amp; y-x&lt;=m;++y) &#123; int t=calc(y-x,y-1,x); t=mul(tmp,calc(m+x-y,n-y,1)); ans=add(ans,mul(tmp,x)); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>数学</tag>
        <tag>codeforces</tag>
        <tag>floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3670 动物园]]></title>
    <url>%2F2019%2F09%2F02%2Fbzoj-3670-%E5%8A%A8%E7%89%A9%E5%9B%AD%2F</url>
    <content type="text"><![CDATA[$kmp$ . 对于每个位置 $i$ ,需要找出 $2|Border|\le i$ 的非空 $Border$ 数目. 用 $kmp$ 求一次 $next$ 数组,根据 $next$ 数组,可以建出 $kmp$ 自动机的树. 这棵树以 $0$ 为根, $next(i)$ 向 $i$ 连边, $i$ 号点表示了长度为 $i$ 的前缀,从根到 $i$ 路径上的点都为前缀 $i$ 的 $Border$ . 那么只需要知道根节点到 $i$ 的路径上有多少个编号 $\le \lfloor \frac i 2\rfloor$ 的节点. 编号从上到下是单调递增的,所以可以维护一个栈,存储根节点到当前节点路径上的点,在栈中二分求出答案. 时间复杂度 $O(T\cdot n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=1e6+10;char s[MAXN];int n,nxt[MAXN];int ecnt=0,head[MAXN],nx[MAXN],to[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int stk[MAXN],tp,ans;void dfs(int u)&#123; if(u) stk[++tp]=u; int L=1,R=tp,res=0; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(stk[mid]*2&lt;=u) res=mid,L=mid+1; else R=mid-1; &#125; ans=mul(ans,res+1); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; dfs(v); &#125; if(u) --tp;&#125;void solve()&#123; ecnt=0; memset(head,0,sizeof head); scanf("%s",s+1); n=strlen(s+1); nxt[1]=0; addedge(0,1); for(int i=2;i&lt;=n;++i) &#123; int j=nxt[i-1]; while(j &amp;&amp; s[i]!=s[j+1]) j=nxt[j]; if(s[i]==s[j+1]) ++j; nxt[i]=j; addedge(nxt[i],i); &#125; ans=1; tp=0; dfs(0); printf("%d\n",ans);&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Beginner Contest 139]]></title>
    <url>%2F2019%2F09%2F01%2FAtcoder-Beginner-Contest-139%2F</url>
    <content type="text"><![CDATA[莫名奇妙被罚了 $6$ 次. A Tenki签到题,注意两个字符串虽然长度都为 $3$ ,但直接这样开会错掉. 1char a[3],b[3]; 要开大一些,可能是因为终止符/空格的问题? 一开始没注意,交上去被罚了一次. B Power Socket签到题,但题意有点难理解. 应该是一开始有 $1$ 个物品,每次可以把 $1$ 个换成 $A$ 个,问至少有 $B$ 个,需要操作多少次,然后就简单了. C Lower签到题,读入后反过来递推即可. D ModSum考试的时候根据样例猜了个结论,令 $P_i=i+1(1\le i&lt;n),P_n=1$ . 这样答案是 $\frac {n(n-1)} 2$ ,然后就过了. E League把每场比赛看做一个点,若 $A$ 必须在 $B$ 之前比赛,就连边 $A\to B$ . 若有环,则无解,否则答案为 $DAG$ 上的最长链. F Engines 其实应该算 POI 原题? 最终的向量一定是由那些在它的方向上投影为正的向量相加得到. 极角排序后扫一圈更新答案即可.]]></content>
      <tags>
        <tag>atcoder</tag>
        <tag>贪心</tag>
        <tag>DAG</tag>
        <tag>拓扑排序</tag>
        <tag>计算几何</tag>
        <tag>极角排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3012 First!]]></title>
    <url>%2F2019%2F09%2F01%2Fbzoj-3012-First%2F</url>
    <content type="text"><![CDATA[$Trie$ 树 + 拓扑排序判环. 将所有串插入到一棵 $Trie$ 树中. 若一个字符串 $s_i$ 成为了字典序最小的串,因为这些串互不相同,所以必须要求其他串都不能是 $s_i$ 的前缀. 即在 $Trie$ 树上,根节点到这个串的终止节点路径上不能有其它的串的终止节点. 另一个条件是根到这个节点路径上每条边字符的字典序比它父亲向所有兄弟的边字符的字典序小. 这可以用若干条有向边表示字符间的大小关系,建出图后拓扑排序,若有环,则不合法,否则合法. 时间复杂度 $O(|S|^2\cdot n+|S|\cdot \sum |s|)$ ,其中 $S$ 代表字符集, $s$ 代表读入的串. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10,N=3e4+10,S=26;char buf[N],s[MAXN];int n,len;int G[S][S],deg[N],ans[N],ans_cnt=0;int d[N],cnt,vis[N];void del(int u)&#123; ++cnt; vis[u]=1; for(int v=0;v&lt;S;++v) if(G[u][v]) &#123; d[v]-=G[u][v]; if(!d[v]) del(v); &#125;&#125;bool topsort()&#123; memset(vis,0,sizeof vis); memcpy(d,deg,sizeof d); cnt=0; for(int i=0;i&lt;S;++i) if(!d[i] &amp;&amp; !vis[i]) del(i); return cnt==S;&#125;struct Trie&#123; int ch[MAXN][S],idx; int val[MAXN]; Trie()&#123;idx=0;&#125; void ins(int id) &#123; int u=0; for(int i=1;i&lt;=len;++i) &#123; int c=buf[i]-'a'; if(!ch[u][c]) ch[u][c]=++idx; u=ch[u][c]; &#125; val[u]=id; &#125; void dfs(int u) &#123; if(val[u]) &#123; if(topsort()) &#123; ans[val[u]]=1; ++ans_cnt; &#125; return; &#125; int q[S],t=0; for(int c=0;c&lt;S;++c) &#123; int v=ch[u][c]; if(!v) continue; q[++t]=c; &#125; for(int c=0;c&lt;S;++c) &#123; int v=ch[u][c]; if(!v) continue; for(int i=1;i&lt;=t;++i) if(q[i]!=c) &#123; ++G[c][q[i]]; ++deg[q[i]]; &#125; dfs(v); for(int i=1;i&lt;=t;++i) if(q[i]!=c) &#123; --G[c][q[i]]; --deg[q[i]]; &#125; &#125; &#125;&#125;T;int lp[N],rp[N];int main()&#123; n=read(); int tot=0; for(int i=1;i&lt;=n;++i) &#123; scanf("%s",buf+1); len=strlen(buf+1); lp[i]=tot+1; for(int j=1;j&lt;=len;++j) s[++tot]=buf[j]; rp[i]=tot; T.ins(i); &#125; T.dfs(0); printf("%d\n",ans_cnt); for(int i=1;i&lt;=n;++i) if(ans[i]) &#123; for(int j=lp[i];j&lt;=rp[i];++j) putchar(s[j]); puts(""); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>拓扑排序</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190901]]></title>
    <url>%2F2019%2F09%2F01%2Ftest20190901%2F</url>
    <content type="text"><![CDATA[自闭场. $masodik$维护 $r$ 和 $c$ 的下凸壳,当前哪个斜率大走哪个. $count$$60​$ 分的做法可以直接枚举 $a,b​$ ,此时可以唯一确定 $c,d​$ ,用 $hash​$ 检验,时间复杂度 $O(n^2)​$ ,但跑不满. 另外一个 $O(n^2)$ 的做法是枚举 $len=b-a+1$ . 当 $len$ 固定时,将串右移 $len+F$ 位,合法的 $(a,b,c,d)$ 中, $(a,b)$ 段和 $(c,d)$ 段就会匹配上. 于是扫一遍,计算匹配数,就可以得出 $len$ 确定时的解,时间复杂度 $O(n^2)$ . 考虑进行优化,仍然枚举 $len$ ,将原串按 $len$ 分段,发现下面这样的红色匹配是没有意义的: 因为红色匹配的长度不会超过 $len$ ,而有效的匹配一定是像绿色匹配那样跨越边界的. 段边界的匹配可以转化为段两端的 $LCP$ 和 $LCS$ ,二分 + $hash$ 来求. 用这一段的 $LCP$ 和前一段的 $LCS$ 组合,若 $LCS\ge len$ ,则这段的解全都合法. 否则这段的解有 $LCP+LCS-len+1$ 个. 时间复杂度 $O(n\log^2 n)$ . 这里的 $LCS$ 指最长公共后缀. $theory$先考虑 $m=0$ 的情况,此时相当于求解 $n^{2n}\equiv x$ . 保证有解,所以 $x$ 一定是二次剩余,等价于求解 $n^n\equiv \sqrt x \pmod p$ . 令 $n\equiv \sqrt x \pmod p,n\equiv 1 \pmod { p-1}$ . 因为 $\gcd(p,p-1)=1​$ ,所以可以 $crt​$ 合并得出一个合法解. 对于 $m&gt;0​$ 的情况,尝试枚举 $n\equiv t\pmod p​$ ,只要 $x-t^m​$ 在模 $p​$ 意义下是二次剩余,就可以沿用上面的做法. 由于一个数是二次剩余的概率为 $\frac 1 2​$ ,所以期望步数很小,可以视作常数. 时间复杂度 $O(\sqrt p)​$ .]]></content>
      <tags>
        <tag>test</tag>
        <tag>crt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2342 双倍回文]]></title>
    <url>%2F2019%2F09%2F01%2Fbzoj-2342-%E5%8F%8C%E5%80%8D%E5%9B%9E%E6%96%87%2F</url>
    <content type="text"><![CDATA[$Manacher$ . 考虑用 $Manacher$ 预处理出每个位置的回文半径. 枚举双倍回文子串的中心 $i$ ,为了得到以 $i$ 为中心的最长双倍回文子串,需要找到左边第一个 $j+R(j)-1\ge i$ ,且 $R(i)\ge 2i-2j $ 的位置 $j$ ,这里的 $i,j​$ 在新串上的字符都必须为 ‘#’​ . 通过第二个条件可知 $j\ge \frac {2i-R(i)} {2}​$ ,即 $j\ge i-\lfloor \frac {R(i)} 2\rfloor​$ . 将所有 $j$ 按照 $j+R(j)-1$ 排序,从大到小枚举 $i$ ,将所有 $j+R(j)-1\ge i$ 的 $j$ 放入一个 $set$ 中. 此时在 $set$ 中查询 $i-\lfloor \frac {R(i)} 2\rfloor$ 的后继,就是要求的 $j$ ,注意特判不存在的情况以及检验 $j&lt;i$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;char buf[MAXN],s[MAXN];int n,R[MAXN];int ans=0;void Manacher()&#123; s[0]='$'; for(int i=1;i&lt;=n;++i) &#123; s[2*i-1]='#'; s[2*i]=buf[i]; &#125; s[2*n+1]='#'; s[2*n+2]='@'; n=2*n+2; int p=0,mx=0; for(int i=1;i&lt;n;++i) &#123; if(i&gt;mx) R[i]=1; else R[i]=min(mx-i+1,R[2*p-i]); while(s[i-R[i]]==s[i+R[i]]) ++R[i]; if(i+R[i]-1&gt;mx) mx=i+R[i]-1,p=i; &#125;&#125;typedef pair&lt;int,int&gt; pii;#define mp make_pairset&lt;int&gt; S;set&lt;int&gt;::iterator it;pii tmp[MAXN];int tot=0;int main()&#123; n=read(); scanf("%s",buf+1); Manacher(); for(int j=1;j&lt;n;++j) if(j&amp;1) tmp[++tot]=mp(j+R[j]-1,j); sort(tmp+1,tmp+tot+1); int nx=tot; for(int i=n-1;i&gt;=1;--i) &#123; if(!(i&amp;1)) continue; while(nx&gt;0 &amp;&amp; tmp[nx].first&gt;=i) S.insert(tmp[nx--].second); it=S.lower_bound(i-R[i]/2); if(it!=S.end() &amp;&amp; *it&lt;i) ans=max(ans,2*(i-*it)); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190831]]></title>
    <url>%2F2019%2F08%2F31%2Ftest20190831%2F</url>
    <content type="text"><![CDATA[神仙题目. $crypto$讲道理,这应该是个愚人节题目. 枚举密钥的长度,假设密钥的长度为 $l$ .我们考虑恢复出密钥的每一位. 例如要恢复第一位,就将密文的第$1,l+1,2l+1,\dots$个字符取出来. 然后这些字符的字母频率应该符合英文字母的分布,可以根据样例输出统计. 可以枚举加密时候的位移是多少,根据英文字母的分布选出最小二乘解. 对于每种密钥长度解密后,选出 $THE$ 最多的长度作为正确答案. $string$貌似只有这道题比较可做. 可以把所有加入的串建一个广义后缀自动机. 或者将相邻的两个串中间加入一个标识符,当成一个串,插入后缀自动机中. 然后每次询问在上面暴力匹配就好了. $eigen$做法是用 幂法 迭代出绝对值最大的解,再不断构造变换,得出其他的解. 我不会做.]]></content>
      <tags>
        <tag>SAM</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2565 最长双回文串]]></title>
    <url>%2F2019%2F08%2F30%2Fbzoj-2565-%E6%9C%80%E9%95%BF%E5%8F%8C%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[$Manacher$ . 考虑枚举 $X,Y$ 两个回文串的分界位置,不能以首尾的 ‘#’ 作为分界位置,否则 $X,Y$ 长度可以为 $0$ . 利用 $Manacher$ ,位置 $i$ 作为分界位置的贡献就是左边能覆盖到 $i$ 的最大长度加上右边能覆盖到 $i$ 的最大长度. 以找左侧最优位置为例,从左往右扫描,同时维护一个当前处理到的右边界 $k$ . 扫描到第 $i$ 位时,就把 $k+1\sim i+R(i)-1$ 这一段的最优位置全部更新为 $i$ ,然后将右边界更新为 $i+R(i)-1$ . 右边界只会向右移动,所以时间复杂度为 $O(n)$ . 右侧最优位置的处理方法同理. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;char buf[MAXN],s[MAXN];int n,R[MAXN],sum[MAXN];void Manacher()&#123; s[0]='$'; for(int i=1;i&lt;=n;++i) &#123; s[2*i-1]='#'; s[2*i]=buf[i]; &#125; s[2*n+1]='#'; s[2*n+2]='@'; n=2*n+2; int p=0,mx=0; for(int i=1;i&lt;n;++i) &#123; if(mx&lt;i) R[i]=1; else R[i]=min(mx-i+1,R[2*p-i]); while(s[i-R[i]]==s[i+R[i]]) ++R[i]; if(i+R[i]-1&gt;mx) mx=i+R[i]-1,p=i; &#125; for(int i=1;i&lt;=n;++i) sum[i]=sum[i-1]+('a'&lt;=s[i] &amp;&amp; s[i]&lt;='z');&#125;int lp[MAXN],rp[MAXN];int main()&#123; scanf("%s",buf+1); n=strlen(buf+1); Manacher(); int k=0; for(int i=1;i&lt;n;++i) &#123; for(int j=k+1;j&lt;=i+R[i]-1;++j) lp[j]=i; k=max(k,i+R[i]-1); &#125; k=n; for(int i=n-1;i&gt;=1;--i) &#123; for(int j=k-1;j&gt;=i-R[i]+1;--j) rp[j]=i; k=min(k,i-R[i]+1); &#125; int ans=0; for(int i=3;i&lt;n-2;++i) if(i&amp;1) &#123; int t=2*(sum[i]-sum[lp[i]-1])-sum[lp[i]]+sum[lp[i]-1]; t+=2*(sum[rp[i]]-sum[i-1])-sum[rp[i]]+sum[rp[i]-1]; ans=max(ans,t); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190830]]></title>
    <url>%2F2019%2F08%2F30%2Ftest20190830%2F</url>
    <content type="text"><![CDATA[开始还以为是原题大战,后来发现题号是连着的,应该是考完后传上去的. $common$典故 考虑分块,将编号 $1\sim n$ 分成 $\sqrt n$ 个块. 做一遍 $dfs$ ,预处理出每个点的 $dfs$ 序,以及它对每一块的贡献次数. 询问时,整块的部分直接调用答案,边角部分利用 $dfs$ 序逐个查询. 时间复杂度 $O(n\sqrt n \log n)$ . $\text{long long}$ 会被卡,要用 $\text{unsigned long long}$ . $art$典故 考虑矩阵树定理,将那 $n$ 个点标号为 $1\sim n$ ,另外 $m$ 个点标号为 $n+1\sim n+m$ . 由于图是一张完全二分图,所以可以直接写出它的基尔霍夫矩阵去掉最后一行一列得到的余子式.$$\begin{vmatrix}m &amp; 0 &amp;\cdots &amp; 0 &amp; -1 &amp; -1 &amp;\cdots &amp; -1 \\0 &amp; m &amp;\cdots &amp; 0 &amp; -1 &amp; -1 &amp;\cdots &amp; -1 \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots&amp; \vdots&amp; \vdots&amp; \vdots&amp; \vdots\\0 &amp; 0 &amp;\cdots &amp; m &amp; -1 &amp; -1 &amp;\cdots &amp; -1 \\-1 &amp; -1 &amp;\dots &amp; -1 &amp; n &amp; 0 &amp; \dots &amp; 0 \\-1 &amp; -1 &amp;\dots &amp; -1 &amp; 0 &amp; n &amp;\dots &amp; 0 \\\vdots &amp; \vdots &amp; \vdots &amp; \vdots&amp; \vdots&amp; \vdots&amp; \ddots&amp; \vdots\\-1 &amp; -1 &amp;\dots &amp; -1 &amp; 0 &amp; 0 &amp;\dots &amp; n\end{vmatrix}$$ 这个矩阵的行列式就是答案,比较明显的,可以将它分成 $4$ 个区域,左下角和右上角全都是 $-1$ . 左上角是一个 $n\times n$ 的对角矩阵,对角线上元素都是 $m$ . 右下角是一个 $(m-1)\times (m-1)$ 的对角矩阵,对角线上元素都是 $n$ . 由于这个矩阵十分特殊,我们直接尝试手算它的行列式. 由于前 $n$ 行已经完成了上三角化,只需要对后 $m-1$ 行上三角化. 将前 $n​$ 行每一行都乘一个 $\frac 1 m ​$ ,加到后 $m-1​$ 行的每一行中,行列式不变,矩阵被消成了这样:$$\begin{vmatrix}m &amp; 0 &amp;\cdots &amp; 0 &amp; -1 &amp; -1 &amp;\cdots &amp; -1 \\0 &amp; m &amp;\cdots &amp; 0 &amp; -1 &amp; -1 &amp;\cdots &amp; -1 \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots&amp; \vdots&amp; \vdots&amp; \vdots&amp; \vdots\\0 &amp; 0 &amp;\cdots &amp; m &amp; -1 &amp; -1 &amp;\cdots &amp; -1 \\0 &amp; 0 &amp;\dots &amp; 0 &amp; \frac{n(m-1)}m &amp; \frac{-n}m &amp; \dots &amp; \frac{-n}m \\0 &amp; 0 &amp;\dots &amp; 0 &amp; \frac{-n}m &amp; \frac{n(m-1)}m &amp;\dots &amp; \frac{-n}m \\\vdots &amp; \vdots &amp; \vdots &amp; \vdots&amp; \vdots&amp; \vdots&amp; \ddots&amp; \vdots\\0 &amp; 0 &amp;\dots &amp; 0 &amp; \frac{-n}m &amp; \frac{-n}m &amp;\dots &amp; \frac{n(m-1)}m\end{vmatrix}$$此时,因为下面 $m-1$ 行的前 $n$ 列都是 $0$ ,无论怎样进行行变换都不会变,所以这个矩阵的行列式其实就等于左上角的 $n\times n$ 的矩阵的行列式与右下角 $(m-1)\times (m-1)$ 的矩阵行列式之积. 左上角的那个对角线矩阵行列式显然是 $m^n​$ . 对于右下角那个矩阵,我们将每个元素都乘上 $\frac m n​$ ,行列式会变为原来的 $(\frac m n)^{m-1}​$ 倍,最后答案要乘上系数 $(\frac n m)^{m-1}​$ . 右下角的元素乘上 $\frac m n$ 后,得到的新的 $(m-1) \times (m-1)$ 的矩阵是这样的:$$\begin{vmatrix}m-1 &amp; -1 &amp;\cdots &amp;-1 \\-1 &amp; m-1 &amp;\cdots &amp;-1\\\vdots &amp; \vdots &amp;\ddots &amp;\vdots\\-1 &amp; -1 &amp; -1 &amp; m-1\end{vmatrix}$$即主对角线上的元素都是 $m-1$ ,其余元素都是 $-1$ . 如果我们再给他在外面补上一行一列,补成一个 $m\times m$ 的矩阵,$$\begin{vmatrix}m-1 &amp; -1 &amp;-1 &amp;\cdots &amp;-1 &amp;-1 \\-1 &amp; m-1 &amp;-1 &amp;\cdots &amp;-1 &amp;-1\\-1 &amp; -1 &amp;m-1 &amp;\cdots &amp;-1 &amp;-1\\\vdots&amp;\vdots &amp; \vdots &amp;\vdots &amp;\ddots&amp;\vdots\\-1 &amp;-1 &amp; -1 &amp; \cdots &amp; -1&amp; m-1\end{vmatrix}$$这个 $m\times m$ 的矩阵其实就是一张完全图 $K_m$ 的基尔霍夫矩阵,每个点度数为 $m-1$ ,每两个点之间都有边. 根据矩阵树定理,那个 $(m-1)\times (m-1)$ 的矩阵的行列式就等于完全图 $K_m$ 的生成树个数. 根据 $Cayley$ 定理,或利用 $prufer$ 序列,这个数目应该是 $m^{m-2}$ . 将两个行列式与那个系数 $(\frac n m)^{m-1}​$ 乘在一起,就得到了答案.$$\begin{aligned}ans&amp;=m^n\cdot n^{m-1} \cdot m^{1-m} \cdot m^{m-2} \\&amp;=m^{n-1}\cdot n^{m-1}\end{aligned}$$ $hands$典故 把两种移动方式看做两个向量 $\vec a,\vec b$ .因为题目保证它们不共线,所以每个点都可以被写成 $x\cdot \vec a+y\cdot \vec b$ . 以解出来的 $(x,y)$ 代替原来的坐标,就变成了每次可以向右或向上走一步,可以直接舍去坐标转换后不是整点的点. 要求不能经过障碍点,求起点到终点的方案数. 如果没有障碍,答案显然是 $C_{x+y}^x$ .但现在有障碍.直接递推显然不行,因为新坐标的大小可以达到 $2\times 500^2$ . 将障碍点,目标点视为关键点,记原点为第 $0​$ 个关键点. 坐标转换后,按照 $x$ 为第一关键字, $y$ 为第二关键字排序,就做出了一个拓扑序,再进行 $dp$ . 设 $f(i)$ 表示从原点到达第 $i$ 个关键点而不经过其他关键点的方案数. $g(i,j)​$ 表示从第 $i​$ 个关键点到第 $j​$ 个关键点的所有方案数. 转移有 $f(i)=g(0,i)-\sum_{j=1}^{i-1} g(j,i)\cdot f(j)$ .而 $g$ 不需要考虑障碍,若能够到达,就是组合数,否则是 $0$ . 时间复杂度 $O(n^2)​$ .]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>数学</tag>
        <tag>线性代数</tag>
        <tag>分块</tag>
        <tag>test</tag>
        <tag>矩阵树定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF17E Palisection]]></title>
    <url>%2F2019%2F08%2F29%2FCF17E-Palisection%2F</url>
    <content type="text"><![CDATA[$Manacher$ + 差分. 利用补集转化思想,求出回文子串的总对数 $-$ 不相交的回文子串对数就是答案. 先跑一遍 $Manacher$ ,得出每个位置的回文半径以及回文子串的总对数. 于是接下来只需要计算不相交的回文子串对数. 记 $f(i)$ 表示以位置 $i$ 开始的回文子串数目, $g(i)$ 表示以位置 $i$ 结尾的回文子串数目. 这可以在跑 $Manacher$ 时打差分标记计算出来. 每个实际位置 $i$ ,即是字母的位置 $i$ ,贡献为 $f(i)\cdot \sum_{j&lt;i} g(j)$ ,枚举的时候记录一下 $g$ 的实际位置上的前缀和. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=51123987;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=4e6+10;char buf[MAXN],s[MAXN];int n,R[MAXN],ans=0;int f[MAXN],g[MAXN];void Manacher()&#123; s[0]='$'; for(int i=1;i&lt;=n;++i) &#123; s[2*i-1]='#'; s[2*i]=buf[i]; &#125; s[2*n+1]='#'; s[2*n+2]='@'; n=2*n+2; int mx=0,p=0; for(int i=1;i&lt;n;++i) &#123; int fl=1,j=2*p-i; if(mx&lt;i) R[i]=1; else if(mx-i&gt;R[j]) R[i]=R[j],fl=0; else R[i]=mx-i+1; if(fl) while(s[i-R[i]]==s[i+R[i]]) ++R[i]; if(i+R[i]-1&gt;mx) mx=i+R[i]-1,p=i; ++f[i-R[i]+1],--f[i+1]; ++g[i],--g[i+R[i]]; ans=add(ans,R[i]/2); &#125;&#125;int main()&#123; n=read(); scanf("%s",buf+1); Manacher(); ans=(1LL*ans*(ans-1)/2)%P; int tmp=0; for(int i=1;i&lt;=n;++i) &#123; f[i]+=f[i-1]; g[i]+=g[i-1]; if(!(i&amp;1)) &#123; ans=add(ans,P-mul(f[i],tmp)); tmp=add(tmp,g[i]); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>Manacher</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2160 拉拉队排练]]></title>
    <url>%2F2019%2F08%2F29%2Fbzoj-2160-%E6%8B%89%E6%8B%89%E9%98%9F%E6%8E%92%E7%BB%83%2F</url>
    <content type="text"><![CDATA[$Manacher$ + 差分维护数列. 首先将字符串添加特殊字符,利用 $Manacher$ 算法求出每个位置的回文半径 $R(i)$ . 维护一个 $cnt(i)$ 表示原串中长度为 $i$ 的回文串数目. 由于只考虑奇回文串,所以枚举时只处理字母作为回文中心的贡献. 若第 $i$ 个位置是字母,则它在原串中对应的奇回文串的长度分别是 $1,3,5,\dots,R(i)-1$ . 给 $1\sim R(i)-1$ 的所有 $cnt$ 都 $+1$ ,可以用差分来维护. 最后统计答案时,从大到小枚举长度,只将奇数长度计入贡献. 时间复杂度 $O(n\log n)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=19930726;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=2e6+10;char s[MAXN],buf[MAXN];int n,R[MAXN],cnt[MAXN];void Manacher()&#123; buf[0]='$'; for(int i=1;i&lt;=n;++i) &#123; buf[2*i-1]='#'; buf[2*i]=s[i]; &#125; buf[2*n+1]='#'; buf[2*n+2]='@'; //1~2n+1 int mx=1,p=1; R[1]=1; for(int i=2;i&lt;=2*n+1;++i) &#123; int f=1; int j=2*p-i; if(mx&lt;i) R[i]=1; else if(mx-i&gt;R[j]) R[i]=R[j],f=0; else R[i]=mx-i+1; if(f) while(buf[i+R[i]]==buf[i-R[i]]) ++R[i]; if(i+R[i]-1&gt;mx) mx=i+R[i]-1,p=i; if('a'&lt;=buf[i] &amp;&amp; buf[i]&lt;='z') ++cnt[1],--cnt[R[i]]; &#125;&#125;ll k;int main()&#123; n=read(),k=read(); scanf("%s",s+1); Manacher(); int ans=1; for(int i=1;i&lt;=n;++i) cnt[i]+=cnt[i-1]; for(int i=n;i&gt;=1;--i) if(cnt[i] &amp;&amp; (i&amp;1)) &#123; if(k&gt;cnt[i]) &#123; ans=mul(ans,fpow(i,cnt[i])); k-=cnt[i]; &#125; else &#123; ans=mul(ans,fpow(i,k)); printf("%d\n",ans); return 0; &#125; &#125; puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>Manacher</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manacher算法学习笔记]]></title>
    <url>%2F2019%2F08%2F29%2FManacher%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[感觉自己之前学的时候没学清楚,于是重新整理了一遍. 本文主要整理自 2014年集训队论文 《浅谈回文子串问题 徐毅》. 回文半径以字符串第 $i$ 个位置为中心的回文子串长度的一半,称为该字符串第 $i$ 位的回文半径,记作 $R(i)​$ . 预处理处理回文子串问题时,为了方便,经常将原字符串加入特殊字符,避免奇偶讨论与边界问题. 如: &quot;abbabcba&quot; -&gt; &quot;$#a#b#b#a#b#c#b#a#@&quot; 对新字符串求出每个位置的回文半径,就对应了原串中以字符为中心的奇回文串和以空隙为中心的偶回文串. $Manacher$ 算法又称马拉车算法. 可以以 $O(n)$ 的时间复杂度求解长度为 $n$ 的字符串每个位置的回文半径. 首先执行上文的预处理,再依次计算位置 $1\sim n$ 的回文半径. 记 $mx$ 表示已经计算出的回文半径覆盖到的最右边界,即 $\max k+R(k)-1$ . 记 $p$ 为对应中心的位置,即使得 $k+R(k)-1$ 取得最大值的 $k$ . 枚举 $i$ ,计算 $R(i)$ 时,考虑暴力匹配的过程,就是从 $i$ 不断向外拓展,也就是从 $1$ 开始枚举 $R(i)​$ ,直到不能拓展. $Manacher$ 算法就是通过记录的 $mx,p$ ,来给 $R(i)$ 确定一个下界,这样枚举 $R(i)$ 时只用从下界开始枚举. 记 $j=2p-i$ ,即 $i$ 关于 $p$ 的对称位置.分以下 $3$ 种情况进行讨论: 情况一: $mx&lt;i$ ,只能确定 $R(i)\ge 1$. 情况二: $mx-i&gt;R(j)$ ,即以第 $j$ 位为中心的回文子串包含于以第 $p$ 位为中心的回文子串. 由于 $i$ 和 $j$ 关于 $p$ 对称,以第 $i$ 位为中心的回文子串必然也包含于以第 $p$ 位为中心的回文子串,故有 $R(i)=R(j)$ . 情况三: $mx-i\le R(j)$ ,此时以第 $j$ 位为中心的回文子串不一定包含于以第 $p$ 位为中心的回文子串. 但因为 $i$ 与 $j$ 关于 $p$ 对称,所以以 $i$ 为中心向右至少能拓展到 $mx$ 的位置,即 $R(i)\ge mx-i+1$ . 在情况一与三中,确定下界后,再从下界开始枚举 $R(i)$ ,继续拓展,即暴力向外匹配. 不难验证,每次暴力向外匹配都会使得 $mx$ 增大,而 $mx$ 最多增大 $n$ 次,所以算法时间复杂度为 $O(n)$ . 从跳 $mx$ 的过程中也可以得到关于回文子串的两条比较重要的性质: 性质一: 一个长度为 $n$ 的字符串含有的本质不同的回文子串只有 $O(n)$ 个. 这是因为只有 $mx$ 增大时,才会产生本质不同的回文子串,否则一定存在对称的回文子串,而 $mx$ 增大不会超过 $n$ 次. 于是可以在算法执行过程中将所有本质不同的回文子串的位置给处理出来,在 $mx$ 增大时进行记录即可. 性质二: 一个长度为 $n$ 的字符串的回文性质可以用 $O(n)​$ 个相等与不等关系表示. 定义一个字符串的回文性质为所有回文子串出现位置的集合. 即,若串 $S$ 与串 $T$ 具有相同的回文性质,则 $S(i,\dots j)$ 为回文串,当且仅当 $T(i,\dots,j)$ 为回文串. 而一个串 $S​$ 的回文性质可以用一些相等和不等关系表示.对于以第 $i​$ 位为中心的回文子串,显然有 $0\le k&lt;R(i),S[i-k]=S[i+k]​$ ,以及 $S[i-R(i)]\not=S[i+R(i)]​$ ,这就是一些相等与不等关系. 只有当 $mx$ 增大时,才会产生新的相等关系,否则一定存在对称的相等关系,相等关系数量是 $O(n)$ 的. 而每个位置作为回文中心只会产生一个不等关系,不等关系数量也是 $O(n)$ 的. 所以可以只用 $O(n)$ 个相等和不等关系表示回文性质.]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190829]]></title>
    <url>%2F2019%2F08%2F29%2Ftest20190829%2F</url>
    <content type="text"><![CDATA[我上当了. $path$典故 枚举出发点 $S$ ,建出以 $S$ 为起点的最短路图,即只保留 $dis(u)+val(i)=dis(v)$ 的边 $i$ . 在最短路图上 $dp$ ,拓扑排序后求出 $f(i)$ 表示 $S\to i$ 的路径条数, $g(i)$ 表示以 $i$ 为起点的路径条数. 那么对于在最短路图上的一条边 $u\to v$ ,以 $S$ 为起点时的所有贡献为 $f(u)\cdot g(v)$ . 时间复杂度 $O(nm\log n)$ . $seq$典故 ,来自电子神大的 $OJ$. 由于题面没说清楚,就强行规定 $j&gt;i$ ,把数据修了. 就是要找到右边第一个严格大于 $a_x$ 的位置 $y$ ,那么 $[x+1,y-1]$ 这一段都可以作为答案,可以在线段树上二分. 然后加上从 $y$ 开始,最长单调不下降子序列的长度,这可以分块. 分成 $\sqrt n$ 个块后,维护每一块内部的不下降子序列和块边界处的不下降子序列. 询问时对整块二分,边角暴力. 然而直接 $O(n^2)$ 暴力可以过 $80\sim 100$ 分? 我上当了,写了个线段树 + 定期重构,比暴力的分还少一些,而且我发现去掉重构之后还是差不多慢. $area$求圆环的面积并, $n\le 1000$ . 留坑. 我上当了,写了个撒点,精度太垃圾了,甚至要开 $0$ 位小数才能过前两个点.]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>计算几何</tag>
        <tag>最短路</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190828]]></title>
    <url>%2F2019%2F08%2F28%2Ftest20190828%2F</url>
    <content type="text"><![CDATA[原题大战. $dna$典故 学了回文自动机再来更. $color$其实应该算是原题的弱化版. 典故 记 $dist(x)$ 表示根节点到 $x$ 的距离, $dis(x,y)$ 表示 $x,y​$ 之间的距离.$$\begin{aligned}ans&amp;=\sum_{y=1}^{k} dis(x,y) \\&amp;=\sum_{y=1}^k dist(x)+dist(y)-2\cdot dist(LCA_{x,y}) \\&amp;=dist(x)\cdot k+\sum_{y=1}^{k} dist(y)-2\cdot\sum_{y=1}^k dist(LCA_{x,y})\end{aligned}$$前面两项都容易维护,考虑如何计算最后一项的贡献. $dist(LCA_{x,y})$ 其实就是 $x$ 到根的路径与 $y$ 到根的路径交集部分的长度. 每新染黑一个 $y$ ,就将 $y$ 到根节点上的每条边标记 $+1$ . 询问时,最后那一项就是 $x$ 到根节点路径上每条边的 标记次数 $\times​$ 边长. 可以用树链剖分 + 线段树来维护,时间复杂度 $O(n\log^2 n)$ . $land$典故 题目中已经告诉我们怎么判断一个格子是否在多边形内部,这个判断条件只跟穿过次数奇偶性有关. 可以利用它进行状压 $dp$. 给每个格子选一条射线,在转移的过程中更新有宝藏和陷阱的格子那条射线穿过边的奇偶性状态. $f(i,j,S)$ 表示当前在格子 $(i,j)$ ,宝藏和陷阱的射线奇偶性状态为 $S$ 时,多边形最小周长. 转移时直接 $bfs$ ,最后枚举哪些宝藏被圈了起来,统计答案.]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>状压dp</tag>
        <tag>test</tag>
        <tag>PAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190827]]></title>
    <url>%2F2019%2F08%2F27%2Ftest20190827%2F</url>
    <content type="text"><![CDATA[roll 制出题人. 大样例没有,小样例极水,权值范围也没有,题意还没说清楚. $guard$每个武器只能打死一个人.我以为能将小于等于它的的全部打死,就保龄了. 将所有武器按 $a$ 从小到大排序. 第一次枚举确定哪些武器用精灵,如果用精灵能打死的怪的 $b&gt; a_i​$ ,就用精灵打. 然后剩下的武器都不用精灵,直接贪心匹配. 时间复杂度 $O(T\cdot n\log n)$ $phase$直接用树剖 + 线段树维护区间内所有点权值的异或和,时间复杂度是 $O(n\log^2 n)$ . 但用一下异或的性质,就能做到 $O(n\log n)$ . 记 $dist(i)​$ 表示从 $i​$ 到根节点的路径上经过的所有点权值异或和. 每次询问 $(x,y)$ ,先求出它们的 $lca$ ,答案就是 $dist(x)\text{ xor }dist(y)\text{ xor }dist(lca)\text{ xor }dist(fa(lca))$ . 树剖后用线段树来维护每个点的 $dist$ ,每次修改时,子树 $x$ 内深度奇偶性与 $x$ 不同的点 $dist$ 会被异或上 $y$ . 线段树中维护两个标记,分别表示深度为奇/偶的点需要异或上的值,时间复杂度 $O(n\log n)$ . $refuse$$50$ 分的做法是状压 $dp$ ,设 $f(r,c)$ 表示行覆盖情况为 $r$ ,列覆盖情况为 $c$ 时的期望,时间复杂度 $O(2^{n+m}\cdot nm)$ . 但不知道怎么回事写挂了,就保龄了. 下面是正解. 设 $f(i)$ 为恰好经过 $i$ 次操作后成功的概率,根据期望定义,答案 $ans=\sum_{i=0}^{+\infty} f(i)\cdot i$ . 再设 $P(i)$ 表示经过了 $i$ 次操作后还没有成功的概率.那么就等价于在之后成功的概率之和, $P(i)=\sum_{j=i+1}^{+\infty} f(i)$ . 可以发现 $ans=\sum_{i=0}^{+\infty} P(i)$ ,因为这样计算,每个 $f(i)$ 都恰好被计算了 $i$ 次. 于是需要考虑如何求出 $P(i)$ . 枚举哪些行和列在前 $i$ 次操作都没有被标记,记它们形成的集合为 $s$ . 设 $p(s)$ 表示选中集合 $s$ 中的行列中的格子 $1$ 的概率,那么 $i$ 次都没选中就是 $(1-p(s))^i$ ,利用容斥原理计算,$$P(i)=\sum_s (-1)^{|s|+1} \cdot (1-p(s))^i$$代入答案 $ans$ ,$$\begin{aligned}ans&amp;=\sum_{i=0}^{+\infty} P(i) \\&amp;=\sum_{i=0}^{+\infty} \sum_s (-1)^{|s|+1} \cdot (1-p(s))^i \\&amp;=\sum_s (-1)^{|s|+1}\cdot \frac 1 {p(s)}\end{aligned}$$设 $tot$ 为格子 $1$ 的总数目, $sum(s)$ 表示集合 $s$ 的行列含有的 $1$ 的数目,那么答案为$$ans=\sum_{s}(-1)^{|s|+1}\cdot \frac {tot} {sum(s)}$$于是只需要计算 $sum(s)$ .因为 $sum(s)$ 相同的状态有很多,可以设 $num(x)=\sum_s [sum(s)=x]\cdot (-1)^{|s|+1}$ . 则答案为$$ans=\sum_{x=1}^{tot} num(x)\cdot \frac {tot} {x}$$考虑如何计算 $num(x)$ ,由于 $n\cdot m\le 200$ ,所以 $\min(n,m)\le 14$ . 假设 $n\le m$ ,否则只需交换行与列. 暴力 $2^n$ 枚举选了哪些行,对列做 $dp$ ,设 $dp(i,j,k)$ 表示考虑了前 $i$ 列, $|s|$ 的奇偶性为 $j$ , $sum(s)=k$ 的方案数. 最后根据奇偶性计算出每个 $num(x)​$ ,统计答案即可. 时间复杂度为 $O(2^n\cdot m^2\cdot n )​$ .]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>概率/期望</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>容斥原理</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190826]]></title>
    <url>%2F2019%2F08%2F26%2Ftest20190826%2F</url>
    <content type="text"><![CDATA[两个简单题 + 一个比较难的原题. $Gene$有一个十分简单的 $O(n\log n)$ 的做法,字符串 $hash$ + 二分,用自然溢出常数比较小,是可以过的. $O(n)$ 的一个做法是 $SAM$ ,对反串建后缀自动机,答案就是每个点的 $siz$ 之和,但空间很容易炸. 另一个做法是利用 $kmp$ 的 $fail$ 数组,每个位置不断往前跳,每跳一次就说明有一个合法的匹配. 暴力跳会超时,记忆化一下,用 $f(i)$ 表示从 $i$ 开始能往前跳几次,则 $f(i)=f(fail_i)+1$ . $Shield$因为给出的两个向量线性无关,可以它们为一组基底,解出每个点在这组基底下的坐标. 于是一个点可以转移到 $x,y$ 都不小于它的点. 将点按 $x$ 为第一关键字, $y$ 为第二关键字排序,将 $y$ 离散化后用树状数组做一个类似于 $LIS$ 的 $dp$ 即可. 时间复杂度 $O(n\log n)$ . 坐标太大,精度爆掉了一个点.其实可以在比较元素时再转换坐标,避免小数运算. $Chronosphere$典故 首先可以建出源汇点 $S,T​$ ,源点向所有点连边,所有点向汇点连边. 问题转化为最小化删去一个点后 $S\to T$ 的最长路长度. 拓扑排序 + $dp$ 处理出 $f(i),g(i)$ 分别表示 $S\to i$ 的最长链与 $i\to T$ 的最长链经过的点数. 那么对于一条边 $u\to v$ ,它的的贡献就是 $f(u)+g(v)-1$ . 若有一个 $S\to T$ 的割,那么所有 $S\to T$ 路径一定会经过至少一条割集中的边,只需要考虑割集中的边贡献. 一开始让 $s$ 集只有 $S$ , $T$ 集包含剩余的所有点,这是一个合法的割. 按照拓扑序枚举删掉 $x$ 后的答案,依次进行如下操作,以将点 $x$ 从 $T$ 集合中取出,放入 $S$ 集中. $1.$ 将 $x$ 的所有入边从割集中删掉. $2.$ 所有割集的边的最大贡献就是删掉点 $x$ 的答案. $3.$ 将 $x$ 的所有出边加入割集. 正确性可以利用数学归纳法证明. 执行第 $1$ 步之前,割是整张图的一个割,假设它不含从 $x$ 出发能到的任何边. 所以删掉 $x$ 的入边后,割就是去掉 $x$ 的图的一个合法割,此时可以更新答案. 若将 $x$ 放回图中, $S\to T$ 的路径就一定经过 $x$ ,所以割掉 $x$ 的所有出边,又成了一个合法割. 因为是按照拓扑序依次处理的,所以加入的 $x$ 的入边在之后一定不能被到达,满足了先前的假设. 而初始状态也是满足假设的,所以可以归纳证得以上算法的正确性. 割集只需要记录边的贡献,不记录边的编号,所以可以用一棵权值线段树进行维护,时间复杂度 $O(m\log m)$ .]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树状数组</tag>
        <tag>kmp</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190825]]></title>
    <url>%2F2019%2F08%2F25%2Ftest20190825%2F</url>
    <content type="text"><![CDATA[我的线段树自带 $10$ 倍常数. $Count$对于每一种 $\prod a_i\not=n^m​$ 的选法,都恰好存在另一种对应的选法 $\prod \frac n {a_i}​$ . 随便选的方案数为 $(\sigma(n))^{2m}$ ,再加上 $\prod a_i=n^m$ 的方案数,除以 $2$ 就是答案. 于是只需要算 $\prod a_i=n^m$ 的方案数. 将 $n$ 分解质因数,显然每个质因子可以分开算方案,答案是每个质因子的贡献乘积. 每个质因子的贡献就是一个整数划分问题, $dp$ 一下,因为方案数只与质因子质数有关,所以可以最后一起加入贡献. $Delete$每次删掉最长的一个单调序列,直到删完. 假设当前的序列长度为 $n$ ,最长上升子序列长度为 $a$ ,最长下降子序列长度为 $b$ . 根据 $Dilworth$ 定理,用最长上升子序列覆盖这个序列至少需要的子序列数目也是 $b$ . 所以就有 $a\cdot b\ge n$ ,得到 $\max(a,b)\ge \sqrt n$ . 于是每次操作至少会使得一个长度为 $n$ 的序列长度减少 $\sqrt n$ ,当 $n=64000$ 时,一定可以在 $500$ 次内删完. $Floor\ it$考虑斐波那契数列的两个特征根 $\phi_1=\frac {1+\sqrt 5} 2,\phi_2=\frac {1-\sqrt 5} 2$ ,其中 $\phi_1$ 就是题目中给出的 $x$ . 构造数列 $a_i=\phi_1^i+\phi_2^i$ ,则 $a$ 有递推式 $a_i=a_{i-1}+a_{i-2},a_1=1,a_2=3$ ,可知 $\forall i\in \mathbb N+,a_i\in \mathbb N+ $. 当 $n$ 为偶数时, $0&lt;\phi_2^n&lt;1,\lfloor x^n\rfloor=a_n-1$ . 当 $n$ 为奇数时, $-1&lt;\phi_2^n&lt;0,\lfloor x^n \rfloor=a_n$ . 用矩阵快速幂 $O(\log n)​$ 求 $a_n​$ 即可.]]></content>
      <tags>
        <tag>构造</tag>
        <tag>线段树</tag>
        <tag>数学</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Japanese Student Championship 2019 Qualification]]></title>
    <url>%2F2019%2F08%2F25%2FJapanese-Student-Championship-2019-Qualification%2F</url>
    <content type="text"><![CDATA[$\text{+9 rating}$ 可还行. A Takahashi Calendar签到题,按题意暴力枚举一下. B Kleene Inversion贡献可以分成两部分,两个数在同一块中的贡献与两个数在不同块中的贡献,分开算一下. C Cell Inversion操作顺序对答案没有影响,将操作视作一个二元组 $(l,r)$ ,我们可以规定按 $l$ 从小到大的顺序操作,最后答案乘上 $n!$ . 将黑色看为 $1$ ,白色看为 $0$ ,显然只需要将偶数位置上的状态取反,然后答案就是前面的 $1$ 与后面的 $0$ 配对的方案数. 开始没判 $1$ 和 $0$ 个数不等的情况,卡了挺久的. D Classified题意读错了.意思是走回来时,走过的长度为偶数,不是每条边经过的次数都为偶数. 于是就要求同一种边权的边形成的图是二分图. 如果用到最大的边权为 $k$ ,那么最多只能构造出 $n=2^k$ 的情况. 首先证最大边权为 $k​$ 时, $n=2^k+1​$ 不可行. 考虑使用数学归纳法,当 $k=1,n=2^1+1=3$ 时,显然不可行.否则,假定 $k=x-1,n=2^{x-1}+1$ 时不可行. 那么当 $k=x,n=2^x+1$ 时,二分图中黑色的节点至少有 $2^{x-1}+1$ 个,否则白色的节点至少有 $2^{x-1}+1$ 个. 假设黑色节点至少有 $2^{x-1}+1$ 个,对于黑色节点内部,因为用前 $x-1$ 种边权无合法解,所以一定会有权值为 $x$ 的边. 这与二分图的定义相矛盾了,所以结论成立,即最大边权为 $k$ 时, $n=2^k+1$ 不可行. 再来证 $n\le2^k$ 时一定存在最大边权不超过 $k$ 的合法解,尝试直接构造方案. 对于节点 $i,j$ ,若它们的二进制位从低到高第 $x$ 位不同,就将它们之间的边权设为 $x$ . 这样对于任意一个 $0\le x&lt;k$ ,边权为 $k$ 的边一定只存在于第 $x$ 位为 $0$ 与第 $x$ 位为 $1$ 的点之间,形成了二分图. E Card Collector考虑像网络流那样,每一行每一列都建出一个点,读入的每个点向所在行列连边,权值都是 $A_i$ . 于是需要选出一些边使得它们的权值最大,并且任意两条边不能有公共点. 分析性质后,发现就是在求解加权拟阵的最大权值独立子集,贪心求解即可. 即将所有边按权值从大到小排序后,依次遍历,若当前的边能加入,就加入. F Candy Retribution留坑.]]></content>
      <tags>
        <tag>Atcoder</tag>
        <tag>构造</tag>
        <tag>数学</tag>
        <tag>二分图</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4245 OR-XOR]]></title>
    <url>%2F2019%2F08%2F24%2Fbzoj-4245-OR-XOR%2F</url>
    <content type="text"><![CDATA[贪心. 因为答案的形式是每一段的权值 $\text {or}$ 起来,从高位到低位考虑,贪心地让高位尽可能为 $0$ . 尝试让答案的第 $i$ 位为 $0$ ,就要求选出的 $m$ 个权值的第 $i$ 位都为 $0$ . 因为这 $m$ 段是连续的,所以就等价于选出 $m$ 个右端点,且最后一个必须选 $n$ . 求出原数列的前缀异或和,容易发现这 $m$ 个右端点处的前缀异或和第 $i$ 位都必须为 $0$ . 于是从高位往低位做,若当前位有至少 $m$ 个可选的位置(必须包含 $n$ ),则这一位对答案的贡献为 $0$, 否则为 $1$ . 每次贡献为 $0$ 时,将前缀异或和这一位为 $1$ 的位置标记出来,表示以后都不能再选了,否则会使得这一位为 $1$ . 注意要用 $\text{1LL}$ 参与位运算. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e5+10;int n,m;ll sum[MAXN];bool vis[MAXN];bool check(int k)&#123; if((sum[n]&gt;&gt;k)&amp;1LL) return false; int cnt=0; for(int i=1;i&lt;=n;++i) if(!((sum[i]&gt;&gt;k)&amp;1LL) &amp;&amp; !vis[i]) ++cnt; return cnt&gt;=m;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) sum[i]=sum[i-1]^read(); ll ans=0; for(int k=62;k&gt;=0;--k) &#123; if(check(k)) &#123; for(int i=1;i&lt;=n;++i) if((sum[i]&gt;&gt;k)&amp;1LL) vis[i]=true; &#125; else ans|=(1LL&lt;&lt;k); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4299 FRBSUM]]></title>
    <url>%2F2019%2F08%2F24%2Fbzoj-4299-FRBSUM%2F</url>
    <content type="text"><![CDATA[主席树. 考虑如何计算一个集合的 $\text{Forbidden Sum}​$ . 将集合内的数从小到大排序,依次加入.若当前可以表示出 $[0,s]$ 内的所有数,再加入一个数 $x$ . 若 $x\le s+1$ ,则可以表示出 $[0,s+x]$ 内的所有数.若 $x&gt; s+1$ ,则 $s+1$ 无法被表示出,答案为 $s+1$ . 实际做的时候可以换一种思路,将枚举 $x$ 变为不断更新 $s$ . 初始令 $s=1​$ ,每次在区间 $[l,r]​$ 内询问所有 $\le s​$ 的数之和,即上面分析的前缀和.若询问到的 $x&lt;s​$ ,则答案为 $s​$ . 否则令 $s=x+1$ ,继续询问. 询问一段区间内 $\le s​$ 的所有数之和可以用主席树实现. 考虑时间复杂度,若每次都 $x\ge s$ ,每次询问 $s$ 至少翻一倍,所以在主席树上查询了 $O(\log \sum a_i)$ 次. 总时间复杂度为 $O(m\cdot \log \max a_i\cdot \log \sum a_i)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;struct PreSegtree&#123; int idx; struct node &#123; int ls,rs; int sum; node()&#123;ls=rs=sum=0;&#125; &#125;Tree[MAXN*30]; PreSegtree()&#123;idx=0;&#125;#define root Tree[o] void ins(int &amp;o,int pre,int l,int r,int pos,int c) &#123; o=++idx; root=Tree[pre]; root.sum+=c; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(root.ls,Tree[pre].ls,l,mid,pos,c); else ins(root.rs,Tree[pre].rs,mid+1,r,pos,c); &#125; int query(int o,int l,int r,int val)// \le val &#123; if(l&gt;val) return 0; if(r&lt;=val) return root.sum; int mid=(l+r)&gt;&gt;1; return query(root.ls,l,mid,val)+query(root.rs,mid+1,r,val); &#125;&#125;T;int n,m,a[MAXN],mx=0,rt[MAXN];int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) mx=max(mx,a[i]=read()); for(int i=1;i&lt;=n;++i) T.ins(rt[i],rt[i-1],1,mx,a[i],a[i]); m=read(); for(int i=1;i&lt;=m;++i) &#123; int L=read(),R=read(); for(int s=1,x;;s=x+1) &#123; x=T.query(rt[R],1,mx,s)-T.query(rt[L-1],1,mx,s); if(x&lt;s) &#123; printf("%d\n",s); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4289 Tax]]></title>
    <url>%2F2019%2F08%2F23%2Fbzoj-4289-Tax%2F</url>
    <content type="text"><![CDATA[构造建图 + 最短路. 先将无向边拆成两条有向边,于是可以将原图中的每条有向边看成一个点,建一个新图. 枚举中继点 $x$ ,则对 $a\to x,x\to b$ 这两条边在新图中连上对应有向边,权值为两者最大值. 在新图中建立源汇点 $S,T$ ,从 $S$ 向所有在原图中以 $1$ 为起点的边连边,从所有在原图中以 $n$ 为终点的边向 $T$ 连边,权值均为原来的权值,那么答案就是新图中 $S\to T$ 的最短路. 但这样边数可以被菊花图这样的东西卡到 $O(m^2)$ 去,需要利用差分的思想优化连边. 对于每个点 $u$ ,将所有以它为起点的边按照权值从小到大排序,对于相邻的两条边 $x,y$ ,假设 $val_x&lt;val_y$ ,就在新图中从 $x$ 向 $y$ 连权值为 $val_y-val_x$ 的边,从 $y$ 向 $x$ 连权值为 $0$ 的边, $S,T$ 相关的边连法不变. 这样连边边数就是 $O(m)$ 了,在新图上跑 $Dijkstra$ 求出最短路. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int N=1e5+10,M=4e5+10;const int MAXM=2e6+10;int n,m;typedef pair&lt;ll,int&gt; pli;priority_queue&lt;pli&gt; q;const ll inf=1e18;struct Graph&#123; int ecnt,head[MAXM],to[MAXM],nx[MAXM],vis[MAXM]; ll val[MAXM],dis[MAXM]; void addedge(int u,int v,ll w) &#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt; &#125; Graph()&#123;ecnt=0;memset(head,0,sizeof head);&#125; ll Dijkstra(int S,int T,int tot) &#123; for(int i=1;i&lt;=tot;++i) vis[i]=0,dis[i]=inf; dis[S]=0; q.push(make_pair(-dis[S],S)); while(!q.empty()) &#123; int u=(q.top()).second; q.pop(); if(vis[u]) continue; vis[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(dis[v]-val[i]&gt;dis[u]) &#123; dis[v]=dis[u]+val[i]; q.push(make_pair(-dis[v],v)); &#125; &#125; &#125; return dis[T]; &#125;&#125;G;int ecnt,head[N],to[M],nx[M];ll val[M];void addedge(int u,int v,ll w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;bool cmp(int x,int y)&#123; return val[x]&lt;val[y];&#125;int S,T,tmp[MAXM],cnt;void BuildGraph()&#123; S=ecnt+1,T=ecnt+2; for(int i=1;i&lt;=ecnt;i+=2) &#123; G.addedge(i,i+1,val[i]); G.addedge(i+1,i,val[i]); &#125; for(int u=1;u&lt;=n;++u) &#123; cnt=0; for(int i=head[u];i;i=nx[i]) tmp[++cnt]=i; sort(tmp+1,tmp+1+cnt,cmp); for(int i=1;i&lt;cnt;++i) &#123; int x=tmp[i],y=tmp[i+1]; G.addedge(x,y,val[v]-val[u]); G.addedge(y,x,0); &#125; &#125; for(int i=head[1];i;i=nx[i]) G.addedge(S,i,val[i]); for(int i=head[n];i;i=nx[i]) G.addedge((i&amp;1)?i+1:i-1,T,val[i]);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); ll w=read(); addedge(u,v,w); addedge(v,u,w); &#125; BuildGraph(); printf("%lld\n",G.Dijkstra(S,T,T)); return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3516 国王奇遇记加强版]]></title>
    <url>%2F2019%2F08%2F23%2Fbzoj-3516-%E5%9B%BD%E7%8E%8B%E5%A5%87%E9%81%87%E8%AE%B0%E5%8A%A0%E5%BC%BA%E7%89%88%2F</url>
    <content type="text"><![CDATA[推式子题目. 设 $s_x=\displaystyle \sum_{i=1}^n i^x\cdot m^i$ ,则答案 $ans=s_m$ . 考虑构造出 $s_x$ 的递推式. $$\begin{aligned}s_x+(n+1)^x\cdot m^{n+1}&amp;=m\cdot\sum_{i=1}^n (i+1)^x \cdot m^i+m \\&amp;=m\cdot \sum_{i=1}^n \sum_{j=0}^x {x\choose j} i^j \cdot m^i+m\\&amp;=m\cdot \sum_{i=0}^x s_i\cdot {x\choose i} + m\\(1-m)s_x&amp;=m\cdot \sum_{i=0}^{x-1}s_i\cdot {x\choose i}+m-(n+1)^x\cdot m^{n+1}\end{aligned}$$ 特判 $m=1$ 的情况,其余情况利用等比数列求和公式算出 $s_0$ ,再 $O(m^2)$ 递推求得 $s_m$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e3+10;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void upd(int &amp;x,int y)&#123; x=add(x,y);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; a=(a%P+P)%P; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;int n,m,C[MAXN][MAXN];int s[MAXN];int main()&#123; n=read(),m=read(); if(m==1) return printf("%d\n",mul(mul(n,n+1),inv(2)))&amp;0; for(int i=0;i&lt;=m;++i) C[i][0]=1; for(int i=1;i&lt;=m;++i) for(int j=1;j&lt;=i;++j) C[i][j]=add(C[i-1][j-1],C[i-1][j]); s[0]=fpow(m,n)-1; s[0]=mul(s[0],inv(m-1)); s[0]=mul(s[0],m); for(int x=1;x&lt;=m;++x) &#123; int &amp;tmp=s[x]; for(int i=0;i&lt;x;++i) upd(tmp,mul(s[i],C[x][i])); tmp=mul(tmp,m); upd(tmp,m); upd(tmp,P-mul(fpow(n+1,x),fpow(m,n+1))); tmp=mul(tmp,inv(1-m)); &#125; cout&lt;&lt;s[m]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5343 混合果汁]]></title>
    <url>%2F2019%2F08%2F20%2Fbzoj-5343-%E6%B7%B7%E5%90%88%E6%9E%9C%E6%B1%81%2F</url>
    <content type="text"><![CDATA[二分答案 + 主席树. 将美味度离散化,并将所有果汁按照美味度从小到大排序. 可以用主席树维护单价区间能购买到的最大体积之和与总金额之和,对美味度可持久化. 对于每个询问,二分答案 $ans$ ,只考虑美味度 $\ge ans$ 的果汁. 显然应该贪心地选,尽可能选便宜的凑够体积. 于是查询时在主席树上将美味度 $\ge ans$ 的部分抠出来,进行二分. 若左儿子内的体积够,就返回左儿子的答案. 否则将需要的体积减去左儿子内的体积,返回右儿子的答案加上左儿子的所有价格. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;const ll inf=1e18;int n,m,td,tp;ll D[MAXN],P[MAXN];struct Juice&#123; int d,p,lim; bool operator &lt; (const Juice &amp;rhs) const &#123; return d&lt;rhs.d; &#125;&#125;a[MAXN];int rt[MAXN];struct PreSegtree&#123; int idx; struct node &#123; int ls,rs; ll sumv,sumc; node()&#123;ls=rs=sumv=sumc=0;&#125; &#125;Tree[MAXN*30]; PreSegtree()&#123;idx=0;&#125; void upd(int &amp;cur,int pre,int l,int r,int cost,ll v,ll c) &#123; cur=++idx; Tree[cur]=Tree[pre]; Tree[cur].sumv+=v; Tree[cur].sumc+=c; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(cost&lt;=mid) upd(Tree[cur].ls,Tree[pre].ls,l,mid,cost,v,c); else upd(Tree[cur].rs,Tree[pre].rs,mid+1,r,cost,v,c); &#125;#define root1 Tree[Lrt]#define root2 Tree[Rrt] ll query(int Lrt,int Rrt,int l,int r,ll tmpv) &#123; if(root2.sumv-root1.sumv&lt;tmpv) return inf; if(root2.sumv-root1.sumv==tmpv) return root2.sumc-root1.sumc; if(l==r) return tmpv*P[l]; int mid=(l+r)&gt;&gt;1; ll totl=Tree[root2.ls].sumv-Tree[root1.ls].sumv; if(totl&gt;=tmpv) return query(root1.ls,root2.ls,l,mid,tmpv); return Tree[root2.ls].sumc-Tree[root1.ls].sumc+query(root1.rs,root2.rs,mid+1,r,tmpv-totl); &#125;&#125;T;int pos[MAXN];bool check(int k,ll budget,ll tmpv)&#123; int rt1=rt[pos[k]-1],rt2=rt[n]; ll cost=T.query(rt1,rt2,1,tp,tmpv); return cost&lt;=budget;&#125;void init()&#123; sort(a+1,a+1+n); for(int i=1;i&lt;=n;++i) &#123; int x=a[i].d; if(!pos[x]) pos[x]=i; T.upd(rt[i],rt[i-1],1,tp,a[i].p,a[i].lim,1LL*a[i].lim*P[a[i].p]); &#125;&#125;void solve()&#123; for(int i=1;i&lt;=m;++i) &#123; ll budget=read(),tmpv=read(); int L=1,R=td,res=-1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid,budget,tmpv)) res=mid,L=mid+1; else R=mid-1; &#125; if(res==-1) puts("-1"); else printf("%lld\n",D[res]); &#125;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; D[i]=a[i].d=read(); P[i]=a[i].p=read(); a[i].lim=read(); &#125; sort(D+1,D+1+n); td=unique(D+1,D+1+n)-D-1; for(int i=1;i&lt;=n;++i) a[i].d=lower_bound(D+1,D+1+td,a[i].d)-D; sort(P+1,P+1+n); tp=unique(P+1,P+1+n)-P-1; for(int i=1;i&lt;=n;++i) a[i].p=lower_bound(P+1,P+1+tp,a[i].p)-P; init(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>主席树</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我复习 noip 数据结构这件小事]]></title>
    <url>%2F2019%2F08%2F20%2F%E5%85%B3%E4%BA%8E%E6%88%91%E5%A4%8D%E4%B9%A0-noip-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%99%E4%BB%B6%E5%B0%8F%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[平衡树与 $LCT$ 待更. $STL$关键是会用.比较常用的有 $set,mutiset,priority\ queue,map$ 这几个. 简单说一下 $bitset$ . 1bitset&lt;MAXN&gt; s; 这样就定义了一个 $bitset$ .默认所有位置都是 $0$ . 可以把它看成是一个长度为 $MAXN$ 的布尔数组,也可以看成是有 $MAXN$ 位的二进制数. 它支持直接调用/修改某一位上的值, 12s[0]=1;s[1]=1; 也可以用它直接进行位运算, 1s=s|(s&lt;&lt;10); 一次位运算耗时是长度/系统位数,一般是 $32$ 或者 $64$ . 这个东西就可以把一些只有 $0/1$ 运算的做法给优化 $32/64$ 倍. 原理也很好理解,就是把每 $32/64$ 位压成一个整数参与运算,所以也可以手写它,不过会比较麻烦. 贪心只能过样例 sol 并查集一定记得要初始化. 优化的方式主要有两种,路径压缩和按秩合并.按秩合并就是把小的合并进大的里面. 如果需要支持退回上一步操作,那么就只能选用按秩合并. 单独使用路径压缩或者按秩合并,查询一次的时间复杂度是 $O(\log n)$ ,同时使用是 $O(\alpha(n))$ . 但大多数情况我们都只写路径压缩,因为很难将它卡到 $\log$ 的级别去. 有些并查集会顺带维护这个块内的其他信息,合并的时候一起合并就可以了. 树状数组一维的树状数组比起线段树的优势就是代码容易编写与常数较小,而功能远不如线段树全面. 它的优点是可以比较简单的拓展到高维,而二维线段树就已经比较难写了. 如二维平面上的数点/求和,但坐标可能需要离散化. 上帝造题的七分钟 线段树经典数据结构,使用的方法也很多. 经典应用线段树的经典应用,维护区间内的信息,并支持单点/区间修改.如维护区间和,支持区间加,区间乘. 本质上只有这三个点是会根据不同的题而产生差别的. 如何将两个小区间内的信息合并起来得到大区间. 一个修改操作执行后,区间内的各个信息分别会怎样变化. 如何合并两个懒标记(如果有区间修改). 如果你发现这三点都能在很短的时间内做到,那么这个信息就可以用线段树来维护. 算术天才⑨与等差数列 sol 排序 sol 序列 sol 动态开点线段树就是新到一个点的时候,如果没有,你再新建一个节点作为这个节点. 回转寿司 sol 可持久化线段树 又称主席树,因为发明者的姓名拼音缩写为 hjt ,与中华人民共和国前国家主席的缩写一样… 可以存储 $m$ 个版本的线段树信息,要求每次修改都只是单点修改,每颗线段树的管辖范围都是 $[1,n]$ . 考虑线段树的一次单点修改操作,影响到的节点只有对应叶子节点到根节点路径上的所有节点. 这些节点数目是 $O(\log n)$ 的,所以在维护新版本的线段树时,只用新建出这些节点,其它节点沿用上个版本的. 并不用每次都把上个版本的所有节点拷贝出来,因为每个节点只需要知道儿子节点,直接将儿子节点指过去. 显然需要使用动态开点. 经典的使用方法是利用主席树对 $[1,1],[1,2],[1,3]\dots,[1,n]$ 这 $n$ 个前缀建出 $m$ 颗线段树. 这样在查询可减的信息时(如某数的个数),就可以直接用 $[1,R]$ 的线段树答案减去 $[1,L-1]$ 的线段树答案了. Kth number sol 混合果汁 sol 李超线段树解决的经典问题是每次可以在平面内添加一条 $y=kx+b​$ 的线段,或者询问当 $x=x_0​$ 时,各个线段中最大的 $y​$ . 如果是先添加完所有线段,再进行若干次询问,可以求出上凸壳, $O(n\log n)$ 解决. 李超线段树维护的是各段区间内 优势线段 的编号. 优势线段 是指,这段区间内能成为最优线段的长度最大的那条线段. 往区间 $(l,r)$ 插入一条线段 $c$ 时,就与当前区间 $(l,r)$ 内维护的优势线段 $s$ 比较. 若这两条线段在 $(l,r)$ 内满足一条完全覆盖了另一条,就直接更新优势线段并返回. 否则,就递归下去,用 $c$ 去更新两个子区间. 因为至少在 $[l,mid]$ 与 $[mid+1,r]$ 这两个区间中的一者, $c$ 完全覆盖了 $s$ ,或 $s$ 完全覆盖了 $c$ . 所以更新一个线段树上的区间的时间复杂度是 $O(\log n)$ ,插入一条线段的总时间复杂度是 $O(\log^2 n)$ . 查询时就在线段上向下走,经过一个区间时,就用这个区间的优势线段来更新答案,每次的时间复杂度是 $O(\log n)$ . 适者 sol 游戏 sol) 吉司机线段树区间取最值问题维护一个长度为 $n$ 的整数序列 $a$ ,支持以下 $m$ 次操作: 区间 $[L,R]$ 内的所有数 $a_i$ 与 $x$ 取 $\min$ . 区间 $[L,R]$ 内所有数加上 $x$ . 询问区间 $[L,R]$ 中 $a_i$ 的最大值. 询问区间 $[L,R]$ 中 $a_i​$ 的和. 对线段树每个区间维护最大值 $mx$ ,最大值的个数 $cnt$ ,次大值 $se$ ,区间和 $sum$ . 询问操作可以定位后直接做. 对于修改操作,若将一个线段树区间对 $x$ 取 $\min$ ,可以分情况讨论: $mx\le x$ ,无效果,直接返回. $se&lt;x&lt;mx$ .效果就是将所有 $mx$ 改为 $x$ ,其它不变.新的区间和 $sum’=sum-(mx-x)\cdot cnt​$ 可以直接算出,再打上修改标记,返回. $x\le se​$ .递归下去,分别修改左右儿子. 复杂度为 $O(n\log^2 n)$ ,但实现效果接近 $O(n\log n)$ .如果没有操作 $2$ ,复杂度就是 $O(n\log n)$ . 最假女选手 历史最值问题维护一个长度为 $n$ 的数列 $a$ ,支持以下 $m$ 次操作: 区间 $[L,R]$ 内所有数加上 $x$ . 区间 $[L,R]$ 内所有数变为 $x$ . 询问 $[L,R]$ 内数的最大值. 询问 $[L,R]$ 内数的历史最大值. 修改操作的 $x$ 可能 $&lt;0$ . 尝试将两种修改操作归纳为一种修改操作 $(a,b)$ ,表示先加上 $a$ ,再与 $b$ 取 $\max$ . 那么修改 $1$ 对应的操作就是 $(x,-\inf)$ ,修改 $2$ 对应的操作就是 $(-\inf,x)$ . 考虑两个标记如何合并,假设当前权值为 $v$ ,依次经过 $(a,b),(c,d)$ 两次修改的效果:$$\begin{aligned}v&amp;\to \max{\max{v+a,b}+c,d} \\&amp;=\max{v+a+c,b+c,d} \\&amp;=\max{v+a+c,\max{b+c,d}}\end{aligned}$$可以看出就等价于一次修改操作 $(a+c,\max{b+c,d})$ ,于是两个标记就合并为了一个. 为了能查询历史信息,维护一个意义一样的标记 $(a,b)$ ,表示区间内历史的最大增加量 $a$ ,历史最大与 $b$ 取 $\max$ . 将两个标记的 $+$ 定义为两个标记的合并,两个标记取 $\max$ 定义为两个元素分别取 $\max$ . 每次更新标记后,若当前标记为 $x$ ,历史标记为 $y$ ,则让 $y=\max(x,y)$ . 每个结点需要维护当前标记,历史标记,当前最大值,历史最大值 $4$ 个信息. CPU监控 线段树分治题目也是让你维护一些信息,每次可以询问,可以执行一种操作,也可以将之前的某个操作撤回. 操作容易维护,但撤回操作不容易维护. 需要将操作,询问都离线下来.将时间轴画出来,那么每个操作只在时间轴上的一个区间内生效. 用线段树给这个区间打上这个操作的标记,维护信息. 数学计算 sol 洞穴勘测 sol 线段树合并其实就是两颗权值线段树的合并,都使用动态开点. 如果合并到一个位置时,其中一者没有这个位置上的节点,就直接返回另一者. 否则将这个位置的信息合并后,还要递归合并它们的儿子. 树的难题 sol $kd-tree$处理二维/高维上点的信息.其实就是一棵二叉树. 注意它是二叉树,所以信息的存储与线段树不同. $kd-tree$ 每个结点存储的是整个子树的信息和自己的信息. 每个点有若干个维度,可以表示为 $(p_1,p_2,p_3,\dots,p_k)$ . 建树时,选择按照当前维度排序后的中点作为根,递归建左右子树,每次进入下一层是更换当前维度. 每个节点需要维护自己的坐标,以及每个维度的管辖范围. 查找平面上最近点是爆搜 + 剪枝,复杂度为玄学. 如果提出一个范围内所有点进行修改/询问,复杂度为 $O(n^{1-\frac 1 k})$ ,其中 $k$ 为维度. 这里的范围是指每一维的坐标都在某个特定的区间中,如二维平面中的矩形. 巧克力王国 弹跳 莫队经典莫队需要离线,且无修改操作. 问题是给出 $m$ 个询问,每次询问序列上一个区间 $[l,r]$ 内的信息. 特点是如果维护了 $[l,r]$ 内的所有信息与答案,则可以 $O(1)$ 得出 $[l,r+1],[l,r-1],[l-1,r],[l+1,r]$ 这些区间的信息与答案. 做法是将长度为 $n$ 的序列分块,每 $B$ 个数分为一块. 再将询问排序,排序时以 $l$ 所属块的编号为第一关键字,以 $r$ 为第二关键字. 然后维护当前区间 $[L,R]$ 中的信息,遍历每个询问,不断移动当前区间端点并更新信息,当前区间与询问区间重合时,就得到了答案. 考虑这样做的时间复杂度. 对于同一块内的询问, $L$ 移动 $O(B)$ 次, $R$ 只会往右侧移动,移动 $O(n)$ 次. 对于不同块内的询问, 在每次块改变时, $L$ 移动 $O(B)$ 次, $R$ 移动 $O(n)$ 次. 所以总移动次数为 $O(mB+\frac {n^2} B)$ 取 $B=\frac n {\sqrt m}$ 时最优. 再加上给询问排序,整个算法时间复杂度为 $O(n\sqrt m+m\log m)$ . mex sol permu sol 带修莫队就是支持修改的莫队. 做法是将每次询问的时间也考虑进去,形成一个三元组 $(l,r,t)$ 排序时加入 $t$ 作为第三关键字. 若移动端点的同时时间跨越了某个修改操作,那么就执行/撤回修改. 为了便于分析,视 $n,m$ 同阶,时间复杂度 $O(n^{\frac 5 3})$ . 树上莫队分块方式 定义这里的取反是指,若当前节点的信息在贡献中,则除去,否则加入. 若从$(pu,pv)$ 移动到 $(u,v)$ ,则只需对路径 $(pu,u),(pv,v)$ 的点是否包含情况取反, $LCA​$ 不处理. 保存答案前对 $(u,v)$ 的 $LCA$ 取反,答案保存后再将它取反回去. 若有修改操作,则还需记录每个询问的时间. 时间复杂度与序列上的莫队完全一致. 糖果公园 扫描线最经典的是求矩形面积并.将每个矩形按照 $x$ 坐标排序,从左往右扫过来,看成两个事件,加入和删除. 每次发生了加入事件就去更新答案. 需要注意边界的处理问题,加入和删除操作需要分出前后顺序,根据题目而定. 花火 sol $cdq$ 分治一段区间 $[l,r]$ 内的元素两两之间可能产生贡献,要计算出所有贡献. 取区间中点 $mid$ 将区间分为左右两段. 贡献可以分为左边对左边的贡献,右边对右边的贡献,左边对右边的贡献. 前两者可以递归下去处理,所以只需要考虑左边对右边的贡献. 注意每次处理左边对右边的贡献时,时间复杂度必须是与 $[L,R]$ 的长度相关,而不是与整个序列长度 $n$ 相关. 陌上花开 sol 稻草人 sol]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2956 模积和]]></title>
    <url>%2F2019%2F08%2F19%2Fbzoj-2956-%E6%A8%A1%E7%A7%AF%E5%92%8C%2F</url>
    <content type="text"><![CDATA[整除分块. 可以把 $i=j$ 的贡献算上,后面再减掉. 假设 $n\le m$ . $$\begin{aligned}ans&amp;=\sum_{i=1}^n \sum_{j=1}^m (n\bmod i)(m\bmod j)-\sum_{i=1}^n (n\bmod i)(m\bmod i) \\&amp;=\sum_{i=1}^n \sum_{j=1}^m (n-\lfloor\frac n i \rfloor\cdot i)(m-\lfloor\frac m j \rfloor\cdot j)-\sum_{i=1}^n (n-\lfloor\frac n i \rfloor\cdot i)(m-\lfloor\frac m i \rfloor\cdot i) \\&amp;=\sum_{i=1}^n (n-\lfloor\frac n i \rfloor\cdot i)\sum_{i=1}^m (m-\lfloor\frac m i \rfloor\cdot i) -\sum_{i=1}^n nm+i^2\cdot \lfloor\frac n i \rfloor\lfloor\frac m i \rfloor-n\cdot \lfloor\frac m i \rfloor\cdot i-m\cdot \lfloor\frac n i \rfloor \cdot i\end{aligned}$$整除分块计算即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=19940417;const int inv2=(P+1)&gt;&gt;1,inv6=3323403;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void upd(int &amp;x,int y)&#123; x=add(x,y);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int S1(int l,int r)&#123; return mul(mul(l+r,r-l+1),inv2);&#125;int s2(int x)&#123; return mul(mul(x,mul(x+1,2*x+1)),inv6);&#125;int S2(int l,int r)&#123; return add(s2(r),P-s2(l-1));&#125;int calc(int n)&#123; int ans=0; for(int l=1,r;l&lt;=n;l=r+1) &#123; r=n/(n/l); upd(ans,mul(n,r-l+1)); upd(ans,P-mul(S1(l,r),n/l)); &#125; return ans;&#125;int main()&#123; int n=read(),m=read(); if(n&gt;m) swap(n,m); int ans=0; upd(ans,mul(calc(n),calc(m))); for(int l=1,r;l&lt;=n;l=r+1) &#123; r=min(n/(n/l),m/(m/l)); upd(ans,P-mul(mul(n,m),r-l+1)); upd(ans,P-mul(mul(n/l,m/l),S2(l,r))); upd(ans,mul(mul(n,m/l),S1(l,r))); upd(ans,mul(mul(m,n/l),S1(l,r))); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>整除分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3105 新Nim游戏]]></title>
    <url>%2F2019%2F08%2F19%2Fbzoj-3105-%E6%96%B0Nim%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[贪心求解最大权值线性无关组. $A$ 先拿走一堆石子, $B$ 再拿走一堆石子,然后做 $Nim$ 游戏. 如果 $A$ 拿了之后给 $B$ 留下的石子中存在一个子集,它们的异或和为 $0$ , $B$ 就可以把其它的石子拿走, $A$ 就败了. 所以 $A$ 要拿走最少的石子,使剩下的石子在异或意义下线性无关. 那么就是要求解最大权值线性无关组,用拟阵的那一套理论,贪心处理. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=100+10;int n,a[MAXN],c[32];ll ans=0;void ins(int x,int val)&#123; for(int i=31;i&gt;=0;--i) if((x&gt;&gt;i)&amp;1) &#123; if(!c[i]) &#123; c[i]=x; break; &#125; else x^=c[i]; &#125; if(!x) ans+=val;&#125;int main()&#123; n=read(); if(!n) return puts("-1")&amp;0; for(int i=1;i&lt;=n;++i) a[i]=read(); sort(a+1,a+1+n); reverse(a+1,a+1+n); for(int i=1;i&lt;=n;++i) ins(a[i],a[i]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>博弈论</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190818]]></title>
    <url>%2F2019%2F08%2F19%2Ftest20190818%2F</url>
    <content type="text"><![CDATA[沙茶出题人数据造出锅了,还要大家来帮他修. 甚至连个题解都没有. $A$考虑换根,若当前根节点从 $u$ 换到 $v$ ,显然只有 $u$ 和 $v$ 的贡献会改变. 预处理一大堆东西,从 $u$ 换到 $v$ 时更新贡献,回溯时撤回. 时间复杂度 $O(n)$ . $B$将每次变换看做一个矩阵,转化为矩阵的 $BSGS$ . 由于矩阵可能没有逆,所以最后再判一下解是否合法. 时间复杂度 $O(T\cdot \sqrt P\cdot \log \sqrt P )$ . $C$将每个数看做 $0/1$ 串,正着建一棵字典树,反着建一棵字典树. 那么每个前缀武器就能在前缀的字典树树上割下一颗子树,每个后缀武器能的后缀的字典树上割下一颗子树. 每个给出的点在两棵树上至少被割掉一次,可以将两颗树拼在一起,建立一个最小割模型.]]></content>
      <tags>
        <tag>数学</tag>
        <tag>Trie</tag>
        <tag>网络流</tag>
        <tag>test</tag>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拟阵学习笔记]]></title>
    <url>%2F2019%2F08%2F18%2F%E6%8B%9F%E9%98%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[可用于解决一些最大权重独立子集的问题. 拟阵的定义一个有限 拟阵 是满足以下条件的二元组 $M=(S,I)$ : $S$ 是有限集. $I$ 是由 $S$ 的一些子集组成的有限非空集合(非空族) ,这些子集称为 $S$ 的 独立子集 . $I​$ 有 遗传性 ,即,若 $B\in I,A\subset B​$ ,则 $A\in I​$ .又因为 $I​$ 非空,所以一定有 $\emptyset \in I​$ . $M$ 有 交换性 ,即,若 $A,B\in I,|B|&gt;|A|$ ,则 $\exists x\in B-A$ ,使得 $A\cup \lbrace x \rbrace \in I$ . 举个例子, $M=(S,I)​$ 是一个拟阵,其中 $S=\lbrace 1,2,3 \rbrace ,I=\lbrace A\subset S:|A|\le 2 \rbrace​$ . 容易验证 $M$ 满足以上的 $4$ 个条件. 拓展有拟阵 $M=(S,I)$ ,若 $A\in I,x\not \in A,A\cup { x } \in I$ ,则称 $x$ 是独立子集 $A$ 的一个 拓展 . 最大独立子集若一个独立子集 $A$ 不存在拓展,则称它为 最大独立子集 . 由这个定义与拟阵的交换性质可以得出一条重要性质:拟阵中所有 最大独立子集 都具有相同的大小. 线性无关与拟阵设 $S$ 是一个行向量组, $I$ 是由所有 $S$ 的线性无关子集组成的集合,有定理: 二元组 $M=(S,I)$ 是一个拟阵. 证明该定理只需要证明 $M=(S,I)$ 满足拟阵的 $4$ 个条件.前 $2$ 个条件显然满足,只需证遗传性和交换性. 遗传性的证明一个线性无关组的子集,显然也线性无关.即,若 $A\in I,B\subset I$ ,则 $B\in I$ ,满足遗传性. 交换性的证明令 $X,Y\in I,|X|&gt;|Y|$ . 考虑反证法,假设 $\forall x\in X-Y​$ ,都有 $Y\cup {x} \not \in I​$ 成立. 则说明将任意一个在 $X$ 集合中,而不在 $Y$ 集合中的向量 $x$ 添加到 $Y$ 集合中,都会使得 $Y$ 变为线性相关. 说明任意一个这样的 $x$ 都可以被 $Y$ 中向量线性组合表示. 而 $X$ 中其它向量也被 $Y$ 包含,也可以被 $Y$ 中向量线性组合表示. 于是 $X$ 中的所有向量都可以被 $Y$ 中向量线性组合表示.但 $X$ 线性无关,不可能被更小的集合完全表示,矛盾. 交换性得证. 加权拟阵若一个拟阵 $M=(S,I)$ 关联了一个权重函数 $w$ ,它为 $S$ 中的每一个元素 $x$ 赋予了一个 严格大于0 的权重 $w(x)$. 则称拟阵 $M$ 是加权的,即 加权拟阵 . $S$ 的子集 $A$ 的权值就是$$w(A)=\sum_{x\in A}w(x)$$ 最大权重独立子集定义在加权拟阵 $M=(S,I)$ 中,权值最大的 独立子集 . 即所有 $A\in I$ 中, $w(A)$ 最大的 $A$ . 贪心求解 将 $S$ 中所有元素按照 $w(x)$ 降序排列. 初始有一个集合 $A=\emptyset​$ ,按照第 $1​$ 步排好的顺序依次遍历 $S​$ 中的每个元素 $x​$ ,若 $A\cup {x}\in I​$ ,则令 $A=A\cup {x}​$ . 遍历结束后,此时的 $A$ 就是要求的最大权重独立子集的一个解. 贪心正确性证明若 $I= { \emptyset }$ ,正确性显然,考虑 $I\not= { \emptyset }$ 的情况. 只需要考虑加权拟阵 $M=(S,I)$ 的 $3$ 条优美性质. 贪心选择性若 $S$ 中的元素已按 $w(x)$ 降序排列,令 $x$ 为 $S$ 中第一个 ${x}\in I$ 的元素. 那么存在一个最大权重独立子集 $A$ ,使得 $x\in A$ . 元素只考虑一次如果一个元素 $x$ 被遍历到时, $A\cup {x}\not \in I$ ,那么之后 $A$ 增大时,也总是有 $A\cup {x}\not \in I$ . 反证,由拟阵的遗传性即可得出矛盾. 最优子结构性质若 $x$ 是求解过程中第一个被选出的元素,那么选出剩下的元素就归结为一个子问题. 即求解加权拟阵 $M’=(S’,I’)$ 的最大权重独立子集,其中,$$S’={y\in S:{x,y}\in I}\I’={B\subset S-{x}:B\cup {x}\in I}$$ 应用根据线性无关与拟阵的关系,一个常见的应用是求解向量组的 最大权值线性无关组 . 直接套用贪心求解的过程即可. 对于其它的问题,如果能构造出对应的拟阵,也可以套用上述贪心求解的过程.]]></content>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4237 稻草人]]></title>
    <url>%2F2019%2F08%2F17%2Fbzoj-4237-%E7%A8%BB%E8%8D%89%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[$cdq$ 分治 + 单调栈. 将所有点先按照 $y$ 排序,然后 $cdq$ 分治,每次只考虑上面的一部分点作为右上角,下面的一部分点作为左下角的贡献. 将上下两部分的点分别按照 $x$ 排序,从左往右枚举上面的点. 发现上面的一个点在只会受到 $y$ 比自己小的点中, $x$ 最大的点的制约,维护一个 $y$ 递增的单调栈来找出这个点. 然后在下面的点中统计有哪些点是合法的,对下面的点维护一个 $y$ 不增的单调栈. 每次在上面加入点后,就将下面 $x$ 小于等于它的点加入下面的栈. 在下面的单调栈中使用二分,找出合法点的区间,时间复杂度 $O(n\log^2 n)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;struct node&#123; int x,y;&#125;a[MAXN],up[MAXN],down[MAXN];bool cmpy(node a,node b)&#123; return a.y==b.y?a.x&lt;b.x:a.y&gt;b.y; &#125;bool cmpx(node a,node b)&#123; return a.x==b.x?a.y&lt;b.y:a.x&lt;b.x;&#125;int n,stk1[MAXN],stk2[MAXN],tp1,tp2;ll ans=0;void cdq(int l,int r)&#123; if(l==r) return; int mid=(l+r)&gt;&gt;1; cdq(l,mid); tp1=tp2=0; int ls=mid-l+1,rs=r-mid; for(int i=l;i&lt;=mid;++i) up[i-l+1]=a[i]; for(int i=mid+1;i&lt;=r;++i) down[i-mid]=a[i]; sort(up+1,up+1+ls,cmpx); sort(down+1,down+1+rs,cmpx); int p=1; for(int i=1;i&lt;=ls;++i) &#123; while(tp1&gt;0 &amp;&amp; up[stk1[tp1]].y&gt;=up[i].y) --tp1; stk1[++tp1]=i; while(p&lt;=rs &amp;&amp; down[p].x&lt;=up[i].x) &#123; while(tp2&gt;0 &amp;&amp; down[stk2[tp2]].y&lt;down[p].y) --tp2; stk2[++tp2]=p; ++p; &#125; if(!tp2) continue; if(tp1==1) &#123; ans+=tp2; continue; &#125; int L=1,R=tp2,lim=up[stk1[tp1-1]].x,res=-1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(down[stk2[mid]].x&gt;=lim) res=mid,R=mid-1; else L=mid+1; &#125; if(res!=-1) ans+=tp2-res+1; &#125; cdq(mid+1,r);&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; a[i].x=read(); a[i].y=read(); &#125; sort(a+1,a+1+n,cmpy); cdq(1,n); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>单调栈</tag>
        <tag>cdq分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190816]]></title>
    <url>%2F2019%2F08%2F16%2Ftest20190816%2F</url>
    <content type="text"><![CDATA[点分治爆栈祭. $phantasm$将每次选择的位置看成一个数列,第一个位置必定是 $1$ ,所以只需要求出它的差分序列方案数. 差分序列中共 $m-1$ 个元素,每个元素必须 $\le k$ ,总和为 $n-1$ . 调整一下后用隔板法处理,答案是组合数,在模 $2$ 意义下,根据 $Lucas$ 定理,只需判断二进制位即可. $skylines$直接大力点分治预处理所有点的答案. 枚举子树时正反顺序都做一次,再考虑上分治中心. 时间复杂度 $O(n\log n+T)$ . $kiseki$题面写得太垃圾了. 每次从已有的数中选一个,得到它的权值,并获得它的后继,存档可以重复获得. 考虑 $dp$ ,状态只与当前有的存档集合有关,与顺序无关. 而从小到大排序后,相邻两项的差分值只可能是 $0/1$ ,所以可以用一个二进制数 $S$ 来记录. 设 $f(i,S)$ 表示有 $i$ 个存档,差分值的状态是 $S$ 的方案数,转移时枚举增加的存档. 总方案数是 $m!$ ,预处理差分状态 $S$ 对应的序列权值是 $val(S)$ ,答案就为 $$\sum_{S} \frac {f(m,S)} {m!} \cdot val(S)$$ 时间复杂度 $O(m\cdot 2^m)$ .]]></content>
      <tags>
        <tag>概率/期望</tag>
        <tag>数学</tag>
        <tag>状压dp</tag>
        <tag>test</tag>
        <tag>Lucas定理</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4236 JOIOJI]]></title>
    <url>%2F2019%2F08%2F16%2Fbzoj-4236-JOIOJI%2F</url>
    <content type="text"><![CDATA[$map$ . 用 $sum(i,0/1/2)$ 分别表示三种字母出现次数的前缀和. 一段区间 $[L+1,R]$ 合法的充要条件是 $sum(r,0)-sum(l,0)=sum(r,1)-sum(l,1),sum(r,1)-sum(l,1)=sum(r,2)-sum(l,2)$ . 将两种差看成两个权值,加入每个元素后询问两个权值都与它相等的元素出现的第一个位置,可以用 $map$ 维护. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;typedef pair&lt;int,int&gt; pii;map&lt;pii,int&gt; mp;int n,sum[MAXN][3];char buf[MAXN];int trans(char c)&#123; if(c=='J') return 2; return c&lt;'J';&#125;int main()&#123; n=read(); scanf("%s",buf+1); int ans=0; mp[make_pair(0,0)]=0; for(int i=1;i&lt;=n;++i) &#123; int x=trans(buf[i]); for(int j=0;j&lt;3;++j) sum[i][j]=sum[i-1][j]; ++sum[i][x]; int u=sum[i][0]-sum[i][1],v=sum[i][1]-sum[i][2]; pii tmp=make_pair(u,v); if(mp.find(tmp)!=mp.end()) ans=max(ans,i-mp[tmp]); else mp[tmp]=i; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1143 祭祀]]></title>
    <url>%2F2019%2F08%2F16%2Fbzoj-1143-%E7%A5%AD%E7%A5%80%2F</url>
    <content type="text"><![CDATA[$floyd$ 传递闭包 + 二分图的相关理论. 先用 $floyd$ 做传递闭包,预处理每两点间的连通性. 每个点拆成入点和出点,再枚举点 $a,b$ ,若 $a$ 能到 $b$ ,就从 $a$ 的入点向 $b$ 的出点连边. 然后就是要求新建出来的二分图的最大独立集,就等于原来的点数减去它的最大匹配数. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=128;int n,m;bool f[MAXN][MAXN];void floyd()&#123; for(int k=1;k&lt;=n;++k) for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) f[i][j]|=(f[i][k]&amp;f[k][j]);&#125;int par[MAXN],vis[MAXN];int dfs(int u)&#123; for(int v=1;v&lt;=n;++v) &#123; if(v!=u &amp;&amp; !vis[v] &amp;&amp; f[u][v]) &#123; vis[v]=1; if(!par[v] || dfs(par[v])) &#123; par[v]=u; return 1; &#125; &#125; &#125; return 0;&#125;int Hungarian()&#123; int ans=0; for(int i=1;i&lt;=n;++i) &#123; memset(vis,0,sizeof vis); ans+=dfs(i); &#125; return ans;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) f[i][i]=true; for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); f[u][v]=true; &#125; floyd(); int ans=Hungarian(); printf("%d\n",n-ans); return 0;&#125;]]></content>
      <tags>
        <tag>floyd</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4358 permu]]></title>
    <url>%2F2019%2F08%2F16%2Fbzoj-4358-permu%2F</url>
    <content type="text"><![CDATA[莫队. 使用莫队,考虑加入一个数 $x$ 造成的影响,发现需要用到 $x-1,x+1$ 的信息. 需要对每个数维护当前它所在的最大连续区间长度,但修改时可能会修改很多数的答案. 简单粗暴的办法是用线段树维护最大子段和,但多一个 $\log$ ,而且常数比较大,跑不过去. 用 $pre_i,nxt_i$ 分别表示 $i$ 在值域上往左/右走最多有几个数, $pre_i+nxt_i-1$ 可以更新答案. 插入数 $i$ 的时候,用 $i-1$ 的 $pre$ 更新 $i$ 的 $pre$ ,用 $i+1$ 的 $nxt$ 更新 $i$ 的 $nxt$ . 然后再更新 $i$ 所在最长连续区间左端点的 $nxt$ 和右端点的 $pre$ . 中间不用管,因为不可能再在中间插入数,也就不可能再用到它们的 $pre,nxt$ 了. 发现删除操作不好维护,我们可以保证右端点不删除,只可能撤销左端点的插入操作,就可以维护了. 对于 $l$ 在同一块内的询问,若 $r​$ 也在这一块内,可以暴力做. 对于 $r$ 在这一块外的,将它们按照 $r$ 从小到大排序. 先将 $L$ 设置为当前块的末尾,右移 $R$ 到询问的 $r$ ,再将 $L$ 左移到询问的 $l$ ,更新答案,再将 $L$ 移回当前块的末尾. 因为插入一个数最多只会影响 $3$ 个数的信息,所以把它们记录下来,移回时撤销,时间复杂度 $O(n\sqrt n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e4+10;int n,m,res,Ans[MAXN];int BlockSize,tot=0,bel[MAXN],a[MAXN];int lpos[MAXN],rpos[MAXN];struct Query&#123; int l,r,id,block; bool operator &lt; (const Query &amp;rhs) const &#123; return block==rhs.block?r&lt;rhs.r:block&lt;rhs.block; &#125;&#125;q[MAXN];int bf_pre[MAXN],bf_nxt[MAXN];int bf_stk[MAXN],bf_tp;int bf(int i)&#123; bf_tp=0; int ans=0; for(int j=q[i].l;j&lt;=q[i].r;++j) &#123; int x=a[j]; bf_stk[++bf_tp]=x; bf_pre[x]=bf_pre[x-1]+1; bf_nxt[x]=bf_nxt[x+1]+1; int len=bf_pre[x]+bf_nxt[x]-1; ans=max(ans,len); bf_nxt[x-bf_pre[x]+1]=len; bf_pre[x+bf_nxt[x]-1]=len; &#125; Ans[q[i].id]=ans; for(int j=1;j&lt;=bf_tp;++j) bf_pre[bf_stk[j]]=bf_nxt[bf_stk[j]]=0;&#125;int nxt[MAXN],pre[MAXN],tp;struct opt&#123; int x; int p1,n1; // pre[x]:p1-&gt;p2 nxt[x]:n1-&gt;n2 void undo() &#123; pre[x]=p1; nxt[x]=n1; &#125;&#125;;opt stk[MAXN];void solve()&#123; int lstblock=-1,L,R; for(int i=1;i&lt;=m;++i) &#123; if(q[i].block!=lstblock) &#123; L=rpos[q[i].block]; R=L-1; res=0; memset(pre,0,sizeof pre); memset(nxt,0,sizeof nxt); tp=0; lstblock=q[i].block; &#125; if(bel[q[i].l]==bel[q[i].r]) &#123; bf(i); continue; &#125; while(R&lt;q[i].r) &#123; int x=a[++R]; pre[x]=pre[x-1]+1; nxt[x]=nxt[x+1]+1; int len=pre[x]+nxt[x]-1; res=max(res,len); nxt[x-pre[x]+1]=len; pre[x+nxt[x]-1]=len; &#125; int tmp=res; while(L&gt;q[i].l) &#123; int x=a[--L]; pre[x]=pre[x-1]+1; nxt[x]=nxt[x+1]+1; stk[++tp]=(opt)&#123;x,0,0&#125;; int len=pre[x]+nxt[x]-1; stk[++tp]=(opt)&#123;x-pre[x]+1,pre[x-pre[x]+1],nxt[x-pre[x]+1]&#125;; stk[++tp]=(opt)&#123;x+nxt[x]-1,pre[x+nxt[x]-1],nxt[x+nxt[x]-1]&#125;; nxt[x-pre[x]+1]=len; pre[x+nxt[x]-1]=len; res=max(res,len); &#125; Ans[q[i].id]=res; while(tp) &#123; stk[tp].undo(); --tp; &#125; L=rpos[q[i].block]; res=tmp; &#125;&#125;void init_Block()&#123; BlockSize=sqrt(n); for(int i=1;i&lt;=n;++i) bel[i]=(i-1)/BlockSize+1; tot=bel[n]; for(int i=1;i&lt;=n;++i) rpos[bel[i]]=i; for(int i=n;i&gt;=1;--i) lpos[bel[i]]=i;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); init_Block(); for(int i=1;i&lt;=m;++i) &#123; q[i].l=read(); q[i].r=read(); q[i].block=bel[q[i].l]; q[i].id=i; &#125; sort(q+1,q+1+m); solve(); for(int i=1;i&lt;=m;++i) printf("%d\n",Ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>离线</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190815]]></title>
    <url>%2F2019%2F08%2F15%2Ftest20190815%2F</url>
    <content type="text"><![CDATA[发现自己的码力还是太弱,可能需要多做毒瘤题(?) $cubicp$$P=a^3-b^3=(a-b)(a^2+ab+b^2)$ ,因为 $P$ 是质数,所以 $a-b=1$ . 于是 $P=3b^2+3b+1$ ,先预处理所有合法的答案,然后快速回答即可. $dp$考虑朴素的 $dp$ ,设 $f(i,j)$ 表示将前 $i$ 个数分成 $j$ 段的最小花费. 先枚举 $j$ ,可以发现 $i$ 的转移决策是具有单调性的,于是可以优化. 不能用二分决策栈的方法,因为转移额外代价 $cost(k,i)$ 不方便快速在线算. 对求解区间和决策区间分治,这样可以像莫队那样暴力移动端点来算 $cost$ ,时间复杂度 $O(n\log n)$ . $number$可以先二分答案 $mid$ ,于是要考虑 $1\sim mid$ 的全部区间.将它们按照 $x$ 从大到小排序,依次加入. 如果同一种 $x$ 的区间的交集被之前加入的所有区间的并集完全覆盖,显然就不合法,否则一定可以构造出合法的方案. 可以直接用线段树来维护区间覆盖,但会多一个 $\log$ . 优秀的做法是用并查集维护当前每个节点在并集中向右能跳到的最远点,就可以判断合法性了.]]></content>
      <tags>
        <tag>二分</tag>
        <tag>并查集</tag>
        <tag>决策单调性</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4345 Korale]]></title>
    <url>%2F2019%2F08%2F15%2Fbzoj-4345-Korale%2F</url>
    <content type="text"><![CDATA[$dfs$ + 堆,求第 $k$ 优解. 首先去求第 $k$ 小的子集权值 $val$ ,先将元素权值从小到大排序. 每个子集可以用一个二元组 $(i,j)$ 表示权值为 $i$ ,最大的元素编号为 $j$ . 将它加入优先队列,一个二元组 $(i,j)$ 可以得到 $(i-a_j+a_{j+1},j+1)$ 与 $(i+a_{j+1},j+1)$ . 前者表示不选 $j$ 了,后者表示保留 $j$ .第 $k$ 次取出二元组时对应的权值就是第 $k$ 小的子集权值. 然后要求第 $k$ 小的具体方案,直接 $dfs$ 爆搜,但要保证权值不超过 $val$ . 每次找后面第一个数,使得加入后权值仍不超过 $val$ ,用线段树来找这个数,第 $k$ 次时集合中的数就是答案. 注意除掉空集的贡献. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;int n,k,a[MAXN],b[MAXN],cnt=0;ll ans[MAXN];typedef pair&lt;ll,int&gt; pli;#define mp make_pairpriority_queue&lt;pli&gt; q;void Find_kth()&#123; sort(b+1,b+1+n); q.push(mp(-b[1],1)); for(int t=1;t&lt;=k;++t) &#123; pli tmp=q.top(); ll i=-tmp.first; int j=tmp.second; q.pop(); ans[t]=i; if(t&lt;k &amp;&amp; j&lt;n) &#123; q.push(mp(-i+b[j]-b[j+1],j+1)); q.push(mp(-i-b[j+1],j+1)); &#125; &#125; for(int i=k;i &amp;&amp; ans[i]==ans[k];--i) ++cnt; printf("%lld\n",ans[k]);&#125;struct SegTree&#123; int Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root=min(lson,rson); &#125; void BuildTree(int o,int l,int r) &#123; if(l==r) return (void)(root=a[l]); int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; int query(int o,int l,int r,int p,ll v)//位置p之后第一个小于等于v的 &#123; if(p&lt;=l) &#123; if(root&gt;v) return 0; if(l==r) return l; &#125; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) &#123; int res=query(o&lt;&lt;1,l,mid,p,v); if(res) return res; &#125; return query(o&lt;&lt;1|1,mid+1,r,p,v); &#125;&#125;T;int stk[MAXN],tp=0;void dfs(int p,ll tmp)&#123; if(!cnt) return; if(!tmp) &#123; --cnt; if(!cnt) for(int i=1;i&lt;=tp;++i) printf("%d" ,stk[i]); return; &#125; for(int i=p+1;i&lt;=n;++i) &#123; i=T.query(1,1,n,i,tmp); if(i) &#123; stk[++tp]=i; dfs(i,tmp-a[i]); --tp; &#125; else break; &#125;&#125;void Construct_kth()&#123; T.BuildTree(1,1,n); dfs(0,ans[k]);&#125;int main()&#123; n=read(),k=read()-1; if(!k) return puts("0")&amp;0; for(int i=1;i&lt;=n;++i) a[i]=b[i]=read(); Find_kth(); Construct_kth(); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>STL</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 515 贪心只能过样例]]></title>
    <url>%2F2019%2F08%2F14%2FLoj-515-%E8%B4%AA%E5%BF%83%E5%8F%AA%E8%83%BD%E8%BF%87%E6%A0%B7%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[$bitset$ 优化 $dp$ . 考虑最朴素的 $dp$ , $f(i,j)$ 表示考虑前 $i$ 个数,能否使得 $S=j$ . 转移时枚举当前这一位选哪一个数,这样直接做的时间复杂度是 $O(n^5)$ . 因为只有 $0/1$ 运算,第二维的最大值为 $10^6$ ,用 $bitset$ 优化,复杂度变成 $O(\frac {n^5} {64})$ ,就可以过了. 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=101;int n;bitset&lt;MAXN*MAXN*MAXN&gt; f,lst;int main()&#123; n=read(); lst[0]=1; for(int i=1;i&lt;=n;++i) &#123; int L=read(),R=read(); f.reset(); for(int x=L;x&lt;=R;++x) f|=lst&lt;&lt;(x*x); lst=f; &#125; cout&lt;&lt;f.count()&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 514 模拟只会猜题意]]></title>
    <url>%2F2019%2F08%2F14%2FLoj-514-%E6%A8%A1%E6%8B%9F%E5%8F%AA%E4%BC%9A%E7%8C%9C%E9%A2%98%E6%84%8F%2F</url>
    <content type="text"><![CDATA[原以为此题必有高论,结果直接 $O(n^2)$ 暴力预处理答案就可以了. 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=1e4+10;int n,m,ans[MAXN],a[MAXN];int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; a[i]=read()+a[i-1]; ans[i]=-inf; &#125; for(int i=1;i&lt;=n;++i) for(int j=i;j&lt;=n;++j) ans[j-i+1]=max(ans[j-i+1],a[j]-a[i-1]); for(int i=n-1;i&gt;=1;--i) ans[i]=max(ans[i+1],ans[i]); for(int i=1;i&lt;=m;++i) printf("%d\n",ans[read()]); return 0;&#125;]]></content>
      <tags>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190814]]></title>
    <url>%2F2019%2F08%2F14%2Ftest20190814%2F</url>
    <content type="text"><![CDATA[$T2$ 被常数卡到暴力分了. $tree$原题.直接树形 $dp$ . $dance$从前往后枚举右端点,依次加入每个点,用单调栈维护后缀最大/最小值,线段树维护答案. $seq$打表或者分析,把递推式子搞出来, $f_i=f_{i-1}+(i-1)\cdot (i-2)$ . 然后用特征方程那一套理论把通项找出来, $f_n=2^{n+1}-n^2-n-2$ ,就可以直接算了.]]></content>
      <tags>
        <tag>树形dp</tag>
        <tag>线段树</tag>
        <tag>数学</tag>
        <tag>单调栈</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2049 洞穴勘测]]></title>
    <url>%2F2019%2F08%2F14%2Fbzoj-2049-%E6%B4%9E%E7%A9%B4%E5%8B%98%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[线段树分治 + 并查集. 这本来是个 $LCT$ 的模板题,但离线下来也可以用线段树分治 + 并查集来做. 每条边可以看做在一个时间区间内生效,每个线段树节点维护一个 $vector$ ,存储在该区间内都有效的边. 一条边只会被加入 $O(\log m)$ 个线段树节点,空间复杂度为 $O(m\log m)$ . 最后 $dfs$ 整个线段树,进入一个节点时,就让它的 $vector$ 中的边都生效,退出时撤销这些边. 因为有撤销,所以不能路径压缩,可以用按秩合并的并查集来维护. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef pair&lt;int,int&gt; pii;#define mp make_pairconst int MAXM=2e5+10;map&lt;pii,int&gt; Eid;struct Edge&#123; int u,v; int l,r; Edge()&#123;r=-1;&#125;&#125; E[MAXM];struct query&#123; int u,v,id;&#125;;int n,m,ans[MAXM],qcnt=0,ecnt=0;vector&lt;query&gt; qry[MAXM];vector&lt;pii&gt; opt[MAXM&lt;&lt;2];int fa[MAXM],siz[MAXM];void init()&#123; for(int i=1; i&lt;=n; ++i) fa[i]=i,siz[i]=1;&#125;int Find(int x)&#123; if(x==fa[x]) return x; return Find(fa[x]);&#125;void Union(int &amp;x,int &amp;y)&#123; if(siz[x]&lt;siz[y]) swap(x,y); siz[x]+=siz[y]; fa[y]=x;&#125;struct SegTree&#123; vector&lt;int&gt; s[MAXM&lt;&lt;2];#define root s[o] void upd(int o,int l,int r,int L,int R,int c) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; root.push_back(c); return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); &#125; void add(int o) &#123; int tot=root.size(); for(int i=0;i&lt;tot;++i) &#123; int x=root[i]; int u=Find(E[x].u),v=Find(E[x].v); if(u==v) continue; Union(u,v); opt[o].push_back(mp(u,v)); &#125; &#125; void del(int o) &#123; int tot=opt[o].size(); for(int i=0;i&lt;tot;++i) &#123; pii t=opt[o][i]; int u=t.first,v=t.second; fa[v]=v; siz[u]-=siz[v]; &#125; &#125; void solve(int o,int p) &#123; int tot=qry[p].size(); for(int i=0;i&lt;tot;++i) &#123; query q=qry[p][i]; int u=Find(q.u),v=Find(q.v); if(u==v) ans[q.id]=1; else ans[q.id]=0; &#125; &#125; void dfs(int o,int l,int r) &#123; add(o); if(l==r) &#123; solve(o,l); del(o); return; &#125; int mid=(l+r)&gt;&gt;1; dfs(o&lt;&lt;1,l,mid); dfs(o&lt;&lt;1|1,mid+1,r); del(o); &#125;&#125; T;int main()&#123; n=read(),m=read(); init(); for(int i=1; i&lt;=m; ++i) &#123; char op[10]; scanf("%s",op); int u=read(),v=read(); if(op[0]=='C') &#123; Eid[mp(u,v)]=Eid[mp(v,u)]=++ecnt; E[ecnt].u=u,E[ecnt].v=v; E[ecnt].l=i; &#125; else if(op[0]=='D') E[Eid[mp(u,v)]].r=i; else qry[i].push_back((query)&#123;u,v,++qcnt&#125;); &#125; for(int i=1; i&lt;=ecnt; ++i) &#123; if(E[i].r==-1) E[i].r=m; T.upd(1,1,m,E[i].l,E[i].r,i); &#125; T.dfs(1,1,m); for(int i=1; i&lt;=qcnt; ++i) puts(ans[i]?"Yes":"No"); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>并查集</tag>
        <tag>线段树分治</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190813]]></title>
    <url>%2F2019%2F08%2F13%2Ftest20190813%2F</url>
    <content type="text"><![CDATA[考了一套简单题. $prime$贪心. 有一个比较明显的贪心策略,即先做若干次除法,再只做加法或只做减法. 做完除法后算答案直接暴力枚举加/减了几步就可以了. 因为 $10^9$ 内的两个相邻质数相差不会超过 $220$ ,所以答案也不会超过 $220$ . 据说质数密度是 $O(\log n)$ 级别的. $path$树状数组. 可以发现这个图就是由若干个不相交的链或者环组成的. 因为只有合并操作,所以可以用并查集来维护每条链和每个环,以及它们的大小. 查询 $(l,r)$ 时,可以用长度不超过 $r$ 的答案减去长度不超过 $l-1$ 的答案,只需要考虑如何计算长度不超过 $k$ 的路径数. 考虑一条大小为 $s$ 的链的贡献.若 $s\le k$ ,贡献为 $\frac {s(s+1)} 2$ ,否则,贡献为 $k\cdot s-\frac {k(k-1)} 2$ . 考虑一个大小为 $s$ 的环的贡献.若 $s\le k$ ,贡献为 $s^2$ ,否则, 贡献为 $s\cdot k$ . 用 $5$ 个树状数组分别维护贡献 (还有一个是链的条数) ,每个链/环的贡献加入它的大小的对应位置. 有个地方没开 $\mbox{long long}$ ,爆成 $95$ 了. 时间复杂度 $O(n\log n)$ . $book$期望 $dp$ . 设 $f(i,j)$ 表示第 $i$ 个人拿到的从新到旧的第 $j$ 本书的期望排名. 转移时枚举每个人拿了哪本书,时间复杂度 $O(n^3)$ .]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>概率/期望</tag>
        <tag>树状数组</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3569 DZY Loves Chinese II]]></title>
    <url>%2F2019%2F08%2F13%2Fbzoj-3569-DZY-Loves-Chinese-II%2F</url>
    <content type="text"><![CDATA[神仙题. 先做出原图的一棵 $dfs$ 树.对于每条非树边,随机分配一个权值 $x$ ,将它在树上覆盖到的树边的权值全部异或上 $x$ . 每次询问给定了一个边的集合 $S$ ,若存在 $S$ 的一个非空子集,该子集内所有的边权异或和为 $0$ ,则不连通,否则连通. 边权覆盖可以用树上差分,查询可以利用线性基,看给出的边权在 $\mbox{xor}$ 意义下是否线性无关. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int read()&#123; int out=0,sgn=1; char jp=getchar(); while(jp!='-' &amp;&amp; (jp&lt;'0' || jp&gt;'9')) jp=getchar(); if(jp=='-') sgn=-1,jp=getchar(); while(jp&gt;='0' &amp;&amp; jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*sgn;&#125;const int MAXN=1e5+10,MAXM=1e6+10;int ecnt=0,head[MAXN],nx[MAXM],to[MAXM],id[MAXM];int st[MAXM],ed[MAXM],ontree[MAXM];void addedge(int u,int v,int k)&#123; ++ecnt; id[ecnt]=k; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int n,m,tot=0;int dfn[MAXN],idx=0;ull dif[MAXN],val[MAXM];void dfs(int u)&#123; dfn[u]=++idx; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(dfn[v]) continue; ontree[id[i]]=1; dfs(v); &#125;&#125;void calc(int u,int t)&#123; dfn[u]+=n; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(dfn[v]&gt;n) continue; calc(v,i); dif[u]^=dif[v]; &#125; val[id[t]]=dif[u];&#125;void init()&#123; for(int i=1;i&lt;=m;++i) if(!ontree[i]) &#123; ull x=rand()*rand()*rand()*rand(); val[i]=x; int u=st[i],v=ed[i]; dif[u]^=x,dif[v]^=x; &#125; calc(1,0);&#125;struct Base&#123; ull a[64]; int siz; void init() &#123; siz=0; memset(a,0,sizeof a); &#125; void ins(ull x) &#123; for(int i=63;i&gt;=0;--i) if(x&amp;(1ULL&lt;&lt;i)) &#123; if(a[i]) x^=a[i]; else &#123; a[i]=x; ++siz; break; &#125; &#125; &#125;&#125;LB;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); addedge(u,v,i); addedge(v,u,i); st[i]=u,ed[i]=v; &#125; dfs(1); int Q=read(); if(idx!=n) &#123; while(Q--) puts("Disconnected"); return 0; &#125; srand(time(NULL)); init(); while(Q--) &#123; int k=read(); LB.init(); for(int i=1;i&lt;=k;++i) &#123; int c=read()^tot; LB.ins(val[c]); &#125; if(k==LB.siz) ++tot,puts("Connected"); else puts("Disconnected"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
        <tag>树上差分</tag>
        <tag>随机化</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4326 运输计划]]></title>
    <url>%2F2019%2F08%2F13%2Fbzoj-4326-%E8%BF%90%E8%BE%93%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[二分答案 + 树上差分. 首先可以考虑二分答案,变为判定是否存在合法方案使得改造后给出的路径长度都不超过 $mid$ . 预处理每条路径的长度 $len$ ,若 $len\le mid$ ,则不用考虑.否则,被改造的边长度至少为 $mid-len$ . 将每条路径按上述过程处理,可以得出被改造的边长度至少为 $\max (mid-len_i)$ ,并且在所有需要考虑的路径上. 用树上差分给路径上的边打上标记,然后枚举每条边进行验证. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int read()&#123; int out=0,sgn=1; char jp=getchar(); while(jp!='-' &amp;&amp; (jp&lt;'0' || jp&gt;'9')) jp=getchar(); if(jp=='-') sgn=-1,jp=getchar(); while(jp&gt;='0' &amp;&amp; jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*sgn;&#125;const int MAXN=3e5+10;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN&lt;&lt;1];void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;int n,m,x[MAXN],y[MAXN],z[MAXN],len[MAXN];int tofa[MAXN],dis[MAXN],mx=0;int dep[MAXN],Log[MAXN],fa[MAXN][20];int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=Log[dep[x]-dep[y]];i&gt;=0;--i) if(dep[x]-dep[y]&gt;=(1&lt;&lt;i)) x=fa[x][i]; if(x==y) return x; for(int i=Log[dep[x]];i&gt;=0;--i) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;void dfs_pre(int u,int F)&#123; fa[u][0]=F; for(int i=1;(1&lt;&lt;i)&lt;=dep[u];++i) fa[u][i]=fa[fa[u][i-1]][i-1]; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==F) continue; dep[v]=dep[u]+1; dis[v]=dis[u]+val[i]; tofa[v]=val[i]; dfs_pre(v,u); &#125;&#125;int dif[MAXN],tot,lim;bool dfs_calc(int u,int F)&#123; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==F) continue; if(dfs_calc(v,u)) return true; dif[u]+=dif[v]; &#125; if(u!=1 &amp;&amp; dif[u]==tot &amp;&amp; tofa[u]&gt;=lim) return true; return false;&#125;bool check(int mid)&#123; tot=0,lim=0; for(int i=1;i&lt;=n;++i) dif[i]=0; for(int i=1;i&lt;=m;++i) &#123; if(len[i]&lt;=mid) continue; lim=max(lim,len[i]-mid); ++tot; ++dif[x[i]],++dif[y[i]]; dif[z[i]]-=2; &#125; if(!tot) return true; return dfs_calc(1,0);&#125;int main()&#123; n=read(),m=read(); Log[0]=-1,Log[1]=0; for(int i=2;i&lt;=n;++i) Log[i]=Log[i&gt;&gt;1]+1; for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; for(int i=1;i&lt;=m;++i) &#123; x[i]=read(); y[i]=read(); &#125; dfs_pre(1,0); for(int i=1;i&lt;=m;++i) &#123; z[i]=LCA(x[i],y[i]); len[i]=dis[x[i]]+dis[y[i]]-2*dis[z[i]]; mx=max(mx,len[i]); &#125; int L=0,R=mx,ans; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid)) ans=mid,R=mid-1; else L=mid+1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 535 花火]]></title>
    <url>%2F2019%2F08%2F13%2FLoj-535-%E8%8A%B1%E7%81%AB%2F</url>
    <content type="text"><![CDATA[扫描线 + 线段树. 特判序列已经有序的情况,此时不需要进行任何交换. 首先,我们可以首先进行特殊的交换,再进行一般的交换,这样显然不会使答案变劣. 特殊交换之后,还需要的次数就是当前逆序对的数目.所以特殊交换要减少尽可能多的逆序对. 考虑交换两个数 $h_x,h_y,x&lt;y$ ,显然当 $h_x&gt;h_y$ 时,逆序对会减少,否则会增加,于是只考虑 $h_x&gt;h_y$ 的情况. 容易发现交换后减少的逆序对数目就是 $1+2|S|,S=\lbrace k|x&lt;k&lt;y,h_y&lt;h_k&lt;h_x \rbrace$ . 考虑左端点 $x$ 的选择,若 $h_{x_1}&gt;h_{x_2},x_1&lt;x_2$ , $x_2$ 就没用了.于是可以维护出有用的 $x$ . 考虑右端点 $pos_y$ 的选择,若 $h_{y_1}&lt;h_{y_2},y_1&gt;y_2$ , $y_2$ 就没用了.于是可以维护出有用的 $y$ . 考虑一个位置 $k$ 会存在哪些点对 $(x,y)$ 满足 $x&lt;k&lt;y,h_y&lt;h_k&lt;h_x$ .在第一个单调栈中二分找出最小的 $l$ ,使得 $h_l&gt;h_k$ ,在第二个单调栈中二分找出最小的 $r$ ,使得 $h_r&lt;h_x$ . 那么点对 $(x,y)$ 满足 $x&lt;k&lt;y,h_y&lt;h_k&lt;h_x$ ,即 $k$ 对 $(x,y)$ 有贡献的条件是 $x\in [l,k-1],y\in[k+1,r]$ . 这相当于是一个矩形覆盖,问题转化为给了若干个矩形,求一个点最多被覆盖了几次. 扫描线 + 线段树解决,时间复杂度 $O(n\log n)​$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int read()&#123; int out=0,sgn=1; char jp=getchar(); while(jp!='-' &amp;&amp; (jp&lt;'0' || jp&gt;'9')) jp=getchar(); if(jp=='-') sgn=-1,jp=getchar(); while(jp&gt;='0' &amp;&amp; jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*sgn;&#125;const int MAXN=3e5+10;int n,h[MAXN],H[MAXN];struct FenwickTree&#123; int bit[MAXN]; FenwickTree()&#123;memset(bit,0,sizeof bit);&#125;#define lowbit(x) x&amp;(-x) void add(int x,int c) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=c; &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x]; return s; &#125;&#125;FT;ll ans=0;int vis[MAXN],sx[MAXN],tx=0,sy[MAXN],ty=0;int bsx(int x)&#123; int L=1,R=tx,res=0; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(h[sx[mid]]&gt;x) res=mid,R=mid-1; else L=mid+1; &#125; return sx[res];&#125;int bsy(int y)&#123; int L=1,R=ty,res=0; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(h[sy[mid]]&lt;y) res=mid,R=mid-1; else L=mid+1; &#125; return sy[res];&#125;struct node&#123; int x,ly,ry,tp;//1 + -1 - bool operator &lt; (const node &amp;rhs) const &#123; return x==rhs.x?tp&gt;rhs.tp:x&lt;rhs.x; &#125;&#125;p[MAXN&lt;&lt;2];struct SegTree&#123; struct node &#123; int mx,tag; &#125;Tree[MAXN&lt;&lt;4];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.mx=max(lson.mx,rson.mx); &#125; void BuildTree(int o,int l,int r) &#123; root.mx=0; root.tag=0; if(l==r) return; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); &#125; void modify(int o,int c) &#123; root.mx+=c; root.tag+=c; &#125; void pushdown(int o) &#123; if(root.tag) &#123; modify(o&lt;&lt;1,root.tag); modify(o&lt;&lt;1|1,root.tag); root.tag=0; &#125; &#125; void upd(int o,int l,int r,int L,int R,int c) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modify(o,c); return; &#125; pushdown(o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125; int query() &#123; return Tree[1].mx; &#125;&#125;ST;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) h[i]=H[i]=read(); sort(H+1,H+1+n); for(int i=1;i&lt;=n;++i) &#123; h[i]=lower_bound(H+1,H+1+n,h[i])-H; ans+=FT.sum(n)-FT.sum(h[i]); FT.add(h[i],1); &#125; if(!ans) return puts("0")&amp;0; ++ans; for(int i=1;i&lt;=n;++i) &#123; if(tx&gt;0 &amp;&amp; h[i]&lt;h[sx[tx]]) continue; sx[++tx]=i; vis[i]=1; &#125; for(int i=n;i&gt;=1;--i) &#123; if(ty&gt;0 &amp;&amp; h[i]&gt;h[sy[ty]]) continue; sy[++ty]=i; vis[i]=1; &#125; int cnt=0; for(int i=1;i&lt;=n;++i) &#123; if(vis[i]) continue; int l=bsx(h[i]),r=bsy(h[i]); if(l&lt;i &amp;&amp; i&lt;r) &#123; p[++cnt]=(node)&#123;l,i+1,r,1&#125;; p[++cnt]=(node)&#123;i-1,i+1,r,-1&#125;; &#125; &#125; sort(p+1,p+1+cnt); int s=0; for(int i=1;i&lt;=cnt;++i) &#123; ST.upd(1,1,n,p[i].ly,p[i].ry,p[i].tp); if(p[i].tp&gt;0) s=max(s,ST.query()); &#125; ans-=(1+2LL*s); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五边形数定理学习笔记]]></title>
    <url>%2F2019%2F08%2F13%2F%E4%BA%94%E8%BE%B9%E5%BD%A2%E6%95%B0%E5%AE%9A%E7%90%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[去 大佬的博客 学习了一下相关知识. 整数划分问题将一个正整数 $n$ 拆分成若干正整数之和,求方案数. 令 $f(i,j)$ 表示将 $j$ 拆成 $i$ 个数的方案数,转移有 $f(i,j)=f(i,j-i)+f(i-1,j-1)$ ,边界为 $f(0,0)=1$ . 意义是所有数都 $+1​$ 或者新加入一个 $1​$ ,时间复杂度 $O(n^2)​$ . 几个拓展 要求拆成的正整数两两不同.这样,新加入一个 $1$ 之前的操作必须是每个数都 $+1$ . $f(i,j)=f(i,j-i)+f(i-1,j-i)$ .显然不超过 $\sqrt n$ 个数,时间复杂度 $O(n\sqrt n)$ . 要求拆成的数全部为奇数.方案数等同于拆成两两不同的方案数.可以构造出一一对应的映射( $Ferrers$ 图转置). 要求拆成若干个大小 $\le k$ 的正整数.方案数等同于拆成 $\le k$ 个任意大小的正整数. 五边形数定理五边形数 $f_1=1,f_n=f_{n-1}+3n-2​$ .对差分求前缀和,得到 $f_n=\frac{n(3n-1)} 2​$ . $1,5,12,22,35,51,70,92,117,145,176,210,247,287\dots​$ 广义五边形数在公式 $f_n=\frac{n(3n-1)} 2$ 中, $n$ 取 $0,1,-1,2,-2\dots$ $0,1,2,5,7,12,15,22,26,35,40,51,57,70,77,92,100,117,126\dots$ 欧拉函数$$\phi(x)=\prod_{i=1}^{+\infty} (1-x^i)$$ 它仅在 $|x|&lt; 1​$ 时收敛,但这里作为形式幂级数,我们不考虑它的敛散性. 五边形数定理$$\begin{aligned}\phi(x)&amp;=1-x-x^2+x^5+x^7-x^{12}-x^{15}\dots \\&amp;=1+\sum_{i=1}^{+\infty}(-1)^i(x^{i(3i-1)/2}+x^{-i(-3i-1)/2})\end{aligned}$$ $x^{i(3i-1)/2}​$ , $x^{-i(-3i-1)/2}​$ 的次数分别是相邻的两个广义五边形数. 五边形数定理与整数划分写出整数划分问题的生成函数 $G(x)​$ ,显然,$$\begin{aligned}G(x)&amp;=\prod_{i=1}^{+\infty}(1+x^i+x^{2i}+x^{3i}+\dots) \\&amp;=\prod_{i=1}^{+\infty}\frac 1 {1-x^i}\end{aligned}$$发现 $G\times \phi=1​$ .把多项式乘法暴力展开,观察系数,可以得到递推式$$G(1)=1,G(n)=G(n-1)+G(n-2)-G(n-5)-G(n-7)+\dots$$因为广义五边形数的级别是 $n^2​$ 的,所以直接递推的时间复杂度为 $O(n\sqrt n)​$ . 也可以直接在模 $x^{n+1}​$ 意义下对 $\phi​$ 求逆得到 $G​$ ,时间复杂度 $O(n\log n)​$. Loj 6268 分拆数模板题,对 $\phi$ 求逆得到 $G$ . code]]></content>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6261 一个人的高三楼]]></title>
    <url>%2F2019%2F08%2F13%2FLoj-6261-%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E9%AB%98%E4%B8%89%E6%A5%BC%2F</url>
    <content type="text"><![CDATA[生成函数 + $NTT$ . 设这个数列做了 $i$ 次前缀和后的生成函数为 $F_i(x)$ . $F_0(x)$ 是已知的,将下标置为从 $0$ 开始. 考虑如何递推,令 $G(x)=\sum_{i=0}^{n-1}x^i$ ,则$$F_{i+1}(x)\equiv F_i(x)\cdot G(x)\ (\mbox{mod}\ x^n)$$那么就有$$F_k(x)\equiv F_0(x)\cdot G^k(x)\ (\mbox{mod}\ x^n)$$直接用多项式快速幂,时间复杂度 $O(n\log n)$ .但这种做法常数比较大,而且写起来麻烦. 考虑 $G(x)^k$ 的组合意义.有 $k$ 个盒子,每个盒子可以拿出 $0\sim n-1$ 个球, $[x^i]G^k(x)$ 表示拿出了 $i$ 个球的方案数. 盒子是不同的,而球是相同的,相当于把这 $i$ 个球分到 $k$ 个盒子里去.隔板法可知 $[x^i]G^k(x)={i+k-1\choose k-1}$ . 用 $NTT$ 将 $F_0(x)$ 和 $G^k(x)$ 乘起来就是答案了.时间复杂度 $O(n\log n)$ ,是与 $k$ 无关的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll read()&#123; ll out=0,sgn=1; char jp=getchar(); while(jp!='-' &amp;&amp; (jp&lt;'0' || jp&gt;'9')) jp=getchar(); if(jp=='-') sgn=-1,jp=getchar(); while(jp&gt;='0' &amp;&amp; jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*sgn;&#125;const int P=998244353,G=3;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=1e5+10;int omega[MAXN&lt;&lt;2],inv[MAXN&lt;&lt;2],rev[MAXN&lt;&lt;2],curn=0;void init(int n)&#123; if(curn==n) return; for(int i=0; i&lt;n; ++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((n&gt;&gt;1)*(i&amp;1)); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; omega[l]=fpow(G,(P-1)/l); inv[l]=fpow(omega[l],P-2); &#125; curn=n;&#125;void DFT(int *a,int n,bool invflag)&#123; init(n); for(int i=0; i&lt;n; ++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; int m=(l&gt;&gt;1); int gi=omega[l]; if(invflag) gi=inv[l]; for(int *p=a; p!=a+n; p+=l) &#123; int g=1; for(int i=0; i&lt;m; ++i) &#123; int t=mul(g,p[i+m]); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int invn=fpow(n,P-2); for(int i=0; i&lt;n; ++i) a[i]=mul(a[i],invn); &#125;&#125;int NTT_A[MAXN&lt;&lt;2],NTT_B[MAXN&lt;&lt;2];void NTT(int *A,int *B,int *C,int lenA,int lenB)&#123; int lenC=lenA+lenB-1,n=1; while(n&lt;lenC) n&lt;&lt;=1; for(int i=0; i&lt;lenA; ++i) NTT_A[i]=A[i]; for(int i=lenA; i&lt;n; ++i) NTT_A[i]=0; for(int i=0; i&lt;lenB; ++i) NTT_B[i]=B[i]; for(int i=lenB; i&lt;n; ++i) NTT_B[i]=0; DFT(NTT_A,n,false); DFT(NTT_B,n,false); for(int i=0; i&lt;n; ++i) C[i]=mul(NTT_A[i],NTT_B[i]); DFT(C,n,true);&#125;int n;ll k;int A[MAXN],B[MAXN],C[MAXN&lt;&lt;2];int main()&#123; n=read(),k=read(); int t=(k-1)%P; for(int i=0; i&lt;n; ++i) A[i]=read(); B[0]=1; for(int i=1; i&lt;n; ++i) &#123; B[i]=mul(B[i-1],add(i,t)); B[i]=mul(B[i],fpow(i,P-2)); &#125; NTT(A,B,C,n,n); for(int i=0; i&lt;n; ++i) printf("%d\n",C[i]); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式的几个板子]]></title>
    <url>%2F2019%2F08%2F13%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%87%A0%E4%B8%AA%E6%9D%BF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[多项式的几个板子,代码也放在一起了. Luogu P4238 多项式求逆给定一个 $n$ 项的多项式 $A$ ,求多项式 $B$ ,使得 $A\cdot B\equiv 1 (\mbox{mod}\ x^n)$ . 首先还是用 $0$ 将 $n$ 补成 $2$ 的幂次,然后递归求解. 若 $n=1$ ,那么只需要让 $B=A_0^{-1}$ . 若 $n&gt;1$ ,则先求解 $B’$ ,使得 $A\cdot B’\equiv 1(\mbox{mod}\ x^{\frac n 2})$ . 因为 $A\cdot B\equiv 1(\mbox{mod}\ x^n)$ ,所以有 $B-B’\equiv 0(\mbox{mod}\ x^{\frac n 2})$ . 即 $B-B’=C\cdot x^{\frac n 2}$ ,所以 $B^2-2\cdot B\cdot B’+B’^2\equiv 0(\mbox{mod}\ x^n)$ . 两边同乘 $A$ ,得到 $B-2B’+A\cdot B’^2\equiv 0(\mbox{mod}\ x^n)$ . 于是可以得到 $B\equiv 2B’-A\cdot B’^2(\mbox{mod}\ x^n)$ . 可以看出,多项式 $A$ 有逆元的充要条件是常数项 $A_0$ 有逆元. 时间复杂度为 $\Theta(n\log n)$ . 实现时可以把递归改成迭代,常数会优秀许多. Luogu 4721 分治FFT可以考虑 cdq 分治,每次处理 $[l,mid)$ 对 $[mid,r)$ 的贡献,时间复杂度 $O(n\log^2 n)$ . 另一个做法是记 $F,G$ 分别表示数列 $f,g$ 的生成函数,将它们卷起来,可以发现 $F(x)G(x)=F(x)-F(0)$ . 则 $F(x)=\frac{F(0)}{1-G(x)}$ ,写个多项式求逆,时间复杂度 $O(n\log n)$ . Luogu P4512 多项式除法/多项式取模给定一个 $n$ 次多项式 $A$ ,一个 $m$ 次多项式 $B$ ,满足 $m\le n$ ,求多项式 $D,R$ ,使得,$$A(x)=D(x)B(x)+R(x)$$并且 $\deg (D)\le n-m,\deg (R)&lt;m$ . 尝试先消去余式 $R(x)$ 的影响,考虑多项式的 系数反转 ,即对于一个 $n$ 次多项式 $A$ ,$$A^R(x)=x^n\cdot A(\frac 1 x)$$如 $A(x)=x^3+2x^2+3x+4$ ,则 $A^R(x)=x^3\cdot A(\frac 1 x)=4x^3+3x^2+2x+1$ . 我们要求满足 $A(x)=D(x)B(x)+R(x)$ 的 $D,R$ ,如果将 $x$ 全部用 $\frac 1 x$ 替换,等式仍然成立. 替换后同时乘上 $x^n$ ,由于 $\deg(D)\le n-m,\deg(R)&lt;m$ ,将 $D,R$ 次数分别看做 $n-m,m-1$ ,用 $0$ 补够. 于是可以得到,$$A^R(x)=D^R(x)B^R(x)+x^{n-m+1}\cdot R^R(x)$$我们将上面的等式两边都对 $x^{n-m+1}$ 取模, $x^{n-m+1}\cdot R^R(x)$ 就被消去了,于是得到,$$A^R(x)\equiv D^R(x)B^R(x) (\mbox{mod}\ x^{n-m+1})$$对 $B^R(x)$ 用一次多项式求逆,再用一次多项式乘法求得模 $x^{n-m+1}$ 意义下的 $D^R(x)$ . 由于 $\deg (D)\le n-m$ ,反转后 $\deg (D^R)\le n-m$ .所以模意义下求得的 $D^R(x)$ 就是真实的 $D^R(x)$ . 再系数反转求得 $D(x)$ ,回代 $A(x)=D(x)B(x)+R(x)$ 得到 $R(x)$ . 从上述过程可以看出,多项式除法/多项式取模的时间复杂度与多项式求逆相同,为 $\Theta(n\log n)$ . Luogu P4728 多项式 $\ln$首先需要了解多项式的求导和不定积分.对于一个 $n-1$ 次多项式 $A$ , $$A(x)=\sum_{i=0}^{n-1} a_i\cdot x_i\\A’(x)=\sum_{i=0}^{n-2} a_{i+1}\cdot(i+1)\cdot x^i \\\int A(x) \mbox d x=\sum_{i=1}^{n}\frac {a_{i-1}} i \cdot x^i+C$$ 现在给出 $n-1$ 次多项式 $A(x)$ ,要在模 $x^n$ 意义下求 $B(x)$ ,使得 $B(x)\equiv \ln (A(x))\ (\mbox{mod}\ x^n)$ . 两边同时求导,得到 $B’(x)\equiv \frac {A’(x)} {A(x)}\ (\mbox{mod}\ x^n)$ . 多项式求逆得到 $\frac 1 {A(x)}$ ,再算出 $B’(x)$ ,再对 $B’(x)$ 不定积分得到 $B(x)$ . 这里 $B(x)$ 的常数项是 $0$ ,因为 $a_0=1$ ,若将 $\ln$ 函数大力展开,就可以发现 $B$ 的常数项就是 $\ln a_0$ . 时间复杂度 $\Theta(n\log n)$ . 多项式牛顿迭代已知一个函数 $G(x)$ ,在模 $x^n$ 意义下求一个多项式 $F(x)\ \mbox{mod}\ x^n$ ,使得 $G(F(x))\equiv 0(\mbox{mod}\ x^n)$ . 仍然将项数用 $0$ 补到 $2$ 的幂次.当 $n=1$ 时,需要单独求解 $G(F(x))\equiv 0(\mbox{mod}\ x)$ . 否则,先求解 $F_0(x)$ ,使得 $G(F_0(x))\equiv 0 (\mbox{mod}\ x^{\frac n 2})$ . 考虑如何拓展到模 $x^n$ 下,把 $G(F(x))$ 在 $F_0(x)$ 处进行泰勒展开, $$G(F(x))=G(F_0(x))+\frac{G’(F_0(x))}{1!}\cdot (F(x)-F_0(x))+\frac{G’’(F_0(x))}{2!}\cdot (F(x)-F_0(x))^2 + \dots$$ 因为 $G(F(x))\equiv 0(\mbox{mod}\ x^n)$ ,所以 $G(F(x))\equiv 0(\mbox{mod}\ x^{\frac n 2})$ 也成立. 而 $G(F_0(x))\equiv 0 (\mbox{mod}\ x^{\frac n 2})$ 所以 $F(x)$ 与 $F_0(x)$ 次数低于 $x^{\frac n 2}$ 的部分是相同的. 所以展开式中从第三项 $\frac{G’’(F_0(x))}{2!}\cdot (F(x)-F_0(x))^2$ 起,在模 $x^n$ 意义下都为 $0$ .于是只保留前两项,得到 $$G(F(x))\equiv G(F_0(x))+{G’(F_0(x))}\cdot (F(x)-F_0(x))\ (\mbox{mod}\ x^n)$$ 而 $G(F(x))\equiv 0(\mbox{mod}\ x^n)$ ,所以就有 $$F(x)\equiv F_0(x)-\frac {G(F_0(x))} {G’(F_0(x))}\ (\mbox{mod}\ x^n)$$ 需要注意,这里的 $G’(F_0(x))$ 是以 $F_0(x)$ 作为自变量求导,而不是以 $x$ 作为自变量求导. 如,若 $G(x)=\ln x,F_0(x)=x$ ,则 $G’(F_0(x))=\frac 1 {F_0(x)}=\frac 1 x$ ,而不是 $\ln(1)=0$ . 时间复杂度为 $O(n\log n)$ ,由于可以实现类似解方程的操作,所以用途比较广泛. 如实现多项式开根,就可以直接设 $G(x)=x^2-A$ . Luogu P4726 多项式 $\exp$给定项数为 $n$ 的多项式 $A(x)$ ,在 $\mbox{mod} \ x^n$ 意义下求多项式 $B(x)$ ,使得 $B(x)\equiv \exp(A(x))\ (\mbox{mod} \ x^n)$ . 取对数,得到 $\ln B\equiv A \ (\mbox{mod} \ x^n)$ ,令 $G(x)=\ln x-A$ . 则问题等价于求解 $F(x)$ ,使得 $G(F(x))\equiv 0(\mbox{mod}\ x^n)$ . 直接套用牛顿迭代的那一套理论,得到$$F\equiv (1-{\ln (F_0)+A})\cdot F_0\ (\mbox{mod}\ x^n)$$递归求解,当 $n=1$ 时,令 $F_0(x)=\exp a_0$ 即可.一般会保证多项式 $A$ 的常数项 $a_0=0$ . Luogu P5245 多项式快速幂给定项数为 $n$ 的多项式 $A(x)$ ,正整数 $k$ . 在 $\mbox{mod}\ x^n$ 下求多项式 $B(x)$ ,使得 $B(x)\equiv A^k(x)\ (\mbox{mod} \ x^n)$ . 两边同时取对数,得到 $\ln B(x)\equiv k\ln A(x) \pmod {x^n}$ ,可以看出 $k$ 可以直接对 $P$ 取模. 再对两边同时做一次 $\exp$ ,得到 $B(x)\equiv \exp(k\ln A(x)) \pmod {x^n}$ . Luogu P5050 多项式多点求值给定一个 $n$ 次多项式 $F(x)$ 和 $m$ 个数 $a_i$ ,需要求出每个 $F(a_i)$ 的值. 定义减法卷积 ${\rm MULT}(F(x),G(x))=\sum_{i\ge0}(\sum_{j\ge 0}f_{i+j}g_j)x^i​$ ,可以将一个多项式取反后再卷积来实现. 有 $F(a_i)=[x^0]{\rm MULT}(F(x),\frac{1}{1-a_ix})$ ,且 ${\rm MULT}(F(x),G(x)H(x))={\rm MULT}({\rm MULT}(F(x),G(x)),H(x))​$ . 分治地来求每个 $F(a_i)​$ .$$G(l,r,x):={\rm MULT}(F(x),\frac 1{\prod_{i=l}^r(1-a_ix)}) \bmod x^{r-l+1}\\G(l,mid,x)={\rm MULT}(G(l,r,x),\prod_{i=mid+1}^r (1-a_ix))\bmod x^{mid-l+1}\\G(mid+1,r,x)={\rm MULT}(G(l,r,x),\prod_{i=l}^{mid} (1-a_ix)) \bmod x^{r-mid}$$ 当递归到 $l=r​$ 时,此时的 $G(l,r,x)​$ 的常数项就是我们要求的点值了. 每个要用到的 $\prod_{i=l}^r (1-a_ix)$ 可以用分治 NTT 预处理出来,时间复杂度 $O(n\log^2 n)​$ . code Loj 150 挑战多项式给出次数为 $n$ 的多项式 $F(x)$ ,求$$\displaystyle G(x) \equiv \left({\left({1+\ln\left({2+F(x)-F(0)-{\exp\left({\int_0^x\frac{1}{\sqrt{F(t)}}\textrm{d}t}\right)}}\right)}\right)^k}\right)^\prime \pmod {x^n}$$ 在代码里面把多项式除法/取模也加上了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353,G=3;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int sqr;struct Complex&#123; int r,i; Complex(int r=0,int i=0):r(r),i(i) &#123;&#125; Complex operator * (const Complex &amp;rhs) const &#123; int x=add(mul(r,rhs.r),mul(mul(i,rhs.i),sqr)); int y=add(mul(r,rhs.i),mul(rhs.r,i)); return Complex(x,y); &#125;&#125;;Complex Complex_Fpow(Complex a,int b)&#123; Complex res=Complex(1,0); while(b) &#123; if(b&amp;1) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;int Cipolla(int x)&#123; if(fpow(x,(P-1)&gt;&gt;1)==P-1) return -1; srand(time(0)); int a; while(1) &#123; a=rand()%P; if(fpow(add(mul(a,a),P-x),(P-1)&gt;&gt;1)==P-1) &#123; sqr=add(mul(a,a),P-x); break; &#125; &#125; Complex tmp=Complex_Fpow(Complex(a,1),(P+1)&gt;&gt;1); int res=tmp.r; return min(res,add(P,-res));&#125;const int MAXN=4e5+10;int rev[MAXN],omega[MAXN],inv[MAXN],curn=0;void init(int n)&#123; if(curn==n) return; for(int i=0;i&lt;n;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(n&gt;&gt;1)); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; omega[l]=fpow(G,(P-1)/l); inv[l]=fpow(omega[l],P-2); &#125; curn=n;&#125;void DFT(int *a,int n,bool invflag)&#123; init(n); for(int i=0;i&lt;n;++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=l&gt;&gt;1; int gi=omega[l]; if(invflag) gi=inv[l]; for(int *p=a;p!=a+n;p+=l) &#123; int g=1; for(int i=0;i&lt;m;++i) &#123; int t=mul(g,p[i+m]); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int invn=fpow(n,P-2); for(int i=0;i&lt;n;++i) a[i]=mul(a[i],invn); &#125;&#125;void NTT(int *A,int *B,int *C,int lenA,int lenB)&#123; int lenC=lenA+lenB-1,n=1; while(n&lt;lenC) n&lt;&lt;=1; static int a[MAXN],b[MAXN]; copy(A,A+lenA,a); fill(a+lenA,a+n,0); copy(B,B+lenB,b); fill(b+lenB,b+n,0); DFT(a,n,false); DFT(b,n,false); for(int i=0;i&lt;n;++i) C[i]=mul(a[i],b[i]); DFT(C,n,true);&#125;void PolyInverse(int *A,int *B,int N) // B=A^(-1)&#123; int n=1; while(n&lt;N) n&lt;&lt;=1; static int res[MAXN],tmp[MAXN]; res[0]=fpow(A[0],P-2); for(int i=2;i&lt;=n;i&lt;&lt;=1) &#123; NTT(A,res,tmp,i,i); NTT(tmp,res,tmp,i,i); for(int j=0;j&lt;i;++j) res[j]=add(mul(2,res[j]),P-tmp[j]); &#125; copy(res,res+N,B);&#125;void PolySqrt(int *A,int *B,int N) // B=sqrt(A)&#123; int n=1; while(n&lt;N) n&lt;&lt;=1; static int res[MAXN],tmp[MAXN]; res[0]=Cipolla(A[0]); for(int i=2;i&lt;=n;i&lt;&lt;=1) &#123; PolyInverse(res,tmp,i); NTT(tmp,A,tmp,i,i); for(int j=0;j&lt;i;++j) res[j]=mul((P+1)&gt;&gt;1,add(res[j],tmp[j])); &#125; copy(res,res+N,B);&#125;void PolyDiff(int *A,int n)&#123; for(int i=0;i&lt;n-1;++i) A[i]=mul(i+1,A[i+1]); A[n-1]=0;&#125;void PolyInt(int *A,int n)&#123; for(int i=n+1;i&gt;=1;--i) A[i]=mul(fpow(i,P-2),A[i-1]); A[0]=0;&#125;void PolyLn(int *A,int *B,int n) // B=ln(A)&#123; static int invA[MAXN],tmp[MAXN]; PolyInverse(A,invA,n); copy(A,A+n,tmp); PolyDiff(tmp,n); NTT(tmp,invA,tmp,n,n); PolyInt(tmp,n); copy(tmp,tmp+n,B);&#125;void PolyExp(int *A,int *B,int N) // B=exp(A)&#123; int n=1; while(n&lt;N) n&lt;&lt;=1; static int res[MAXN],tmp[MAXN]; res[0]=1; for(int i=2;i&lt;=n;i&lt;&lt;=1) &#123; PolyLn(res,tmp,i); for(int j=0;j&lt;i;++j) tmp[j]=add(A[j],P-tmp[j]); inc(tmp[0],1); NTT(tmp,res,res,i,i); &#125; copy(res,res+N,B);&#125;void PolyPow(int *A,int *B,int n,int k) // B=A^k&#123; static int tmp[MAXN]; PolyLn(A,tmp,n); for(int i=0;i&lt;n;++i) tmp[i]=mul(tmp[i],k); PolyExp(tmp,B,n);&#125;void PolyDivision(int *A,int *B,int *D,int *R,int n,int m) // A=B*D+R len(A)=n len(B)=m&#123; static int ModA[MAXN],ModB[MAXN],InvB[MAXN]; --n,--m; reverse(A,A+n+1); reverse(B,B+m+1); copy(A,A+n-m+1,ModA); copy(B,B+n-m+1,ModB); int N=1; while(N&lt;n-m+1) N&lt;&lt;=1; PolyInverse(ModB,InvB,N); fill(InvB+n-m+1,InvB+N,0); NTT(ModA,InvB,D,n-m+1,n-m+1); reverse(D,D+n-m+1); reverse(A,A+n+1); reverse(B,B+m+1); NTT(B,D,R,m,n-m+1); for(int i=0;i&lt;n;++i) R[i]=add(A[i],P-R[i]);&#125;int n,k,f[MAXN],g[MAXN];int main()&#123; n=read()+1,k=read(); for(int i=0;i&lt;n;++i) f[i]=g[i]=read(); PolySqrt(g,g,n); PolyInverse(g,g,n); PolyInt(g,n); PolyExp(g,g,n); for(int i=0;i&lt;n;++i) g[i]=add(f[i],P-g[i]); inc(g[0],add(2,P-f[0])); PolyLn(g,g,n); inc(g[0],1); PolyPow(g,g,n,k); PolyDiff(g,n); for(int i=0;i&lt;n-1;++i) printf("%d ",g[i]); puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4373 算术天才⑨与等差数列]]></title>
    <url>%2F2019%2F08%2F13%2Fbzoj-4373-%E7%AE%97%E6%9C%AF%E5%A4%A9%E6%89%8D%E2%91%A8%E4%B8%8E%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[线段树 + $hash$ 乱搞. 可以考虑用线段树维护区间的最小值,最大值. 若是等差数列,根据最小/大值,公差可以算出长度,区间元素和,区间元素平方和,区间元素立方和,后两个自然溢出. 在线段树中把这些信息也维护进去,然后查询区间的这些要素,看一下是否符合预期结果即可. 立方和不判似乎也可以过.这东西应该挺难卡的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int read()&#123; int out=0,sgn=1; char jp=getchar(); while(jp!='-' &amp;&amp; (jp&lt;'0' || jp&gt;'9')) jp=getchar(); if(jp=='-') sgn=-1,jp=getchar(); while(jp&gt;='0' &amp;&amp; jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*sgn;&#125;const int MAXN=3e5+10;const int P=1e9+7;ull cube(ull x)&#123; return x*x*x;&#125;ull S1(ull x)&#123; return x*(x+1)/2;&#125;ull S2(ull x)&#123; return x*(x+1)*(2*x+1)/6;&#125;ull S3(ull x)&#123; return S1(x)*S1(x);&#125;const ull U=1;int n,m,tot=0,a[MAXN];struct SegTree&#123; struct node &#123; int minv,maxv; ll sum1; ull sum2,sum3; friend node operator + (node lson,node rson) &#123; node root; root.minv=min(lson.minv,rson.minv); root.maxv=max(lson.maxv,rson.maxv); root.sum1=lson.sum1+rson.sum1; root.sum2=lson.sum2+rson.sum2; root.sum3=lson.sum3+rson.sum3; return root; &#125; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root=lson+rson; &#125; void BuildTree(int o,int l,int r) &#123; if(l==r) &#123; root=(node)&#123;a[l],a[l],a[l],U*a[l]*a[l],cube(a[l])&#125;; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; void upd(int o,int l,int r,int pos,int c) &#123; if(l==r) &#123; root=(node)&#123;c,c,c,U*c*c,cube(c)&#125;; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(o&lt;&lt;1,l,mid,pos,c); else upd(o&lt;&lt;1|1,mid+1,r,pos,c); pushup(o); &#125; node query(int o,int l,int r,int L,int R) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) return root; int mid=(l+r)&gt;&gt;1; if(R&lt;=mid) return query(o&lt;&lt;1,l,mid,L,R); if(L&gt;mid) return query(o&lt;&lt;1|1,mid+1,r,L,R); return query(o&lt;&lt;1,l,mid,L,R)+query(o&lt;&lt;1|1,mid+1,r,L,R); &#125; bool check(int L,int R,int k) &#123; node tmp=query(1,1,n,L,R); ull len=R-L+1; if((tmp.maxv-tmp.minv)!=(len-1)*k) return false; ll expsum1=len*(tmp.minv+tmp.maxv)/2; if(expsum1!=tmp.sum1) return false; ull b=tmp.minv-k; ull expsum2=len*b*b; expsum2+=k*b*(len+1)*len; expsum2+=k*k*S2(len); if(expsum2!=tmp.sum2) return false; ull expsum3=cube(k)*S3(len); expsum3+=U*3*k*k*b*S2(len); expsum3+=U*3*k*b*b*S1(len); expsum3+=len*cube(b); if(expsum3!=tmp.sum3) return false; return true; &#125;&#125;T;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); T.BuildTree(1,1,n); while(m--) &#123; int op=read(); if(op==1) &#123; int x=read()^tot,y=read()^tot; T.upd(1,1,n,x,y); &#125; else &#123; int L=read()^tot,R=read()^tot,k=read()^tot; if(T.check(L,R,k)) &#123; puts("Yes"); ++tot; &#125; else puts("No"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Beginner Contest 134]]></title>
    <url>%2F2019%2F07%2F20%2FAtcoder-Beginner-Contest-134%2F</url>
    <content type="text"><![CDATA[$F$ 题不错. A Dodecagon签到题. 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int main()&#123; int x=read(); cout&lt;&lt;3*x*x&lt;&lt;endl; return 0;&#125; B Golden Apple签到题. 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int main()&#123; int n=read(),D=read(); cout&lt;&lt;(n+2*D)/(2*D+1)&lt;&lt;endl; return 0;&#125; C Exception Handling$ST$ 表或者线段树写一写就好了.或许有不用数据结构的高论? 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int a[MAXN];struct Segtree&#123; struct node &#123; int mx; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.mx=max(lson.mx,rson.mx); &#125; void bd(int o,int l,int r) &#123; if(l==r) &#123; root.mx=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; bd(o&lt;&lt;1,l,mid); bd(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; int query(int o,int l,int r,int L,int R) &#123; if(L&gt;R || L&gt;r || l&gt;R) return -1; if(L&lt;=l &amp;&amp; r&lt;=R) return root.mx; int res=0; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res=max(res,query(o&lt;&lt;1,l,mid,L,R)); if(R&gt;mid) res=max(res,query(o&lt;&lt;1|1,mid+1,r,L,R)); return res; &#125;&#125;T;int main()&#123; int n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); T.bd(1,1,n); for(int i=1;i&lt;=n;++i) printf("%d\n",max(T.query(1,1,n,1,i-1),T.query(1,1,n,i+1,n))); return 0;&#125; D Preparing Boxes倒着确定每个数,显然每个数是唯一确定的. 暴力统计就好了,由调和级数知,时间复杂度 $O(n\log n)$ . 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,a[MAXN];int t[MAXN],m=0;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=n;i&gt;=1;--i) &#123; int x=a[i]; for(int j=i*2;j&lt;=n;j+=i) x^=t[j]; t[i]=x; if(x) ++m; &#125; cout&lt;&lt;m&lt;&lt;endl; for(int i=1;i&lt;=n;++i) if(t[i]) printf("%d ",i); return 0;&#125; E Sequence Decomposing给一个序列,求最少分成几个单调上升子序列. 大概就是导弹拦截那道题.答案就是最长单调不降子序列的长度. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,A[MAXN],a[MAXN];#define lowbit(x) x&amp;(-x)int bit[MAXN];void add(int x,int c)&#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]=max(bit[x],c);&#125;int sum(int x)&#123; int s=0; for(;x;x-=lowbit(x)) s=max(s,bit[x]); return s;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) A[i]=a[i]=read(); sort(A+1,A+1+n); int m=unique(A+1,A+1+n)-A-1; for(int i=1;i&lt;=n;++i) &#123; int x=lower_bound(A+1,A+1+m,a[i])-A; x=m+1-x; int y=sum(x)+1; add(x,y); &#125; cout&lt;&lt;sum(n)&lt;&lt;endl; return 0;&#125; F Permutation Oddness$dp$ 计数,设 $f(i,j,k,l)$ 表示考虑前 $i$ 个位置, $1,2,\dots i $ 中有 $j$ 个数还没有填,位置 $1,2,\dots,i$ 中有 $k$ 个位置还没有放,已经确定的权值为 $l$ 时的方案数. 后两维可以写在一起,状态数 $O(n^4)$ ,转移 $O(1)$ ,时间复杂度 $O(n^4)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=51;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;void upd(int &amp;x,int y)&#123; x=add(x,y);&#125;int N,K;int f[MAXN][MAXN][MAXN*MAXN];int main()&#123; N=read(),K=read(); f[0][0][0]=1; for(int i=1;i&lt;=N;++i) for(int j=0;j&lt;=i;++j) for(int k=2*j;k&lt;=K;++k) &#123; upd(f[i][j][k],mul(2*j+1,f[i-1][j][k-2*j])); upd(f[i][j][k],mul(j*j+2*j+1,f[i-1][j+1][k-2*j])); if(j) upd(f[i][j][k],f[i-1][j-1][k-2*j]); &#125; cout&lt;&lt;f[N][0][K]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>Atcoder</tag>
        <tag>dp计数</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190720]]></title>
    <url>%2F2019%2F07%2F20%2Ftest20190720%2F</url>
    <content type="text"><![CDATA[好题. $A\ Safe\ Bet$$25$ 分做法:枚举镜子摆放的位置,模拟光线,每次用 $set$ 找到下一面镜子,修改方向,最后检验是否从 $(R,C)$ 出来. 满分做法:不额外增加镜子,直接模拟光线,若最后从 $(R,C)$ 出来,答案为 $0$ . 否则,模拟反向光线,从 $(R,C+1)$ 反向射入,可以发现放镜子的可行位置为两条光线的所有交点. 用扫描线 + 线段树求交点数目以及字典序最小的交点即可. 考试情况:只写了 $25$ 分的做法. $std$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;cstdio&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;#define rep(i,n) for (int i=0;i&lt;n;++i)#define pb push_back#define mk make_pair#define X first#define Y second#define tree int t,int l,int r#define left t*2,l,mid#define right t*2+1,mid+1,r#define M int mid=l+r&gt;&gt;1const int N=1000005;typedef pair&lt;int,int&gt; pr;typedef vector&lt;pair&lt;int,pr&gt; &gt; seq;set&lt;pr&gt; a[N],b[N];seq f1,g1,f2,g2;int Case,n,m,R,C,x,y,ll,rr,c[N];long long ans;int get(int x)&#123; int res=0; for (; x; x-=x&amp;-x) res+=c[x]; return res;&#125;void add(int x,int v)&#123; for (; x&lt;=C; x+=x&amp;-x) c[x]+=v;&#125;void ins(int side)&#123; scanf("%d%d",&amp;x,&amp;y),a[x].insert(mk(y,side)),b[y].insert(mk(x,side));&#125;bool track(int x,int y,int d,seq &amp;f,seq &amp;g)&#123; f.clear(),g.clear(); set&lt;pr&gt; :: iterator it; for (;;) &#123; if (d&amp;1) &#123; if (d==1) &#123; it=b[y].upper_bound(mk(x,1)); f.pb(mk(x+1,mk(y,1))); if (it==b[y].end()) return f.pb(mk(R+1,mk(y,-1))),0; f.pb(mk(it-&gt;X,mk(y,-1))),x=it-&gt;X,d=it-&gt;Y?2:0; &#125; else &#123; it=b[y].lower_bound(mk(x,0)); f.pb(mk(x,mk(y,-1))); if (it==b[y].begin()) return f.pb(mk(1,mk(y,1))),0; --it; f.pb(mk(it-&gt;X+1,mk(y,1))),x=it-&gt;X,d=it-&gt;Y?0:2; &#125; &#125; else &#123; if (d==0) &#123; it=a[x].upper_bound(mk(y,1)); if (it==a[x].end()) return g.pb(mk(x,mk(y+1,C))),x==R; g.pb(mk(x,mk(y+1,it-&gt;X-1))),y=it-&gt;X,d=it-&gt;Y?3:1; &#125; else &#123; it=a[x].lower_bound(mk(y,0)); if (it==a[x].begin()) return g.pb(mk(x,mk(1,y-1))),0; --it; g.pb(mk(x,mk(it-&gt;X+1,y-1))),y=it-&gt;X,d=it-&gt;Y?1:3; &#125; &#125; &#125;&#125;void work(seq &amp;f,seq &amp;g)&#123; sort(f.begin(),f.end()),sort(g.begin(),g.end()); int m=f.size(),n=g.size(),j=0; rep(i,n) &#123; while (j&lt;m &amp;&amp; f[j].X&lt;=g[i].X) add(f[j].Y.X,f[j].Y.Y),++j; ll=g[i].Y.X,rr=g[i].Y.Y; int res=get(rr)-get(ll-1); ans+=res; if (g[i].X&lt;x &amp;&amp; res) &#123; x=g[i].X,y=ll; for (int j=20; j&gt;=0; --j) if (y+(1&lt;&lt;j)&lt;=rr &amp;&amp; !(get(y-1+(1&lt;&lt;j))-get(y-1))) y+=1&lt;&lt;j; &#125; &#125; while (j&lt;m) add(f[j].Y.X,f[j].Y.Y),++j;&#125;int main()&#123; freopen("safe.in","r",stdin); freopen("safe.out","w",stdout); while (scanf("%d%d%d%d",&amp;R,&amp;C,&amp;n,&amp;m)!=EOF) &#123; rep(i,R+1) a[i].clear(); rep(j,C+1) b[j].clear(); rep(i,n+m) ins(i&lt;n); printf("Case %d: ",++Case); if (track(1,0,0,f1,g1)) &#123; puts("0"); continue; &#125; track(R,C+1,2,f2,g2); ans=0,x=R+1,work(f1,g2),work(f2,g1); if (ans) printf("%I64d %d %d\n",ans,x,y); else puts("impossible"); &#125; return 0;&#125; $Room\ Service$$25$ 分做法:一堆特判.矩形的情况答案就是对角线长度 $\times 2$ . 我的 $60$ 分做法:其实就是乱搞,出题人是没有设计这一部分的,也没有卡我. 把每条边 $K$ 等分,拆成 $K+1$ 个点,设 $f(i,j,S)$ 表示从出发点到达第 $i$ 条边上的第 $j$ 个点,已经到达过的边集合为 $S$ 时走过的最短长度.大力转移,时间复杂度为 $O(n^2\cdot2^n\cdot K^2)$ .实际上有很多无用状态.参数 $K$ 取 $200$ 就可以了. 满分做法:若需要到的线段为直线,显然只需要将点 $P$ 关于 $n$ 条边都镜面反射一次,得到 $P’$ , $dis(P,P’)$ 即为答案. 但现在是线段,有可能交点在线段外,此时一定是某一个端点处最优.于是只有端点或交点处的状态有用, $flyod$ 预处理两点间最短路后,枚举第一个到的关键点和最后一个到的关键点,更新答案.时间复杂度 $O(n^3)$ . 考试情况:乱搞获得 $60$ 分. $std$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;#define rep(i,n) for (int i=1;i&lt;=n;++i)const double eps=1e-8;int Case,n;double ans,d[205][205];struct node&#123; double x,y; node() &#123;&#125; node(double _x,double _y):x(_x),y(_y) &#123;&#125; node operator +(const node &amp;A) &#123; return node(x+A.x,y+A.y); &#125; node operator -(const node &amp;A) &#123; return node(x-A.x,y-A.y); &#125; node operator *(const double &amp;A) &#123; return node(x*A,y*A); &#125; double operator *(const node &amp;A) &#123; return x*A.x+y*A.y; &#125; double operator %(const node &amp;A) &#123; return x*A.y-y*A.x; &#125; double norm() &#123; return x*x+y*y; &#125; double len() &#123; return sqrt(norm()); &#125; void read() &#123; scanf("%lf%lf",&amp;x,&amp;y); &#125;&#125; a[205];bool cross(node &amp;A,node &amp;B,node &amp;C,node &amp;D)&#123; return ((C-A)%(B-A))*((D-A)%(B-A))&lt;=0 &amp;&amp; ((C-A)%(B-A))*((D-A)%(B-A))&lt;=0;&#125;void rev(node A,node B,node &amp;C)&#123; node V=B-A; C=(A+V*(((C-A)*V)/V.norm()))*2-C;&#125;double work(node A,int l,node B,int r)&#123; for (int i=l; i&lt;r; ++i) rev(a[i],a[i+1],A); for (int i=r; i&gt;l; --i) &#123; if (!cross(A,B,a[i-1],a[i])) return 1e9; rev(a[i-1],a[i],A),rev(a[i-1],a[i],B); &#125; return (A-B).len();&#125;inline int chg(int x)&#123; return x&gt;n?x-n:x;&#125;inline void Min(double &amp;x,double y)&#123; if (y&lt;x) x=y;&#125;int main()&#123; freopen("room.in","r",stdin); freopen("room.out","w",stdout); while (scanf("%d",&amp;n)!=EOF) &#123; ans=1e9,a[0].read(); rep(i,n) a[i].read(),a[n+i]=a[i]; rep(i,n) rep(j,n-1) d[i][chg(i+j)]=work(a[i],i+1,a[i+j],i+j-1); rep(k,n) rep(i,n) rep(j,n) Min(d[i][j],d[i][k]+d[k][j]); rep(i,n) &#123; ans=min(ans,work(*a,i,*a,i+n)); for (int j=0; j&lt;n; ++j) d[0][chg(i+j)]=work(*a,i,a[i+j],i+j-1), d[chg(i+j)][0]=work(a[i+j],i+j+1,*a,i+n); rep(j,n) rep(k,n) Min(ans,d[0][j]+d[j][k]+d[k][0]); &#125; printf("%.2lf\n",ans); &#125; return 0;&#125; $Rain$满分做法:一个点的水面高度取决于它到边界必须经过的点中的最高海拔. 预处理出边界,从边界上的点出发跑 $Dijkstra$ ,求出每个点的水面高度,然后 $bfs$ 求联通块. 求边界可以先极角排序,从 $x$ 坐标最小的点出发,绕一圈就是边界. 时间复杂度 $O(m\cdot \log m)$ . 考试情况: puts(“0”); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;#define rep(i,n) for (int i=0,_=n;i&lt;_;++i)#define pb push_back#define mk make_pairconst int N=52*52;int Case,n,m,u,v,X,Y,now,o,x[N],y[N],h[N],d[N],id[N],ans[N];bool b[N];priority_queue&lt;pair&lt;int,int&gt; &gt; H;vector&lt;int&gt; e[N];char st[5];int C(char x)&#123; return x&lt;'a'?x-65:x-71;&#125;int get()&#123; scanf("%s",st); int v=C(st[0])*52+C(st[1]); if (id[v]&lt;0) id[v]=now++; return id[v];&#125;bool cmp(const int i,const int j)&#123; return atan2(y[i]-Y,x[i]-X)&lt;atan2(y[j]-Y,x[j]-X);&#125;void dfs(int i)&#123; if (!b[i] || d[i]&lt;=h[i]) return; b[i]=0; rep(k,e[i].size()) dfs(e[i][k]);&#125;int main()&#123; freopen("rain.in","r",stdin); freopen("rain.out","w",stdout); while (scanf("%d%d",&amp;n,&amp;m)!=EOF) &#123; rep(i,N) b[i]=1,id[i]=-1,e[i].clear(),d[i]=1&lt;&lt;20; now=0,o=0; rep(i,n) &#123; u=get(),scanf("%d%d%d",x+u,y+u,h+u); if (x[u]&lt;x[o]) o=u; &#125; rep(i,m) u=get(),v=get(),e[u].pb(v),e[v].pb(u); rep(i,n) X=x[i],Y=y[i],sort(e[i].begin(),e[i].end(),cmp); d[o]=h[o],H.push(mk(-d[o],o)); for (int j=o,i=e[o][0];; j=i,i=e[i][u]) &#123; rep(k,e[i].size()) if (e[i][k]==j) &#123; u=k; break; &#125; if (++u==e[i].size()) u=0; d[i]=h[i],H.push(mk(-d[i],i)); if (i==o &amp;&amp; !u) break; &#125; while (!H.empty()) &#123; pair&lt;int,int&gt; t=H.top(); H.pop(); int i=t.second; if (-t.first==d[i]) rep(k,e[i].size()) &#123; int j=e[i][k]; if (max(d[i],h[j])&lt;d[j]) d[j]=max(d[i],h[j]),H.push(mk(-d[j],j)); &#125; &#125; int L=0; rep(i,n) if (b[i] &amp;&amp; d[i]&gt;h[i]) ans[L++]=d[i],dfs(i); if (!L) puts("0"); sort(ans,ans+L); rep(i,L) printf("%d\n",ans[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>计算几何</tag>
        <tag>最短路</tag>
        <tag>扫描线</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4446 小凸玩密室]]></title>
    <url>%2F2019%2F07%2F20%2Fbzoj-4446-%E5%B0%8F%E5%87%B8%E7%8E%A9%E5%AF%86%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[树形 $dp$ . 设 $f(i,j)$ 表示将子树 $i$ 全部点亮,下一次点亮点 $j$ 的最小花费.这样的话,状态数是 $O(n^2)$ 的. 注意到点亮子树 $i$ 后,下一次要么点亮 $i$ 的某个祖先,要么点亮 $i$ 的某个祖先的另外一侧的儿子.树是完全二叉树,所以可以直接用深度表示,树深是 $O(\log n)$ 的,再通过位运算得到节点标号. 设 $f(i,j)$ 表示点亮子树 $i$ 后,下一次点亮 $i$ 的第 $j$ 级祖先的最小花费, $g(i,j)$ 表示点亮子树 $i$ 后,下一次点亮 $i$ 的第 $j$ 级祖先的另一个儿子的最小花费.这样状态数是 $O(n\log n)$ 的. 默认以 $1$ 为根, $dp$ 求出 $f,g$ 的值.然后枚举第一个点亮的点 $x$ ,先点亮子树 $x$ ,跳到 $fa_x$ ,再点亮 $fa_x$ 的另一侧子树,再跳到 $fa_{fa_x}$ ,点亮 $fa_{fa_x}$ 的另一颗子树…需要跳 $O(\log n)$ 次. 时间复杂度 $O(n\log n)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int fa(int x)&#123; return x&gt;&gt;1;&#125;int lson(int x)&#123; return x&lt;&lt;1;&#125;int rson(int x)&#123; return x&lt;&lt;1|1;&#125;int Ancestor(int x,int i)&#123; return x&gt;&gt;i;&#125;int Brother(int x,int i)&#123; return (x&gt;&gt;(i-1))^1;&#125;const int MAXN=2e5+10;const int Log=20;const ll inf=1e18;int n,dep[MAXN];ll a[MAXN],dis[MAXN][Log],f[MAXN][Log],g[MAXN][Log];int main()&#123; n=read(); for(int i=1; i&lt;=n; ++i) a[i]=read(); dep[1]=1; for(int i=2; i&lt;=n; ++i) &#123; dep[i]=dep[fa(i)]+1; dis[i][1]=read(); for(int j=2; j&lt;=dep[i]; ++j) dis[i][j]=dis[fa(i)][j-1]+dis[i][1]; &#125; for(int i=n; i&gt;=1; --i) &#123; int l=lson(i),r=rson(i); for(int j=1; j&lt;=dep[i]; ++j) &#123; if(r&lt;=n) //lson and rson &#123; f[i][j]=min(a[l]*dis[l][1]+g[l][1]+f[r][j+1],a[r]*dis[r][1]+g[r][1]+f[l][j+1]); g[i][j]=min(a[l]*dis[l][1]+g[l][1]+g[r][j+1],a[r]*dis[r][1]+g[r][1]+g[l][j+1]); &#125; else if(l&lt;=n)// only lson &#123; f[i][j]=a[l]*dis[l][1]+f[l][j+1]; g[i][j]=a[l]*dis[l][1]+g[l][j+1]; &#125; else //leaf &#123; f[i][j]=dis[i][j]*a[Ancestor(i,j)]; g[i][j]=(dis[i][j]+dis[Brother(i,j)][1])*a[Brother(i,j)]; &#125; &#125; &#125; ll ans=inf; for(int i=1; i&lt;=n; ++i) &#123; ll tmp=f[i][1]; for(int x=fa(i),y=i; x; y=x,x=fa(x)) &#123; int z=y^1; if(z&lt;=n) tmp+=dis[z][1]*a[z]+f[z][2]; else tmp+=dis[x][1]*a[fa(x)]; &#125; ans=min(ans,tmp); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4444 国旗计划]]></title>
    <url>%2F2019%2F07%2F19%2Fbzoj-4444-%E5%9B%BD%E6%97%97%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[$two\ pointer$ + 倍增. 首先破环成链,接一段长度为 $m$ 的在后面.因为区间不覆盖,对于一个区间 $(l,r)$ ,它后面应该接的区间可以贪心确定,就是左端点在 $[l,r]$ 范围内,而右端点最大的区间.这个可以通过 $two\ pointer$ 预处理. 然后用倍增的做法,处理 $f(i,j)$ 表示区间 $i$ 之后的第 $2^j$ 个区间标号. 查询时从 $i$ 开始跳,找到第一个区间使得区间总长 $\ge m$ 即可.时间复杂度 $O(n\cdot \log m)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=4e5+10;struct node&#123; int l,r,id; node(int l=0,int r=0,int id=0):l(l),r(r),id(id) &#123;&#125; bool operator &lt; (const node &amp;rhs) const &#123; return r&lt;rhs.r; &#125;&#125;p[MAXN];int n,m,f[MAXN][20];int ans[MAXN];int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; int l=read(),r=read(); if(l&gt;r) p[2*i-1]=node(l,r+m,i),p[2*i]=node(l+m,r+2*m,i); else p[2*i-1]=node(l,r,i),p[2*i]=node(l+m,r+m,i); &#125; sort(p+1,p+1+2*n); for(int i=1,j=1;i&lt;=2*n;++i) &#123; while(j&lt;2*n &amp;&amp; p[j+1].l&lt;=p[i].r) ++j; f[i][0]=(i==j)?0:j; &#125; for(int j=1;(1&lt;&lt;j)&lt;=2*n;++j) for(int i=1;i&lt;=2*n;++i) f[i][j]=f[f[i][j-1]][j-1]; for(int i=1;i&lt;=2*n;++i) &#123; if(p[i].l&gt;m) continue; int x=i,tmp=0; for(int j=19;j&gt;=0;--j) if(f[x][j] &amp;&amp; p[f[x][j]].r&lt;p[i].l+m) x=f[x][j],tmp+=(1&lt;&lt;j); x=f[x][0]; ++tmp; ans[p[i].id]=tmp+(int)(p[i].id!=p[x].id); &#125; for(int i=1;i&lt;=n;++i) printf("%d ",ans[i]); puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>倍增</tag>
        <tag>two pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4443 小凸玩矩阵]]></title>
    <url>%2F2019%2F07%2F19%2Fbzoj-4443-%E5%B0%8F%E5%87%B8%E7%8E%A9%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[二分答案 + 二分图最大匹配. 二分答案 $mid$ ,权值 $\le mid$ 的边才有用,第 $k$ 大就是第 $n-k+1$ 小,判断一下最大匹配数是否达到 $n-k+1$ ,达到则合法,否则不合法. 时间复杂度 $O(n^3\cdot \log (\max v))$ . 匈牙利算法每次 $dfs$ 前都需要清空 $vis$ 数组. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=256;int a[MAXN][MAXN];vector&lt;int&gt; E[MAXN&lt;&lt;1];int pr[MAXN&lt;&lt;1],vis[MAXN&lt;&lt;1];int n,m,k;bool dfs(int u)&#123; int t=E[u].size(); for(int i=0;i&lt;t;++i) &#123; int v=E[u][i]; if(!vis[v]) &#123; vis[v]=1; if(!pr[v] || dfs(pr[v])) &#123; pr[v]=u; pr[u]=v; return true; &#125; &#125; &#125; return false;&#125;bool check(int mid)&#123; for(int i=1;i&lt;=n+m;++i) E[i].clear(); memset(pr,0,sizeof pr); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) if(a[i][j]&lt;=mid) &#123; E[i].push_back(j+n); E[j+n].push_back(j); &#125; int ans=0; for(int i=1;i&lt;=n;++i) if(!pr[i]) &#123; memset(vis,0,sizeof vis); ans+=(int)(dfs(i)); &#125; return ans&gt;=(n+1-k);&#125;int main()&#123; n=read(),m=read(),k=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) a[i][j]=read(); int L=1,R=inf,ans=inf; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid)) ans=mid,R=mid-1; else L=mid+1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF19E Fairy]]></title>
    <url>%2F2019%2F07%2F19%2FCF19E-Fairy%2F</url>
    <content type="text"><![CDATA[树上差分. 二分图定义是能用黑白两种颜色给图染色,使得没有两个有边相连的节点颜色相同.其实也就是说图中不存在奇环. 那么一张二分图,删去任意一条边后一定仍是二分图.于是我们先做出原图的一棵生成树,再将剩下的边加入. 预处理 $LCA,dep$ ,然后加入非树边 $(u,v)$ .那么树上 $u\to v$ 路径上所有边都被这条非树边”覆盖”了. 若 $dis(u,v)$ 为奇,加入 $(u,v)$ 后会形成偶环,称这样的边为合法的边. 若 $dis(u,v)$ 为偶,则加入 $(u,v)$ 后会形成奇环,称这样的边为不合法的边. 记不合法的边总数为 $tot$ ,若 $tot=0$ ,可以删的边就是所有的边. 若 $tot=1$ ,可以删的边就是唯一的那条不合法边,以及树上被它覆盖,但未被合法边覆盖的边. 若 $tot&gt;1$ ,可以删的边就是树上被所有不合法边覆盖,但未被任意一条合法边覆盖的边. 删去树边时要求未被合法边覆盖,是因为 $(u,v)$ 若被合法边覆盖,删去后 $u$ 可以走奇数步走到 $v$ ,图中仍存在奇环. 判断使用树上差分,被不合法边覆盖 $+1$ ,被合法边覆盖 $-1$ . 图可能有重边,自环,判起来比较麻烦.还可能不连通,需要每个联通块分别做上述步骤. 没有判重边/自环的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;int n,m,vis[MAXN];vector&lt;int&gt; G[MAXN];int color[MAXN];struct Edge&#123; int u,v,id,tp; bool operator &lt; (const Edge &amp;rhs) const &#123; return color[u]&lt;color[rhs.u]; &#125;&#125;E[MAXN];struct DSU&#123; int Fa[MAXN]; void init() &#123; for(int i=1;i&lt;=n;++i) Fa[i]=i; &#125; int Find(int x) &#123; if(x==Fa[x]) return x; return Fa[x]=Find(Fa[x]); &#125; bool Union(int x,int y) &#123; x=Find(x),y=Find(y); if(x==y) return false; Fa[x]=y; return true; &#125;&#125;dsu;void dfs_dye(int u,int col)&#123; color[u]=col; int t=G[u].size(); for(int i=0;i&lt;t;++i) &#123; int v=G[u][i]; if(color[v]) continue; dfs_dye(v,col); &#125;&#125;typedef pair&lt;int,int&gt; pii;map&lt;pii,int&gt; mp;int fa[MAXN],dep[MAXN],siz[MAXN],mxson[MAXN],top[MAXN];void dfs1(int u,int F)&#123; fa[u]=F; siz[u]=1; int t=G[u].size(); for(int i=0;i&lt;t;++i) &#123; int v=G[u][i]; if(v==F) continue; dep[v]=dep[u]+1; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; top[u]=tp; if(mxson[u]) dfs2(mxson[u],tp); int t=G[u].size(); for(int i=0;i&lt;t;++i) &#123; int v=G[u][i]; if(v==fa[u] || v==mxson[u]) continue; dfs2(v,v); &#125;&#125;int LCA(int x,int y)&#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=fa[top[x]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;int rt[MAXN],L[MAXN],R[MAXN],delta[MAXN];vector&lt;int&gt; ans;void ins(int k)&#123; ans.push_back(E[k].id);&#125;void dfs_sum(int u)&#123; int t=G[u].size(); for(int i=0;i&lt;t;++i) &#123; int v=G[u][i]; if(v==fa[u]) continue; dfs_sum(v); delta[u]+=delta[v]; &#125;&#125;int main()&#123; n=read(),m=read(); dsu.init(); int cnt=0; for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); ++cnt; E[cnt].u=u,E[cnt].v=v; E[cnt].id=i; G[u].push_back(v); G[v].push_back(u); &#125; m=cnt; int col=0; for(int i=1;i&lt;=n;++i) if(!color[i]) &#123; rt[++col]=i; dfs_dye(i,col); &#125; sort(E+1,E+1+m); for(int i=1;i&lt;=n;++i) G[i].clear(); int curcol=1; L[1]=1; for(int i=1;i&lt;=m;++i) &#123; int u=E[i].u,v=E[i].v; if(color[u]!=curcol) &#123; R[curcol]=i-1; ++curcol; L[curcol]=i; &#125; if(dsu.Union(u,v))//ontree &#123; E[i].tp=1; G[u].push_back(v); G[v].push_back(u); &#125; else E[i].tp=0; &#125; R[curcol]=m; for(int i=1;i&lt;=n;++i) if(!siz[i]) dfs1(i,0); for(int i=1;i&lt;=n;++i) if(!top[i]) dfs2(i,i); for(int c=1;c&lt;=curcol;++c) &#123; int tot=0,tmp; for(int i=L[c];i&lt;=R[c];++i) &#123; if(E[i].tp) continue; int u=E[i].u,v=E[i].v,lca=LCA(u,v); int dis=dep[u]+dep[v]-2*dep[lca],val; if(dis&amp;1) val=-1; else &#123; ++tot; val=1; tmp=i; &#125; delta[u]+=val,delta[v]+=val; delta[lca]-=2*val; &#125; if(!tot) &#123; for(int i=L[c];i&lt;=R[c];++i) ins(i); &#125; else &#123; dfs_sum(rt[c]); if(tot==1) ins(tmp); for(int i=L[c];i&lt;=R[c];++i) &#123; if(!E[i].tp) continue; int u=E[i].u,v=E[i].v; if(fa[u]==v) swap(u,v); if(delta[v]==tot) ins(i); &#125; &#125; &#125; sort(ans.begin(),ans.end()); int t=ans.size(); printf("%d\n",t); for(int i=0;i&lt;t;++i) printf("%d ",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>二分图</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4417 超级跳马]]></title>
    <url>%2F2019%2F07%2F19%2Fbzoj-4417-%E8%B6%85%E7%BA%A7%E8%B7%B3%E9%A9%AC%2F</url>
    <content type="text"><![CDATA[矩阵快速幂. 最朴素的 $dp$ 是设 $f(i,j)$ 表示从出发点走到 $(i,j)$ 的方案数.有一个比较精妙的状态设计, 直接令 $f(2,1)=f(2,2)=1,f(i,j)=f(i-2,j)+f(i-1,j-1)+f(i-1,j)+f(i-1,j+1)$ . 后面三项表示从前一列转移过来的贡献,而 $f(i-2,j)$ 表示从第 $i-3,i-5\dots$ 列转移过来的贡献前缀和. 构造一个 $2n\times 2n$ 的矩阵加速转移,时间复杂度 $O(n^3\cdot \log m)$ . 需要特判 $n=1$ 以及 $m=1$ 的情况. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=30011;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=101;int n,m,N;struct Matrix&#123; int v[MAXN][MAXN]; Matrix()&#123;memset(v,0,sizeof v);&#125; Matrix operator * (const Matrix &amp;rhs) const &#123; Matrix res; for(int k=0;k&lt;N;++k) for(int i=0;i&lt;N;++i) for(int j=0;j&lt;N;++j) res.v[i][j]=add(res.v[i][j],mul(v[i][k],rhs.v[k][j])); return res; &#125;&#125;;Matrix fpow(Matrix a,int b)&#123; Matrix res; for(int i=0;i&lt;2*n;++i) res.v[i][i]=1; while(b) &#123; if(b&amp;1) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; n=read(),m=read(); if(m==1) &#123; if(n==1) puts("1"); else puts("0"); return 0; &#125; Matrix trans,st; if(n==1) &#123; st.v[0][0]=1; st.v[1][0]=1; trans.v[0][1]=1; trans.v[1][1]=trans.v[1][2]=1; trans.v[2][1]=1; N=3; st=fpow(trans,m-1)*st; cout&lt;&lt;st.v[0][0]&lt;&lt;endl; return 0; &#125; st.v[0][0]=st.v[1][0]=1; for(int i=0;i&lt;n;++i) &#123; trans.v[i][i]=1; if(i&gt;0) trans.v[i][i-1]=1; if(i&lt;n-1) trans.v[i][i+1]=1; trans.v[i][i+n]=1; &#125; for(int i=n;i&lt;2*n;++i) trans.v[i][i-n]=1; N=2*n; st=fpow(trans,m-2)*st; cout&lt;&lt;st.v[n-1][0]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
        <tag>矩阵优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4416 阶乘字符串]]></title>
    <url>%2F2019%2F07%2F18%2Fbzoj-4416-%E9%98%B6%E4%B9%98%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[状压 $dp$ . 设 $f(S)$ 表示从 $1$ 开始,使得集合 $S$ 中元素所有排列均出现的最小长度. 预处理从位置 $i$ 开始,字母 $j$ 首次出现的位置 $nxt(i,j)$ ,可以状压 $dp$ .转移时枚举排列的最后一个元素的位置, $O(2^n\cdot n+len\cdot n)$ . $n\le 26$ ,似乎过不去?然而字符串长度 $\le 450$ ,最小的合法串是 $O(n^2)$ 级别, $n\ge 22$ 时一定无解. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=451,MAXS=(1&lt;&lt;21)+10;int n,nxt[MAXN][26],f[MAXS];char buf[MAXN];void solve()&#123; n=read(); scanf("%s",buf+1); if(n&gt;=22) &#123; puts("NO"); return; &#125; int m=strlen(buf+1); buf[0]=buf[m+1]='#'; for(int j=0;j&lt;n;++j) nxt[m+1][j]=m+1; for(int i=m;i&gt;=0;--i) for(int j=0;j&lt;n;++j) nxt[i][j]=(buf[i+1]-'a'==j)?i+1:nxt[i+1][j]; memset(f,0,sizeof f); int mx=(1&lt;&lt;n)-1; for(int i=1;i&lt;=mx;++i) &#123; for(int j=0;j&lt;n;++j) if((1&lt;&lt;j)&amp;i) f[i]=max(f[i],nxt[f[i^(1&lt;&lt;j)]][j]); &#125; if(f[mx]&lt;=m) puts("YES"); else puts("NO");&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190717]]></title>
    <url>%2F2019%2F07%2F17%2Ftest20190717%2F</url>
    <content type="text"><![CDATA[$noip$ 套题. 看了下题,感觉可能 $T1$ 比较麻烦,后面两个大概都是 $noip$ 难度. 于是打算把后面两个写了再做 $T1$ .( $flag$ ) $b$这个题上次 $nicodafagood$ 讲过,当时就直接口胡出来了,做法比较套路. 对第 $4$ 个条件 $\gcd_{i=1}^k a_i=1$ 容斥一下,设 $f(i)$ 表示所有数均为 $i$ 的倍数,不考虑第 $4$ 个条件的答案. 那么原问题答案就是 $f(1)-f(2)-f(3)-f(5)+f(6)\dots$ 有奇数个质因子就减去,偶数个质因子就加上,若它的某个质因子次数 $\ge 2$ ,那么它的贡献一定在算那个质因子的 $f$ 的时候被算入,就不用算了. 所以这个系数就是 $\mu$ ,记不考虑第 $4$ 个条件, $a_i$ 取值范围为 $[1,x]$ 时答案为 $F(x)$ ,即 $f(\lfloor \frac n x \rfloor)$. 原问题答案为 $\sum_{i=1}^n F(\lfloor \frac n i\rfloor)\cdot \mu(i)$ . 显然可以整除分块, $\mu$ 的前缀和用杜教筛计算. 计算 $F(x)$ 也是经典问题,位置 $i$ 的元素加上 $i-1$ ,就变成了求单调递增序列个数,而取值范围变成 $[1,x+k-1]$ . 随便取 $k$ 个数,从小到大排序后恰好对应了一种方案.于是 $F(x)={x+k-1\choose k}$ . $x$ 可能很大,但 $k\le 10^3$ ,所以每次求组合数的时候暴力 $O(k)$ 求,大概就能过了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;const int N=870963;int prime[N+10],cnt=0,ism[N+10],mu[N+10],summu[N+10];void init()&#123; ism[1]=1; mu[1]=1; for(int i=2;i&lt;=N;++i) &#123; if(!ism[i]) &#123; prime[++cnt]=i; mu[i]=P-1; &#125; for(int j=1;j&lt;=cnt &amp;&amp; 1LL*prime[j]*i&lt;=N;++j) &#123; int num=prime[j]*i; ism[num]=1; if(i%prime[j]==0) break; mu[num]=add(P,-mu[i]); &#125; &#125; for(int i=1;i&lt;=N;++i) summu[i]=add(summu[i-1],mu[i]);&#125;map&lt;int,int&gt; mp;int sum(int x)&#123; if(x&lt;=N) return summu[x]; if(mp.find(x)!=mp.end()) return mp[x]; int res=1; for(int l=2,r;l&lt;=x;l=r+1) &#123; r=x/(x/l); res=add(res,mul(P-sum(x/l),r-l+1)); &#125; return mp[x]=res;&#125;int n,k,invfack;int F(int x)&#123; int res=invfack; for(int i=x;i&lt;=x+k-1;++i) res=mul(res,i); return res;&#125;void solve()&#123; n=read(),k=read(); invfack=1; for(int i=2;i&lt;=k;++i) invfack=mul(invfack,i); invfack=inv(invfack); int ans=0; for(int l=1,r;l&lt;=n;l=r+1) &#123; r=n/(n/l); int tmp=add(sum(r),P-sum(l-1)); tmp=mul(tmp,F(n/l)); ans=add(ans,tmp); &#125; printf("%d\n",ans);&#125;int main()&#123; freopen("b.in","r",stdin); freopen("b.out","w",stdout); init(); int T=read(); while(T--) solve(); return 0;&#125; $c$显然是点分治. 但点的贡献写起来比边的贡献麻烦,因为根节点的贡献只能贡献一次.所以记录时带上根节点的贡献,查询时不带. 分两种情况讨论一下,一种是最大值在当前点到根节点路径上,另一种是在根节点到另外一个点的路径上. 式子列一列,发现就相当于二维平面内有若干点,要统计 $x=x_0$ ,$y\le y_0$ 或 $y&gt;y_0$ 的点的数目. 按 $x$ 为第一关键字, $y$ 为第二关键字排序. 这个东西还要离散化,我的做法写起来特别麻烦,细节特别多. 一直写,一直改,终于改对的时候就没时间了. 于是 $T1$ 爆零. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;int P,n;inline int add(int a,int b)&#123; return (a + b) % P;&#125;const int MAXN=1e5+10;struct SegTree&#123; int idx,Rt; struct node &#123; int ls,rs; int sum; node()&#123;ls=rs=sum=0;&#125; &#125;Tree[MAXN*30];#define root Tree[o] SegTree()&#123;idx=Rt=0;&#125; int query(int o,ll l,ll r,ll L,ll R) &#123; if(!o || L&gt;R || R&lt;=0) return 0; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; ll mid=(l+r)&gt;&gt;1; int res=0; if(L&lt;=mid) res+=query(root.ls,l,mid,L,R); if(R&gt;mid) res+=query(root.rs,mid+1,r,L,R); return res; &#125; void ins(int &amp;o,ll l,ll r,ll pos,int c) &#123; if(pos&gt;r || pos&lt;l) return; if(!o) o=++idx; root.sum+=c; if(l==r) return; ll mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(root.ls,l,mid,pos,c); else ins(root.rs,mid+1,r,pos,c); &#125;&#125;T1,T2,T3,T4;typedef pair&lt;int,int&gt; pii;#define mp make_pairint head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],ecnt=0;int val[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;ll ans=0;int rt,mi,totsiz,siz[MAXN],vis[MAXN];void Findrt(int u,int fa)&#123; siz[u]=1; int mxsiz=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa || vis[v]) continue; Findrt(v,u); siz[u]+=siz[v]; mxsiz=max(mxsiz,siz[v]); &#125; mxsiz=max(mxsiz,totsiz-siz[u]); if(mxsiz&lt;mi) mi=mxsiz,rt=u;&#125;pii stk1[MAXN],stk2[MAXN];int tp1=0,tp2=0;pii q1[MAXN],q2[MAXN];pii q3[MAXN],q4[MAXN];int t=0,t1,t2;inline int id1l(int sum,int mx)&#123; return lower_bound(q1+1,q1+t1+1,mp(sum,mx))-q1;&#125;inline int id1r(int sum,int mx)&#123; return upper_bound(q1+1,q1+t1+1,mp(sum,mx))-q1-1;&#125;inline int id2l(int sum,int mx)&#123; return lower_bound(q2+1,q2+t2+1,mp(sum,mx))-q2;&#125;inline int id2r(int sum,int mx)&#123; return upper_bound(q2+1,q2+t2+1,mp(sum,mx))-q2-1;&#125;int calc1(int sum,int mx)&#123; ll L=id1l(add(P,mx-sum),0); ll R=id1r(add(P,mx-sum),mx); int k=T1.query(1,1,n,L,R); return k; &#125;int calc2(int sum,int mx)&#123; ll L=id2l(sum,mx-1); ll R=id2r(sum,1000000000); int k=T2.query(1,1,n,L,R); return k;&#125;void dfs_pre(int u,int fa,int sum,int mx)&#123; sum=add(sum,val[u]); mx=max(mx,val[u]); q1[++t]=mp(sum,mx); q2[t]=mp(add(P,mx-sum),mx); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa || vis[v]) continue; dfs_pre(v,u,sum,mx); &#125;&#125;void dfs(int u,int fa,int SS,int MM,int sum,int mx)&#123; sum=add(sum,val[u]); mx=max(mx,val[u]); SS=add(SS,val[u]); MM=max(MM,val[u]); ans+=calc1(sum,mx); ans+=calc2(sum,mx); stk2[++tp2]=mp(SS,MM); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa || vis[v]) continue; dfs(v,u,SS,MM,sum,mx); &#125;&#125;void solve(int u)&#123; t=0; q1[++t]=mp(val[u]%P,val[u]); q2[t]=mp(0,val[u]); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v]) continue; dfs_pre(v,0,val[u]%P,val[u]); &#125; sort(q1+1,q1+1+t); sort(q2+1,q2+1+t); t1=unique(q1+1,q1+1+t)-q1-1; t2=unique(q2+1,q2+1+t)-q2-1; stk1[tp1=1]=mp(val[u]%P,val[u]); T1.ins(T1.Rt,1,n,id1l(val[u]%P,val[u]),1); T2.ins(T2.Rt,1,n,id2l(0,val[u]),1); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v]) continue; tp2=0; dfs(v,0,val[u],val[u],0,0); for(int i=1;i&lt;=tp2;++i) &#123; T1.ins(T1.Rt,1,n,id1l(stk2[i].first,stk2[i].second),1); T2.ins(T2.Rt,1,n,id2l(add(P,stk2[i].second-stk2[i].first),stk2[i].second),1); stk1[++tp1]=stk2[i]; &#125; &#125; for(int i=1;i&lt;=tp1;++i) &#123; T1.ins(T1.Rt,1,n,id1l(stk1[i].first,stk1[i].second),-1); T2.ins(T2.Rt,1,n,id2l(add(P,stk1[i].second-stk1[i].first),stk1[i].second),-1); &#125;&#125;void Divide(int u)&#123; vis[u]=1; solve(u); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v]) continue; mi=inf; totsiz=siz[v]; Findrt(v,0); Divide(rt); &#125;&#125;int main()&#123; freopen("c.in","r",stdin); freopen("c.out","w",stdout); n=read(),P=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; for(int i=1;i&lt;=n;++i) val[i]=read(); mi=inf; totsiz=n; Findrt(1,0); Divide(rt); cout&lt;&lt;ans+n&lt;&lt;endl; return 0;&#125; $a$暴力 + 最优化剪枝 可过.]]></content>
      <tags>
        <tag>容斥原理</tag>
        <tag>test</tag>
        <tag>点分治</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4414 数量积]]></title>
    <url>%2F2019%2F07%2F17%2Fbzoj-4414-%E6%95%B0%E9%87%8F%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[结论题. 结论:对于类似斐波那契数列的,满足 $a_i=a_{i-1}+a_{i-2}(i\ge 2),a_1=a_2$ 的数列 $a$ ,有以下等式成立: $$a_1\cdot a_{n+m+1}=a_n\cdot a_m + a_{n+1} \cdot a_{m+1}$$ 等式右边那坨就是我们要求的数量积.即 $v_i\cdot v_j=C\cdot a_{2i+2j+1}$ . 把可以作为数量积的 $O(n)$ 个数全部求出来即可. 证明过程 $sto\ xmk$ . 考虑矩阵乘法. 比较一下最左端的向量和最右端的运算结果即得结论中的等式. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int P;inline int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=6e5+10;int n;int res[MAXN],tot=0;int main()&#123; int f1=read(); P=read(),n=read(); int a=0,b=f1%P; for(int i=2;i&lt;=4*n-1;++i) &#123; int c=add(a,b); if((i&amp;1) &amp;&amp; (i&gt;=7)) res[++tot]=mul(c,f1); a=b; b=c; &#125; sort(res+1,res+1+tot); tot=unique(res+1,res+1+tot)-res-1; cout&lt;&lt;tot%P&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4783 矩阵求逆]]></title>
    <url>%2F2019%2F07%2F17%2FLuogu-4783-%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86%2F</url>
    <content type="text"><![CDATA[矩阵求逆板子. 对一个矩阵,定义它的三种初等行变换: 交换某两行. 将某一行的元素全部 $\times k (k\not= 0)$ . 将某一行的元素的 $k$ 倍加到另一行对应位置上去. 每个初等行变换都对应了一个初等矩阵,即,对矩阵 $A$ 做一次初等行变换,等价于用对应的初等矩阵 $P_0$ 左乘 $A$ ,即 $A=P_0A$ . 若矩阵 $A$ 有逆,一定可以通过高斯消元,做有限次初等行变换得到单位矩阵 $I$ .即, $P_kP_{k-1}\dots P_0 A=I$ .根据矩阵乘法的结合律,把前面所有 $P_i$ 看做一个矩阵 $P$ ,即 $PA=I$ ,根据定义, $P$ 就是我们要求的 $A^{-1}$ . 而 $PI=P$ ,所以我们再维护一个矩阵 $B$ ,初始为 $I$ ,高斯消元时同步与 $A$ 做相同的初等行变换,当 $A$ 变为 $I$ 时, 得到的 $B$ 就是我们要求的 $P$ ,即 $A^{-1}$ . 若在高斯消元时发现 $A$ 无法消成 $I$ ,则说明 $A$ 不可逆. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a + b) % P;&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=400+10;int n,A[MAXN][MAXN],B[MAXN][MAXN];void addrow(int a[],int b[],int t)&#123; for(int i=1;i&lt;=n;++i) a[i]=add(a[i],mul(b[i],t));&#125;bool inverse()&#123; for(int i=1;i&lt;=n;++i) B[i][i]=1; for(int i=1;i&lt;=n;++i) &#123; if(!A[i][i]) &#123; for(int j=i+1;j&lt;=n;++j) if(A[j][i]) &#123; swap(A[i],A[j]); swap(B[i],B[j]); break; &#125; &#125; if(!A[i][i]) return false; int inv=fpow(A[i][i],P-2); for(int j=i+1;j&lt;=n;++j) &#123; int x=A[j][i]; addrow(A[j],A[i],P-mul(x,inv)); addrow(B[j],B[i],P-mul(x,inv)); &#125; &#125; for(int i=n;i&gt;=1;--i) &#123; int inv=fpow(A[i][i],P-2); for(int j=1;j&lt;i;++j) &#123; int x=A[j][i]; addrow(A[j],A[i],P-mul(x,inv)); addrow(B[j],B[i],P-mul(x,inv)); &#125; &#125; for(int i=1;i&lt;=n;++i) &#123; if(!A[i][i]) return false; int inv=fpow(A[i][i],P-2); for(int j=1;j&lt;=n;++j) B[i][j]=mul(B[i][j],inv); &#125; return true;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) A[i][j]=read(); if(inverse()) &#123; for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=n;++j) printf("%d ",B[i][j]); puts(""); &#125; &#125; else puts("No Solution"); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2019同步赛游记]]></title>
    <url>%2F2019%2F07%2F16%2FNOI2019%E5%90%8C%E6%AD%A5%E8%B5%9B%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[流星延停 $Day -\infty$今年的 CTS 和 APIO 因为一些个人因素没有去. 这期间一边学 OI ,一边上文化课,月考凭借爆算苟了一个级 rk1 . 说起来这还是从初中开始的第一个 rk1 呢,算是完成了一个小心愿?虽然 rk2 拿了好几次… $Day\ 1$做题顺序 $1\to 2\to 3$ . $T1$ 感觉 $70$ 分很可做,大力 $O(\max q\cdot n)$ 来 $dp$ . 不是 $DAG​$ 也没有关系,时间那一维是没有后效性的,先枚举时间就好了. 然后又感觉后面的 $15$ 分也可以做,每个点按照所有的上/下车时间,将 $n$ 个点拆成 $O(m)$ 个点,这部分 $A=0$ ,贡献是线性的,所以对于原来一个点拆出来的所有点,连边时不需要两两连,按时间排序,相邻的才连边,然后跑 $Dijkstra​$ . 感觉这个玩意细节处理起来比较麻烦,只有 $15$ 分,就先放着,去看后面两个题. $T2$ 无想法,写了 $20$ 分暴力就放着了. $T3$ 无想法,写了个 $28$ 分的 $O(n^4)$ 大力 $dp$ 就放着了. 回过去看 $T1$ ,发现 $\max q$ 只有 $1000$ . 算了一下,发现答案不会爆 $int$ ,这样开一个 $\max q\cdot n$ 的二维数组需要 $400\ MB$ 左右?空间限制是 $512\ MB$ ? 那直接 $O(\max q\cdot n)$ 行不行啊,感觉还有很多无效状态的样子.写了一发,开上 $O2$ ,发现大样例要跑 $2s$ .感觉可以寻址优化,于是把二维数组的两个维度交换一下,就只用跑 $0.5s$ 了.这东西能过?虽然不太清楚但也只能先这样了… $T2$ 还是没有什么想法,但发现 $T3$ 费用流应该可以做 $n\le 150$ 的点,说不定 $n\le 2000$ 也可以过. 迅速建了个模,码码码…发现不对.肉眼调试了一会,发现没加反边.(蠢得离谱) 改过来,发现还是不对.调了一会,发现我求的是最小值.把费用改成负的,还是不对? 小数据调了一下,发现建模有问题,流量可以偷偷流走.调整了几波模型,发现流量还是偷偷流走. 可能就没什么时间了.费用流就破产了,把三道题的三个暴力检查了一下,卡了下常数,今天就结束了. 然后出去吃饭,黄学长还吃过敏了… 下午 $4$ 点左右有数据了.测了一下, $100+20+28=148$ ,没挂, 成功 获得暴力分. $Day\ 2$做题顺序 $1\to 2\to 3$ . $T1$ 感觉用 $kdt$ 建图就好了?然后发现空间 128 MB .跑了一波边数,发现开不下. 意识到出题人安排这个空间就是卡 $kdt$ 的?但是貌似想不出其他比较优秀的做法了… 只好头铁写了一波 $kdt$ . 看 $T2$ ,怎么又是 $landlords$ …先写了个 $10$ 分暴力,写 $dp$ 的部分分时候思路很乱,胡乱写了一发,过不了样例.调了一会,未果,只好放着了… $T3$ 是个交互?自己似乎是第一次做这种带端口的交互(之前只在 $CF/ATC$ 上遇到输出命令来交互的题). 有点被吓到,冷静下来分析一波,发现前面 $5$ 个点就是暴力分,每个点改一次,再询问所有点,变了的就是与它有边的. 度数 $=1$ 的部分也比较可做,图是 $N/2$ 个点对,询问次数是 $N\log N$ ,提示得比较明显,每个二进制位都做一次,将当前二进制位为 $1$ 的点 $modify$ 一次,再询问所有点,若它的状态改变,说明它连的点这一位上与它相同,否则不同. 于是就有 $36$ 分的暴力了. 回过去再卡了一下 $T1$ 的空间,就结束了… 下午测了一波, $76+10+36=122$ . 后记果然自己还是菜的真实,打 $\color{brown} {Cu}$ 了.希望明年能作为正式选手取得令自己满意的成绩吧. 结果官方测出来有 $286$ ?虽然还是打 $\color{brown} {Cu}$ 了.]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190715]]></title>
    <url>%2F2019%2F07%2F15%2Ftest20190715%2F</url>
    <content type="text"><![CDATA[神仙题,又被虐了. $graph$ $60$ 分做法:将所有方程列出来,因为保证有唯一解,所以不用管方程个数,直接高斯消元.时间复杂度 $O(m^3)$ . 满分做法:比较神仙,注意到条件 $2$ 的形式是电学中基尔霍夫方程组,将 $A$ 看做 $\epsilon$ , $B$ 看做 $R$ , $C$ 看做 $I$ . 为每个节点定义一个电压 $\phi(u)$ ,规定 $\phi (1)=0$ , $\phi(u)=\sum_{i=0}^{k-1} I(v_i,v_{i+1})\cdot R(v_i,v_{i+1})-\epsilon (v_i,v_{i+1})$ ,其中 $&lt;v_0=1,v_1,\dots,v_{k-1},v_k=u&gt;$ 是原图中一条路径,这样定义也满足了条件 $3$ . 容易验证无论选择怎样的路径,每个点的电压值都是不变的.利用条件 $1$ 列出 $n-1$ 个方程,高斯消元解出 $2\sim n$ 的电压,再根据 $I(u,v)=\frac {\phi(u)-\phi(v)+\epsilon(u,v)} {R(u,v)}$ 求出电流.时间复杂度 $O(n^3)$ . 考试情况:只写了 $60$ 分的做法. $std$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;string.h&gt;#include &lt;memory.h&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;#define rep(i,a,b) for(int i=(a);i&lt;=(b);i++)#define repk(i,a,b) rep(i,a,(b)-1)#define rrep(i,a,b) for(int i=(b);i&gt;=(a);i--)#define rrepk(i,a,b) rrep(i,a,(b)-1)#define fe(e,x) for(edge *e = (x)-&gt;first;e;e = e-&gt;next)#define foreach(tank_type,iterator_name,set_name) \ for(tank_type::iterator iterator_name = (set_name).begin();iterator_name != (set_name).end();iterator_name++)#define comp_def(cmp_name,type) bool cmp_name(type l,type r)#define ifn(x) if(!(x))#define vind(p_point) (p_point-points)#define eind(p_edge) (p_edge-edges)#define eopp(p_edge) (edges+(eind(p_edge)^1))#define mp(x,y) make_pair((x),(y))typedef long long ll;const int inf = 0x3fffffff,upinf = 0x7fffffff,geps = 10;const double eps = 1e-12,dinf = 1e20;ll modnum;struct modll&#123; ll x; modll():x(0)&#123;&#125; modll(ll _x)&#123; _x &lt; 0 ? x = _x % modnum + modnum : (_x &gt;= modnum ? x = _x % modnum : x = _x); &#125; inline static ll pmod(ll _x)&#123; return _x &gt;= modnum ? _x - modnum : _x; &#125; inline static ll plus(ll x,ll y)&#123; return pmod(x + y); &#125; inline static ll minus(ll x,ll y)&#123; return pmod(x + modnum - y); &#125; inline static ll multi(ll x,ll y)&#123; ll s = 0; for(;y;y&gt;&gt;=1)&#123; if(y&amp;1) s = plus(s,x); x = plus(x,x); &#125;return s; &#125; inline static ll inv(ll a)&#123; ll b = modnum,c = a%b,q = a/b,k1 = 1,k2 = 0,k3 = pmod(minus(k1,multi(q,k2))); while(c^1) a = b,b = c,c = a%b,q = a/b,k1 = k2,k2 = k3,k3 = pmod(minus(k1,multi(q,k2))); return k3; &#125; inline static ll llpow(ll b,ll p)&#123; ll s = 1; for(;p;p&gt;&gt;=1)&#123; if(p&amp;1) s = multi(s,b); b = multi(b,b); &#125;return s; &#125;&#125;;bool operator==(modll l,modll r)&#123;return l.x == r.x;&#125;bool operator!=(modll l,modll r)&#123;return l.x != r.x;&#125;modll operator+(modll l,modll r)&#123;return modll(modll::plus(l.x,r.x));&#125;modll operator-(modll l,modll r)&#123;return modll(modll::minus(l.x,r.x));&#125;modll operator*(modll l,modll r)&#123;return modll(modll::multi(l.x,r.x));&#125;modll operator/(modll l,modll r)&#123;return modll(modll::multi(l.x,modll::inv(r.x)));&#125;modll operator^(modll l,ll r)&#123; return r &lt; 0 ? modll(modll::llpow(modll::inv(l.x),-r)) : modll(modll::llpow(l.x,r));&#125;modll operator-(modll l)&#123;return modll(-l.x);&#125;modll operator+=(modll&amp; l,modll r)&#123;return modll(l.x = modll::plus(l.x,r.x));&#125;modll operator-=(modll&amp; l,modll r)&#123;return modll(l.x = modll::minus(l.x,r.x));&#125;modll operator*=(modll&amp; l,modll r)&#123;return modll(l.x = modll::multi(l.x,r.x));&#125;modll operator/=(modll&amp; l,modll r)&#123;return modll(l.x = modll::multi(l.x,modll::inv(r.x)));&#125;modll operator^=(modll&amp; l,ll r)&#123; return modll( l.x = r &lt; 0 ? modll::llpow(modll::inv(l.x),-r) : modll::llpow(l.x,r) );&#125;const int maxn = 100,maxm = 2000;struct equation&#123; modll dat[maxn][maxn + geps]; int n; void clear(int _n)&#123; n = _n; repk(i,0,n) repk(j,0,n+1) dat[i][j].x = 0; &#125; modll&amp; operator()(int i,int j)&#123;return dat[i][j];&#125; void rowswap(int r1,int r2)&#123; repk(j,0,n+1) swap(dat[r1][j],dat[r2][j]); &#125; void elimination(int r1,int r2)&#123;//eliminate r2 from r1 modll g = dat[r2][r1]/dat[r1][r1]; repk(j,0,n+1) dat[r2][j] -= dat[r1][j] * g; &#125; vector&lt;modll&gt; getans()&#123; vector&lt;modll&gt; ans; repk(i,0,n)&#123; if(dat[i][i] == 0)&#123; repk(j,i+1,n) if(dat[i][j] != 0) &#123;rowswap(i,j);break;&#125; if(dat[i][i] == 0) return ans; &#125;repk(j,0,n) if(i != j) elimination(i,j); &#125;repk(i,0,n) ans.push_back(dat[i][n] / dat[i][i]); return ans; &#125;&#125;;struct Graph&#123; equation Eq;pair&lt;int,int&gt; edge[maxm]; modll As[maxm],Bs[maxm]; int V,E; void create(int _V)&#123;Eq.clear(V = _V);E = 0;&#125; void addedge(int u,int v,modll A,modll B)&#123; Eq(v,v) += 1/B; Eq(v,u) -= 1/B; Eq(v,V) -= A/B; Eq(u,v) -= 1/B; Eq(u,u) += 1/B; Eq(u,V) += A/B; As[E] = A,Bs[E] = B; edge[E++] = make_pair(u,v); &#125; vector&lt;ll&gt; solve_graph()&#123; repk(j,0,V+1) Eq(V-1,j) = 0; Eq(V-1,V-1) = 1; vector&lt;modll&gt; Por = Eq.getans(); vector&lt;ll&gt; ans; if(Por.size() == 0) return ans; repk(i,0,E)&#123; int u = edge[i].first,v = edge[i].second; ans.push_back(((Por[v] - Por[u] + As[i]) / Bs[i]).x); &#125;return ans; &#125;&#125;G;int n,m;void Init()&#123; scanf("%d%d%lld",&amp;n,&amp;m,&amp;modnum);G.create(n); int x,y;ll A,B; repk(i,0,m)&#123; scanf("%d%d%lld%lld",&amp;x,&amp;y,&amp;A,&amp;B); G.addedge(x-1,y-1,A,B); &#125;&#125;void solve()&#123; vector&lt;ll&gt; ans = G.solve_graph(); if(ans.size() == 0) printf("-1\n"); else foreach(vector&lt;ll&gt;,it,ans) printf("%lld\n",*it);&#125;int main()&#123; freopen("graph.in","r",stdin); freopen("graph.out","w",stdout); Init(); solve(); return 0;&#125; $grid$ $40$ 分做法:设 $f(s,i,j,d)$ 表示两人各自都走了 $s$ 步,以 $(1,1)$ 作为左下角,第一个人向右走了 $i$ 步,第二个人向右走了 $j$ 步,一共已经经过了 $d$ 个特殊点时的方案数.两人交换算一种方案,限制 $j\le i$ , $O(n^4)$ 大力 $dp$ . 满分做法:先考虑一条路径的方案数,将特殊点按照 $x+y$ 排序,那么一条路径上出现的特殊点的编号递增. 设 $f(i,j)$ 表示走到了第 $i$ 个特殊点,此前经过了 $j$ 个特殊点的方案数, $g(i,j)$ 表示从第 $i$ 个特殊点走到第 $j$ 个特殊点而不经过其他特殊点的方案数.枚举上一个走过的特殊点是 $k$ , $$f(i,j)=\sum_{k=1}^{i-1} f(k,j-1)\cdot g(k,i)$$ 把起点看做 $0$ 号点,终点看做 $C+1$ 号点,方案数为: $$ans=\sum_{i=0}^D f(C+1,i)$$ 考虑如何求 $g(i,j)$ .若不考虑特殊点,从 $(x_0,y_0)$ 走到 $(x_1,y_1)$ 的方案数显然是 $x_1-x_0+y_1-y_0\choose x_1-x_0$ . 记 $h(i,j)$ 表示从特殊点 $i$ 到特殊点 $j$ 的方案数(不考虑限制),枚举不合法路径上的第一个点 $k$ , $$g(i,j)=h(i,j)-\sum_{k=i+1}^{j-1} g(i,k)\cdot h(k,j)$$ 于是我们用 $O(C^3)$ 的时间复杂度解决了一条路径经过特殊点个数不超过 $D$ 的方案数. 到目前为止的部分和 这个题 做法是差不多的. 若要求两条不相交路径的方案数,将两条路径看做 $(1,2)\to (n-1,m)$ 与 $(2,1) \to (n,m-1)$ . 记它们为 $s_1\to t_1,s_2\to t_2$ .容斥一下,用总方案数减去路径相交的方案数. 若两条路径相交于点 $p$ ,可以将它们的后半段交换,得到 $s_1\to p\to t_2$ 与 $s_2\to p \to t_1$ 两条路径. 于是可以断言,所有的 $s_1\to t_2$ 与所有的 $s_2\to t_1$ 一定是一一对应的,且对应的两条路径一定相交. 那么最终答案为 $s_1\to t_1,s_2\to t_2$ 的方案数乘积减去 $s_1\to t_2$ 与 $s_2\to t_1$ 的方案数之和,不需要不相交,直接套用前部分算一条路径的方案数即可. 模数不为质数时,无法直接预处理阶乘逆元,需要分解质因子, $mod=\prod p_i^k$ ,处理每个质因子的时候,位置 $p_i^j$ 特判,其余位置直接求逆元,最后再用 $CRT$ 合并答案. 考试情况:只写了 $40$ 分的部分. $std$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define ll long long#define mkp make_pair#define fir first#define sec secondusing namespace std;const int MaxN = 200010, Log = 10;int fac[MaxN], facpow[MaxN][Log], facinv[MaxN];int factor[Log], ftot;int mod;void exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123; x = 1, y = 0; return; &#125; exgcd(b, a % b, y, x); y -= a / b * x;&#125;int get_inv(int a) &#123; int x, y; exgcd(a, mod, x, y); return ((x % mod) + mod) % mod;&#125;int power(ll x, int l) &#123; ll ret = 1; for (; l; l &gt;&gt;= 1, x = x * x % mod) if (l &amp; 1) ret = ret * x % mod; return ret;&#125;void init(int n) &#123; ftot = 0; int x = mod; for (int i = 2; i * i &lt;= mod; ++i) if (x % i == 0) &#123; factor[ftot++] = i; while (x % i == 0) x /= i; &#125; if (x != 1) factor[ftot++] = x; fac[0] = facinv[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; int x = i; memcpy(facpow[i], facpow[i - 1], sizeof facpow[i]); for (int j = 0; j &lt; ftot; ++j) while (x % factor[j] == 0) &#123; x /= factor[j]; ++facpow[i][j]; &#125; fac[i] = 1ll * fac[i - 1] * x % mod; facinv[i] = get_inv(fac[i]); &#125;&#125;int comb(int n, int m) &#123; int ret = 1ll * fac[n] * facinv[m] % mod * facinv[n - m] % mod; for (int j = 0; j &lt; ftot; ++j) ret = 1ll * ret * power(factor[j], facpow[n][j] - facpow[m][j] - facpow[n - m][j]) % mod; return ret;&#125;const int MaxC = 210;int n, m, c, d;int f[MaxC][MaxC], g[MaxC][MaxC], ways[MaxC][MaxC];bool mark[MaxC][MaxC];int a[2][2][MaxC], ans[MaxC];pair &lt;int, int&gt; car[MaxN];inline bool tless(pair &lt;int, int&gt; a, pair &lt;int, int&gt; b) &#123; return (a.fir &lt;= b.fir) &amp;&amp; (a.sec &lt;= b.sec);&#125;void init_car() &#123; memset(ways, 0, sizeof(ways)); memset(f, 0, sizeof(f)); memset(mark, 0, sizeof(mark)); for (int i = 1; i &lt;= c; ++i) for (int j = i; j &lt;= c; ++j) if (tless(car[i], car[j])) &#123; ways[i][j] = comb(car[j].fir - car[i].fir + car[j].sec - car[i].sec, car[j].fir - car[i].fir); mark[i][j] = 1; &#125; for (int i = 1; i &lt;= c; ++i) for (int j = 1; j &lt;= c; ++j) if (mark[i][j]) &#123; f[i][j] = ways[i][j]; for (int k = i + 1; k &lt; j; ++k) if (mark[i][k] &amp;&amp; mark[k][j] &amp;&amp; f[i][k]) &#123; f[i][j] = (f[i][j] - 1ll * f[i][k] * ways[k][j]) % mod; &#125; &#125;&#125;void calc(int a[], int sx, int sy, int tx, int ty) &#123; fill(a, a + c + 1, 0); car[0] = mkp(sx, sy); car[c + 1] = mkp(tx, ty); if (!tless(car[0], car[c + 1])) return; //init f[0][], f[][c + 1] for (int i = 0; i &lt;= c + 1; ++i) if (tless(car[0], car[i])) &#123; f[0][i] = ways[0][i] = comb(car[i].fir - sx + car[i].sec - sy, car[i].fir - sx); mark[0][i] = 1; for (int j = 1; j &lt; i; ++j) if (mark[0][j] &amp;&amp; mark[j][i] &amp;&amp; f[0][j]) f[0][i] = (f[0][i] - 1ll * f[0][j] * ways[j][i]) % mod; &#125; else &#123; f[0][i] = ways[0][i] = mark[0][i] = 0; &#125; for (int i = c + 1; i &gt;= 0; --i) if (tless(car[i], car[c + 1])) &#123; f[i][c + 1] = ways[i][c + 1] = comb(tx - car[i].fir + ty - car[i].sec, tx - car[i].fir); mark[i][c + 1] = 1; for (int j = i + 1; j &lt;= c; ++j) if (mark[i][j] &amp;&amp; mark[j][c + 1] &amp;&amp; f[i][j]) &#123; f[i][c + 1] = (f[i][c + 1] - 1ll * f[i][j] * ways[j][c + 1]) % mod; &#125; &#125; else &#123; f[i][c + 1] = ways[i][c + 1] = mark[i][c + 1] = 0; &#125; memset(g, 0, sizeof(g)); g[0][0] = 1; for (int i = 1; i &lt;= c + 1; ++i) for (int j = 1; j &lt;= d + 1; ++j) for (int k = 0; k &lt; i; ++k) &#123; g[i][j] = (g[i][j] + 1ll * g[k][j - 1] * f[k][i]) % mod; &#125; for (int i = 0; i &lt;= d + 1; ++i) a[i] = g[c + 1][i + 1];// for (int i = 0; i &lt;= d + 1; ++i) printf("%d ", a[i]); puts(";");&#125;void Main() &#123; scanf("%d%d%d%d%d", &amp;n, &amp;m, &amp;c, &amp;d, &amp;mod); init(n + m); for (int i = 1; i &lt;= c; ++i) scanf("%d%d", &amp;car[i].fir, &amp;car[i].sec); sort(car + 1, car + c + 1); init_car(); calc(a[0][0], 1, 2, n - 1, m); calc(a[0][1], 1, 2, n, m - 1); calc(a[1][0], 2, 1, n - 1, m); calc(a[1][1], 2, 1, n, m - 1); int ret = 0; memset(ans, 0, sizeof(ans)); for (int i = 0; i &lt;= d; ++i) &#123; for (int j = 0; j &lt;= i; ++j) ans[i] = (ans[i] + 1ll * a[0][0][j] * a[1][1][i - j] - 1ll * a[0][1][j] * a[1][0][i - j]) % mod; ret += (ans[i] &lt; 0 ? ans[i] += mod : ans[i]); ret &gt;= mod ? ret -= mod : ret; &#125; cout &lt;&lt; ret &lt;&lt; endl;&#125;int main()&#123; freopen("grid.in", "r", stdin); freopen("grid.out", "w", stdout); int T; scanf("%d", &amp;T); while (T--) Main(); return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>构造</tag>
        <tag>数学</tag>
        <tag>容斥原理</tag>
        <tag>高斯消元</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190714]]></title>
    <url>%2F2019%2F07%2F15%2Ftest20190714%2F</url>
    <content type="text"><![CDATA[又被虐了. $Fable$ 每做一次冒泡,对于一个数 $a_i$ ,若 $i$ 之前的位置有比它大的数,那么其中一个一定会跳到它的后面. 则它的位置向前移了一位,比它大的数少了一个. 初始时,若前面比它大的数的个数 $\ge k$ ,则说明每次都能往前移,最后的位置就是初始位置 $-k$ .对于剩下的数,它们最后一定会从小到大把剩余的位置补满. 离散化 + 树状数组处理. 考试情况:大部分时间都在想/写/调这个题.最后 $A$ 了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,k;typedef pair&lt;int,int&gt; pii;pii a[MAXN];int ans[MAXN],tot[MAXN],rk[MAXN];int bit[MAXN];#define lowbit(x) x&amp;(-x)void add(int x,int c)&#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=c;&#125;int sum(int x)&#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x]; return s;&#125;int main()&#123; freopen("fable.in","r",stdin); freopen("fable.out","w",stdout); n=read(),k=read(); for(int i=1;i&lt;=n;++i) a[i].second=i,a[i].first=read(); sort(a+1,a+1+n); rk[a[1].second]=1; for(int i=2;i&lt;=n;++i) &#123; if(a[i].first==a[i-1].first) rk[a[i].second]=rk[a[i-1].second]; else rk[a[i].second]=i; &#125; for(int i=1;i&lt;=n;++i) &#123; add(rk[i],1); tot[i]=sum(n)-sum(rk[i]); if(tot[i]&gt;k) ans[i-k]=a[rk[i]].first; &#125; int pos=1; for(int i=1;i&lt;=n;++i) &#123; if(tot[a[i].second]&lt;=k) &#123; while(pos&lt;=n &amp;&amp; ans[pos]) ++pos; ans[pos]=a[i].first; &#125; &#125; for(int i=1;i&lt;=n;++i) printf("%d\n",ans[i]); return 0;&#125; $Fiend$ 看到 排列,逆序对 ,考虑构造矩阵,观察其行列式. 构造一个矩阵 $A_{i,j}=[L_i\le j\le R_i]$ ,考虑它的行列式定义: $$|A|=\sum_{p\in S_n} sgn(p) \prod_{i=1}^k A_{i,p_i}$$ 对于一种排列 $p$ ,若存在 $L_i\leq p_i\le R_i$ 不成立,则 $A_{i,p_i}=0$ ,对于求和的贡献就是 $0$ . 否则,若逆序对数为偶数,贡献为 $1$ ,逆序对数为奇数,贡献为 $-1$ ,于是只需要判断 $|A|$ 的符号. 直接高斯消元是 $O(n^3)$ 的,可以获得 $70$ 分.由于构造的这个矩阵比较特殊,尝试手动消元. 每一行的 $1$ 都是一段区间,尝试在消元时保持每一行的 $1$ 仍然是一段区间.从小到大枚举 $x$ ,找出所有 $L_i=x$ 的行,找出其中 $R_k$ 最小的那一行 $k$ ,用第 $k$ 行去消其他的 $L_i=x$ 的行. 这些行被消过之后,其中的 $1$ 仍是一段区间,只是左端点变为了 $R_{k+1}$ .维护 $n$ 个集合, $i$ 号集合内存储左端点 $=i$ 的元素,每个元素记录它的行号,右端点. 从小到大枚举 $x$ ,将 $x$ 号集合的元素,除了 $R_k$ ,都放入 $R_{k+1}$ 号集合.用线段树合并实现. 考试情况:构造矩阵的时候不知道怎么就错了,于是感觉不可做,此题爆零. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;typedef pair&lt;int,int&gt; pii;#define mp make_pairstruct node&#123; int val,pos,h; int ls,rs; node(int Val=0,int Pos=0) &#123; ls=rs=h=0; val=Val; pos=Pos; &#125;&#125;Tree[MAXN&lt;&lt;2];int merge(int a,int b)&#123; if(!a || !b) return a+b; if(Tree[a].val&gt;Tree[b].val) swap(a,b); Tree[a].rs=merge(Tree[a].rs,b); if(Tree[Tree[a].ls].h&lt;Tree[Tree[a].rs].h) swap(Tree[a].ls,Tree[a].rs); Tree[a].h=Tree[Tree[a].rs].h+1; return a;&#125;int n,rt[MAXN],id[MAXN],tmp[MAXN];int Calc_Det()&#123; int prod=1; for(int i=1;i&lt;=n;++i) &#123; if(!rt[i]) return 0; node cur=Tree[rt[i]]; rt[i]=merge(Tree[rt[i]].ls,Tree[rt[i]].rs); if(rt[i] &amp;&amp; Tree[rt[i]].val==cur.val) return 0; if(id[cur.pos]!=i) &#123; prod*=-1; int x=tmp[i]; swap(tmp[id[cur.pos]],tmp[i]); swap(id[cur.pos],id[x]); &#125; if(cur.val&lt;n) rt[cur.val+1]=merge(rt[cur.val+1],rt[i]); &#125; return prod;&#125;void solve()&#123; n=read(); for(int i=1;i&lt;=n;++i) rt[i]=0; for(int i=1;i&lt;=n;++i) &#123; int L=read(),R=read(); Tree[i]=node(R,i); id[i]=tmp[i]=i; rt[L]=merge(rt[L],i); &#125; int ans=Calc_Det(); if(ans&lt;0) puts("F"); else if(ans==0) puts("D"); else puts("Y");&#125;int main()&#123; freopen("fiend.in","r",stdin); freopen("fiend.out","w",stdout); int T=read(); while(T--) solve(); return 0;&#125; $Flair$ 分成两部分做,记恰好选 $i$ 道菜的概率为 $A_i$ ,浪费掉的钱为 $B_i$ ,答案为 $\sum_{i=0}^n A_i\cdot B_i$. 答案扩大 $100^n$ 倍,所以 $A_i=p^i\cdot (100-p)^{n-i}\cdot {n\choose i}$ .考虑如何计算 $B_i$ . 若将 $c_i$ 从小到大排序,在模 $c_1$ 意义下对金额跑最短路,显然长度不会超过 $c_1$ ,而每一步的权值不超过 $c_2$ ,所以浪费金额在 $c_1\cdot c_2$ 内, $B_i$ 就会以 $c_1$ 为周期循环. 记 $len=c_1\cdot c_2,per=c_1$ .需要计算出 $A_0,A_1,\dots,A_{len-1}$ 与 $D_j=\sum_{i\ge len,i\ mod\ per=j} A_i$ . 于是答案就为 $\sum_{i=0}^{len-1} A_i\cdot B_i+\sum_{j=0}^{per-1} \lceil \frac {n-len+1-j} {per} \rceil \cdot B_j\cdot D_j$ . $D$ 就是多项式 $(px+1-p)^n$ 长度为 $c_1$ 的循环卷积结果再减去 $&lt;len$ 的部分. 使用 $NTT$ 优化这个卷积.但 $P=10^9+7$ ,所以还要用 $MTT$ .(好毒啊) 考试情况:推出了 $B_i$ 的循环性质,但没有联想到循环卷积,于是只得了 $10$ 分暴力分.]]></content>
      <tags>
        <tag>构造</tag>
        <tag>数学</tag>
        <tag>树状数组</tag>
        <tag>多项式</tag>
        <tag>test</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4407 于神之怒加强版]]></title>
    <url>%2F2019%2F07%2F14%2Fbzoj-4407-%E4%BA%8E%E7%A5%9E%E4%B9%8B%E6%80%92%E5%8A%A0%E5%BC%BA%E7%89%88%2F</url>
    <content type="text"><![CDATA[莫比乌斯反演. 假定 $n\leq m$ ,推式子. 把后面那个 $\sum_{d|x} \mu(\frac x d) \cdot d^k$ 看做关于 $x$ 的函数 $f(x)$ ,它显然是个积性函数,因为可以看成 $\mu(x)$ 与 $x^k$ 的卷积. 线性筛预处理出 $f(x)$ 的前缀和,然后整除分块计算即可. 时间复杂度 $O(n+T\cdot \sqrt n)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a+b&gt;=P?a+b-P:a+b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=5e6+10;int ism[MAXN],prime[MAXN],cnt=0,mu[MAXN],pw[MAXN];int k,sum[MAXN],f[MAXN];void init(int n)&#123; f[1]=1; for(int i=2;i&lt;=n;++i) &#123; if(!ism[i]) &#123; prime[++cnt]=i; pw[i]=fpow(i,k); f[i]=add(pw[i],P-1); &#125; for(int j=1;j&lt;=cnt &amp;&amp; 1LL*i*prime[j]&lt;=n;++j) &#123; int x=i*prime[j]; ism[x]=1; pw[x]=mul(pw[i],pw[prime[j]]); if(i%prime[j]==0) &#123; f[x]=mul(f[i],pw[prime[j]]); break; &#125; f[x]=mul(f[i],f[prime[j]]); &#125; &#125; for(int i=1;i&lt;=n;++i) sum[i]=add(sum[i-1],f[i]);&#125;int n,m;int main()&#123; int T=read(); k=read(); init(5000000); while(T--) &#123; n=read(),m=read(); if(n&gt;m) swap(n,m); int ans=0; for(int l=1,r;l&lt;=n;l=r+1) &#123; r=min(n/(n/l),m/(m/l)); int tmp=mul(n/l,m/l); tmp=mul(tmp,add(sum[r],P-sum[l-1])); ans=add(ans,tmp); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4403 序列统计]]></title>
    <url>%2F2019%2F07%2F14%2Fbzoj-4403-%E5%BA%8F%E5%88%97%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[组合计数 + $Lucas$ 定理. 把位置 $i$ 上的数加上它的下标,就变成求单调上升序列的数目了. 即,对于长度为 $i$ 的序列,权值范围变为 $[l+1,r+i]$ .方案数显然为 $r-l+i \choose i$ ,即在权值范围内任选 $i$ 个不同的数,排序后就是一个单调上升序列. 答案为 $\sum_{i=1}^n {r-l+i\choose i}={r-l+1+n\choose n}-1$ . $-1$ 是减去长度为 $0$ 的情况. $P=10^6+3$ ,且是个质数,用 $Lucas$ 定理计算组合数即可.时间复杂度 $O(P+T\cdot \log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e6+3;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int fac[P+10],invfac[P+10];void init()&#123; fac[0]=invfac[0]=1; for(int i=1;i&lt;P;++i) fac[i]=mul(fac[i-1],i); invfac[P-1]=fpow(fac[P-1],P-2); for(int i=P-2;i&gt;=1;--i) invfac[i]=mul(invfac[i+1],i+1);&#125;int C(int n,int m)&#123; if(n&lt;0 || m&lt;0 || n&gt;m) return 0; if(n&lt;P &amp;&amp; m&lt;P) return mul(fac[m],mul(invfac[n],invfac[m-n])); return mul(C(n/P,m/P),C(n%P,m%P));&#125;int main()&#123; init(); int T=read(); while(T--) &#123; int n=read(),L=read(),R=read(); int m=R-L+1; printf("%d\n",add(C(n,m+n),P-1)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>Lucas定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4402 Claris的剑]]></title>
    <url>%2F2019%2F07%2F14%2Fbzoj-4402-Claris%E7%9A%84%E5%89%91%2F</url>
    <content type="text"><![CDATA[组合计数. 求本质不同的序列数目,考虑以最小字典序表示序列,进行计数. 设序列中出现的最大值为 $m$ ,那么序列用最小字典序表示后只有下面两种情况: $1,(2,1,2,1\dots),2,(3,2,3,2\dots),3,\dots m$ . 或者 $1,(2,1,2,1\dots),2,(3,2,3,2\dots),3,\dots m,m-1$ . 若序列长度为 $n$ ,第一种情况可以看做 $\lfloor \frac {n-m} 2 \rfloor$ 个相同的球放入 $m-1$ 个盒子的方案数.盒子可以为空. 第二种情况可以看做$\lfloor \frac {n-m-1} 2 \rfloor$ 个相同的球放入 $m-1$ 个盒子的方案数.盒子可以为空. 枚举 $m$ ,由于长度是 $\le N$ 的,所以相当于那些球也可以不放.预处理阶乘及其逆元后 $O(M)$ 计算即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=2e6+10;int fac[MAXN],invfac[MAXN];int C(int n,int m)&#123; return mul(fac[m],mul(invfac[n],invfac[m-n]));&#125;int calc(int n,int m)&#123; return C(n,m+n-1);&#125;void Init_Fac(int n)&#123; fac[0]=invfac[0]=1; for(int i=1;i&lt;=n;++i) fac[i]=mul(fac[i-1],i); invfac[n]=fpow(fac[n],P-2); for(int i=n-1;i&gt;=1;--i) invfac[i]=mul(invfac[i+1],i+1);&#125;int main()&#123; int N=read(),M=read(); Init_Fac((N+M)&gt;&gt;1); int ans=1;//m=1 for(int m=2;m&lt;=N &amp;&amp; m&lt;=M;++m) &#123; ans=add(ans,calc((N-m)&gt;&gt;1,m)); if(N&gt;=m+1) ans=add(ans,calc((N-m-1)&gt;&gt;1,m)); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4419 发微博]]></title>
    <url>%2F2019%2F07%2F14%2Fbzoj-4419-%E5%8F%91%E5%BE%AE%E5%8D%9A%2F</url>
    <content type="text"><![CDATA[乱搞. 对每个人 $i$ 维护一个标记 $val_i$ ,表示这个人发过了多少条微博. 如果新连上一个点 $j$ , $ans_j-=val_i$ ,若断开一个点 $j$ , $ans_j+=val_i$ . 最后再将所有边断掉即可. 注意自己发的微博不计入自己的贡献. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,m,ans[MAXN],val[MAXN];set&lt;int&gt; s[MAXN];set&lt;int&gt;::iterator it;int main()&#123; n=read(),m=read(); while(m--) &#123; char buf[2]; scanf("%s",buf); if(buf[0]=='!') &#123; int x=read(); ++val[x]; &#125; else if(buf[0]=='+') &#123; int x=read(),y=read(); ans[x]-=val[y]; ans[y]-=val[x]; s[x].insert(y); s[y].insert(x); &#125; else &#123; int x=read(),y=read(); ans[x]+=val[y]; ans[y]+=val[x]; s[x].erase(y); s[y].erase(x); &#125; &#125; for(int i=1;i&lt;=n;++i) for(it=s[i].begin();it!=s[i].end();++it) &#123; int j=*it; s[i].erase(j); s[j].erase(i); ans[i]+=val[j]; ans[j]+=val[i]; &#125; printf("%d",ans[1]); for(int i=2;i&lt;=n;++i) printf(" %d",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1191]]></title>
    <url>%2F2019%2F07%2F13%2FCF1191%2F</url>
    <content type="text"><![CDATA[$Div.2$ 怎么出了两个博弈的题啊… A Tokitsukaze and Enhancement 模拟即可. 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int main()&#123; int x=read(); x%=4; if(x==0) puts("1 A"); else if(x==1) puts("0 A"); else if(x==2) puts("1 B"); else puts("2 A"); return 0;&#125; B Tokitsukaze and Mahjong 模拟即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;char buf[3][3];int k1(int i)&#123; return buf[i][0];&#125;int k2(int i)&#123; return buf[i][1];&#125;bool equal(int i,int j)&#123; return k1(i)==k1(j) &amp;&amp; k2(i)==k2(j);&#125;bool nx(int i,int j)&#123; return abs(k1(i)-k1(j))&lt;=2 &amp;&amp; k2(i)==k2(j);&#125;int main()&#123; for(int i=1;i&lt;=3;++i) scanf("%s",buf[i]); if(k1(1)==k1(2) &amp;&amp; k1(1)==k1(3) &amp;&amp; k2(1)==k2(2) &amp;&amp; k2(2)==k2(3)) &#123; puts("0"); return 0; &#125; if(k2(1)==k2(2) &amp;&amp; k2(1)==k2(3)) &#123; int a[3]; a[0]=k1(1),a[1]=k1(2),a[2]=k1(3); sort(a,a+3); if(a[1]-a[0]==1 &amp;&amp; a[2]-a[1]==1) &#123; puts("0"); return 0; &#125; &#125; if(equal(1,2) || equal(1,3) || equal(2,3)) puts("1"); else if(nx(1,2) || nx(1,3) || nx(2,3)) puts("1"); else puts("2"); return 0;&#125; C Tokitsukaze and Discard Items 模拟删数的过程,二分找出此次删掉的最后一个数. 每次至少删掉一个数,时间复杂度 $O(m\cdot \log m)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;ll p[MAXN];int x=1,m;int bs(ll lim,int tot)&#123; int L=x,R=m; int ans=x; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(p[mid]-tot&lt;=lim) ans=mid,L=mid+1; else R=mid-1; &#125; return ans;&#125;int main()&#123; ll n=read(); m=read(); ll k=read(); for(int i=1;i&lt;=m;++i) p[i]=read()-1; int tot=0,ans=0; while(tot!=m) &#123; ll pos=(p[x]-tot)/k; ll y=bs(pos*k+k-1,tot); ans++; tot+=y-x+1; x=y+1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D Tokitsukaze, CSL and Stone Game 感觉思路已经非常接近正解了,但有个情况没判到. 除了先手第一次拿后就必败,最后一定是石子数形成 $0,1,2,\dots n-1$ 的排列. 记初始时石子数为 $x$ 的有 $cnt_x$ 堆,特判一下先手第一次拿后就必败的情况: 若第一次取后未败,则只需判断使局面形成 $0,1,2,\dots n-1$ 的排列需要取的石头的奇偶性. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,a[MAXN],p[MAXN];unordered_map&lt;int,int&gt; cnt;bool check()&#123; if(cnt[0]==n) return true; if(cnt[0]&gt;=2) return true; int k=0; sort(p+1,p+1+n); int m=unique(p+1,p+1+n)-p-1; for(int i=1;i&lt;=m;++i) &#123; int x=p[i]; if(cnt[x]&gt;=3) return true; if(cnt[x]==2 &amp;&amp; cnt[x-1]&gt;=1) return true; if(cnt[x]==2) ++k; &#125; if(k&gt;=2) return true; return false;&#125;int main()&#123; n=read(); int s=0; for(int i=1;i&lt;=n;++i) &#123; p[i]=a[i]=read(); ++cnt[p[i]]; &#125; if(check()) return puts("cslnb")&amp;0; sort(a+1,a+1+n); for(int i=1;i&lt;=n;++i) s^=(a[i]-i+1)&amp;1; if(s) puts("sjfnb"); else puts("cslnb"); return 0;&#125; E Tokitsukaze and Duel 给一段 $0/1$ 序列,双方轮流操作,每次操作将一段长度为 $k$ 的区间全部变成一个值,操作后使得整个序列全是 $0$ 或全是 $1$ 的人获胜.可能出现无限操作下去的情况,判为平局. 注意到一个人若第一次操作无法直接取胜,那么他永远也无法取胜,因为对方总是可以通过执行相反的操作. 于是先判断一下先手能否一次操作取胜,再判断一下是否先手第一次无论怎样操作,后手总能一次操作取胜. 若两者都不能取胜,则为平局. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,k,a[MAXN],sum[MAXN];int pre[MAXN][2],nxt[MAXN][2];char s[MAXN];bool first_win(int p)&#123; int l=p,r=p+k-1; if(sum[l-1]+sum[n]-sum[r]+k==n) return true; if(sum[l-1]+sum[n]-sum[r]==0) return true; return false;&#125;int find_first(int L,int R,int x)&#123; int s=nxt[L][x]; if(s==0 || s&gt;R) return 0; return s;&#125;int find_last(int L,int R,int x)&#123; int s=pre[R][x]; if(s==0 || s&lt;L) return 0; return s; &#125;bool second_win(int p,int x)&#123; int l=p,r=p+k-1; int L,R; L=find_first(1,l-1,x); if(!L) L=find_first(r+1,n,x); R=find_last(r+1,n,x); if(!R) R=find_last(1,l-1,x); assert(L &amp;&amp; R); return R-L+1&lt;=k;&#125;bool Second_win(int p)&#123; return second_win(p,0) &amp;&amp; second_win(p,1);&#125;int main()&#123; n=read(),k=read(); scanf("%s",s+1); for(int i=1;i&lt;=n;++i) &#123; a[i]=s[i]-'0'; sum[i]=sum[i-1]+a[i]; &#125; for(int i=1;i&lt;=n;++i) &#123; pre[i][0]=(a[i]==0)?i:pre[i-1][0]; pre[i][1]=(a[i]==1)?i:pre[i-1][1]; &#125; for(int i=n;i&gt;=1;--i) &#123; nxt[i][0]=(a[i]==0)?i:nxt[i+1][0]; nxt[i][1]=(a[i]==1)?i:nxt[i+1][1]; &#125; bool f=true; for(int i=1;i+k-1&lt;=n;++i) &#123; if(first_win(i)) &#123; puts("tokitsukaze"); return 0; &#125; if(f &amp;&amp; !Second_win(i)) f=false; &#125; if(f) puts("quailty"); else puts("once again"); return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
        <tag>博弈论</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4598 模式字符串]]></title>
    <url>%2F2019%2F07%2F12%2Fbzoj-4598-%E6%A8%A1%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[点分治 + $hash$ . 考虑点分治.由于分治时路径起点不确定,无法直接匹配,所以需要 $hash$ 暂时存储状态. 若当前分治中心为 $rt$ ,维护 $pre(i),suf(i)$ 分别表示节点 $i$ 到 $rt$ 的路径, $rt$ 到 $i$ 的路径的 $hash$ 值. 到一个点,先算得它的 $pre$ ,在后面接上 $rt$ 的字符,判断这个串在循环意义下是否与模式串的某个前缀匹配. 可以反着推,假设它能与某个前缀循环匹配,那么根据这个串的长度,可以算出它应该是模式串重复了 $\lfloor len/m \rfloor$ 次,再接上一个长度为 $len\mod m$ 的前缀形成的.判一下 $pre$ 是否与理论上求得的 $hash$ 值相等即可. 若在循环意义下匹配上了长度为 $i$ 的前缀,它的贡献就是当前能与长度 $m-i$ 的后缀循环匹配的 $suf$ 数目. 再算这个点 $suf$ 的贡献,与上面的方法类似.维护一个反串的 $hash$ 会十分方便. 常数大的一批,写法是对的,但时限卡不进去. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=1e5+10;int n,m;char buf[MAXN];int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;typedef unsigned long long ull;const ull Base=37;ull pw[MAXN],Hash[MAXN],revHash[MAXN];ull val[MAXN],pre[MAXN],suf[MAXN];ull Pattern_Power[MAXN],revPattern_Power[MAXN];ull Add_Char(ull hash,int c)&#123; return hash*Base+c;&#125;void Init_Hash()&#123; Hash[0]=0; for(int i=1;i&lt;=m;++i) Hash[i]=Hash[i-1]*Base+(buf[i]-'A'); revHash[0]=0; for(int i=1;i&lt;=m;++i) revHash[i]=revHash[i-1]*Base+(buf[m-i+1]-'A'); Pattern_Power[0]=0; for(int i=1;i*m&lt;=n;++i) Pattern_Power[i]=Pattern_Power[i-1]*pw[m]+Hash[m]; revPattern_Power[0]=0; for(int i=1;i*m&lt;=n;++i) revPattern_Power[i]=revPattern_Power[i-1]*pw[m]+revHash[m];&#125;int rt,totsize,mi,siz[MAXN],vis[MAXN];ll ans;void Findrt(int u,int fa)&#123; siz[u]=1; int mxsiz=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa || vis[v]) continue; Findrt(v,u); siz[u]+=siz[v]; if(siz[v]&gt;mxsiz) mxsiz=v; &#125; mxsiz=max(mxsiz,totsize-siz[u]); if(mxsiz&lt;mi) mi=mxsiz,rt=u;&#125;int sumpre[MAXN],sumsuf[MAXN];int stk1[MAXN],stk2[MAXN],tp=0;int lstpre[MAXN],lstsuf[MAXN],cnt=0;int Match_pre(ull hash,int len)&#123; int x=len/m,y=len%m; ull exphash=Pattern_Power[x]*pw[y]+Hash[y]; if(exphash==hash) return y; else return m;&#125;int Match_suf(ull hash,int len)&#123; int x=len/m,y=len%m; ull exphash=revPattern_Power[x]*pw[y]+revHash[y]; if(exphash==hash) return y; else return m;&#125;int prelen,suflen;ull preval,sufval;void dfs(int u,int fa,int len,int Rt)&#123; pre[u]=val[u]*pw[len-1]+pre[fa]; suf[u]=val[u]*pw[len-1]+suf[fa]; prelen=Match_pre(pre[u],len); suflen=Match_suf(suf[u],len); if(prelen!=m || suflen!=m) &#123; ++cnt; lstpre[cnt]=prelen; lstsuf[cnt]=suflen; &#125; preval=Add_Char(pre[u],val[Rt]); prelen=Match_pre(preval,len+1); sufval=Add_Char(suf[u],val[Rt]); suflen=Match_suf(sufval,len+1); if(prelen!=m) ans+=sumsuf[(m-prelen)%m]; if(suflen!=m) ans+=sumpre[(m-suflen)%m]; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v] || v==fa) continue; dfs(v,u,len+1,Rt); &#125;&#125;void solve(int u)&#123; vis[u]=1; if(siz[u]&lt;m) return; for(int i=1;i&lt;=tp;++i) &#123; sumpre[stk1[i]]=0; sumsuf[stk2[i]]=0; &#125; pre[u]=suf[u]=0; ++sumpre[0],++sumsuf[0]; tp=1; stk1[tp]=0; stk2[tp]=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v]) continue; dfs(v,u,1,u); while(cnt) &#123; ++tp; stk1[tp]=lstpre[cnt]; stk2[tp]=lstsuf[cnt]; ++sumpre[lstpre[cnt]]; ++sumsuf[lstsuf[cnt]]; --cnt; &#125; &#125;&#125;void Divide(int u)&#123; solve(u); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v]) continue; mi=inf,totsize=siz[v]; Findrt(v,0); Divide(rt); &#125;&#125;void Reset()&#123; memset(head,0,sizeof head); ecnt=0; memset(vis,0,sizeof vis); ans=0;&#125;int main()&#123; pw[0]=1; for(int i=1;i&lt;=100000;++i) pw[i]=pw[i-1]*Base; int T=read(); while(T--) &#123; Reset(); n=read(),m=read(); scanf("%s",buf+1); for(int i=1;i&lt;=n;++i) val[i]=buf[i]-'A'; for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; scanf("%s",buf+1); Init_Hash(); mi=inf,totsize=n; Findrt(1,0); Divide(rt); printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>hash</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4893 聚变反应炉]]></title>
    <url>%2F2019%2F07%2F12%2Fbzoj-4893-%E8%81%9A%E5%8F%98%E5%8F%8D%E5%BA%94%E7%82%89%2F</url>
    <content type="text"><![CDATA[贪心 + 树形背包. 本以为此题必有高论,但发现只有 $n-1$ 条边,是个树.那很显然就是一个树形背包了. 前 $50$ 分 $n$ 比较大,但 $c_i\in \lbrace 0,1 \rbrace$ ,可以贪心.显然先将所有 $c=1$ 的点激发,再激发 $c=0$ 的点最优, 对于后面的 $50$ 分, $n\leq 2000$ ,树形背包解决. 设 $f(u,x)$ 表示将子树 $u$ 内的点全部激发,并且节点 $u$ 初始需要 $x$ 点能量激发. $dfs$ 到节点 $u$ 时,枚举它的所有儿子 $v$ ,递归下去计算出所有 $v$ 的 $f$ 值. 先选一些儿子出来(选 $0$ 个也可),将它们的子树激发,再激发 $u$ ,再激发剩余的子树.那么一个儿子 $v$ 被选,造成的贡献是 $f(v,d_v)$ ,没被选,造成的贡献是 $f(v,\max(d_v-c_u,0))$ , $u$ 的贡献是 $x$ 减去选了的 $c_v$ ,与 $0$ 取 $\max$ . 设 $g(i,j)$ 表示考虑了前 $i$ 个儿子,选了的儿子 $c_v$ 总和是 $j$ 时,前 $i$ 个儿子造成的最小贡献. 对于第 $i$ 个儿子 $v$ ,若选它,有转移 $g(i,j+c_v)\leftarrow g(i-1,j)+f(v,d_v)$ . 若不选它,有转移 $g(i,j)\leftarrow g(i-1,j)+f(v,\max(d_v-c_u,0))$ . 若 $u$ 有 $k$ 个儿子,那么 $f(u,x)=\min \lbrace g(k,j)+\max(x-j,0)\rbrace$ . 注意到 $f$ 的第二维 $x$ 对于确定的 $u$ ,其实只有 $2$ 种取值 $\lbrace d_u,\max(d_u-c_{fa},0)\rbrace$ ,分别用 $0,1$ 代替即可. 时间复杂度 $O(n\cdot \sum c_i)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;void upd(int &amp;x,int y)&#123; x=min(x,y);&#125;const int inf=1e9;const int MAXN=1e5+10,MAXS=1e4+10;int n,c[MAXN],d[MAXN],fa[MAXN];int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];int sumc[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int f[2019][2],g[2019][MAXS];int calc(int u,int x)&#123; if(!x) return d[u]; if(x==1) return max(0,d[u]-c[fa[u]]);&#125;void solve(int u,int id,int k)&#123; int x=calc(u,id); if(!k) &#123; f[u][id]=x; return; &#125; int i=0; for(int I=head[u];I;I=nx[I]) &#123; int v=to[I]; if(v==fa[u]) continue; ++i; for(int j=0;j&lt;=sumc[u];++j) &#123; if(j+c[v]&lt;=sumc[u]) upd(g[i][j+c[v]],g[i-1][j]+f[v][0]); upd(g[i][j],g[i-1][j]+f[v][1]); &#125; &#125; f[u][id]=inf; for(int j=0;j&lt;=sumc[u];++j) f[u][id]=min(f[u][id],g[k][j]+max(x-j,0)); for(int i=1;i&lt;=k;++i) for(int j=0;j&lt;=sumc[u];++j) g[i][j]=inf;&#125;void dfs(int u,int Fa)&#123; fa[u]=Fa; int k=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==Fa) continue; sumc[u]+=c[v]; dfs(v,u); ++k; &#125; solve(u,0,k); solve(u,1,k);&#125;int solve_greedy()&#123; int greedy_ans=0; for(int u=1;u&lt;=n;++u) if(c[u]) &#123; greedy_ans+=max(d[u],0); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; d[v]-=c[u]; &#125; &#125; for(int u=1;u&lt;=n;++u) if(!c[u]) greedy_ans+=max(d[u],0); cout&lt;&lt;greedy_ans&lt;&lt;endl; return 0;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) d[i]=read(); for(int i=1;i&lt;=n;++i) c[i]=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; if(n&gt;2000) return solve_greedy(); for(int i=0;i&lt;=n;++i) for(int j=0;j&lt;=10000;++j) g[i][j]=inf; g[0][0]=0; dfs(1,0); cout&lt;&lt;f[1][0]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>树形dp</tag>
        <tag>贪心</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4592 脑洞治疗仪]]></title>
    <url>%2F2019%2F07%2F12%2Fbzoj-4592-%E8%84%91%E6%B4%9E%E6%B2%BB%E7%96%97%E4%BB%AA%2F</url>
    <content type="text"><![CDATA[线段树. 需要维护一段区间的区间和,最长包含左端点的全 $0$ 区间长度,最长的包含右端点的全 $0$ 区间长度,最长全 $0$ 区间长度,以及支持区间赋值. 用线段树维护.操作 $1,3$ 都比较简单,操作 $2$ ,先查询 $[L_0,R_0]$ 中 $1$ 的数目,再将这段覆盖成 $0$ . 接下来用线段树把 $[L_1,R_1]$ 拆成 $\log$ 个线段树上的区间,遍历一次,找到能填补的最后一个区间. 再在那个区间内二分能填到的最后一个位置.方法类似于找第 $k$ 大.这样就只有一只 $\log$ 了. 时间复杂度 $O(n \cdot \log n)$ . 另外一个做法是使用珂朵莉树,但使用前提是数据随机,或者,区间赋值操作的数目与随机时的数目相近. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,m;struct SegTree&#123; struct node &#123; int sum,tag,Len; int lenl,lenr,len; &#125;Tree[MAXN&lt;&lt;2]; friend node operator + (node lson,node rson) &#123; node root; root.Len=lson.Len+rson.Len; root.sum=lson.sum+rson.sum; if(lson.lenl==lson.Len) root.lenl=lson.lenl+rson.lenl; else root.lenl=lson.lenl; if(rson.lenr==rson.Len) root.lenr=rson.lenr+lson.lenr; else root.lenr=rson.lenr; root.len=max(lson.len,rson.len); root.len=max(root.len,lson.lenr+rson.lenl); root.len=max(root.len,root.lenl); root.len=max(root.len,root.lenr); return root; &#125;#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; int t=root.tag; root=lson+rson; root.tag=t; &#125; void BuildTree(int o,int l,int r) &#123; root.sum=root.Len=r-l+1; root.tag=-1; root.lenl=root.lenr=root.len=0; if(l==r) return; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); &#125; void Modifiy(int o,int c) &#123; root.tag=c; root.sum=root.Len*c; root.lenl=root.lenr=root.len=c?0:root.Len; &#125; void pushdown(int o) &#123; if(root.tag!=-1) &#123; Modifiy(o&lt;&lt;1,root.tag); Modifiy(o&lt;&lt;1|1,root.tag); root.tag=-1; &#125; &#125; void upd(int o,int l,int r,int L,int R,int c) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; Modifiy(o,c); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125; int query_sum(int o,int l,int r,int L,int R) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; int mid=(l+r)&gt;&gt;1; pushdown(o); int res=0; if(L&lt;=mid) res+=query_sum(o&lt;&lt;1,l,mid,L,R); if(R&gt;mid) res+=query_sum(o&lt;&lt;1|1,mid+1,r,L,R); return res; &#125; int tmp[50],tot,LL[50],RR[50]; void Split(int o,int l,int r,int L,int R) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; tmp[++tot]=o; LL[tot]=l; RR[tot]=r; return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) Split(o&lt;&lt;1,l,mid,L,R); if(R&gt;mid) Split(o&lt;&lt;1|1,mid+1,r,L,R); &#125; int Binary_Search(int o,int l,int r,int x) &#123; int mid=(l+r)&gt;&gt;1; if(l!=r) pushdown(o); if(root.Len-root.sum==x) return r; if(lson.Len-lson.sum&lt;x) return Binary_Search(o&lt;&lt;1|1,mid+1,r,x-lson.Len+lson.sum); else return Binary_Search(o&lt;&lt;1,l,mid,x); &#125; int Search(int L,int R,int brain) &#123; tot=0; Split(1,1,n,L,R); int zero=0,mxrt=-1,x; for(int i=1;i&lt;=tot &amp;&amp; mxrt==-1;++i) &#123; zero+=Tree[tmp[i]].Len-Tree[tmp[i]].sum; if(zero&gt;=brain) &#123; mxrt=i; x=brain-(zero-Tree[tmp[i]].Len+Tree[tmp[i]].sum); &#125; &#125; return Binary_Search(tmp[mxrt],LL[mxrt],RR[mxrt],x); &#125; node query_len(int o,int l,int r,int L,int R) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) return root; int mid=(l+r)&gt;&gt;1; pushdown(o); if(R&lt;=mid) return query_len(o&lt;&lt;1,l,mid,L,R); if(L&gt;mid) return query_len(o&lt;&lt;1|1,mid+1,r,L,R); if(L&lt;=mid &amp;&amp; R&gt;mid) return query_len(o&lt;&lt;1,l,mid,L,R)+query_len(o&lt;&lt;1|1,mid+1,r,L,R); &#125; int solve(int L,int R) &#123; node tmp=query_len(1,1,n,L,R); return tmp.len; &#125;&#125;T;int main()&#123; n=read(),m=read(); T.BuildTree(1,1,n); while(m--) &#123; int tp=read(); if(tp==0) &#123; int L=read(),R=read(); T.upd(1,1,n,L,R,0); &#125; else if(tp==1) &#123; int L0=read(),R0=read(); int L1=read(),R1=read(); int tot1=T.query_sum(1,1,n,L0,R0); if(!tot1) continue; T.upd(1,1,n,L0,R0,0); int tot2=T.query_sum(1,1,n,L1,R1); if(tot1+tot2&gt;=R1-L1+1) T.upd(1,1,n,L1,R1,1); else &#123; int pos=T.Search(L1,R1,tot1); T.upd(1,1,n,L1,pos,1); &#125; &#125; else &#123; int L=read(),R=read(); printf("%d\n",T.solve(L,R)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4562 食物链]]></title>
    <url>%2F2019%2F07%2F11%2Fbzoj-4562-%E9%A3%9F%E7%89%A9%E9%93%BE%2F</url>
    <content type="text"><![CDATA[记忆化搜索. 题面写得非常烂 .作为一道省选题,没有对 食物链 下任何规范的定义,就让求数目,甚至限制也只说 输入数据符合生物学特点. 讲道理,出题人是要出来谢罪的. 结合样例强行理解,可以给出抽象的题目描述. 给定一张 $DAG$ ,求满足以下条件的路径数目:路径的起点终点不同,且起点的入度为 $0$ ,终点的出度为 $0$ . 记忆化搜索一下,记 $f(i)$ 表示从 $i$ 出发到出度为 $0$ 的点的路径条数.答案为所有入度为 $0$ 的点的 $f$ 之和. 注意特判除掉入度出度均为 $0$ 的点. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,m,indeg[MAXN],outdeg[MAXN];int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt; ++outdeg[u]; ++indeg[v];&#125;int f[MAXN];int dp(int u)&#123; if(f[u]!=-1) return f[u]; if(outdeg[u]==0) return f[u]=1; int &amp;res=f[u]; res=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; res+=dp(v); &#125; return res;&#125;int main()&#123; memset(f,-1,sizeof f); n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); addedge(u,v); &#125; int ans=0; for(int i=1;i&lt;=n;++i) if(!indeg[i] &amp;&amp; outdeg[i]) ans+=dp(i); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>DAG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1189]]></title>
    <url>%2F2019%2F07%2F11%2FCF1189%2F</url>
    <content type="text"><![CDATA[$Div.2$ A Keanu Reeves 显然只需要判断不分割是否可行,若不可行,就把第一个字符分出去,分成两段就好了. 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=128;char s[MAXN];int main()&#123; int n=read(); scanf("%s",s+1); int t[2]=&#123;0,0&#125;; for(int i=1;i&lt;=n;++i) ++t[s[i]-'0']; if(t[0]!=t[1]) &#123; puts("1"); printf("%s\n",s+1); &#125; else &#123; puts("2"); putchar(s[1]); putchar(' '); for(int i=2;i&lt;=n;++i) putchar(s[i]); puts(""); &#125; return 0;&#125; B Number CirCle 假的一批,这个题被罚了 $3$ 次. 构造方法是先将元素排序,先将最大的放在任意一个位置 $x$ ,然后次大的放在 $x+1$ ,第三大放在 $x-1$ ,第四大放在 $x+1\dots$ 然后检验是否合法,若这样放置不合法,则其他所有放置也不可能合法. 为什么?因为题面中的图和样例就是这样做的.大概是因为一个比较大的数,它旁边的数尽量也安排成比较大的数,这样对于双方都最优. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,a[MAXN];int b[MAXN];bool check()&#123; if(b[1]&gt;=b[n]+b[2]) return false; if(b[n]&gt;=b[1]+b[n-1]) return false; for(int i=2;i&lt;n;++i) if(b[i]&gt;=b[i-1]+b[i+1]) return false; return true;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); sort(a+1,a+1+n); int x=(n+1)/2; b[x]=a[n]; int tot=n-1; for(int i=1;tot;++i) &#123; b[x+i]=a[tot--]; if(tot) b[x-i]=a[tot--]; &#125; if(check()) &#123; puts("YES"); for(int i=1;i&lt;=n;++i) printf("%d ",b[i]); &#125; else puts("NO"); return 0;&#125; C Candies! 仔细思考一下,不难发现答案就是 $\lfloor \frac {sum(l,r)} {10}\rfloor$ . 因为这个答案就是进位的次数,与运算顺序无关,直接将它们加起来 $/10$ ,得到的就是进位次数. 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int a[MAXN];int main()&#123; int n=read(); for(int i=1;i&lt;=n;++i) a[i]=a[i-1]+read(); int q=read(); while(q--) &#123; int l=read(),r=read(); int ans=a[r]-a[l-1]; ans/=10; printf("%d\n",ans); &#125; return 0;&#125; D1 Add on a Tree 容易发现,当且仅当存在两条边,它们只能同时加减同一个数时,就无法得到它们的权值不同的情况. 若存在这样两条边,则一定存在两条这样相邻的边,要让它们满足条件,它们的公共点度数一定为 $2$ ,即不存在其他的边. 于是判一下是否存在度数为 $2$ 的点即可. 代码就是 $D2$ 的一小部分,就不贴了. D2 Add on a Tree: Revolution 好题. 判断合法性和 $D1$ 一样,判是否有度数为 $2$ 的点.若合法,要将每条边的权值都改为要求的权值.特判 $n=2$ . 考虑如何给一条路径 $(u,L_0)$ 上的所有边加上一个权值 $x$ ,其中 $L_0$ 为叶子节点.先选择一个非叶子节点作为根. $u$ 的度数至少为 $3$ ,故一定可以找到另外两个叶子节点 $L_1,L_2$ ,并且这 $3$ 个叶子节点在 $u$ 的 $3$ 个不同子树内. 因为边权都是偶数( $pairwise$ ),所以我们要加的 $x$ 也都选择偶数.于是执行 $(L_0,L_1,\frac x 2),(L_0,L_2,\frac x 2),(L_1,L_2,-\frac x 2)$ 这三个操作,路径 $(u,L_0)$ 上所有边权值就 $+x$ 了. 再来解决原问题,对每条边,维护当前边上的权值与要求的权值还差 $\Delta$ ,然后从根节点开始 $dfs$ ,遍历到 $u$ 时,对它的每个儿子节点 $v$ ,选出子树 $v$ 内任一个叶子节点 $L_0$ ,用上面的操作给路径 $(u,L_0)$ 上的边加上 $\Delta_{u,v}$ 即可. $n\le 1000$ ,可以暴力找/修改,不用写数据结构.时间复杂度 $O(n^2)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e3+10;int head[MAXN],ecnt=0,to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN&lt;&lt;1];int n,m=0;struct opt&#123; int u,v; ll x; opt(int u=0,int v=0,ll x=0):u(u),v(v),x(x) &#123;&#125;&#125;;queue&lt;opt&gt; Q;void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;int deg[MAXN],dfn[MAXN],siz[MAXN],idx=0;int fa[MAXN];ll Delta[MAXN];//Edge(i,fa_i)bool In_SubTree(int v,int x)&#123; return dfn[v]&lt;=dfn[x] &amp;&amp; dfn[x]&lt;=dfn[v]+siz[v]-1;&#125;void Init(int u,int Fa)&#123; dfn[u]=++idx; siz[u]=1; fa[u]=Fa; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==Fa) continue; Delta[v]=val[i]; Init(v,u); siz[u]+=siz[v]; &#125;&#125;int rt;void Assign(int u,int v0,int L0,ll x)&#123; int L1=0,L2=0; if(u!=rt) &#123; for(int i=1;i&lt;=n;++i) &#123; if(deg[i]==1 &amp;&amp; !In_SubTree(v0,i)) &#123; if(!L1 &amp;&amp; In_SubTree(u,i)) L1=i; if(!L2 &amp;&amp; !In_SubTree(u,i)) L2=i; if(L1 &amp;&amp; L2) break; &#125; &#125; &#125; else &#123; int v1=0,v2; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==v0 || v==v1) continue; if(!v1) v1=v; else v2=v; &#125; for(int i=1;i&lt;=n;++i) if(deg[i]==1 &amp;&amp; In_SubTree(v1,i)) L1=i; else if(deg[i]==1 &amp;&amp; In_SubTree(v2,i)) L2=i; &#125; m+=3; Q.push(opt(L0,L1,x/2)); Q.push(opt(L0,L2,x/2)); Q.push(opt(L1,L2,-x/2)); while(L0!=u) &#123; Delta[L0]-=x; L0=fa[L0]; &#125;&#125;void dfs(int u)&#123; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa[u]) continue; int L0=0; for(int j=1;j&lt;=n &amp;&amp; !L0;++j) if(deg[j]==1 &amp;&amp; In_SubTree(v,j)) L0=j; Assign(u,v,L0,Delta[v]); dfs(v); &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); ++deg[u],++deg[v]; &#125; if(n==2) &#123; puts("YES"); puts("1"); printf("1 2 %d\n",val[1]); return 0; &#125; for(int i=1;i&lt;=n;++i) if(deg[i]==2) &#123; puts("NO"); return 0; &#125; puts("YES"); rt=0; for(int i=1;i&lt;=n &amp;&amp; !rt;++i) if(deg[i]&gt;1) rt=i; Init(rt,0); dfs(rt); cout&lt;&lt;m&lt;&lt;endl; opt tmp; while(!Q.empty()) &#123; tmp=Q.front(); Q.pop(); printf("%d %d %I64d\n",tmp.u,tmp.v,tmp.x); &#125; return 0;&#125; E Count Pairs 这个题比 $D2$ 简单许多.对于原方程,因为 $a_i\not= a_j$ ,两边乘上 $(a_i-a_j)$ ,可得$$a_i^4 - a_j^4 \equiv k(a_i-a_j)$$ 可以 $O(n) $枚举 $j$ ,计算有多少个 $i$ 满足方程.于是 $a_j$ 此时为常数,整理一下,得到$$a_i^4-k\cdot a_i \equiv a_j^4-k\cdot a_j$$ $k$ 是不变的,所以用一个 $map$ 对于每个 $x\in [0,P)$ 记录 $a_i^4-k\cdot a_i\equiv x$ 的 $i$ 有多少个就好了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int P;int add(int a,int b)&#123; return (a + b) % P;&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int pw4(int x)&#123; x=mul(x,x); x=mul(x,x); return x;&#125;const int MAXN=3e5+10;unordered_map&lt;int,int&gt; cnt;int n,a[MAXN];int main()&#123; n=read(),P=read(); int k=read(); ll ans=0; for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); int x=pw4(a[i]); x=add(x,mul(P-k,a[i])); if(cnt.find(x)!=cnt.end()) ans+=cnt[x]; ++cnt[x]; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; F Array Beauty 元素的顺序是不影响答案的,所以可以先将所有元素从小到大排序.记最大的元素为 $m$ . $Beauty$ 值最大为 $m$ ,记 $Beauty$ 值 $\ge x$ 的子序列有 $p_x$ 个,那么答案为 $\sum_{x=1}^m p_x$ ,因为若一个子序列的 $Beauty$ 值为 $s$ ,它就会在求和中贡献 $s$ 次. 枚举 $x$ 的值,用 $dp$ 求解 $p_x$ .设 $f(i,j)$ 表示以第 $i$ 个数结尾,长度为 $j$ 的,且美丽值 $\ge x$ 的子序列数目. 转移有 $f(i,j)=\sum f(d,j-1),d&lt;i,a_j-a_d\ge x$ .由于 $a$ 已经排过序,所以合法的 $d$ 一定是一段前缀,可以用 $two\ pointer$ 维护,并记录 $f$ 的前缀和.这样, $p_x=\sum f(i,k)$ ,求一个 $p_x$ 的时间复杂度为 $O(n\cdot k)$ . 注意到 $x$ 只需要枚举到 $\lfloor \frac m {k-1}\rfloor$ ,若 $x$ 大于这个值,子序列首尾元素差值就会 $&gt; m$ ,不可能出现. 所以整个问题的时间复杂度为 $O(m \cdot n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;const int MAXN=1e3+10;int n,k;int f[MAXN][MAXN],sum[MAXN][MAXN],a[MAXN];int solve(int x)&#123; for(int i=1;i&lt;=n;++i) f[i][1]=1,sum[i][1]=i; for(int j=2;j&lt;=k;++j) &#123; sum[0][j]=0; int r=1; for(int i=1;i&lt;=n;++i) &#123; while(a[r]&lt;=a[i]-x) ++r; f[i][j]=sum[r-1][j-1]; sum[i][j]=add(sum[i-1][j],f[i][j]); &#125; &#125; return sum[n][k];&#125;int main()&#123; n=read(),k=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); sort(a+1,a+1+n); int m=a[n]; int ans=0; for(int x=1;x&lt;=m/(k-1);++x) ans=add(ans,solve(x)); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>数学</tag>
        <tag>codeforces</tag>
        <tag>two pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4561 圆的异或并]]></title>
    <url>%2F2019%2F07%2F11%2Fbzoj-4561-%E5%9C%86%E7%9A%84%E5%BC%82%E6%88%96%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[扫描线 + $set$ . 把圆看做上下两段半圆弧,因为位置关系只有包含和相离,所以无论 $x$ 取什么值,各个圆弧上下相对顺序是不变的.所以可以将它们全都丢进 $set$ 里面,方便接下来查询. 做一个扫描线,左边插入,右边删除.对于每个圆弧,插入的时候询问它的 $upper_bound$ . 若找到的是上圆弧,说明它就是当前圆外面的第一个圆. 若找到的是下圆弧,说明当前圆外面的第一个圆就是那个下圆弧外面的第一个圆. 可能出现找不到的情况,需要特判. 发现自己好像是第一次写扫描线… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;inline double sq(double x)&#123; return x*x;&#125;const int MAXN=2e5+10;int n;double x[MAXN],y[MAXN],r[MAXN],pos;int Sgn[MAXN];struct LR_Arc&#123; int id,sgn; LR_Arc(int id=0,int sgn=0):id(id),sgn(sgn) &#123;&#125; bool operator &lt; (const LR_Arc &amp;rhs) const &#123; return x[id]+sgn*r[id]&lt;x[rhs.id]+rhs.sgn*r[rhs.id]; &#125;&#125;q[MAXN&lt;&lt;1];struct UD_Arc&#123; int id,sgn;//1-up -1-down UD_Arc(int id=0,int sgn=0):id(id),sgn(sgn) &#123;&#125; bool operator &lt; (const UD_Arc &amp;rhs) const &#123; int i=id,j=rhs.id; double y1=y[i]+sgn*(sqrt(sq(r[i])-sq(x[i]-pos))); double y2=y[j]+rhs.sgn*(sqrt(sq(r[j])-sq(x[j]-pos))); return y1==y2?sgn&lt;rhs.sgn:y1&lt;y2; &#125;&#125;;set&lt;UD_Arc&gt; S;set&lt;UD_Arc&gt;::iterator it;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; x[i]=(double)(read()); y[i]=(double)(read()); r[i]=(double)(read()); q[i*2-1]=LR_Arc(i,-1); q[i*2]=LR_Arc(i,1); &#125; sort(q+1,q+1+2*n); for(int i=1;i&lt;=2*n;++i) &#123; pos=x[q[i].id]+q[i].sgn*r[q[i].id]; if(q[i].sgn==-1) &#123; it=S.upper_bound(UD_Arc(q[i].id,1)); if(it!=S.end()) &#123; UD_Arc tmp=*it; if(tmp.sgn==-1) Sgn[q[i].id]=Sgn[tmp.id]; else Sgn[q[i].id]=-Sgn[tmp.id]; &#125; else Sgn[q[i].id]=1; S.insert(UD_Arc(q[i].id,1)); S.insert(UD_Arc(q[i].id,-1)); &#125; else &#123; S.erase(UD_Arc(q[i].id,1)); S.erase(UD_Arc(q[i].id,-1)); &#125; &#125; double ans=0; for(int i=1;i&lt;=n;++i) ans+=sq(r[i])*Sgn[i]; cout&lt;&lt;(ll)(ans)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4560 字符串覆盖]]></title>
    <url>%2F2019%2F07%2F11%2Fbzoj-4560-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[字符串 $hash$ + 贪心 + $dp$ . 首先可以字符串 $hash$ 预处理出 $N$ 个串各自可以放的位置 (用开头的位置表示) ,以及 $L_{i,j} ,R_{i,j}$ 分别表示从位置 $j$ 往左/右边找,能找到的第一个可以放第 $i$ 个串的位置(不包含 $j$ ). 求最大值,可以贪心.首先枚举这 $N$ 个串放置的 $N!$ 种顺序,依次选择位置.分两种情况,记上个串结束位置为 $p$ ,若与上个串相交,则放在 $L_{i,p}$ 最优,若与上个串不相交,则放在 $R_{i,p}$ 最优.这个决策也可以大力枚举.这一步的时间复杂度 $O(N!\cdot 2^N)$ 求最小值,不相交时贪心放在 $R_{i,p}$ 不一定最优,考虑 $dp$ . 仍然枚举 $N!$ 种放置顺序,设 $f(i,j)$ 表示考虑了前 $j$ 个位置,下一个放置的应该是第 $i$ 个串. 若不放第 $i$ 个串,则转移到 $f(i,j+1)$ . 若放第 $i$ 个串,若它与上一个串不相交,转移到 $f(i+1,j+Len(i))$ .否则放在匹配 $j$ 后能放的第一个位置. 这一步时间复杂度 $O(N!\cdot N\cdot Len(A))$ ,也是总的时间复杂度. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e4+10;const ull Base=37;int n,N,len[5];ull Hash[MAXN],pw[MAXN];char A[MAXN],B[5][MAXN];void Init_Hash()&#123; Hash[0]=0; for(int i=1;i&lt;=n;++i) Hash[i]=Hash[i-1]*Base+(ull)(A[i]-'a');&#125;ull Calc_Hash(int l,int r)&#123; return Hash[r]-Hash[l-1]*pw[r-l+1];&#125;int L[5][MAXN],R[5][MAXN],f[5][MAXN];int id[5];int DP(int i,int j)&#123; if(i&gt;N) return 0; j=R[id[i]][j]; if(j==0) return n+1; if(f[i][j]!=-1) return f[i][j]; int &amp;ans=f[i][j]; ans=DP(i,j+1); int k=j+len[id[i]],st=j; ++i; for(;i&lt;=N;++i) &#123; ans=min(ans,DP(i,k)+k-j); int p=R[id[i]][j]; if(p&lt;st || p&gt;=k) return ans; st=p; k=max(k,st+len[id[i]]); &#125; ans=min(ans,k-j); return ans;&#125;int dfs(int i,int j)&#123; if(i&gt;N) return 0; j=R[id[i]][j]; if(!j) return 0; int k=j+len[id[i]],st=j; int ans=0; ++i; for(;i&lt;=N;++i) &#123; ans=max(ans,dfs(i,k)+k-j); int p=L[id[i]][k]; if(p&lt;st || p&gt;=k) return ans; st=p; k=max(k,st+len[id[i]]); &#125; ans=max(ans,k-j); return ans;&#125;int main()&#123; pw[0]=1; for(int i=1;i&lt;=10000;++i) pw[i]=pw[i-1]*Base; int T=read(); while(T--) &#123; scanf("%s",A+1); n=strlen(A+1); N=read(); for(int i=1;i&lt;=N;++i) &#123; scanf("%s",B[i]+1); len[i]=strlen(B[i]+1); &#125; Init_Hash(); memset(L,0,sizeof L); memset(R,0,sizeof R); for(int i=1;i&lt;=N;++i) &#123; ull val=0; for(int j=1;j&lt;=len[i];++j) val=val*Base+(B[i][j]-'a'); for(int j=1;j+len[i]-1&lt;=n;++j) if(Calc_Hash(j,j+len[i]-1)==val) L[i][j]=j; else L[i][j]=L[i][j-1]; for(int j=n+1-len[i];j&gt;=1;--j) if(Calc_Hash(j,j+len[i]-1)==val) R[i][j]=j; else R[i][j]=R[i][j+1]; &#125; for(int i=1;i&lt;=N;++i) id[i]=i; int minans=n+1,maxans=0; do &#123; memset(f,-1,sizeof f); minans=min(minans,DP(1,1)); maxans=max(maxans,dfs(1,1)); &#125;while(next_permutation(id+1,id+1+N)); printf("%d %d\n",minans,maxans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4559 成绩比较]]></title>
    <url>%2F2019%2F07%2F10%2Fbzoj-4559-%E6%88%90%E7%BB%A9%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[组合计数 + 容斥原理 + 拉格朗日插值法. 首先我们确定哪些人被碾压,再确定没有被碾压的人各科分数分别是高于 $B$ 神还是小于等于 $B$ 神.然后就可以将每科分开算所有人各自具体分数的方案数,最后乘在一起. 选出被碾压的人有 $n-1\choose k$ 种方案. 对于课程 $i$ ,有 $r_i-1$ 个人的分比 $B$ 神高,这 $r_i-1$ 个人显然只能在未被碾压的 $n-k-1$ 个人中产生.如果任意分配,可能会出现新的人被碾压.所以用容斥原理计算这部分的贡献,没有人被碾压方案数 $=$ 总方案数 $-$ 保证 $1$ 个人被碾压方案数 $+$ 保证 $2$ 个人被碾压方案数 $\dots$ 记这个答案为 $s$ . 再来计算第 $i$ 科排名恰好为 $r_i$ 的方案数 $p_i$ .枚举这一科 $B$ 神考了 $x$ 分.(有 $r_i=1$ 的情况,所以定义 $0^0=1$ ). $$\begin{aligned}p_i=\sum_{x=1}^{u_i} x^{n-r_i}\cdot (u_i-x)^{r_i-1}\end{aligned}$$ 若暴力算 $p_i$ 可以拿到 $70$ 分.注意到 $p_i$ 是个关于 $u_i$ 的 $n$ 次多项式,而我们只需要求它在某一个位置的值. 拉格朗日插值即可,答案为 ${n-1\choose k}\cdot s \cdot \prod p_i$ . 时间复杂度 $O(n^3\cdot \log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=128;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;int n,m,k,C[MAXN][MAXN];int u[MAXN],r[MAXN];void init()&#123; C[0][0]=1; for(int i=1;i&lt;=n;++i) C[i][0]=1; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=i;++j) C[i][j]=add(C[i-1][j],C[i-1][j-1]);&#125;int Assign_Rank()&#123; int res=1; for(int i=1;i&lt;=m;++i) res=mul(res,C[n-k-1][r[i]-1]); bool flag=true; for(int i=1;i&lt;=n-k-1 &amp;&amp; flag;++i) &#123; int tmp=C[n-k-1][i]; for(int j=1;j&lt;=m;++j) if(n-k-1-i&gt;=r[j]-1) tmp=mul(tmp,C[n-k-1-i][r[j]-1]); else &#123; tmp=0; flag=false; break; &#125; if(i&amp;1) res=add(res,P-tmp); else res=add(res,tmp); &#125; return res;&#125;int Calc_p(int i,int U)&#123; int res=0; for(int x=1;x&lt;=U;++x) res=add(res,mul(fpow(x,n-r[i]),fpow(U-x,r[i]-1))); return res;&#125;int x[MAXN],y[MAXN];int Lagrange(int N,int pos)&#123; int res=0; for(int i=1;i&lt;=N;++i) &#123; int tmp=y[i]; for(int j=1;j&lt;=N;++j) if(i!=j) &#123; tmp=mul(tmp,add(pos,P-x[j])); tmp=mul(tmp,inv(add(x[i],P-x[j]))); &#125; res=add(res,tmp); &#125; return res;&#125;int Assign_Score(int i)&#123; for(int U=2;U&lt;=n+2;++U) x[U-1]=U,y[U-1]=Calc_p(i,U); return Lagrange(n+1,u[i]);&#125;int main()&#123; n=read(),m=read(),k=read(); for(int i=1;i&lt;=m;++i) u[i]=read(); for(int i=1;i&lt;=m;++i) r[i]=read(); init(); int ans=C[n-1][k]; ans=mul(ans,Assign_Rank()); for(int i=1;i&lt;=m;++i) ans=mul(ans,Assign_Score(i)); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>容斥原理</tag>
        <tag>拉格朗日插值法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4558 方]]></title>
    <url>%2F2019%2F07%2F10%2Fbzoj-4558-%E6%96%B9%2F</url>
    <content type="text"><![CDATA[容斥原理. 记 $s_i$ 表示顶点恰好有 $i$ 个点是不合法点的正方形数,答案显然是 $s_0-s_1+s_2-s_3+s_4$ . $s_0$ 可以直接算, $s_1$ 可以枚举每个不合法点来算. 算 $s_2,s_3,s_4$ 都只需要枚举每对不合法点,并判断其他两个顶点是否合法,将贡献加入对应的 $s$ . 注意考虑斜着放的正方形. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e8+7;const int inv2=(P+1)&gt;&gt;1;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=2e3+10;typedef pair&lt;int,int&gt; pii;#define mp make_pairset&lt;pii&gt; S;int n,m,k,s[5];int Calc(int l,int r,int h)&#123; int z=min(l+r,h); if(!z) return 0; int res=mul(mul(z,z+3),inv2); if(z&gt;l) res=add(res,P-mul(inv2,mul(z-l,z-l+1))); if(z&gt;r) res=add(res,P-mul(inv2,mul(z-r,z-r+1))); return res;&#125;int calc1(int x,int y)&#123; int t=x,b=n-x,l=y,r=m-y; int res=0; res=add(res,Calc(t,b,l)); res=add(res,Calc(t,b,r)); res=add(res,Calc(l,r,t)); res=add(res,Calc(l,r,b)); res=add(res,P-min(l,t)); res=add(res,P-min(r,t)); res=add(res,P-min(l,b)); res=add(res,P-min(r,b)); return res;&#125;bool check(int x,int y)&#123; return x&gt;=0 &amp;&amp; x&lt;=n &amp;&amp; y&gt;=0 &amp;&amp; y&lt;=m;&#125;void count(int ax,int ay,int bx,int by)&#123; if(check(ax,ay) &amp;&amp; check(bx,by)) &#123; int t=S.count(mp(ax,ay))+S.count(mp(bx,by)); ++s[2]; if(t&gt;0) s[3]=add(s[3],1); if(t&gt;1) s[3]=add(s[3],1),s[4]=add(s[4],1); &#125;&#125;int x[MAXN],y[MAXN];void solve()&#123; for(int i=1;i&lt;=n &amp;&amp; i&lt;=m;++i) s[0]=add(s[0],mul(i,mul(n-i+1,m-i+1))); for(int i=1;i&lt;=k;++i) s[1]=add(s[1],calc1(x[i],y[i])); for(int i=1;i&lt;k;++i) for(int j=i+1;j&lt;=k;++j) &#123; int dx=x[i]-x[j]; int dy=y[i]-y[j]; count(x[i]+dy,y[i]-dx,x[j]+dy,y[j]-dx); count(x[i]-dy,y[i]+dx,x[j]-dy,y[j]+dx); if(abs(dx)+abs(dy) &amp; 1) continue; int X=(dx-dy)&gt;&gt;1,Y=(dx+dy)&gt;&gt;1; count(x[i]-X,y[i]-Y,x[j]+X,y[j]+Y); &#125; s[3]/=3; s[4]/=6;&#125;int main()&#123; n=read(),m=read(); k=read(); for(int i=1;i&lt;=k;++i) &#123; x[i]=read(); y[i]=read(); S.insert(mp(x[i],y[i])); &#125; solve(); int ans=0; for(int i=0;i&lt;=4;++i) if(i&amp;1) ans=add(ans,P-s[i]); else ans=add(ans,s[i]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5104 Fib数列]]></title>
    <url>%2F2019%2F07%2F10%2Fbzoj-5104-Fib%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[二次剩余 + $BSGS$ . 这个题可以暴力水过去.先找出模 $P=10^9+9​$ 意义下的循环节,发现是 $\frac {P-1} 3​$ .于是 $O(\frac {P-1} 3)​$ 暴力判. 考虑正经一点的,比较优秀的做法.记 $\phi=\frac {\sqrt 5+1} 2​$ ,则数列第 $n​$ 项 $F_n=\frac 1 {\sqrt 5} \cdot (\phi^n-(-\frac 1 \phi)^n)​$ . 注意 $5$ 在模 $P$ 意义下可以开根号,记开出来的根为 $k=383008016$ ,答案为 $x$ ,那么要解的方程化为, $$\phi^x-(-\frac 1 \phi)^x=k\cdot n$$ 换元,令 $t=\phi ^x$ ,则方程化为, $$t^2-(-1)^x\cdot=(k\cdot n)t$$ 得到了 $t$ 的一元二次方程,对 $x$ 为奇数/偶数分别求解.若 $\Delta$ 不为二次剩余,则无解. 否则,求根公式解得 $t​$ ,再根据 $t=\phi ^x​$ 用 $BSGS​$ 解出最小 $x​$ . 瓶颈在 $BSGS​$ 上,时间复杂度 $O(\sqrt P)​$ . 暴力 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+9;inline int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int solve(int n)&#123; if(n==1) return 1; int len=333333336; int a=0,b=1,c; for(int i=2;i&lt;=len;++i) &#123; c=add(a,b); if(c==n) return i; a=b; b=c; &#125; return -1;&#125;int main()&#123; int n=read(); cout&lt;&lt;solve(n)&lt;&lt;endl; return 0;&#125; 正经做法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+9,inv2=(P+1)&gt;&gt;1;const int k=383008016,phi=691504013;const int Len=(P+1)/3;inline int add(int a,int b)&#123; return ((a+b)%P+P)%P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;bool EulerJudge(int x)&#123; return fpow(x,(P-1)&gt;&gt;1)!=(P-1);&#125;int wi;struct Complex&#123; int x,y;//x+yw Complex(int x=0,int y=0):x(x),y(y) &#123;&#125; Complex operator * (const Complex &amp;rhs) const &#123; int tx=mul(mul(y,rhs.y),wi); tx=add(tx,mul(x,rhs.x)); int ty=add(mul(x,rhs.y),mul(y,rhs.x)); return Complex(tx,ty); &#125; friend Complex operator ^ (Complex a,int b) &#123; Complex res=Complex(1,0); while(b) &#123; if(b&amp;1) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res; &#125;&#125;;int Cipolla(int n)&#123; if(!EulerJudge(n)) return -1; srand(time(NULL)); int a; while("RLDAKIOI") &#123; a=rand()%P; wi=add(mul(a,a),-n); if(!EulerJudge(wi)) break; &#125; Complex res=Complex(a,1); res=res^((P+1)&gt;&gt;1); res.x=add(res.x,P); return min(res.x,P-res.x);&#125;map&lt;int,int&gt; mp;int BSGS(int a,int b)//a^x=b&#123; mp.clear(); int m=ceil(sqrt(P)); for(int j=0; j&lt;m; ++j) mp[mul(b,fpow(a,j))]=j; for(int i=1; i&lt;=m; ++i) &#123; int j,val=fpow(a,i*m); if(mp.find(val)!=mp.end()) &#123; j=mp[val]; return i*m-j; &#125; &#125; return P;&#125;int n;int solve(int b,int c,int t)&#123; if(t==-1) return P; t=add(t,-b); t=mul(t,inv2); int x=BSGS(phi,t); if(c==1 &amp;&amp; x%2==0) return P; if(c==-1 &amp;&amp; x%2==1) return P; return x;&#125;int calc(int b,int c)&#123; int Delta=add(mul(b,b),mul(-4,c)); int t=Cipolla(Delta); if(t==-1) return P; return min(solve(b,c,t),solve(b,c,add(P,-t)));&#125;int main()&#123; n=read(); int ans=P; int b=mul(P-k,n); ans=min(ans,calc(b,1));//odd ans=min(ans,calc(b,-1));//even if(ans&lt;P) printf("%d\n",ans); else puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>BSGS</tag>
        <tag>二次剩余</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2305 游戏]]></title>
    <url>%2F2019%2F07%2F10%2FLoj-2305-%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[$2-SAT$ . 如果没有地图 $x$ ,每张地图只能选两种车,就是个裸的 $2-SAT$ 问题. 现在有地图 $x$ ,但不超过 $8$ 张.所以可以暴力枚举每张地图 $x$ 不能选哪种车,然后 $2-SAT$ 判断. 注意枚举不能选的车时,只用枚举两种,就已经包含了地图 $x$ 选车的所有情况. $2-SAT$ 问题若有解,输出一组合法解的方法,是对于每个状态 $i$ 与它的对立面 $inv(i)$ 比较所在 $scc$ 编号的大小,选择所在 $scc$ 编号小的状态.这样做是和缩点建反图后 $topsort$ 等价的. 时间复杂度 $O(2^d\cdot (n+m))$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int n,m,d;char buf[MAXN],s[10];bool flag[MAXN];int idx(int x,int type)&#123; return x*3+type;&#125;int inv(int id)&#123; int x=id/3; int t=id%3; if(flag[idx(x,0)]==false) return idx(x,3-0-t); if(flag[idx(x,1)]==false) return idx(x,3-1-t); if(flag[idx(x,2)]==false) return idx(x,3-2-t);&#125;int ecnt=0,head[MAXN],to[MAXN],nx[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;struct Edge&#123; int x,y; int hx,hy;&#125;E[MAXN];int dfn[MAXN],low[MAXN],scc[MAXN],cnt,tot;int stk[MAXN],tp,in[MAXN];void tarjan(int u)&#123; dfn[u]=low[u]=++cnt; stk[++tp]=u; in[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(!flag[v]) continue; if(!dfn[v]) &#123; tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(in[v]) low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u]) &#123; int v; ++tot; do &#123; v=stk[tp--]; in[v]=0; scc[v]=tot; &#125;while(u!=v); &#125;&#125;bool solve(int st)&#123; for(int i=0;i&lt;n;++i) &#123; if(buf[i]=='x') &#123; int t=st&amp;1; flag[idx(i,0)]=true; flag[idx(i,1)]=true; flag[idx(i,t)]=false; st&gt;&gt;=1; &#125; &#125; memset(head,0,sizeof head); ecnt=0; for(int i=1;i&lt;=m;++i) &#123; int x=idx(E[i].x,E[i].hx); int y=idx(E[i].y,E[i].hy); if(x==y) continue; if(!flag[x]) continue; else if(!flag[y]) addedge(x,inv(x)); else &#123; addedge(x,y); addedge(inv(y),inv(x)); &#125; &#125; memset(dfn,0,sizeof dfn); memset(low,0,sizeof low); memset(scc,0,sizeof scc); memset(in,0,sizeof in); tp=0; tot=0; cnt=0; for(int i=0;i&lt;3*n;++i) if(flag[i] &amp;&amp; !dfn[i]) tarjan(i); for(int i=0;i&lt;3*n;++i) if(flag[i] &amp;&amp; scc[i]==scc[inv(i)]) return false; for(int i=0;i&lt;3*n;++i) &#123; if(flag[i] &amp;&amp; scc[i]&lt;scc[inv(i)]) putchar(i%3+'A'); &#125; puts(""); return true;&#125;int main()&#123; n=read(),d=read(); scanf("%s",buf); for(int i=0;i&lt;n;++i) &#123; flag[idx(i,0)]=true; flag[idx(i,1)]=true; flag[idx(i,2)]=true; if(buf[i]!='x') flag[idx(i,buf[i]-'a')]=false; &#125; m=read(); for(int i=1;i&lt;=m;++i) &#123; E[i].x=read()-1; scanf("%s",s); E[i].hx=s[0]-'A'; E[i].y=read()-1; scanf("%s",s); E[i].hy=s[0]-'A'; &#125; bool f=false; for(int i=0;i&lt;(1&lt;&lt;d);++i) if(solve(i)) &#123; f=true; break; &#125; if(!f) puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>tarjan</tag>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2302 整数]]></title>
    <url>%2F2019%2F07%2F09%2FLoj-2302-%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[线段树 + 压位. 可以用线段树维护 $x$ 的每个二进制位,一次加/减法可以拆成 $\log$ 次给某一位 $\pm 1$. 假设给第 $p$ 位 $+1$ ,就向高位找到第一个为 $0$ 的位置 $q$ ,将位置 $q$ 改为 $1$ , $p\sim q-1$ 改为 $0$ . 假设给第 $p$ 位 $-1$ ,就向高位找到第一个为 $1$ 的位置 $q$ ,将位置 $q$ 改为 $0$ , $p\sim q-1$ 改为 $1$ . 这样直接做是 $O(n\cdot \log^2n)$ 的,比较慢.因为只维护 $0/1$ 信息,所以一个比较自然的想法是压位. $b\le 30n$ ,为了方便,将 $30$ 位压在一个 $int$ 里面,这样每次操作只用拆成 $2$ 位. 线段树的第 $i$ 个位置维护了二进制位 $(i-1)\times 30\sim i\times 30-1$ 这些位置上的信息.时间复杂度 $O(n\cdot \log n)$. 细节巨多,巨烦.调了两节课. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;const int Base=30;const int s=(1&lt;&lt;30)-1;int n;struct SegTree&#123; struct node &#123; int val,tag; bool mi,mx; node()&#123;val=0;tag=-1;mi=true;mx=false;&#125; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.mi=lson.mi&amp;rson.mi; root.mx=lson.mx&amp;rson.mx; &#125; void modifiy(int o,int c) &#123; root.tag=c; if(!c) &#123; root.val=0; root.mi=true; root.mx=false; &#125; else &#123; root.val=s; root.mi=false; root.mx=true; &#125; &#125; void pushdown(int o) &#123; if(root.tag!=-1) &#123; modifiy(o&lt;&lt;1,root.tag); modifiy(o&lt;&lt;1|1,root.tag); root.tag=-1; &#125; &#125; void upd(int o,int l,int r,int L,int R,int c) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125; int query(int o,int l,int r,int a,int b)//第b个大位第a小位 &#123; if(l==r) return (root.val&gt;&gt;a)&amp;1; int mid=(l+r)&gt;&gt;1; pushdown(o); if(b&lt;=mid) return query(o&lt;&lt;1,l,mid,a,b); else return query(o&lt;&lt;1|1,mid+1,r,a,b); &#125; void Rejudge(int o) &#123; root.mi=(!root.val); root.mx=(root.val==s); &#125; void upd_fa(int o) &#123; while(o!=1) &#123; pushup(o&gt;&gt;1); o&gt;&gt;=1; &#125; &#125; int Access(int o,int l,int r,int pos) &#123; if(l==r) return o; int mid=(l+r)&gt;&gt;1; pushdown(o); if(pos&lt;=mid) return Access(o&lt;&lt;1,l,mid,pos); else return Access(o&lt;&lt;1|1,mid+1,r,pos); &#125; int First_Non_Mx(int o,int l,int r,int pos) &#123; if(root.mx) return -1; if(l==r) return l; int mid=(l+r)&gt;&gt;1; pushdown(o); if(pos&lt;=mid) &#123; int res=First_Non_Mx(o&lt;&lt;1,l,mid,pos); if(res==-1) return First_Non_Mx(o&lt;&lt;1|1,mid+1,r,pos); else return res; &#125; else return First_Non_Mx(o&lt;&lt;1|1,mid+1,r,pos); &#125; int First_Non_Mi(int o,int l,int r,int pos) &#123; if(root.mi) return -1; if(l==r) return l; int mid=(l+r)&gt;&gt;1; pushdown(o); if(pos&lt;=mid) &#123; int res=First_Non_Mi(o&lt;&lt;1,l,mid,pos); if(res==-1) return First_Non_Mi(o&lt;&lt;1|1,mid+1,r,pos); else return res; &#125; else return First_Non_Mi(o&lt;&lt;1|1,mid+1,r,pos); &#125; void Add(int o,int l,int r,int a,int b)//在第b个大位+a &#123; if(l==r) &#123; root.val+=a; if(root.val&gt;s) &#123; root.val&amp;=s; int p=First_Non_Mx(1,0,n,l+1); int t=Access(1,0,n,p); Tree[t].val++; Rejudge(t); if(Tree[t].val==1 || Tree[t].val==s) upd_fa(t); if(l+1&lt;=p-1) upd(1,0,n,l+1,p-1,0); &#125; Rejudge(o); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(b&lt;=mid) Add(o&lt;&lt;1,l,mid,a,b); else Add(o&lt;&lt;1|1,mid+1,r,a,b); pushup(o); &#125; void Del(int o,int l,int r,int a,int b)//在第b个大位-a &#123; if(l==r) &#123; if(root.val&gt;=a) &#123; root.val-=a; Rejudge(o); return; &#125; root.val=s+1+root.val-a; Rejudge(o); int p=First_Non_Mi(1,0,n,l+1); int t=Access(1,0,n,p); Tree[t].val--; Rejudge(t); if(Tree[t].val==0 || Tree[t].val==s-1) upd_fa(t); if(l+1&lt;=p-1) upd(1,0,n,l+1,p-1,1); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(b&lt;=mid) Del(o&lt;&lt;1,l,mid,a,b); else Del(o&lt;&lt;1|1,mid+1,r,a,b); pushup(o); &#125;&#125;T;int main()&#123; n=read(); read(),read(),read(); for(int i=1;i&lt;=n;++i) &#123; int tp=read(); if(tp==1) &#123; ll a; scanf("%lld",&amp;a); int b=read(); bool flag=(a&gt;0); a=abs(a); a&lt;&lt;=(b%Base); b/=Base; if(flag) &#123; if(a&amp;s) T.Add(1,0,n,a&amp;s,b); if(a&gt;&gt;Base) T.Add(1,0,n,a&gt;&gt;Base,b+1); &#125; else &#123; if(a&amp;s) T.Del(1,0,n,a&amp;s,b); if(a&gt;&gt;Base) T.Del(1,0,n,a&gt;&gt;Base,b+1); &#125; &#125; else &#123; int k=read(); int ans=T.query(1,0,n,k%Base,k/Base); printf("%d\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4161 Shlw loves matrix I]]></title>
    <url>%2F2019%2F07%2F09%2Fbzoj-4161-Shlw-loves-matrix-I%2F</url>
    <content type="text"><![CDATA[常系数线性递推. 矩阵快速幂是 $O(k^3\cdot logn)$ 的,不够优秀.观察式子(后续用 $a$ 代替 $h$ ,用 $f$ 代替 $a$ ), $$a_n=\sum_{i=1}^k f_i\cdot a_{n-i}$$ 注意到任意一项 $a_i$ 都可以被 $\lbrace a_0,a_1,\dots,a_{k-1} \rbrace$ 线性表示,考虑已知 $a_n$ 的线性表示,如何求得 $a_{2n}$ 的线性表示.这里需要利用一个性质,若: $$a_n=\sum_{i=0}^{k-1}b_i\cdot a_i$$ 则, $$a_{n+x}=\sum_{i=0}^{k-1}b_i\cdot a_{i+x}$$ 证明应该是显然的,相当于将 $a_x$ 看做这个数列的首项,递推式都是一样的,所以对应系数也是一样的. 于是,连续用 $2$ 次该性质可得, 这样就用 $\lbrace a_0,a_1,a_2,\dots,a_{2k-2} \rbrace$ 线性表示了 $a_{2n}$ .那么只需要求得 $\lbrace a_k,a_{k+1},a_{k+2},\dots,a_{2k-2} \rbrace$ 的线性表示,然后代进去即可. 像快速幂那样做下去,只用做 $logn$ 次.时间复杂度 $O(k^2\cdot logn)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=2e3+10;int n,k,tmp[MAXN&lt;&lt;1];void Mul(int *a,int *b,int *f)&#123; memset(tmp,0,k&lt;&lt;3); for(int i=0;i&lt;k;++i) for(int j=0;j&lt;k;++j) tmp[i+j]=add(tmp[i+j],mul(a[i],b[j])); for(int i=2*k-2;i&gt;=k;--i) for(int j=0;j&lt;k;++j) tmp[i-j-1]=add(tmp[i-j-1],mul(tmp[i],f[j])); memcpy(a,tmp,k&lt;&lt;2); &#125;int base[MAXN],ans[MAXN];int solve(int *a,int *f,int N)&#123; if(N&lt;k) return a[N]; base[1]=ans[0]=1; while(N) &#123; if(N&amp;1) Mul(ans,base,f); Mul(base,base,f); N&gt;&gt;=1; &#125; int res=0; for(int i=0;i&lt;k;++i) res=add(res,mul(a[i],ans[i])); return res;&#125;int f[MAXN],a[MAXN];int main()&#123; n=read(),k=read(); for(int i=0;i&lt;k;++i) f[i]=add(read(),P); for(int i=0;i&lt;k;++i) a[i]=add(read(),P); cout&lt;&lt;solve(a,f,n)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>常系数线性递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2304 泳池]]></title>
    <url>%2F2019%2F07%2F09%2FLoj-2304-%E6%B3%B3%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[$dp$ + 常系数线性递推. 面积恰好 $=K$ 的概率不太好求,考虑求出面积 $\le K$ 与面积 $\le K-1$ 的概率,两者相减即为答案. 设 $f(i,j)$ 表示矩形长为 $i$ ,最下面 $j$ 行都安全,而第 $j+1$ 行至少一个位置危险,最大面积不超过 $K$ 的概率. 记 $g(i,j)$ 表示矩形长为 $i$ ,最下面 $j$ 行都安全,最大面积不超过 $K$ 的概率.则 $g(i,j)=\sum_{p\ge j} f(i,p)$ . 边界为 $g(0,j)=f(0,j)=1,g(i,j)=f(i,j)=0\ (i\cdot j&gt;K)$ .我们需要求得 $g(n,0)$ . 枚举第 $j+1$ 行第一个危险的格子在 $r+1$ 列.那么要求前 $r$ 列 $j+1$ 行都安全, $r+2\sim i$ 列前 $j$ 行安全,第 $r+1$ 列前 $j$ 行安全, 第 $r+1$ 列第 $j+1$ 行危险,则转移有, $$f(i,j)=\sum_{r=0}^{i-1} g(r,j+1)\cdot g(i-r-1,j) \cdot q^j\cdot(1-q)$$ $4$ 个限制依次对应了转移方程中的 $4$ 项. 大力 $dp$ ,时间复杂度为 $O(n^2)$ . 考虑如何优化.注意到当 $n&gt;K$ 时,仅有 $f(i,0)$ 与 $g(i,0)$ 这些项不为 $0$ ,而我们要求的是 $g(n,0)$ . 所以只用考虑它们的转移.将 $j=0$ 代入原来的转移方程,可以发现, $$f(i,0)=g(i,0)=\sum_{r=0}^K g(r,1)\cdot g(i-r-1,0)\cdot (1-q)$$ $g(r,1)$ 最多只有前 $K+1$ 项非 $0$ ,这部分可以通过大力 $dp$ 求出.那么 $g(r,1)\cdot (1-q)$ 就可看做常系数. 求 $g(i,0)$ 就是一个常系数线性递推,递推式的长度为 $K$ .使用 $O(K^2\cdot logn)$ 的大力取模做法即可. 总时间复杂度 $O(K^2\cdot logn)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;const int MAXN=1e3+10;int base[MAXN],ans[MAXN],tmp[MAXN&lt;&lt;1];void Mul(int *a,int *b,int *f,int k)&#123; memset(tmp,0,k&lt;&lt;3); for(int i=0;i&lt;k;++i) for(int j=0;j&lt;k;++j) tmp[i+j]=add(tmp[i+j],mul(a[i],b[j])); for(int i=2*k-2;i&gt;=k;--i) for(int j=0;j&lt;k;++j) tmp[i-j-1]=add(tmp[i-j-1],mul(tmp[i],f[j])); memcpy(a,tmp,k&lt;&lt;2);&#125;int solve(int *a,int *f,int n,int k)&#123; memset(base,0,sizeof base); memset(ans,0,sizeof ans); base[1]=ans[0]=1; while(n) &#123; if(n&amp;1) Mul(ans,base,f,k); Mul(base,base,f,k); n&gt;&gt;=1; &#125; int res=0; for(int i=0;i&lt;k;++i) res=add(res,mul(a[i],ans[i])); return res;&#125;int n,q,pw[MAXN];int f[MAXN][MAXN],g[MAXN][MAXN];int a[MAXN],F[MAXN];int Solve(int k)&#123; memset(f,0,sizeof f); memset(g,0,sizeof g); memset(a,0,sizeof a); memset(F,0,sizeof F); for(int j=0;j&lt;=k+1;++j) g[0][j]=f[0][j]=1; for(int i=1;i&lt;=1000;++i) &#123; for(int j=k/i;j&gt;=0;--j) &#123; int L=j?(i-1-k/j):0; L=max(L,0); int R=min(i-1,k/(j+1)); for(int r=L;r&lt;=R;++r) &#123; int t=mul(pw[j],add(1,P-q)); t=mul(t,mul(g[r][j+1],g[i-1-r][j])); f[i][j]=add(f[i][j],t); &#125; g[i][j]=add(g[i][j+1],f[i][j]); &#125; &#125; if(n&lt;=1000) return g[n][0]; for(int i=0;i&lt;=k;++i) a[i]=g[i][0]; for(int r=0;r&lt;=k;++r) F[r]=mul(g[r][1],add(1,P-q)); return solve(a,F,n,k+1);&#125;int main()&#123; n=read(); int k=read(); int x=read(),y=read(); q=mul(x,inv(y)); pw[0]=1; for(int i=1;i&lt;=k;++i) pw[i]=mul(pw[i-1],q); cout&lt;&lt;add(Solve(k),P-Solve(k-1))&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>概率/期望</tag>
        <tag>数学</tag>
        <tag>常系数线性递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Berlekamp-Massey 算法学习笔记]]></title>
    <url>%2F2019%2F07%2F09%2FBerlekamp-Massey-%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[在李巨的指引下学了一发. 简称 $BM$ 算法,可以以 $O(n^2)$ 的时间复杂度求解一个长度为 $n$ 的数列的最短线性递推式. 对于数列 $\lbrace a_1,a_2,a_3,\dots,a_n \rbrace$ ,称数列 $\lbrace R_1,R_2,R_3,\dots,R_m \rbrace$ 为其线性递推式,当且仅当下式成立: $$\forall m+1\le i\le n,a_i=\sum_{j=1}^m R_j\cdot a_{i-j}$$ 若它是所有合法线性递推式中长度 $m$ 最小的线性递推式,则称它为数列 $\lbrace a_1,a_2,a_3,\dots,a_n \rbrace$ 的最短线性递推式. 若未特殊说明,接下来的递推式,线性递推式均指 最短线性递推式 , $BM$ 算法的主要思路是从前往后依次考虑每个数,修改当前递推式使其合法,并且满足最短. 尝试由 $\lbrace a_1,a_2,a_3,\dots,a_{i-1} \rbrace$ 的递推式 $\lbrace r_1,r_2,r_3,\dots,r_m \rbrace$ 得出 $\lbrace a_1,a_2,a_3,\dots,a_i \rbrace$ 的递推式. 记递推式被更改的次数为 $cnt$ ,第 $i$ 次修改后得到的递推式为 $R_i$ ,规定 $R_0$ 为空.记递推式 $\lbrace r_1,r_2,r_3,\dots,r_m \rbrace$ 为当前递推式,即 $R_{cnt}$ . 记 $delta_i=a_i-\sum_{j=1}^m r_{j}\cdot a_{i-j}$ ,即用当前递推式算得的值与真实值之间的误差.若 $delta_i=0$ ,则不需要对递推式进行修改,直接考虑下一个元素 $a_{i+1}$ . 否则说明 $R_{cnt}$ 在位置 $i$ 出错了,记 $R_{cnt}$ 第一次出错的位置为 $fail_i$ ,则 $fail_{cnt}=i$ .考虑对 $R_{cnt}$ 进行修改,得到 $R_{cnt+1}$ ,并使得它在位置 $i$ 也成立. 若当前 $cnt=0$ ,说明 $a_i$ 是第一个非零元素,直接将 $R_1$ 置为 $\lbrace 0,0,0,\dots0 \rbrace$ ( $i$ 个 $0$ ) 即可. 否则, $cnt&gt;0$ ,说明之前已经修改过递推式,即存在 $R_k$, 记录 $p=fail_k$ ,尝试在 $R_k$ 的基础上修改,在 $a_i$ 的位置上递推出一个 $-delta_{p}$ 每个位置乘上 $\frac {delta_i} {delta_p}$ ,每个位置再加上原来的 $R_{cnt}$ 就得到合法的 $R_{cnt+1}$ . 将 $R_k$ 的元素全部变成它的相反数,再在前面补上一个 $1$ , $-delta_p$ 就到 $p+1$ 位置上来了.再在前面补 $i-p-1$ 个 $0$ , $-delta_p$ 就到位置 $i$ 上来了. 于是得到 $R_{cnt+1}=\frac {delta_i} {delta_p}*\lbrace 0,0,0,\dots,1,-R_{k_1},-R_{k_2},\dots,-R_{k_M} \rbrace + R_{cnt}$ . $0$ 有 $i-p-1$ 个. 为了保证得到的递推式长度最短,我们需要选取恰当的 $k$ .容易看出,得到的 $R_{cnt+1}$ 的长度为 $\max(i-p+M,m)$ , $M$ 为 $R_k$ 的长度, $m$ 为 $R_{cnt}$ 的长度.于是记录 $M-p$ 最短的递推式作为 $R_k$ . 最坏情况需要更新 $n$ 次递推式,时间复杂度 $O(n^2)$ . 用 $BM$ 得到的最短递推式长度最好要明显小于 $n$ 的一半,否则需要再打些表. 为什么?因为若长度为 $\frac n 2$,可以看做 $\frac n 2$ 个变量列出 $\frac n 2$ 个方程,总能找到解. 所以一个随机数列解出的最短递推式长度就是 $n$ 的一半左右,长度在 $\frac n 2$ 左右说明原数列很可能并没有一定的规律,即,大概率对之后的数据不适用. 另,因为计算中涉及 $\frac {delta_i} {delta_p}$ ,所以 $BM$ 在实数域内求解可能有一定的精度误差.若在模质数意义下,则不用考虑. 板子. $vector$ 下标从 $0$ 开始,要注意处理. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;const int inf=P+1;inline int add(int a,int b)&#123; return (a+b)%P;&#125;inline int sub(int a,int b)&#123; return (a-b+P)%P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;#define len(A) A.size()typedef vector&lt;int&gt; poly;poly BerlekampMassey(poly a)&#123; poly R_k,R; int n=a.size(); int p=-inf,Delta; int fail,delta; for(int i=0;i&lt;n;++i) &#123; delta=a[i]; for(int j=0;j&lt;len(R);++j) delta=sub(delta,mul(R[j],a[i-(j+1)])); if(!delta) continue; fail=i; if(p==-inf) &#123; R.resize(i+1); p=fail; Delta=delta; continue; &#125; poly r; int tmp=mul(delta,inv(Delta)); for(int j=1;j&lt;=i-p-1;++j) r.push_back(0); r.push_back(tmp); for(int j=0;j&lt;len(R_k);++j) r.push_back(sub(0,mul(tmp,R_k[j]))); if(len(r)&lt;len(R)) r.resize(len(R)); for(int j=0;j&lt;len(R);++j) r[j]=add(r[j],R[j]); if(len(R)+p&lt;len(R_k)+fail) &#123; R_k=R; Delta=delta; p=fail; &#125; R=r; &#125; return R;&#125;int main()&#123; int n=read(); poly a; for(int i=1;i&lt;=n;++i) a.push_back(read()); poly R=BerlekampMassey(a); int m=R.size(); printf("%u\n",m); for(int i=0;i&lt;m;++i) printf("%d ",R[i]); puts(""); for(int i=m;i&lt;n;++i) &#123; int delta=a[i]; for(int j=0;j&lt;m;++j) delta=sub(delta,mul(R[j],a[i-(j+1)])); assert(!delta); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>BM</tag>
        <tag>常系数线性递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4557 侦察守卫]]></title>
    <url>%2F2019%2F07%2F08%2Fbzoj-4557-%E4%BE%A6%E5%AF%9F%E5%AE%88%E5%8D%AB%2F</url>
    <content type="text"><![CDATA[树形 $dp$ . 设 $f(i,j)$ 表示将子树 $i$ 内除了最上面 $j$ 层,其余关键点都被覆盖的最小代价. $g(i,j)$ 表示子树 $i$ 内所有关键点都已被覆盖,并且还向上覆盖了 $j$ 层的最小代价. 当前处理节点为 $u$ ,其中一个儿子节点为 $v$ ,有转移 $g(u,j)=\min(g(u,j)+f(v,j), f(u,j+1)+g(v,j+1)),f(u,j)=\sum f(v,j-1)$ . 第一个转移表示让子树 $v$ 内的点来覆盖原来需要覆盖的 $j$ 层.第二个转移比较显然. 最后再贪心考虑 $f,g$ 的前缀/后缀和,即 $f(u,j)\leftarrow f(u,j-1),g(u,j)\leftarrow g(u,j+1)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;void upd(int &amp;x,int y)&#123; x=min(x,y);&#125;const int inf=1e9;const int MAXN=5e5+10;int n,m,d,w[MAXN],flag[MAXN];int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int f[MAXN][22],g[MAXN][22];void dfs(int u,int fa)&#123; if(flag[u]) f[u][0]=g[u][0]=w[u]; for(int i=1;i&lt;=d;++i) g[u][i]=w[u]; g[u][d+1]=f[u][d+1]=inf; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa) continue; dfs(v,u); for(int j=0;j&lt;=d;++j) g[u][j]=min(g[u][j]+f[v][j],f[u][j+1]+g[v][j+1]); for(int j=d-1;j&gt;=0;--j) upd(g[u][j],g[u][j+1]); f[u][0]=g[u][0]; for(int j=1;j&lt;=d;++j) f[u][j]+=f[v][j-1]; for(int j=1;j&lt;=d;++j) upd(f[u][j],f[u][j-1]); &#125;&#125;int main()&#123; n=read(),d=read(); for(int i=1;i&lt;=n;++i) w[i]=read(); m=read(); for(int i=1;i&lt;=m;++i) flag[read()]=1; for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs(1,0); cout&lt;&lt;g[1][0]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2718 归程]]></title>
    <url>%2F2019%2F07%2F08%2FLoj-2718-%E5%BD%92%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[最短路 + 可持久化并查集. 假设有一个新图,只保留当前没有积水的边,那么一个连通块内的点都可以用车直接到达. 询问出发点为 $v$ 时的答案,就是询问新图中 $v$ 所在联通块内的点到 $1$ 号节点的最短距离.可以先用 $Dijkstra$ 预处理出每个点到 $1$ 的距离. 如果不强制在线,可以将询问离线后按水位线从高到低排序,这样在新图中就只有加边的操作,直接用并查集维护联通情况以及联通块的答案. 强制在线的话,就换成可持久化并查集 (用主席树维护 $fa$ ) ,将边从大到小排序依次加入并更新联通块信息.询问时根据高度二分找到对应的版本,然后回答询问即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef pair&lt;int,int&gt; pii;#define mp make_pairconst int MAXN=4e5+10;int lastans,n,m,Q,K,S;struct Edge&#123; int fr,to,val,h; bool operator &lt; (const Edge &amp;rhs) const &#123; return h==rhs.h?val&gt;rhs.val:h&gt;rhs.h; &#125;&#125;E[MAXN&lt;&lt;1];int ecnt,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN&lt;&lt;1];void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;priority_queue&lt;pii&gt; q;int dis[MAXN],vis[MAXN];void Dijkstra()&#123; dis[1]=0; q.push(mp(0,1)); while(!q.empty()) &#123; int u=(q.top()).second; q.pop(); if(vis[u]) continue; vis[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(dis[v]-dis[u]&gt;val[i]) &#123; dis[v]=dis[u]+val[i]; q.push(mp(-dis[v],v)); &#125; &#125; &#125;&#125;int rt[MAXN&lt;&lt;1];struct PreSegTree&#123; int nodeidx; struct node &#123; int ls,rs; int fa,dep,mn; &#125;Tree[MAXN*30];#define root Tree[o] void init()&#123;nodeidx=0;&#125; void BuildTree(int &amp;o,int l,int r) &#123; o=++nodeidx; if(l==r) &#123; root.fa=l; root.dep=1; root.mn=dis[l]; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(root.ls,l,mid); BuildTree(root.rs,mid+1,r); &#125; void upd_fa(int &amp;o,int pre,int l,int r,int pos,int c) &#123; o=++nodeidx; root=Tree[pre]; if(l==r) &#123; root.fa=c; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd_fa(root.ls,Tree[pre].ls,l,mid,pos,c); else upd_fa(root.rs,Tree[pre].rs,mid+1,r,pos,c); &#125; void upd_dep(int o,int l,int r,int pos) &#123; if(l==r) &#123; ++root.dep; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd_dep(root.ls,l,mid,pos); else upd_dep(root.rs,mid+1,r,pos); &#125; int query_id(int o,int l,int r,int pos) &#123; if(l==r) return o; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) return query_id(root.ls,l,mid,pos); else return query_id(root.rs,mid+1,r,pos); &#125; int query_fa(int o,int x) &#123; int p=query_id(o,1,n,x); if(Tree[p].fa==x) return p; else return query_fa(o,Tree[p].fa); &#125; void recall(int &amp;o,int pre,int l,int r,int pos) &#123; o=++nodeidx; root=Tree[pre]; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) recall(root.ls,Tree[pre].ls,l,mid,pos); else recall(root.rs,Tree[pre].rs,mid+1,r,pos); &#125; void merge(int x,int y,int idx) &#123; if(Tree[x].dep&gt;Tree[y].dep) swap(x,y); upd_fa(rt[idx],rt[idx-1],1,n,Tree[x].fa,Tree[y].fa); recall(rt[idx],rt[idx],1,n,Tree[y].fa); int u=query_id(rt[idx],1,n,Tree[y].fa); int v=query_id(rt[idx],1,n,Tree[x].fa); Tree[u].mn=min(Tree[u].mn,Tree[v].mn); if(Tree[x].dep==Tree[y].dep) upd_dep(rt[idx],1,n,Tree[y].fa); &#125;&#125;T;int H[MAXN&lt;&lt;1];void init()&#123; Dijkstra(); sort(E+1,E+1+m); for(int i=1;i&lt;=m;++i) H[i]=E[m+1-i].h; T.BuildTree(rt[0],1,n); for(int i=1;i&lt;=m;++i) &#123; rt[i]=rt[i-1]; int x=E[i].fr,y=E[i].to; x=T.query_fa(rt[i],x); y=T.query_fa(rt[i],y); if(T.Tree[x].fa!=T.Tree[y].fa) T.merge(x,y,i); &#125;&#125;int solve(int v,int p)&#123; int idx=m+1-(upper_bound(H+1,H+1+m,p)-H); int x=T.query_fa(rt[idx],v); return T.Tree[x].mn;&#125;void Reset()&#123; lastans=0; ecnt=0; memset(head,0,sizeof head); memset(dis,0x7f,sizeof dis); memset(vis,0,sizeof vis); T.init(); rt[0]=0;&#125;int main()&#123; freopen("return.in","r",stdin); freopen("return.out","w",stdout); int T=read(); while(T--) &#123; Reset(); n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=(E[i].fr=read()); int v=(E[i].to=read()); E[i].val=read(); E[i].h=read(); addedge(u,v,E[i].val); addedge(v,u,E[i].val); &#125; init(); Q=read(),K=read(),S=read(); while(Q--) &#123; int v=(read()+K*lastans-1)%n+1; int p=(read()+K*lastans)%(S+1); lastans=solve(v,p); printf("%d\n",lastans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>最短路</tag>
        <tag>可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4555 求和]]></title>
    <url>%2F2019%2F07%2F08%2Fbzoj-4555-%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[第二类斯特林数 + $NTT$ . 第二类斯特林数 $S(n,m)$ 表示将 $n$ 个球放入 $m$ 个相同盒子的方案数. 递推式是 $S(n,m)=S(n-1,m-1)+m\cdot S(n-1,m)$ .即讨论第一个球是否单独占一个盒子. 也可利用容斥原理计算, $$S(n,m)=\frac 1 {m!} \sum_{k=0}^m (-1)^k{m\choose k}(m-k)^n$$ 意义是枚举空盒个数为 $k$ ,剩下的球任意放置.因为盒子相同,所以最后要除以 $m!$ . 回到这道题, $j&lt;i$ 时, $S(i,j)=0$ ,所以 $j$ 的枚举范围可以换成 $n$ .将上面的容斥计算式代到要求的式子里面, 仔细观察,发现第二个 $\sum$ 后面那一坨是一个卷积的形式,令 $a_i=\frac {(-1)^i} {i!},b_i=\frac {\sum_{j=0}^n i^j} {i!}$ , $c=a*b$ ,则 $ans=\sum_{j=0}^n 2^j\cdot j!\cdot c_j$ . 预处理 $a,b,2^j,j!$ ( $b_i$ 的分子是等比数列求和 ) ,用 $NTT$ 计算 $c$ . 空间要开够. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353,G=3;const int MAXN=1e5+10;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;int rev[MAXN&lt;&lt;2];void NTT_init(int n,int lim)&#123; for(int i=0;i&lt;n;++i) &#123; for(int j=0;j&lt;lim;++j) if((i&gt;&gt;j)&amp;1) rev[i]|=1&lt;&lt;(lim-j-1); &#125;&#125;void DFT(int *a,int n,bool invflag)&#123; for(int i=0;i&lt;n;++i) &#123; if(i&lt;rev[i]) swap(a[i],a[rev[i]]); &#125; for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int gi=fpow(G,(P-1)/l); if(invflag) gi=inv(gi); int m=l&gt;&gt;1; for(int *p=a;p!=a+n;p+=l) &#123; int g=1; for(int i=0;i&lt;m;++i) &#123; int t=mul(g,p[i+m]); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int Invn=inv(n); for(int i=0;i&lt;n;++i) a[i]=mul(a[i],Invn); &#125;&#125;int n;int a[MAXN&lt;&lt;2],b[MAXN&lt;&lt;2],c[MAXN&lt;&lt;2];int fac[MAXN],invfac[MAXN],pw[MAXN];void init()&#123; pw[0]=1; for(int i=1;i&lt;=n;++i) pw[i]=mul(pw[i-1],2); fac[0]=invfac[0]=1; for(int i=1;i&lt;=n;++i) fac[i]=mul(fac[i-1],i); invfac[n]=inv(fac[n]); for(int i=n-1;i&gt;=1;--i) invfac[i]=mul(invfac[i+1],i+1); for(int i=0;i&lt;=n;++i) if(i&amp;1) a[i]=add(P,-invfac[i]); else a[i]=invfac[i]; b[0]=1; b[1]=n+1; for(int i=2;i&lt;=n;++i) &#123; b[i]=add(fpow(i,n+1),P-1); b[i]=mul(b[i],inv(i-1)); b[i]=mul(b[i],invfac[i]); &#125;&#125;int main()&#123; n=read(); init(); int N=1,lim=0; while(N&lt;=2*n) N&lt;&lt;=1,++lim; NTT_init(N,lim); DFT(a,N,false); DFT(b,N,false); for(int i=0;i&lt;N;++i) c[i]=mul(a[i],b[i]); DFT(c,N,true); int ans=0; for(int i=0;i&lt;=n;++i) &#123; int tmp=mul(pw[i],fac[i]); ans=add(ans,mul(tmp,c[i])); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4554 游戏]]></title>
    <url>%2F2019%2F07%2F08%2Fbzoj-4554-%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[最大流. 比较明显是个网络流,考虑如何建模. 硬石头将每一行分成了若干块,每一块内最多放一个炸弹,每一列也同理.然后对每一行/列的块建出它们的点,每一块能通过的流量都是 $1$ .对于空地 $(x,y)$ ,就从 $(x,y)$ 所在的行块向 $(x,y)$ 所在的列块连流量为 $1$ 的边就好了. 再建出源汇点连上这些块,跑一个最大流即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e3+10,MAXM=3e5+10,N=51;int n,m,Map[N][N],bx[N][N],by[N][N],tx=0,ty=0;const int inf=1e9;char buf[N];struct Edge&#123; int nx,to,flow;&#125;E[MAXM];int head[MAXN],ecnt=-1;void addedge(int u,int v,int flow)&#123; ++ecnt; E[ecnt].to=v; E[ecnt].nx=head[u]; E[ecnt].flow=flow; head[u]=ecnt;&#125;void ins(int u,int v,int flow)&#123; addedge(u,v,flow); addedge(v,u,0);&#125;int trans(char c)&#123; if(c=='*') return 0; if(c=='x') return 1; return 2;&#125;int cur[MAXN],dis[MAXN],flow[MAXN],dep[MAXN];queue&lt;int&gt; q;bool bfs(int S,int T)&#123; for(int i=1;i&lt;=T;++i) cur[i]=head[i]; memset(dep,-1,sizeof dep); dep[S]=0; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u];i!=-1;i=E[i].nx) &#123; int v=E[i].to; if(dep[v]==-1 &amp;&amp; E[i].flow) &#123; dep[v]=dep[u]+1; q.push(v); &#125; &#125; &#125; return dep[T]!=-1;&#125;int dfs(int u,int T,int limit)&#123; if(u==T || !limit) return limit; int f,Flow=0; for(int i=cur[u];i!=-1;i=E[i].nx) &#123; cur[u]=i; int v=E[i].to; if(dep[v]==dep[u]+1 &amp;&amp; (f=dfs(v,T,min(limit,E[i].flow)))) &#123; Flow+=f; limit-=f; E[i].flow-=f; E[i^1].flow+=f; if(!limit) break; &#125; &#125; return Flow;&#125;int Dinic(int S,int T)&#123; int Maxflow=0; while(bfs(S,T)) Maxflow+=dfs(S,T,inf); return Maxflow;&#125;void solve()&#123; for(int i=1;i&lt;=n;++i) &#123; ++tx; for(int j=1;j&lt;=m;++j) &#123; bx[i][j]=tx; if(Map[i][j]==2) ++tx; &#125; &#125; for(int j=1;j&lt;=m;++j) &#123; ++ty; for(int i=1;i&lt;=n;++i) &#123; by[i][j]=ty; if(Map[i][j]==2) ++ty; &#125; &#125; int S=tx+ty+1,T=tx+ty+2; for(int i=1;i&lt;=tx;++i) ins(S,i,1); for(int i=1;i&lt;=ty;++i) ins(i+tx,T,1); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) if(!Map[i][j]) ins(bx[i][j],by[i][j]+tx,1); cout&lt;&lt;Dinic(S,T)&lt;&lt;endl;&#125;int main()&#123; memset(head,-1,sizeof head); n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; scanf("%s",buf+1); for(int j=1;j&lt;=m;++j) Map[i][j]=trans(buf[j]); &#125; solve(); return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4553 序列]]></title>
    <url>%2F2019%2F07%2F08%2Fbzoj-4553-%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[$cdq$ 分治处理三维偏序. 记位置 $i$ 原本的值为 $a_i$ ,可能出现的最大值为 $mx_i$ ,可能出现的最小值为 $mn_i$ .像普通的 $LIS$ 那样,设 $f(i)$ 表示必须以第 $i$ 个数结尾的 $LIS$ 长度. 因为每次只能有一个位置被修改,不难发现完成转移 $f(i)\leftarrow f(j)+1$ 需要同时满足三个条件, $mx_j\leq a_i,a_j\leq mn_i,j&lt;i​$ . 就是一个三维偏序,贡献又是可结合的,于是用 $cdq$ 分治处理即可.时间复杂度 $O(n\cdot log^2n)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,m,a[MAXN],mx[MAXN],mn[MAXN];int f[MAXN];struct FenwickTree&#123; int bit[MAXN]; FenwickTree()&#123;memset(bit,0,sizeof bit);&#125;#define lowbit(x) x&amp;(-x) void add(int x,int c) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]=max(bit[x],c); &#125; void rst(int x) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]=0; &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s=max(s,bit[x]); return s; &#125;&#125;T;struct opt&#123; int x,y,pos; bool operator &lt; (const opt &amp;rhs) const &#123; return y==rhs.y?pos&lt;=rhs.pos:y&lt;=rhs.y; &#125;&#125;q[MAXN];void cdq(int L,int R)&#123; if(L==R) return; int mid=(L+R)&gt;&gt;1; cdq(L,mid); int tot=0; for(int i=L;i&lt;=R;++i) &#123; q[++tot].pos=i; if(i&lt;=mid) q[tot].x=mx[i],q[tot].y=a[i]; else q[tot].x=a[i],q[tot].y=mn[i]; &#125; sort(q+1,q+1+tot); for(int i=1;i&lt;=tot;++i) &#123; if(q[i].pos&lt;=mid) T.add(q[i].x,f[q[i].pos]); else f[q[i].pos]=max(f[q[i].pos],T.sum(q[i].x)+1); &#125; for(int i=1;i&lt;=tot;++i) if(q[i].pos&lt;=mid) T.rst(q[i].x); cdq(mid+1,R);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; mx[i]=mn[i]=a[i]=read(); f[i]=1; &#125; for(int i=1;i&lt;=m;++i) &#123; int pos=read(),x=read(); mx[pos]=max(mx[pos],x); mn[pos]=min(mn[pos],x); &#125; cdq(1,n); cout&lt;&lt;f[n]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>cdq分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Beginner Contest 133]]></title>
    <url>%2F2019%2F07%2F08%2FAtcoder-Beginner-Contest-133%2F</url>
    <content type="text"><![CDATA[$F$ 没调出来,炸了. C Remainder Minimization 2019 可以直接大力枚举两个余数是多少,再判断它们是否合法,合法就计入贡献. 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;bool judge(int a,int b,int L,int R)&#123; if(R&lt;a || R&lt;b) return false; int L1=(L-a+2018)/2019,R1=(R-a)/2019; int L2=(L-b+2018)/2019,R2=(R-b)/2019; if(L1&gt;R1 || L2&gt;R2) return false; if(a&lt;b) return L1&lt;=R2; else return L1&lt;R2;&#125;int main()&#123; int L=read(),R=read(); int ans=2019; for(int i=0;i&lt;2019;++i) for(int j=0;j&lt;2019;++j) if(judge(i,j,L,R)) ans=min(ans,i*j%2019); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D Rain Flows into Dams 设第 $i$ 座山收到的水为 $x_i$ ,可以把题目中所给的条件表示为方程组的形式. 题目保证 $x$ 有唯一的一组合法解,所以直接将这个方程组解出来,得到的就是那组合法解,过程中不必判断. 尝试手动解.首先将所有方程加起来可以得到 $\sum x_i$ .每两个相邻的方程相减可以得到 $x_3-x_1,x_4-x_2,x_5-x_3,x_6-x_4\dots$ 这些值. 求前缀和就可以得到每个奇数位置与 $x_1$ 的差值,每个偶数位置与 $x_2$ 的差值.再根据 $x_n+x_1$ 将 $x_1$ 以及所有奇数位置的 $x$ 解出,用 $\sum x_i$ 减去奇数位置的总和,得到偶数位置的总和,再根据求得的差分解出所有偶数位置 $x$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n;ll sum=0,a[MAXN],t[MAXN],x[MAXN];void pr()&#123; for(int i=1;i&lt;=n;++i) printf("%lld ",x[i]); puts("");&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) sum+=(a[i]=read()); for(int i=3;i&lt;=n;i+=2) &#123; t[i]=a[i-1]-a[i-2]; t[i]+=t[i-2]; &#125; x[1]=a[n]-t[n]; for(int i=1;i&lt;=n;i+=2) sum-=(x[i]=x[1]+2*(t[i])); if(n==3) &#123; x[2]=sum; pr(); return 0; &#125; ll tot=0,cnt=1; for(int i=4;i&lt;n;i+=2) &#123; t[i]=2*(a[i-1]-a[i-2]); t[i]+=t[i-2]; tot+=t[i]; ++cnt; &#125; x[2]=(sum-tot)/(cnt); for(int i=4;i&lt;n;i+=2) x[i]=x[2]+t[i]; pr(); return 0;&#125; E Virus Tree 2 只需满足每个点与它的父亲颜色不同,每个点与它父亲的父亲颜色不同,每个点的所有儿子颜色不同. 设 $f(i)$ 表示当节点 $i$ 的颜色已被确定时,子树 $i$ 内染色的方案数,随便 $dfs$ 一下即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],ecnt=0;void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a + b) % P;&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int fac[MAXN],invfac[MAXN];int n,k,f[MAXN],Deg[MAXN];int fa[MAXN];int A(int N,int M)&#123; if(N&gt;M) return 0; return mul(fac[M],invfac[M-N]);&#125;int dfs(int u,int num,int Fa)&#123; fa[u]=Fa; if(num&lt;=0) return f[u]=0; int deg=(u==1?Deg[u]:Deg[u]-1); if(!deg) return f[u]=1; if(u==1) f[u]=A(deg,k-1); else f[u]=A(deg,k-2); if(!f[u]) return f[u]; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==Fa) continue; if(u==1) dfs(v,k-1,u); else dfs(v,k-2,u); f[u]=mul(f[u],f[v]); &#125; return f[u];&#125;int main()&#123; n=read(),k=read(); fac[1]=1; for(int i=2;i&lt;=k;++i) fac[i]=mul(fac[i-1],i); invfac[k]=fpow(fac[k],P-2); for(int i=k-1;i&gt;=0;--i) invfac[i]=mul(invfac[i+1],i+1); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); ++Deg[u],++Deg[v]; &#125; cout&lt;&lt;mul(dfs(1,k,0),k)&lt;&lt;endl; return 0;&#125; F Colorful Tree 不难发现对于每个询问 $(x,y,u,v)$ 只需要找出 $u\to v$ 的路径上颜色为 $x$ 的边的数目 $cnt$ 以及这些边的总长度 $sum$ .答案就是 $dist(u,v)-sum+cnt\cdot y$ . 询问一段区间某种颜色的数目/权值和,用主席树进行维护.时间复杂度 $O(n\cdot log^n)$ . 树上的主席树并不需要像线段树那样维护 $dfs$ 序.直接在第一次 $dfs$ 时每个点复制父亲的信息,再修改即可.询问就是 $rt[u]+rt[v]-rt[LCA]-rt[LCA.fa]$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;struct Edge&#123; int nx,to;&#125;E[MAXN&lt;&lt;1];int head[MAXN],ecnt=0;int col[MAXN],val[MAXN];void addedge(int u,int v)&#123; ++ecnt; E[ecnt].nx=head[u]; E[ecnt].to=v; head[u]=ecnt;&#125;void ins(int u,int v)&#123; addedge(u,v); addedge(v,u);&#125;int n,m;int dfn[MAXN],idx=0;int dep[MAXN],fa[MAXN],top[MAXN];int siz[MAXN],mxson[MAXN],dist[MAXN];struct PreSegTree&#123; int nodeidx; struct node &#123; int cnt,sum; int ls,rs; &#125;Tree[MAXN*30]; PreSegTree()&#123;nodeidx=0;Tree[0].cnt=Tree[0].sum=0;&#125;#define root Tree[o] void upd(int &amp;o,int pre,int l,int r,int pos,int c) &#123; o=++nodeidx; root=Tree[pre]; if(!pos) return; if(l==r) &#123; root.cnt++; root.sum+=c; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(root.ls,Tree[pre].ls,l,mid,pos,c); else upd(root.rs,Tree[pre].rs,mid+1,r,pos,c); &#125; int query_sum(int o,int l,int r,int pos) &#123; if(!o) return root.sum; if(l==r) return root.sum; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) return query_sum(root.ls,l,mid,pos); else return query_sum(root.rs,mid+1,r,pos); &#125; int query_cnt(int o,int l,int r,int pos) &#123; if(!o) return root.cnt; if(l==r) return root.cnt; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) return query_cnt(root.ls,l,mid,pos); else return query_cnt(root.rs,mid+1,r,pos); &#125;&#125;T;int rt[MAXN];void dfs1(int u,int Fa)&#123; fa[u]=Fa; dep[u]=dep[Fa]+1; siz[u]=1; T.upd(rt[u],rt[Fa],1,n,col[u],val[u]); for(int i=head[u];i;i=E[i].nx) &#123; int v=E[i].to; if(v==Fa) continue; dist[v]=dist[u]+val[v]; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; top[u]=tp; if(mxson[u]) dfs2(mxson[u],tp); for(int i=head[u];i;i=E[i].nx) &#123; int v=E[i].to; if(v==fa[u] || v==mxson[u]) continue; dfs2(v,v); &#125;&#125;void init()&#123; dfs1(1,0); dfs2(1,1);&#125;int getLCA(int x,int y)&#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=fa[top[x]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;int Solve(int c,int d,int x,int y)&#123; int LCA=getLCA(x,y); int cnt=0,sum=0; cnt+=T.query_cnt(rt[x],1,n,c)+T.query_cnt(rt[y],1,n,c); cnt-=T.query_cnt(rt[LCA],1,n,c)+T.query_cnt(rt[fa[LCA]],1,n,c); sum+=T.query_sum(rt[x],1,n,c)+T.query_sum(rt[y],1,n,c); sum-=T.query_sum(rt[LCA],1,n,c)+T.query_sum(rt[fa[LCA]],1,n,c); int res=dist[x]+dist[y]-dist[LCA]-dist[fa[LCA]]; return res-sum+d*cnt;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); col[n+i]=read(),val[n+i]=read(); ins(u,n+i); ins(v,n+i); &#125; n=2*n-1; init(); while(m--) &#123; int x=read(),y=read(); int u=read(),v=read(); printf("%d\n",Solve(x,y,u,v)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Atcoder</tag>
        <tag>树形dp</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4551 树]]></title>
    <url>%2F2019%2F07%2F06%2Fbzoj-4551-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[并查集. 大力用树剖 + 树状数组维护是 $O(n\cdot log^3n)$ 的. 考虑先将操作先全部离线下来,每个标记都打上,对于没有被打标记的点,用并查集将它与它的父亲合并. 然后从后往前处理操作,遇到询问就直接回答,遇到修改,其实是给某个点的标记次数 $-1$ ,删除后用并查集合并. 时间复杂度 $O(n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,Q;char buf[2];int head[MAXN],to[MAXN],nx[MAXN],ecnt=0;void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;struct opt&#123; int tp,x;&#125;q[MAXN];struct dsu&#123; int fa[MAXN]; void init() &#123; for(int i=1;i&lt;=n;++i) fa[i]=i; &#125; int Find(int x) &#123; if(x==fa[x]) return x; return (fa[x]=Find(fa[x])); &#125; void Merge(int u,int v) &#123; u=Find(u),v=Find(v); if(u!=v) fa[u]=v; &#125;&#125;DSU;int flag[MAXN],Fa[MAXN];void dfs(int u,int f)&#123; Fa[u]=f; if(!flag[u]) DSU.Merge(u,f); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; dfs(v,u); &#125;&#125;int ans[MAXN],tot=0;int main()&#123; n=read(),Q=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); &#125; flag[1]=1; for(int i=1;i&lt;=Q;++i) &#123; scanf("%s",buf); q[i].tp=(buf[0]=='C'); q[i].x=read(); if(q[i].tp) ++flag[q[i].x]; else ++tot; &#125; int pt=tot; DSU.init(); dfs(1,0); for(int i=Q;i&gt;=1;--i) &#123; int tp=q[i].tp,x=q[i].x; if(!tp) &#123; x=DSU.Find(x); ans[pt--]=x; &#125; else &#123; --flag[x]; if(!flag[x]) DSU.Merge(x,Fa[x]); &#125; &#125; for(int i=1;i&lt;=tot;++i) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4552 排序]]></title>
    <url>%2F2019%2F07%2F04%2Fbzoj-4552-%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[二分 + 线段树. 开始以为是中间有多次询问,想了两节课.读题发现,只在最后询问一次,那就很友好了. 操作/贡献都只与相对大小有关,经典套路就是二分答案,将数列变为 $0/1$ 数列,就可以直接用线段树维护了. 时间复杂度 $O(m\cdot log^2n)$ . 修改操作注意特判 $L&gt;R$ 的情况. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,m,q,a[MAXN];struct SegTree&#123; struct node &#123; int sum,tag; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.sum=lson.sum+rson.sum; &#125; void BuildTree(int o,int l,int r,int k) &#123; root.tag=-1; if(l==r) &#123; if(a[l]&gt;=k) root.sum=1; else root.sum=0; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid,k); BuildTree(o&lt;&lt;1|1,mid+1,r,k); pushup(o); &#125; void Modifiy(int o,int l,int r,int c) &#123; root.sum=(r-l+1)*c; root.tag=c; &#125; void pushdown(int o,int l,int r) &#123; if(root.tag!=-1) &#123; int mid=(l+r)&gt;&gt;1; Modifiy(o&lt;&lt;1,l,mid,root.tag); Modifiy(o&lt;&lt;1|1,mid+1,r,root.tag); root.tag=-1; &#125; &#125; void upd(int o,int l,int r,int L,int R,int c) &#123; if(L&gt;R) return; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; Modifiy(o,l,r,c); return; &#125; pushdown(o,l,r); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125; int query(int o,int l,int r,int L,int R) &#123; if(L&gt;R) return 0; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; pushdown(o,l,r); int mid=(l+r)&gt;&gt;1; int res=0; if(L&lt;=mid) res+=query(o&lt;&lt;1,l,mid,L,R); if(R&gt;mid) res+=query(o&lt;&lt;1|1,mid+1,r,L,R); return res; &#125;&#125;T;struct opt&#123; int op,L,R;&#125;Q[MAXN];bool check(int k)&#123; T.BuildTree(1,1,n,k); for(int i=1;i&lt;=m;++i) &#123; int L=Q[i].L,R=Q[i].R; int tot1=T.query(1,1,n,L,R); int tot0=R-L+1-tot1; if(Q[i].op==0) &#123; T.upd(1,1,n,L,L+tot0-1,0); T.upd(1,1,n,L+tot0,R,1); &#125; else &#123; T.upd(1,1,n,L,L+tot1-1,1); T.upd(1,1,n,L+tot1,R,0); &#125; &#125; return (bool)(T.query(1,1,n,q,q));&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=1;i&lt;=m;++i) &#123; Q[i].op=read(); Q[i].L=read(); Q[i].R=read(); &#125; q=read(); int L=1,R=n,ans=-1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid)) ans=mid,L=mid+1; else R=mid-1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4550 小奇的博弈]]></title>
    <url>%2F2019%2F07%2F02%2Fbzoj-4550-%E5%B0%8F%E5%A5%87%E7%9A%84%E5%8D%9A%E5%BC%88%2F</url>
    <content type="text"><![CDATA[$Nimk$ 游戏 + $dp$ 计数. 最优策略下,白棋显然都选择右移,黑棋都选择左移.如果把每对棋子的间隔长度看做一堆石子的石子数目,那么此题就是一个 $Nim$ 游戏的变种,每次最多可以选 $d$ 堆石子进行操作.这个东西叫做 $Nimk$ 游戏. $Nimk$ 游戏先手必败条件:对于每个二进制位 $i$ ,所有石子数目的第 $i$ 位之和为 $d+1$ 的倍数. 即, $\forall i,(\sum_j(a_j&gt;&gt;i)\&amp;1)\mod d+1=0​$ . 转成 $Nimk$ 模型,有 $\frac k 2$ 堆石子,石子总数不超过 $n-k$ 个.求必胜方案数可以用总方案数 $n \choose k$ 减去必败方案数. 令 $f(i,j)$ 表示从第 $0$ 位开始算,已经考虑了二进制的前 $i$ 位,用掉了 $j$ 个石子的方案数.转移有: $$f(i+1,j+x\cdot (d+1)\cdot 2^i)+=f(i,j)\cdot {k/2 \choose x\cdot(d+1)}$$ 枚举 $x$ 进行转移,必败方案数就是 $\sum f(inf,j)\cdot {n-j-k/2\choose k/2}$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;const int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;inline void upd(int &amp;a,int b)&#123; a=add(a,b);&#125;const int MAXK=101,MAXN=1e4+10;int C[MAXN][MAXK],f[20][MAXN];int main()&#123; int n=read(),k=read(),d=read(); C[0][0]=1; for(int i=1;i&lt;=n;++i) &#123; C[i][0]=1; for(int j=1;j&lt;=i &amp;&amp; j&lt;=k;++j) C[i][j]=add(C[i-1][j],C[i-1][j-1]); &#125; f[0][0]=1; for(int i=0;i&lt;=16;++i) for(int j=0;j&lt;=n-k;++j) for(ll x=0;x*(d+1)&lt;=k/2 &amp;&amp; x*(d+1)*(1LL&lt;&lt;i)+j&lt;=n-k;++x) upd(f[i+1][x*(d+1)*(1&lt;&lt;i)+j],mul(f[i][j],C[k/2][x*(d+1)])); int ans=0; for(int j=0;j&lt;=n-k;++j) upd(ans,mul(f[16][j],C[n-j-k/2][k/2])); ans=add(-ans,C[n][k]); ans%=P,ans+=P,ans%=P; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4548 小奇的糖果]]></title>
    <url>%2F2019%2F06%2F29%2Fbzoj-4548-%E5%B0%8F%E5%A5%87%E7%9A%84%E7%B3%96%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[树状数组. 题面有些歧义,线段上/下方的点是指横坐标也落在线段范围内的点.不包含所有颜色是指不包含所有 $k$ 种颜色. 要求不包含所有颜色,即至少有一种颜色没有包含.可以枚举这个颜色 $c$ ,计算不包含 $c$ 时的最大收益. 把所有点按照 $y$ 坐标从小到大排序,依次处理.如果对某一个点,以它的 $y$ 坐标为下边界画矩形,贪心画最大的,往两边拓展,直到遇到不能选的颜色为止.这个就是在对应颜色的 $set$ 里面找一下前驱后继. 以它的 $y$ 坐标为上边界同理,将 $y$ 坐标从大到小排序做上面过程即可.画矩形时的收益用树状数组维护. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;struct node&#123; int x,y,col; bool operator &lt; (const node &amp;rhs) const &#123; return y&lt;rhs.y; &#125;&#125;a[MAXN];int n,m,ans=0,v[MAXN];struct FenwickTree&#123; int bit[MAXN]; void init()&#123;memset(bit,0,sizeof bit);&#125;#define lowbit(x) x&amp;(-x) void add(int x,int c) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=c; &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x]; return s; &#125;&#125;T;set&lt;int&gt; s[MAXN];set&lt;int&gt;::iterator it;void solve()&#123; T.init(); for(int i=1;i&lt;=m;++i) &#123; s[i].clear(); s[i].insert(0); s[i].insert(n+1); &#125; for(int i=1,j=1;i&lt;=n;i=j) &#123; while(j&lt;=n &amp;&amp; a[j].y==a[i].y) ++j; for(int k=i;k&lt;j;++k) &#123; int tmp=T.sum(*s[a[k].col].lower_bound(a[k].x)-1); tmp-=T.sum(*--s[a[k].col].upper_bound(a[k].x)); ans=max(ans,tmp); &#125; for(int k=i;k&lt;j;++k) &#123; T.add(a[k].x,1); s[a[k].col].insert(a[k].x); &#125; &#125; for(int i=1;i&lt;=m;++i) for(it=s[i].begin();*it!=n+1;) &#123; int j=*it; ++it; ans=max(ans,T.sum(*it-1)-T.sum(j)); &#125;&#125;int main()&#123; int C=read(); while(C--) &#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; a[i].x=read(); a[i].y=read(); a[i].col=read(); v[i]=a[i].x; &#125; sort(a+1,a+1+n); sort(v+1,v+1+n); int cnt=unique(v+1,v+1+n)-v-1; for(int i=1;i&lt;=n;++i) a[i].x=lower_bound(v+1,v+1+cnt,a[i].x)-v; ans=0; solve(); for(int i=1;i*2&lt;=n;++i) swap(a[i],a[n+1-i]); solve(); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190629]]></title>
    <url>%2F2019%2F06%2F29%2Ftest20190629%2F</url>
    <content type="text"><![CDATA[$\%\ nicodafagood$ . $quadratic$ 给 $n$ 个二次项系数为 $1$ 的二次函数,分别求 $x=1\sim n$ 时这 $n$ 个函数中的最小值. $n\leq 10^5$ . 因为二次项贡献固定,所以只需要算一次项和常数项的贡献,就相当于 $n$ 条直线在某个位置的最小值. 用凸包或者李超线段树写一下就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;int n;int A[MAXN],B[MAXN];ll k[MAXN],b[MAXN];const ll inf=1e18;inline ll calc(int seg,int x)&#123; return k[seg]*x+b[seg];&#125;inline int sgn(ll x)&#123; if(!x) return 0; return x&lt;0?-1:1;&#125;ll ans;struct SegTree&#123; int nodecnt; SegTree()&#123;nodecnt=0;&#125; struct node &#123; int ls,rs,id; ll mi; node()&#123;ls=rs=id=0;mi=inf;&#125; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[root.ls]#define rson Tree[root.rs] void BuildTree(int l,int r) &#123; int o=++nodecnt; if(l==r) return; int mid=(l+r)&gt;&gt;1; root.ls=nodecnt+1; BuildTree(l,mid); root.rs=nodecnt+1; BuildTree(mid+1,r); &#125; void pushup(int o,int l,int r) &#123; if(root.id) root.mi=k[root.id]&lt;0?calc(root.id,r):calc(root.id,l); else root.mi=inf; if(l&lt;r) &#123; root.mi=min(root.mi,lson.mi); root.mi=min(root.mi,rson.mi); &#125; &#125; void upd(int o,int l,int r,int L,int R,int seg) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; if(!root.id) &#123; root.id=seg; pushup(o,l,r); return; &#125; bool f1=calc(root.id,l)&lt;calc(seg,l); bool f2=calc(root.id,r)&lt;calc(seg,r); if(f1==f2 || l==r) &#123; if(!f1) &#123; root.id=seg; pushup(o,l,r); &#125; return; &#125; int mid=(l+r)&gt;&gt;1; bool f3=calc(root.id,mid)&lt;calc(seg,mid); if(f1==f3) &#123; if(f1) upd(root.rs,mid+1,r,L,R,seg); else upd(root.rs,mid+1,r,L,R,root.id),root.id=seg; &#125; else &#123; if(f1) upd(root.ls,l,mid,L,R,root.id),root.id=seg; else upd(root.ls,l,mid,L,R,seg); &#125; &#125; else &#123; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(root.ls,l,mid,L,R,seg); if(R&gt;mid) upd(root.rs,mid+1,r,L,R,seg); &#125; pushup(o,l,r); &#125; void query(int o,int l,int r,int pos) &#123; if(root.id) &#123; if(k[root.id]&lt;0) ans=min(ans,calc(root.id,min(r,pos))); else ans=min(ans,calc(root.id,max(l,pos))); &#125; if(l==r) &#123; ans=min(ans,root.mi); return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) query(root.ls,l,mid,pos); else query(root.rs,mid+1,r,pos); &#125;&#125;T;int main()&#123; freopen("quadratic.in","r",stdin); freopen("quadratic.out","w",stdout); n=read(); b[0]=inf; for(int i=1;i&lt;=n;++i) A[i]=read(); T.BuildTree(1,n); for(int i=1;i&lt;=n;++i) &#123; B[i]=read(); k[i]=-2LL*A[i]; b[i]=1LL*A[i]*A[i]+B[i]; T.upd(1,1,n,1,n,i); &#125; for(int i=1;i&lt;=n;++i) &#123; ans=inf; T.query(1,1,n,i); printf("%lld\n",ans+1LL*i*i); &#125; return 0;&#125; $equation$ 给定 $a,b,p,x$ ,求解 $[1,x]$ 中,满足 $n\cdot a^n\equiv b \mod p$ 的 $n$ 的数目. $0\leq a,b&lt;p\leq 10^6.x\leq 10^{12}.$ 保证 $p$ 为质数. 根据费马小定理,指数可以对 $p-1$ 取模.而 $p$ 的范围比较小,于是直接枚举 $n$ 对 $p-1$ 取模的结果 $i$. 即,在 $[0,p-2]$ 内枚举 $i$ ,对应贡献为满足下面两个条件的 $n$ 的数目. $$n\equiv i (mod\ p-1),n\equiv b\cdot a^{-i}(mod\ p)$$ 用 $CRT$ 求解 $p\cdot (p-1)$ 内的 $n$ ,再计算 $[1,x]$ 内对应 $n$ 数目即可. 时间复杂度 $O(p\cdot logp)$ . $datastructure$ 给定一个长度为 $n$ 的正整数数列 $a$ ,要求支持下列操作,共 $m$ 次. 将区间 $[l,r]$ 内的元素加上 $x$ . 将区间 $[l,r]$ 内的元素开平方,向下取整. 询问区间 $[l,r]$ 内的元素平方总和. 询问区间 $[l,r]$ 内的元素总和. $n,m\leq 10^5,1\leq a_i,x\leq 10^9$ . 考虑用线段树维护询问的答案. 有一档部分分是没有操作 $1$ 的,可以直接做,对每个区间记录元素是否都是 $1$ ,开方时讨论即可. 正解做法类似,不过优化的方法不同.开方 $[l,r]$ 时,先询问 $[l,r]$ 内的最大值 $a$ 与最小值 $b$ . 开方时都向下取整,若 $\sqrt {a}=\sqrt {b}$ ,就将这个区间全部修改为 $\sqrt a$ .若 $a-\sqrt a=b-\sqrt b$ ,就给这个区间全部减去 $a-\sqrt a$ ,因为这个差是关于元素大小不下降的. 若两种情况都不满足,就暴力修改区间内所有元素. 因为一次区间加最多会使得 $logn$ 个结点的 $a-b$ 变化,而变化后我们最多暴力开 $6$ 次方它就变成 $1$ 了,所以操作 $1,2$ 复杂度均摊下来,一次为 $O(logn)$ .于是总时间复杂度 $O(nlogn)$ . $unsigned\ long\ long$ 输出指令是 $\%llu$ .考试写成 $\%u$ 了. $70\to 15$ .]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>数学</tag>
        <tag>test</tag>
        <tag>李超线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1186]]></title>
    <url>%2F2019%2F06%2F29%2FCF1186%2F</url>
    <content type="text"><![CDATA[$Div.2$ 冲上来就 $pp$ 了前 $4$ 个题,感觉终于可以上个分,然后就 $Unrated$ 了. A Vus the Cossack and a Contest 签到题. 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int main()&#123; int n=read(),m=read(),k=read(); if(n&lt;=m &amp;&amp; n&lt;=k) puts("Yes"); else puts("No"); return 0;&#125; B Vus the Cossack and a Game 题已经被爆破了. 有一个 $n\times m$ 的网格,要在里面放上若干 $1\times 2$ 的骨牌,要求任意两个八连通的格子不能被同时占据,求最多放置的骨牌数目. $n,m\leq 10^9$ . 暂时还不知道有没有可行的做法. C Vus the Cossack and Strings 其实可以直接算 $1$ 的个数是否相同,若相同,则不同的位置一定是偶数个. 因为两个 $1$ 如果对齐放,没有贡献,如果错开放,贡献是 $2$ ,也相当于没有贡献. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;int n,m,a[MAXN],b[MAXN];char buf[MAXN];int k[MAXN];void init()&#123; scanf("%s",buf+1); n=strlen(buf+1); for(int i=1;i&lt;=n;++i) a[i]=buf[i]-'0'; scanf("%s",buf+1); m=strlen(buf+1); for(int i=1;i&lt;=m;++i) b[i]=buf[i]-'0';&#125;int query(int l,int r)&#123; return k[r]^k[l-1];&#125;int main()&#123; init(); for(int i=2;i&lt;=n;++i) if(a[i]!=a[i-1]) k[i]^=1; for(int i=1;i&lt;=n;++i) k[i]^=k[i-1]; int ans=0,s=0; for(int i=1;i&lt;=m;++i) if(a[i]!=b[i]) s^=1; if(s==0) ++ans; for(int i=2;i+m-1&lt;=n;++i) &#123; s^=query(i,i+m-1); if(s==0) ++ans; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D Vus the Cossack and Numbers 考虑如果将所有数都向下取整,得到的和为 $-sum$ ,那么显然需要将 $sum$ 个数改成向上取整. 只要不是整数都能改,所以改掉 $sum$ 个就可以了. 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;const double eps=1e-8;int n;double a[MAXN],upv[MAXN],downv[MAXN],delta[MAXN];bool flag[MAXN];void pr()&#123; for(int i=1;i&lt;=n;++i) printf("%d\n",flag[i]?(int)ceil(a[i]):(int)floor(a[i]));&#125;int main()&#123; n=read(); double sum=0; for(int i=1;i&lt;=n;++i) &#123; scanf("%lf",&amp;a[i]); upv[i]=ceil(a[i])-a[i]; downv[i]=floor(a[i])-a[i]; delta[i]=upv[i]-downv[i]; sum-=downv[i]; &#125; for(int i=1;i&lt;=n &amp;&amp; fabs(sum)&gt;eps;++i) if(fabs(delta[i])&gt;eps) flag[i]=true,sum-=1.0; pr(); return 0;&#125; E Vus the Cossack and a Field 可以直接算二维前缀和再相减.记 $f(x,y)$ 表示以 $(1,1)$ 为左上角, $(x,y)$ 为右下角的子矩形的权值和. 那么答案就是 $f(x_2,y_2)-f(x_2,y_1-1)-f(x_1-1,y_2)+f(x_1-1,y_1-1)$ . 先预处理出 $x\leq n,y\leq m$ 内的 $f(x,y)$ ,就是二维前缀和. 然后计算所有的 $f(x,y)$ ,就可以将它分割成整的块的不整的块,不整的块用预处理的前缀和算就好了. F Vus the Cossack and a Graph 待更. 有个贪心的假做法,不知道为什么很多人都用这个水过去了.]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4547 小奇的集合]]></title>
    <url>%2F2019%2F06%2F27%2Fbzoj-4547-%E5%B0%8F%E5%A5%87%E7%9A%84%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[贪心 + 矩阵快速幂. 显然可以贪心,每次取最大的两个数加起来.答案为初始所有元素之和加上每次操作加入的数. 记初始时最大数为 $a$ ,次大数为 $b$ ,因为题目保证答案非负,所以 $a,b$ 不可能都为负. 若 $a,b$ 都非负,那么加入的数就是一个类斐波那契数列,用矩阵快速幂加速计算就可以了. 若 $a&gt;0$ , $b&lt;0$ ,那么就先算出最少要加几次能使得有两个非负数.只要 $k$ 不为 $0$ ,又保证最终答案为非负,那么一定能在 $k$ 次之内得到两个非负数. 这部分贡献可以直接算出,然后再对剩余次数计算类斐波那契数列部分的贡献即可. 记得答案 $+$ 模数后再输出. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=0x7fffffff;const int P=1e7+7;const int inv2=(P+1)&gt;&gt;1;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;struct Matrix&#123; int A[3][3]; Matrix()&#123;memset(A,0,sizeof A);&#125; Matrix operator * (const Matrix &amp;rhs) const &#123; Matrix res; for(int k=0;k&lt;3;++k) for(int i=0;i&lt;3;++i) for(int j=0;j&lt;3;++j) res.A[i][j]=add(res.A[i][j],mul(A[i][k],rhs.A[k][j])); return res; &#125;&#125;;Matrix fpow(Matrix a,int b)&#123; Matrix res; for(int i=0;i&lt;3;++i) res.A[i][i]=1; while(b) &#123; if(b&amp;1) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;int calc(int a,int b,int k)&#123; assert(k&gt;=0); Matrix trans,st; trans.A[0][0]=trans.A[0][1]=1; trans.A[1][0]=1; trans.A[2][0]=trans.A[2][1]=trans.A[2][2]=1; st.A[0][0]=a; st.A[1][0]=b; st=fpow(trans,k)*st; return st.A[2][0];&#125;int main()&#123; int n=read(),k=read(),ans=0; int a=-inf,b=-inf; while(n--) &#123; int x=read(); ans=add(ans,x); if(x&gt;a) b=a,a=x; else if(x&gt;b) b=x; &#125; if(a&gt;=0 &amp;&amp; b&gt;=0) ans=add(ans,calc(a,b,k)); else &#123; int tmp=(-b+a-1)/a; ans=add(ans,mul(tmp,b)); ans=add(ans,mul(a,mul(inv2,mul(tmp+1,tmp)))); k-=tmp; b=tmp*a+b; if(b&gt;a) swap(a,b); ans=add(ans,calc(a,b,k)); &#125; cout&lt;&lt;add(ans,P)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>矩阵优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1041 圆上的整点]]></title>
    <url>%2F2019%2F06%2F26%2Fbzoj-1041-%E5%9C%86%E4%B8%8A%E7%9A%84%E6%95%B4%E7%82%B9%2F</url>
    <content type="text"><![CDATA[有技巧的大力枚举. 求 $x^2+y^2=r^2$ 的整数解组数,只需要求出 $x,y&gt;0$ 的组数,再 $\times 4,+4$ 即为答案. 方程变形得到 $y^2=(r+x)(r-x)$ ,记 $d=gcd(r+x,r-x)$ ,则 $y^2=d^2\cdot \frac {r+x} d \cdot \frac {r-x} d$ . 记 $u^2=\frac {r+x} d,v^2=\frac {r-x} d,u&gt;v&gt;0$ .则 $2r=d(u^2+v^2),2x=d(u^2-v^2),y=uvd$ . 因为 $d$ 是 $2r$ 的约数,所以大力枚举 $d$ ,再大力枚举 $u$ ,计算出 $v$ 后再验证 $u&gt;v$ 及 $gcd(u,v)=1$ 是否成立即可. 时间复杂度 $O(r^{3\over 4} \cdot \log r)​$ .实际上跑不满,因为枚举 $d​$ 是 $O(r^{1\over 2})​$ 的,而只有 $d​$ 为 $2r​$ 约数时才枚举 $u​$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;ll gcd(ll a,ll b)&#123; if(!b) return a; return gcd(b,a%b);&#125;int check(ll r,ll d,ll u)&#123; ll v2=2*r/d-u*u; ll v=sqrt(v2); if(v*v!=v2) return 0; if(u&lt;=v) return 0; ll x=d*(u*u-v*v); if(x&amp;1) return 0; x/=2; if(gcd(u,v)!=1) return 0; return 1;&#125;int main()&#123; ll r=read(); ll ans=0; for(ll d=1;d*d&lt;=2*r;++d) &#123; if(2*r%d==0) &#123; for(ll u=1;u*u&lt;2*r/d;++u) ans+=check(r,d,u); ll D=2*r/d; if(D!=d) &#123; for(ll u=1;u*u&lt;2*r/D;++u) ans+=check(r,D,u); &#125; &#125; &#125; ans*=4; ans+=4; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4538 网络]]></title>
    <url>%2F2019%2F06%2F25%2Fbzoj-4538-%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[整体二分 + 树状数组. 如果断掉一个点,将经过它的链给撤去,就会比较麻烦.换一个思路,二分答案 $mid$ ,如果所有权值 $\geq mid$ 的链都经过了它,那么真实答案就 $\leq mid$ ,否则 $\geq mid$ . 于是只加入权值 $\geq mid$ 的链,判断该点被覆盖的次数.链的覆盖有一个比较经典的套路,若一条链首尾是 $u,v$ ,就将 $u,v$ 处的权值 $+1$ ,将 $u,v$ 的 $lca$ 以及 $lca$ 的父亲节点的权值 $-1$ ,查询一个点 $x$ 被覆盖的次数,就是查询子树 $x$ 内所有点的权值和.这个可以用一个树状数组来实现. 这些操作是满足整体二分的要求的,所以再套一个整体二分一起处理.时间复杂度 $O(nlog^2n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int n,m,ans[MAXN],qcnt=0;struct Node&#123; int type,id; int a,b,v,t,x;&#125;q[MAXN&lt;&lt;2],ql[MAXN],qr[MAXN];struct FenwickTree&#123;#define lowbit(x) x&amp;(-x) int bit[MAXN]; void add(int x,int c) &#123; if(!x) return; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=c; &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x]; return s; &#125; int query(int l,int r) &#123; return sum(r)-sum(l-1); &#125;&#125;T;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int fa[MAXN],mxson[MAXN],siz[MAXN];int dep[MAXN],dfnidx=0,dfn[MAXN],top[MAXN];void dfs1(int u,int Fa)&#123; dep[u]=dep[Fa]+1; siz[u]=1; fa[u]=Fa; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==Fa) continue; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; top[u]=tp; dfn[u]=++dfnidx; if(mxson[u]) dfs2(mxson[u],tp); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v!=fa[u] &amp;&amp; v!=mxson[u]) dfs2(v,v); &#125;&#125;int LCA(int x,int y)&#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=fa[top[x]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;int val[MAXN],totv=0;int pcnt=0,pos[MAXN];void upd(int a,int b,int k)&#123; int lca=LCA(a,b); T.add(dfn[a],k); T.add(dfn[b],k); T.add(dfn[lca],-k); T.add(dfn[fa[lca]],-k);&#125;void solve(int l,int r,int L,int R)&#123; if(l&gt;r || L&gt;R) return; if(l==r) &#123; for(int i=L;i&lt;=R;++i) if(q[i].type==2) ans[q[i].id]=val[l]; return; &#125; int mid=val[(l+r)&gt;&gt;1],cntl=0,cntr=0; int tot=0; for(int i=L;i&lt;=R;++i) &#123; if(q[i].type==0) &#123; if(q[i].v&gt;mid) &#123; upd(q[i].a,q[i].b,1); ++tot; qr[++cntr]=q[i]; &#125; else ql[++cntl]=q[i]; &#125; else if(q[i].type==1) &#123; if(q[i].v&gt;mid) &#123; upd(q[i].a,q[i].b,-1); --tot; qr[++cntr]=q[i]; &#125; else ql[++cntl]=q[i]; &#125; else &#123; int x=q[i].x; int tmp=T.query(dfn[x],dfn[x]+siz[x]-1); if(tmp&gt;=tot) ql[++cntl]=q[i]; else qr[++cntr]=q[i]; &#125; &#125; for(int i=L;i&lt;=R;++i) if(q[i].type==0 &amp;&amp; q[i].v&gt;mid) upd(q[i].a,q[i].b,-1); else if(q[i].type==1 &amp;&amp; q[i].v&gt;mid) upd(q[i].a,q[i].b,1); for(int i=1;i&lt;=cntl;++i) q[L+i-1]=ql[i]; for(int i=1;i&lt;=cntr;++i) q[L+i+cntl-1]=qr[i]; int Mid=(l+r)&gt;&gt;1; solve(l,Mid,L,L+cntl-1); solve(Mid+1,r,L+cntl,R);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs1(1,0); dfs2(1,1); for(int i=1;i&lt;=m;++i) &#123; q[i].type=read(); if(q[i].type==0) &#123; q[i].a=read(); q[i].b=read(); q[i].v=read(); val[++totv]=q[i].v; &#125; else if(q[i].type==1) &#123; int t=read(); q[i]=q[t]; q[i].type=1; &#125; else &#123; q[i].x=read(); q[i].id=++qcnt; &#125; &#125; val[++totv]=-1; sort(val+1,val+1+totv); totv=unique(val+1,val+1+totv)-val-1; solve(1,totv,1,m); for(int i=1;i&lt;=qcnt;++i) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3110 K大数查询]]></title>
    <url>%2F2019%2F06%2F23%2Fbzoj-3110-K%E5%A4%A7%E6%95%B0%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[整体二分. 整体二分. 因为修改操作对二分答案的贡献是给一段区间 $+1$ ,所以用线段树来维护即可. 一次分治结束后并不能直接重置线段树,因为这样每次操作就和整个序列长度线性相关了. 将修改操作 $+1$ 的部分都 $-1$ 撤回即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e4+10;int n,m,ans[MAXN],qcnt=0;struct Node&#123; int a,b; ll c; int type,id;&#125;q[MAXN&lt;&lt;2],ql[MAXN],qr[MAXN];struct Segtree&#123; struct node &#123; ll sum,tag; node()&#123;sum=0;tag=0;&#125; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.sum=lson.sum+rson.sum; &#125; void modifiy(int o,int c,int l,int r) &#123; root.sum+=1LL*c*(r-l+1); root.tag+=c; &#125; void pushdown(int o,int l,int r) &#123; if(root.tag) &#123; int mid=(l+r)&gt;&gt;1; modifiy(o&lt;&lt;1,root.tag,l,mid); modifiy(o&lt;&lt;1|1,root.tag,mid+1,r); root.tag=0; &#125; &#125; void upd(int o,int l,int r,int L,int R,int c) &#123; if(l&gt;R || L&gt;r) return; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c,l,r); return; &#125; pushdown(o,l,r); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125; ll query(int o,int l,int r,int L,int R) &#123; if(l&gt;R || L&gt;r) return 0; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; ll res=0; pushdown(o,l,r); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res+=query(o&lt;&lt;1,l,mid,L,R); if(R&gt;mid) res+=query(o&lt;&lt;1|1,mid+1,r,L,R); return res; &#125;&#125;T;void solve(int l,int r,int L,int R)&#123; if(l&gt;r || L&gt;R) return; if(l==r) &#123; for(int i=L;i&lt;=R;++i) if(q[i].type==2) ans[q[i].id]=l; return; &#125; int cntl=0,cntr=0; int mid=(l+r)&gt;&gt;1; for(int i=L;i&lt;=R;++i) &#123; if(q[i].type==1) &#123; if(q[i].c&gt;mid) &#123; T.upd(1,1,n,q[i].a,q[i].b,1); qr[++cntr]=q[i]; &#125; else ql[++cntl]=q[i]; &#125; else &#123; ll tmp=T.query(1,1,n,q[i].a,q[i].b); if(tmp&gt;=q[i].c) qr[++cntr]=q[i]; else if(tmp&lt;q[i].c) &#123; q[i].c-=tmp; ql[++cntl]=q[i]; &#125; &#125; &#125; for(int i=L;i&lt;=R;++i) if(q[i].type==1 &amp;&amp; q[i].c&gt;mid) T.upd(1,1,n,q[i].a,q[i].b,-1); for(int i=1;i&lt;=cntl;++i) q[L+i-1]=ql[i]; for(int i=1;i&lt;=cntr;++i) q[L+i+cntl-1]=qr[i]; solve(l,mid,L,L+cntl-1); solve(mid+1,r,L+cntl,R);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; q[i].type=read(); q[i].a=read(); q[i].b=read(); q[i].c=read(); if(q[i].type==2) q[i].id=++qcnt; &#125; solve(-n,n,1,m); for(int i=1;i&lt;=qcnt;++i) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1901 Dynamic Rankings]]></title>
    <url>%2F2019%2F06%2F21%2Fbzoj-1901-Dynamic-Rankings%2F</url>
    <content type="text"><![CDATA[整体二分. $solve(l,r,L,R)$ 表示当前处理编号在 $L\sim R$ 内的询问与修改操作,询问的答案在 $l\sim r$ 内. 每次处理时,若当前 $l=r$ ,就回答 $L\sim R$ 内的询问. 否则,二分答案 $mid$ ,对于编号在 $L\sim R$ 内的修改操作,按照修改的权值分成 $\le mid,&gt;mid$ 两边,若 $\le mid$ ,就在树状数组里将它对应的位置 $+1$ . 对于编号在 $L\sim R$ 内的询问操作,按照在树状数组中询问区间的权值和 $sum\le k,&gt;k$ 分成两边,若 $&lt;k$ ,就将 $k$ 减去这个 $sum$ . 然后将分出的修改与询问操作分到左右两边,递归解决即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=1e5+10;int n,m,a[MAXN];int ans[MAXN];struct node&#123; int x,y,k,id,type; node()&#123;x=y=k=id=type=0;&#125; node(int x,int y,int k,int id,int type):x(x),y(y),k(k),id(id),type(type) &#123;&#125;&#125;q[MAXN*3],ql[MAXN*3],qr[MAXN*3];struct FenwickTree&#123; int bit[MAXN]; FenwickTree()&#123;memset(bit,0,sizeof bit);&#125;#define lowbit(x) x&amp;(-x) void add(int x,int c) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=c; &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x]; return s; &#125; int query(int l,int r) &#123; return sum(r)-sum(l-1); &#125;&#125;T;int cnt=0,qcnt=0;void solve(int l,int r,int L,int R)&#123; if(l&gt;r || L&gt;R) return; if(l==r) &#123; for(int i=L;i&lt;=R;++i) if(q[i].type) ans[q[i].id]=l; return; &#125; int mid=(l+r)&gt;&gt;1,cntl=0,cntr=0; for(int i=L;i&lt;=R;++i) &#123; if(q[i].type) &#123; int sum=T.query(q[i].x,q[i].y); if(sum&gt;=q[i].k) ql[++cntl]=q[i]; else &#123; q[i].k-=sum; qr[++cntr]=q[i]; &#125; &#125; else &#123; if(q[i].x&lt;=mid) &#123; T.add(q[i].id,q[i].y); ql[++cntl]=q[i]; &#125; else qr[++cntr]=q[i]; &#125; &#125; for(int i=1;i&lt;=cntl;++i) if(!ql[i].type) T.add(ql[i].id,-ql[i].y); for(int i=1;i&lt;=cntl;++i) q[L+i-1]=ql[i]; for(int i=1;i&lt;=cntr;++i) q[L+cntl+i-1]=qr[i]; solve(l,mid,L,L+cntl-1); solve(mid+1,r,L+cntl,R);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); q[++cnt]=node(a[i],1,0,i,0); &#125; for(int i=1;i&lt;=m;++i) &#123; char buf[2]; scanf("%s",buf); if(buf[0]=='Q') &#123; int x=read(),y=read(),k=read(); q[++cnt]=node(x,y,k,++qcnt,1); &#125; else &#123; int x=read(),y=read(); q[++cnt]=node(a[x],-1,0,x,0); a[x]=y; q[++cnt]=node(a[x],1,0,x,0); &#125; &#125; solve(-inf,inf,1,cnt); for(int i=1;i&lt;=qcnt;++i) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>离线</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4540 序列]]></title>
    <url>%2F2019%2F06%2F20%2Fbzoj-4540-%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[线段树. 这道题显然有一个莫队的做法,但它是带根号的,不够优秀.考虑用一个 $O(nlogn)$ 的做法解决它. 考虑将询问离线下来,从 $1$ 到 $n$ 依次加入元素,当前已经加入了第 $p$ 个元素,对每个位置维护 $val_i,sum_i$ ,分别表示区间 $[i,p]$ 的最小值,以及 $val_i$ 所有历史版本值之和.若 $i&gt;p$ ,则当前 $val_i=0$ . 加入第 $p$ 个元素后,立即回答所有 $r=p$ 的询问,答案显然是 $\sum_{i=l}^r sum_i$ . 于是我们只需要用一颗线段树来维护 $val,sum$ 这两个值(的区间和)即可. 考虑加入第 $p$ 个元素后如何修改 $val,sum$ .可以通过单调栈求出最小的 $i$ ,使得 $[i,p]$ 内最小值都为 $a_p$ .需要将 $[i,p]$ 这个区间内的 $val$ 都修改成 $a_p$ ,并让区间 $[1,p]$ 内的 $sum$ 加上对应位置新的 $val$. 时间复杂度 $O(nlogn)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,Q,A[MAXN];ll ans[MAXN];struct Query&#123; int l,id; Query(int l=0,int id=0):l(l),id(id) &#123;&#125;&#125;;vector&lt;Query&gt; V[MAXN];int stk[MAXN],tp=0;struct tag&#123; ll a,b,c,d; void init()&#123;a=1;b=c=d=0;&#125; tag(int a,int b,int c,int d):a(a),b(b),c(c),d(d) &#123;&#125; tag()&#123;init();&#125; bool valid() &#123; if(a==1 &amp;&amp; !b &amp;&amp; !c &amp;&amp; !d) return false; return true; &#125; tag operator + (const tag &amp;rhs) const &#123; tag Newtag; Newtag.a=rhs.a*a; Newtag.b=rhs.a*b+rhs.b; Newtag.c=rhs.c*a+c; Newtag.d=rhs.c*b+d+rhs.d; return Newtag; &#125;&#125;;struct SegTree&#123; struct node &#123; ll val,sum,len; tag t; bool TagValid() &#123; return t.valid(); &#125; &#125; Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void BuildTree(int o,int l,int r) &#123; root.val=root.sum=0; root.len=r-l+1; if(l==r) return; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); &#125; void pushup(int o) &#123; root.val=lson.val+rson.val; root.sum=lson.sum+rson.sum; &#125; void Modifiy(int o,tag Newtag) &#123; root.sum+=Newtag.c*root.val+Newtag.d*root.len; root.val=Newtag.a*root.val+Newtag.b*root.len; root.t=root.t+Newtag; &#125; void pushdown(int o) &#123; if(root.TagValid()) &#123; Modifiy(o&lt;&lt;1,root.t); Modifiy(o&lt;&lt;1|1,root.t); (root.t).init(); &#125; &#125; void upd(int o,int l,int r,int L,int R,tag Newtag) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; Modifiy(o,Newtag); return; &#125; pushdown(o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,Newtag); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,Newtag); pushup(o); &#125; ll query(int o,int l,int r,int L,int R) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; pushdown(o); int mid=(l+r)&gt;&gt;1; ll res=0; if(L&lt;=mid) res+=query(o&lt;&lt;1,l,mid,L,R); if(R&gt;mid) res+=query(o&lt;&lt;1|1,mid+1,r,L,R); return res; &#125;&#125;T;int main()&#123; n=read(),Q=read(); for(int i=1; i&lt;=n; ++i) A[i]=read(); for(int i=1; i&lt;=Q; ++i) &#123; int l=read(),r=read(); V[r].push_back(Query(l,i)); &#125; T.BuildTree(1,1,n); for(int p=1; p&lt;=n; ++p) &#123; while(tp &amp;&amp; A[p]&lt;A[stk[tp]]) --tp; int i=stk[tp]+1; stk[++tp]=p; tag Newtag=tag(0,A[p],0,0); T.upd(1,1,n,i,p,Newtag); Newtag=tag(1,0,1,0); T.upd(1,1,n,1,p,Newtag); int siz=V[p].size(); for(int j=0; j&lt;siz; ++j) ans[V[p][j].id]=T.query(1,1,n,V[p][j].l,p); &#125; for(int i=1; i&lt;=Q; ++i) printf("%lld\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4537 最小公倍数]]></title>
    <url>%2F2019%2F06%2F19%2Fbzoj-4537-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[分块 + 并查集. 如果对于每个询问 $(u,v,a,b)$ ,我们都只加入 $a,b$ 均小于等于该询问的 $a,b$ 的边,那么答案为 $Yes$ 就等价于 $u,v$ 在同一个联通块中,并且这个连通块中有一条边的 $a$ 等于该询问的 $a$ ,有一条边的 $b$ 等于该询问的 $b$ . 若只有 $a$ 这一维的限制,可以将所有边,询问按 $a$ 排序后依次处理,用并查集维护. 但现在有 $a,b$ 两维的限制,而 $m$ 不是很大,考虑分块. 将所有边与询问按照 $a$ 的大小分成 $\sqrt m$ 块,按顺序处理每一块.处理第 $i$ 块的时候,将第 $1\sim i-1$ 块内的边和第 $i$ 块内的询问都拿出来,按照 $b$ 从小到大排序后依次处理,并用并查集维护连通性和联通块内最大的 $a,b$ . 第 $i$ 块内的边也可能产生贡献,因为它们的数量不超过 $\sqrt m$ ,所以每次遇到询问时,将这些边当中合法的加入,这个询问结束后再撤销就好了. 因为要实现可撤销的并查集,所以要按秩合并,不能路径压缩.时间复杂度 $O(m\sqrt m\cdot logm)$ . 注意 $a,b$ 可能为 $0$ ,所以初始化最大值要为 $-1$ .因为这个调了一节课. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e5+10;struct node&#123; int u,v,a,b,id; int type;&#125;eq[MAXN],tmp[MAXN];bool cmp1(node A,node B)&#123; return A.a&lt;B.a || (A.a==B.a &amp;&amp; A.type&lt;B.type);&#125;bool cmp2(node A,node B)&#123; return A.b&lt;B.b || (A.b==B.b &amp;&amp; A.type&lt;B.type);&#125;int ans[MAXN];int n,m,q,BlockSize,BlockNum;int L[MAXN],R[MAXN],lpos[MAXN],rpos[MAXN];struct Disjoint_Set_Union&#123; int fa[MAXN],siz[MAXN],maxa[MAXN],maxb[MAXN]; int OperationNum; struct Operation &#123; int x,NewFa,sizx,Orgmaxa,Orgmaxb; &#125;opt[MAXN]; void SaveOperation(int x,int NewFa,int sizx,int Orgmaxa,int Orgmaxb) &#123; int k=++OperationNum; opt[k].x=x; opt[k].NewFa=NewFa; opt[k].sizx=sizx; opt[k].Orgmaxa=Orgmaxa; opt[k].Orgmaxb=Orgmaxb; &#125; void Undo() &#123; while(OperationNum) &#123; int k=OperationNum--; int x=opt[k].x,NewFa=opt[k].NewFa; int sizx=opt[k].sizx; int Orgmaxa=opt[k].Orgmaxa; int Orgmaxb=opt[k].Orgmaxb; if(x!=NewFa) siz[NewFa]-=sizx; fa[x]=x; maxa[NewFa]=Orgmaxa; maxb[NewFa]=Orgmaxb; &#125; &#125; void init() &#123; OperationNum=0; for(int i=1;i&lt;=n;++i) &#123; fa[i]=i; siz[i]=1; maxa[i]=maxb[i]=-1; &#125; &#125; int Find(int x) &#123; if(fa[x]==x) return x; return Find(fa[x]); &#125; void addedge(int u,int v,int a,int b,bool flag) &#123; u=Find(u),v=Find(v); if(u!=v) &#123; if(siz[v]&gt;siz[u]) swap(u,v); if(flag) SaveOperation(v,u,siz[v],maxa[u],maxb[u]); siz[u]+=siz[v]; fa[v]=u; maxa[u]=max(maxa[u],a); maxa[u]=max(maxa[u],maxa[v]); maxb[u]=max(maxb[u],b); maxb[u]=max(maxb[u],maxb[v]); &#125; else &#123; if(flag) SaveOperation(u,u,siz[u],maxa[u],maxb[u]); maxa[u]=max(maxa[u],a); maxb[u]=max(maxb[u],b); &#125; &#125; bool check(int u,int v,int a,int b) &#123; u=Find(u),v=Find(v); if(u!=v) return false; if(maxa[u]!=a || maxb[u]!=b) return false; return true; &#125;&#125;DSU;void solve(int CurBlock)&#123; DSU.init(); int tot=0; for(int i=1;i&lt;L[CurBlock];++i) if(eq[i].type==1) tmp[++tot]=eq[i]; for(int i=L[CurBlock];i&lt;=R[CurBlock];++i) if(eq[i].type==2) tmp[++tot]=eq[i]; sort(tmp+1,tmp+1+tot,cmp2); for(int i=1;i&lt;=tot;++i) &#123; if(tmp[i].type==1) DSU.addedge(tmp[i].u,tmp[i].v,tmp[i].a,tmp[i].b,false); else &#123; if(tmp[i].id==44) &#123; int qq=1; &#125; for(int j=L[CurBlock];j&lt;=R[CurBlock];++j) if(eq[j].type==1 &amp;&amp; eq[j].a&lt;=tmp[i].a &amp;&amp; eq[j].b&lt;=tmp[i].b) DSU.addedge(eq[j].u,eq[j].v,eq[j].a,eq[j].b,true); ans[tmp[i].id]=DSU.check(tmp[i].u,tmp[i].v,tmp[i].a,tmp[i].b); DSU.Undo(); &#125; &#125;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; eq[i].u=read(); eq[i].v=read(); eq[i].a=read(); eq[i].b=read(); eq[i].type=1; &#125; q=read(); for(int i=1;i&lt;=q;++i) &#123; eq[i+m].u=read(); eq[i+m].v=read(); eq[i+m].a=read(); eq[i+m].b=read(); eq[i+m].id=i; eq[i+m].type=2; &#125; sort(eq+1,eq+m+q+1,cmp1); BlockSize=sqrt(m+q); BlockNum=(m+q+BlockSize-1)/BlockSize; for(int i=1;i&lt;=BlockNum;++i) &#123; L[i]=R[i-1]+1; R[i]=L[i]+BlockSize-1; &#125; R[BlockNum]=m+q; for(int i=1;i&lt;=BlockNum;++i) solve(i); for(int i=1;i&lt;=q;++i) puts(ans[i]?"Yes":"No"); return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>离线</tag>
        <tag>分块</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4518 征途]]></title>
    <url>%2F2019%2F06%2F18%2Fbzoj-4518-%E5%BE%81%E9%80%94%2F</url>
    <content type="text"><![CDATA[斜率优化 $dp$ . 推一下式子,记第 $i$ 天走的长度为 $t_i$ , $s=\sum t_i$ ,则 $S^2 \cdot m^2=(m\cdot \sum t_i^2)-s^2$ . 由于 $m,s$ 为定值,所以只需要最小化平方和 $\sum t_i^2$ . 设 $f(i,j)$ 表示走了 $i$ 天,恰好走了 $j$ 段路时的最小平方和, $sum_i$ 表示前 $i$ 段路的长度和. 暴力转移有 $f(i,j)=\min \lbrace f(i-1,k)+(sum_j-sum_k)^2,0\leq k&lt;j \rbrace$ ,可以看出暴力转移是 $O(n^3)$ 的. 若固定 $i$ ,可以看出 $j$ 这一维是满足斜率优化的,因为同时与 $j,k$ 有关的项是 $-2sum_j\cdot sum_k$ ,而 $sum_k$ 单调. 于是就可以进行斜率优化了.若用 $k_1$ 转移比 $k_2$ 更优 ( $k_1&gt;k_2$ ) ,由转移方程可得到: $$slope(k_1,k_2)={f(i-1,k_1)+sum_{k_1}^2-f(i-1,k_2)-sum_{k_2}^2 \over sum_{k_1}-sum_{k_2}} &lt; 2sum_j$$ 而斜率 $2sum_j$ 也是单调的,所以并不需要二分,直接暴力跳指针,用单调队列维护下凸壳即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e3+10;int n,m,sum[MAXN],s;ll f[MAXN][MAXN];double sqr(double x)&#123; return x*x;&#125;double slope(int i,int k1,int k2)&#123; return (f[i-1][k1]+sqr(sum[k1])-f[i-1][k2]-sqr(sum[k2]))/(1.0*sum[k1]-1.0*sum[k2]);&#125;int q[MAXN],head,tail;// [head,tail]int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) sum[i]=sum[i-1]+read(); memset(f,63,sizeof f); f[0][0]=0; for(int i=1;i&lt;=m;++i) &#123; head=tail=0; for(int j=1;j&lt;=n;++j) &#123; while(head&lt;tail &amp;&amp; slope(i,q[head+1],q[head])&lt;2*sum[j]) ++head; int k=q[head]; f[i][j]=f[i-1][k]+1LL*(sum[j]-sum[k])*(sum[j]-sum[k]); while(head&lt;tail &amp;&amp; slope(i,q[tail],q[tail-1])&gt;slope(i,q[tail],j)) --tail; q[++tail]=j; &#125; &#125; cout&lt;&lt;f[m][n]*m-1LL*sum[n]*sum[n]&lt;&lt;endl; return 0;&#125; 更了一个用 $WQS$ 二分的做法. 这道题用 $WQS$ 二分,也称凸优化,可以做到 $O(n\log s_n)$ 的时间复杂度. 定义 $g(i)$ 表示必须走 $i$ 段时的最小 $\sum t_j^2$ .那么我们就是要求 $g(m)$ 的值. 普通的斜率优化其实就是在枚举选了多少段. 二分一个权值 $mid$ ,表示每选一段带来的额外花费,此时得到新的函数 $f(x)=g(x)+mid\cdot x$ . 因为 $g(x)$ 是具有凸性的,所以 $g’(x)$ 是单调的,而 $f’(x)=g’(x)+mid$ ,相当于在左右移动 $g’(x)$ 的零点. 而 $f’(x)$ 的零点就是让 $f(x)$ 取得最小值的点,一次斜率 $dp$ 可以 $O(n)$ 求出,也同时求出了 $f(x)$ 的最小值. 通过二分不断调整 $mid$ ,直到 $f’(x)$ 的零点为 $m$ ,就得到了 $f(m)$ ,再根据 $g(m)=f(m)-mid\cdot m$ 得出答案. 因为实际问题中,这些函数只在整数处才有定义,所以二分权值时也只用在整数中二分. 时间复杂度 $O(n\log s_n)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int read()&#123; int out=0,sgn=1; char jp=getchar(); while(jp!='-' &amp;&amp; (jp&lt;'0' || jp&gt;'9')) jp=getchar(); if(jp=='-') sgn=-1,jp=getchar(); while(jp&gt;='0' &amp;&amp; jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*sgn;&#125;const int MAXN=3e3+10;ll sqr(ll x)&#123; return x*x;&#125;int n,m;ll f[MAXN],g[MAXN],s[MAXN];double slope(int k1,int k2)&#123; return (double)(f[k1]+sqr(s[k1])-f[k2]-sqr(s[k2]))/(double)(s[k1]-s[k2]);&#125;int q[MAXN],head,tail;bool check(ll mid)&#123; q[head=tail=0]=0; for(int i=1;i&lt;=n;++i) &#123; while(head&lt;tail &amp;&amp; slope(q[head+1],q[head])&lt;2*s[i]) ++head; int k=q[head]; f[i]=f[k]+sqr(s[i]-s[k])+mid; g[i]=g[k]+1; while(head&lt;tail &amp;&amp; slope(q[tail-1],q[tail])&gt;slope(q[tail],i)) --tail; q[++tail]=i; &#125; return g[n]&lt;=m;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) s[i]=s[i-1]+read(); ll L=0,R=s[n]*s[n]/m; ll res; while(L&lt;=R) &#123; ll mid=(L+R)&gt;&gt;1; if(check(mid)) &#123; res=m*(f[n]-mid*m)-sqr(s[n]); R=mid-1; &#125; else L=mid+1; &#125; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4516 生成魔咒]]></title>
    <url>%2F2019%2F06%2F18%2Fbzoj-4516-%E7%94%9F%E6%88%90%E9%AD%94%E5%92%92%2F</url>
    <content type="text"><![CDATA[$SAM$ . 每次在末尾加入一个字符,再询问当前串本质不同的子串数目. 用 $SAM$ 维护,答案就是所有非根结点的 $maxlen-minlen+1$ 之和,即 $maxlen(u)-maxlen(fa_u)$ 之和. 由于字符集比较大,所以用 $map$ 存边,确定/更换父亲结点时更新答案即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;struct SuffixAutomaton&#123; map&lt;int,int&gt; ch[MAXN]; int idx,lst; int len[MAXN],fa[MAXN]; ll ans; SuffixAutomaton()&#123;idx=lst=1;ans=0;memset(fa,0,sizeof fa);&#125; void Extend(int c) &#123; int p=lst,np=++idx; lst=np; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1,ans+=len[np]; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) &#123; fa[np]=q; ans+=len[np]-len[q]; &#125; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; ans+=len[np]-len[nq]; ch[nq]=ch[q]; while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; printf("%lld\n",ans); &#125;&#125;SAM;int main()&#123; int n=read(); for(int i=1;i&lt;=n;++i) SAM.Extend(read()); return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1181]]></title>
    <url>%2F2019%2F06%2F18%2FCF1181%2F</url>
    <content type="text"><![CDATA[$Div.2$ 鸽了生物晚自习过来打. A Chunga-Changa 签到题.分类讨论一下就好了. 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;ll x,y,z;int main()&#123; x=read(),y=read(),z=read(); if((x+y)/z==x/z+y/z) cout&lt;&lt;(x+y)/z&lt;&lt;' '&lt;&lt;0&lt;&lt;endl; else &#123; ll s=x/z+y/z; x%=z,y%=z; if((x+y)/z) cout&lt;&lt;s+1&lt;&lt;' '&lt;&lt;min(z-x,z-y)&lt;&lt;endl; else cout&lt;&lt;s&lt;&lt;0&lt;&lt;endl; &#125; return 0;&#125; B Split a Number 显然应该贪心从最中间的位置切开. 有 $0$ 的话,就从中间往两边分别找第一个合法的位置就好了. 高精度用 $python$ 就很棒. 12345678910111213n = input()s = raw_input()fig = []for i in xrange(1, n): if s[i] != '0': fig.append((max(i, n - i), i))fig.sort()k = fig[0][0]ans = int(s)for i in xrange(min(10, len(fig))): j = fig[i][1] ans = min(ans, int(s[:j]) + int(s[j:]))print ans C Flag 记录 $D(i,j)$ 表示从 $(i,j)$ 往下走,并且满足颜色一直相同能走到的最远位置, $k(i,j)$ 表示从 $(i,j)$ 往右走,并且满足颜色一直相同能走的最远格数. 然后大力枚举 $(i,j)$ ,统计以 $(i,j)$ 为左上角的 $Flag$ 数目即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e3+10;int n,m;int col[MAXN][MAXN];char buf[MAXN];int D[MAXN][MAXN];int k[MAXN][MAXN];const int inf=1e9;struct seg&#123; int val[MAXN&lt;&lt;2];#define root val[o]#define lson val[o&lt;&lt;1]#define rson val[o&lt;&lt;1|1] void bd(int y,int o,int l,int r) &#123; if(l==r) &#123; root=k[l][y]; return; &#125; int mid=(l+r)&gt;&gt;1; bd(y,o&lt;&lt;1,l,mid); bd(y,o&lt;&lt;1|1,mid+1,r); root=min(lson,rson); &#125; int query(int o,int l,int r,int L,int R) &#123; assert(root); if(L&lt;=l &amp;&amp; r&lt;=R) return root; int mid=(l+r)&gt;&gt;1; int s=inf; if(L&lt;=mid) s=min(s,query(o&lt;&lt;1,l,mid,L,R)); if(R&gt;mid) s=min(s,query(o&lt;&lt;1|1,mid+1,r,L,R)); assert(s&gt;=1 &amp;&amp; s&lt;=m); return s; &#125;&#125;T[MAXN];ll calc(int x,int y)&#123; int p1=x; int p2=D[p1][y]+1; if(p2&gt;n) return 0; int p3=D[p2][y]+1; if(p3&gt;n) return 0; int len=p2-p1; if(p3!=p2+len) return 0; if(p3+len-1&gt;n) return 0; if(D[p3][y]&lt;p3+len-1) return 0; return T[y].query(1,1,n,p1,p3+len-1);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; scanf("%s",buf+1); for(int j=1;j&lt;=m;++j) col[i][j]=buf[j]-'a'+1; &#125; for(int i=1;i&lt;=n;++i) &#123; for(int j=m;j&gt;=1;--j) if(col[i][j]!=col[i][j+1]) k[i][j]=1; else k[i][j]=k[i][j+1]+1; &#125; for(int j=1;j&lt;=m;++j) &#123; for(int i=n;i&gt;=1;--i) if(col[i][j]!=col[i+1][j]) D[i][j]=i; else D[i][j]=D[i+1][j]; &#125; for(int j=1;j&lt;=m;++j) T[j].bd(j,1,1,n); ll ans=0; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) ans+=calc(i,j); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D Irrigation 容易发现当所有的城市次数都相等后举办地点一定会出现循环 $1,2,3,\dots,m$ . 记初始 $n$ 轮举办后,举办次数最多的一个城市举办了 $t$ 场,那么根据规则,再举办 $t\cdot m-n$ 场后,即从第 $t\cdot m+1$ 场开始举办城市就会开始出现循环 $1,2,3,\dots,m$ . 可以将询问离线下来,按照时间从前往后顺序进行回答. 一层一层填满下面这个图,边填边回答询问 ( $two\ pointer$ ),用 $treap$ 维护当前可能会被填到的元素就好了. 最后还剩下的询问的答案一定是出现在 $1,2,3,\dots,m$ 的循环中,答案容易得出. E A Story of One Country 尝试倒着做,每次水平或竖直地将一个子矩形切成两个,并且切的时候不能切断任意一个 $castle$ 区域. 如果经过若干次切割后,能使得每个子矩形内都包含了 恰好一个 $castle$ 区域,那么原图就是合法的. 注意到对于同一个子矩形,如果把它内部的 $castle$ 区域用这个 $castle$ 区域的一个非空子集代替,不会使结果变劣,即,若原子矩形是合法的,那么替换后的子矩形仍然是合法的. 又因为题目对切割次数没有限制,所以我们只要能找到一条切割线(水平或竖直)使得切割后得到的两个子矩形内部都含有 $castle$ 区域,且自身不穿过 $castle$ 区域,就称它是合法的,沿着它切开,不会影响最终的答案. 于是我们可以递归解决这个问题,对于当前的子矩形每次找到一条切割线,切割后递归处理得到的两个子矩形.若当前矩形不是恰好包含一个 $castle$ 区域,又找不到合法的切割线,则说明当前子矩形不合法,原图也不合法. 如果每次随意去找一条合法切割线执行上述操作,最坏情况是每次切割后,一个子矩形内只有 $1$ 个 $castle$ 区域,而另一个子矩形内含有剩下所有的 $castle$ 区域,此时的时间复杂度是 $O(n^2logn)$ ,只能通过简单版的数据. 用线段树来维护 $castle$ 区域,每次找出合适的切割使得得到的两个子矩形含有的 $castle$ 区域数目差尽可能小,此时时间复杂度为 $O(nlog^2n)$ ,可以通过所有数据.]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>平衡树</tag>
        <tag>线段树</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diverta 2019 Programming Contest 2]]></title>
    <url>%2F2019%2F06%2F17%2Fdiverta-2019-Programming-Contest-2%2F</url>
    <content type="text"><![CDATA[来的时候发现只有一个小时了.然而还是 头铁 开题,怒掉一波 $rating$ . 比赛链接. 官方题解. A Ball Distribution 签到题. 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int main()&#123; int n=read(),k=read(); if(k&gt;1) cout&lt;&lt;n-k; else cout&lt;&lt;0; return 0;&#125; B Picking Up 显然只需要枚举两个点,将它们的坐标差作为 $(p,q)$ 进行计算,其他的 $(p,q)$ 没有用. 然后用并查集或者记忆化搜索随便搞搞就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef pair&lt;int,int&gt; pii;int n;pii p[51];int ans=51;int f[51],A,B;map&lt;pii,int&gt; id;int dfs(int x)&#123; if(f[x]!=-1) return f[x]; int&amp; res=f[x]; res=0; if(id.find(make_pair(p[x].first-A,p[x].second-B))!=id.end()) &#123; int y=id[make_pair(p[x].first-A,p[x].second-B)]; if(f[y]!=-1) return 0; else &#123; res=0; return dfs(y); &#125; &#125; return res=1;&#125;void solve(int a,int b)&#123; if(a==-3 &amp;&amp; b==-2) &#123; int d=1; &#125; A=a,B=b; int res=0; memset(f,-1,sizeof f); for(int i=1;i&lt;=n;++i) if(f[i]==-1) res+=dfs(i); ans=min(ans,res);&#125;int main()&#123; n=read(); if(n==1) &#123; puts("1"); return 0; &#125; for(int i=1;i&lt;=n;++i) &#123; p[i].first=read(); p[i].second=read(); id[p[i]]=i; &#125; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) if(i!=j) solve(p[i].first-p[j].first,p[i].second-p[j].second); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; C Successive Subtraction 构造 + 贪心. 首先可以将 $0$ 全部减掉,于是只剩下正/负数. 特判只有正数与只有负数的情况,只有正数就让最小的那个数贡献为负,只有负数就让最大的那个数贡献为负. 否则,正负数都有的情况,答案一定是 $\sum |a_i|$ . 证明的话,考虑只有一个正数的情况,用它去减其他所有数即得 $\sum |a_i|$ .只有一个负数的情况,留下一个正数后,让那个负数减其他所有数,再让留下的正数减它,答案也是 $\sum |a_i|$ . 否则,正负数都至少有 $2$ 个.每次取出两个正数 $x,y$ ,一个负数 $z$ ,连续操作两次,先得到 $z-y$ ,再得到 $x-(z-y)=x+y-z$ . 这样操作后正负数都减少了 $1$ 个,并且每个数的贡献还是 $|a_i|$ ,一直操作,直到正数只有一个或负数只有一个时,执行对应情况的操作即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define int llinline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,a[MAXN];int res=0;void solve1()//-&#123; cout&lt;&lt;res+2*a[n]&lt;&lt;endl; int x=a[n]; for(int i=n-1;i&gt;=1;--i) &#123; printf("%lld %lld\n",x,a[i]); x-=a[i]; &#125;&#125;void solve2()//+&#123; cout&lt;&lt;res-2*a[1]&lt;&lt;endl; int x=a[1]; for(int i=2;i&lt;n;++i) &#123; printf("%lld %lld\n",x,a[i]); x-=a[i]; &#125; printf("%lld %lld\n",a[n],x);&#125;int stk1[MAXN],stk2[MAXN];int tp1=0,tp2=0;void solve3()//+,-&#123; cout&lt;&lt;res&lt;&lt;endl; int zr=0; for(int i=1;i&lt;=n;++i) &#123; if(a[i]&gt;0) stk1[++tp1]=a[i]; else if(a[i]&lt;0) stk2[++tp2]=a[i]; else ++zr; &#125; assert(zr!=n); while(zr--) printf("%lld 0\n",stk1[tp1]); assert(tp1 &amp;&amp; tp2); while(tp1!=1 &amp;&amp; tp2!=1) &#123; int x=stk1[tp1]; --tp1; int y=stk1[tp1]; --tp1; int z=stk2[tp2]; --tp2; printf("%lld %lld\n",z,y); printf("%lld %lld\n",x,z-y); stk1[++tp1]=x+y-z; &#125; if(tp1==1) &#123; int x=stk1[tp1]; while(tp2) &#123; printf("%lld %lld\n",x,stk2[tp2]); x-=stk2[tp2--]; &#125; &#125; else &#123; int x=stk2[tp2]; for(int i=1;i&lt;tp1;++i) &#123; printf("%lld %lld\n",x,stk1[i]); x-=stk1[i]; &#125; printf("%lld %lld\n",stk1[tp1],x); &#125;&#125;signed main()&#123; n=read(); bool f1=false,f2=false; for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); res+=abs(a[i]); if(a[i]&gt;0) f1=true; if(a[i]&lt;0) f2=true; &#125; sort(a+1,a+1+n); if(!f1) solve1(); else if(!f2) solve2(); else solve3(); return 0;&#125; D Squirrel Merchant 贪心 + 背包. 显然到 $B$ 时可以先把先前在 $A$ 买的东西全部卖掉后再进行操作,不会使结果变劣. 于是就成了 $A$ 买 + $B$ 卖 与 $B$ 买 + $A$ 卖 两个过程.尝试最大化每一步的收益即可. 如 $A$ 买 + $B$ 卖 这个过程,就可以用 $g_A$ 的容量换取 $g_B-g_A$ 的收益.另外的两种同理. 做两次背包即可.时间复杂度 $O(N\cdot \max(g,s,b))$ . 注意开 $long\ long$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int w[4],c[4],V;const int MAXN=5001*5001;int f[MAXN];int solve_package()&#123; memset(f,0,sizeof f); int res=0; for(int j=1;j&lt;=3;++j) &#123; if(c[j]&lt;=0) continue; for(int i=w[j];i&lt;=V;++i) &#123; f[i]=max(f[i],f[i-w[j]]+c[j]); res=max(res,f[i]); &#125; &#125; return res;&#125;int pr[2][4];int main()&#123; V=read(); for(int i=0;i&lt;2;++i) for(int j=1;j&lt;=3;++j) pr[i][j]=read(); for(int i=1;i&lt;=3;++i) &#123; c[i]=pr[1][i]-pr[0][i]; w[i]=pr[0][i]; &#125; V+=solve_package(); for(int i=1;i&lt;=3;++i) &#123; c[i]=pr[0][i]-pr[1][i]; w[i]=pr[1][i]; &#125; V+=solve_package(); cout&lt;&lt;V&lt;&lt;endl; return 0;&#125; E Balanced Piles $dp$ . 先只考虑 $D=1$ 的情况.设 $f(i,j)$ 表示当前最大值为 $i$ ,最大值有 $j$ 个时,操作到最终状态的方案数. 预先给每块砖钦定一个两两不同的优先度,若可以操作多块砖,则优先操作优先度高的砖. 那么若 $i\not=H$ ,可以转移到 $f(i+1,1)$ ,若 $j\not=N$ ,可以转移到 $f(i,j+1)$ .新加入的那块砖插入到原来的 $j$ 块砖中,有 $j+1$ 种方案.所以 $f(i,j)=f(i+1,1)+(j+1)\cdot f(i,j+1)$ ( $i=H$ 或 $j=N$ 除外). 边界是 $f(H,N)=1$ ,答案是 $f(0,N)$ .钦定优先度会使方案数 $\times N!$ ,但我们转移时规定了顺序,即方案数是序列的方案数,所以又要 $/ N!$ ,两者就抵消掉了. 123456789101112131415161718192021int f[MAXN][MAXN];int dfs(int i,int j)&#123; if(f[i][j]!=-1) return f[i][j]; int&amp; res=f[i][j]; res=0; if(i!=H) res=add(res,dfs(i+1,1)); if(j!=N) res=add(res,mul(j+1,dfs(i,j+1))); return res;&#125;int main()&#123; N=read(),H=read(),D=read(); memset(f,-1,sizeof f); f[H][N]=1; cout&lt;&lt;dfs(0,N)&lt;&lt;endl; return 0;&#125; 观察转移形式 $f(i,j)=f(i+1,1)+(j+1)\cdot f(i,j+1)$ ,可发现答案 $f(0,N)$ 就对应了下面这个 $DAG$ 从 $(0,N)$ 到 $(H,N)$ 的路径条数. 边上的数字代表有几条重边 ,图中 $N=4,H=5$ . 经过 奥妙重重 的运算,答案 $f(0,N)=(\sum_{i=1}^N i!)^{H-1}\cdot N!$ . 再来考虑一般的 $D\geq 1$ 的情况. 考虑一个数列 $0=h_0&lt;h_1&lt;\dots &lt;h_K=H$ ,满足 $\forall 0\leq i&lt;K,h_{i+1}-h_i\leq D$ .那么现在要求每次操作的高度 $h$ 能依次构成上面形式的数列,答案就是 $(\sum_{i=1}^N i!)^{K-1}\cdot N!$ . 沿用 $D=1$ 时构造 $DAG$ 的思路,答案对应了下面的 $DAG$ 从 $0$ 到 $N$ 的路径数目. $weight$ 其实就是说重边的数目.图片均来自官方题解. 维护 $f(i)$ 表示 $0\to i$ 的路径条数,并维护 $f$ 的前缀和,即可在 $O(n)$ 内解决此题. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;const int MAXN=1e6+10;int fac[MAXN];inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;int N,H,D,sf=0;int f[MAXN],sum[MAXN];int main()&#123; N=read(),H=read(),D=read(); fac[0]=1; for(int i=1;i&lt;=N;++i) &#123; fac[i]=mul(fac[i-1],i); sf=add(sf,fac[i]); &#125; f[0]=1,sum[0]=1; for(int i=1;i&lt;=H;++i) &#123; if(i-D-1&gt;=0) f[i]=add(sum[i-1],P-sum[i-D-1]); else f[i]=sum[i-1]; f[i]=mul(f[i],sf); sum[i]=add(sum[i-1],f[i]); &#125; cout&lt;&lt;mul(mul(f[H],fac[N]),inv(sf))&lt;&lt;endl; return 0;&#125; F Diverta City 构造. 考虑数学归纳法,对于 $N=2$ 的情况,显然可以直接连一条长度 $1$ 的边完成构造. 否则,对于 $N\geq 3$ ,先构造一个 $N-1$ 个点的完全图满足要求,再加入第 $N$ 个点,则只需要考虑从第 $N$ 个点向前 $N-1$ 个点连边的长度. 令 $M$ 为先前构造出的 $N-1$ 个点的图中最长的哈密顿路径长度,令 $a=\lbrace 1,2,4,7,12,20,29,38,52\rbrace$ ,则第 $N$ 个点与第 $i$ 个点相连的边长度为 $(M+1)\cdot a_i$ 即可满足新得到的 $N$ 个点的图也符合要求. 为啥呢?因为任意一条新图的哈密顿路径中,只有 $1$ 条新加入的边( $N$ 为路径起点/终点) , 或 $2$ 条新加入的边( $N$ 不为路径起点/终点),而其余的边一定是 $N-1$ 个点的图中一条哈密顿路径的一部分. 所以新图中的每一条哈密顿路径长度都可以被表示为 $x+(M+1)\cdot a_i$ 或 $x+(M+1)\cdot(a_i+a_j)$ . 其中 $0\leq x\leq M$ .而我们构造的数列 $a$ 是满足所有 $a_i,a_i+a_j$ 都是互异的,所以新图的每条哈密顿路径长度也是互异的,于是得到的新图也满足条件. 当 $N=10$ 时,可以验证此时最长的边为 $96755758040&lt;10^{11}$ 满足限制.每次加点后暴力枚举 $i!/2$ 条哈密顿路径,计算 $M$ .时间复杂度 $O((N+1)!)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=11;const int a[]=&#123;0,1,2,4,7,12,20,29,38,52&#125;;int n,p[MAXN];ll w[MAXN][MAXN],M;void GetM(int x)&#123; M=0; for(int i=1;i&lt;=x;++i) p[i]=i; do &#123; ll res=0; for(int i=1;i&lt;x;++i) res+=w[p[i]][p[i+1]]; M=max(M,res); &#125;while(next_permutation(p+1,p+1+x));&#125;void solve(int x)&#123; for(int i=1;i&lt;x;++i) w[i][x]=w[x][i]=(M+1)*a[i];&#125;int main()&#123; n=read(); w[1][2]=w[2][1]=1; M=1; for(int i=3;i&lt;=n;++i) &#123; solve(i); GetM(i); &#125; for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=n;++j) printf("%lld ",w[i][j]); puts(""); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>atcoder</tag>
        <tag>dp计数</tag>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>DAG</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4515 游戏]]></title>
    <url>%2F2019%2F06%2F14%2Fbzoj-4515-%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[树链剖分 + 李超线段树. 显然可以先来一个树剖,就成了区间上的问题.每次修改 $(s,t)$ 就拆成 $(s,lca),(lca,t)$ 两段来做. 于是修改操作都是给一条区间加一条线段的形式,询问是问一个区间内点值的最小值. 用李超线段树维护优势线段与区间的答案即可. 时间复杂度 $O(nlog^3n)$ ,但常数比较小,所以能过. 强行上树系列. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const ll inf=123456789123456789;const int MAXN=1e5+10;int ecnt=0,head[MAXN];int to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN&lt;&lt;1];void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;ll dist[MAXN];int mxson[MAXN],siz[MAXN],fa[MAXN],dep[MAXN];int idx=0,dfn[MAXN],rnk[MAXN],top[MAXN],distofa[MAXN];void dfs1(int u,int Fa)&#123; siz[u]=1; fa[u]=Fa; dep[u]=dep[Fa]+1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==Fa) continue; distofa[v]=val[i]; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp,ll CurDist)&#123; top[u]=tp; dfn[u]=++idx; rnk[idx]=u; dist[idx]=CurDist; if(mxson[u]) dfs2(mxson[u],tp,CurDist+distofa[mxson[u]]); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa[u] || v==mxson[u]) continue; dfs2(v,v,CurDist+distofa[v]); &#125;&#125;int Query_LCA(int x,int y)&#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=fa[top[x]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;ll tmp,k[MAXN*50],b[MAXN*50];ll calc(int seg,int x)&#123; return k[seg]*dist[x]+b[seg];&#125;int n,m,cnt=0;ll ans;struct SegTree&#123; int nodecnt; SegTree()&#123;nodecnt=0;&#125; struct node &#123; int ls,rs,id; ll mi; node()&#123;ls=rs=id=0;mi=inf;&#125; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[root.ls]#define rson Tree[root.rs] void BuildTree(int l,int r) &#123; int o=++nodecnt; if(l==r) return; int mid=(l+r)&gt;&gt;1; root.ls=nodecnt+1; BuildTree(l,mid); root.rs=nodecnt+1; BuildTree(mid+1,r); &#125; void pushup(int o,int l,int r) &#123; if(root.id) root.mi=k[root.id]&lt;0?calc(root.id,r):calc(root.id,l); else root.mi=inf; if(l&lt;r) &#123; root.mi=min(root.mi,lson.mi); root.mi=min(root.mi,rson.mi); &#125; &#125; void upd(int o,int l,int r,int L,int R,int seg) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; if(!root.id) &#123; root.id=seg; pushup(o,l,r); return; &#125; bool f1=calc(root.id,l)&lt;calc(seg,l); bool f2=calc(root.id,r)&lt;calc(seg,r); if(f1==f2 || l==r) &#123; if(!f1) &#123; root.id=seg; pushup(o,l,r); &#125; return; &#125; int mid=(l+r)&gt;&gt;1; bool f3=calc(root.id,mid)&lt;calc(seg,mid); if(f1==f3) &#123; if(f1) upd(root.rs,mid+1,r,L,R,seg); else upd(root.rs,mid+1,r,L,R,root.id),root.id=seg; &#125; else &#123; if(f1) upd(root.ls,l,mid,L,R,root.id),root.id=seg; else upd(root.ls,l,mid,L,R,seg); &#125; &#125; else &#123; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(root.ls,l,mid,L,R,seg); if(R&gt;mid) upd(root.rs,mid+1,r,L,R,seg); &#125; pushup(o,l,r); &#125; void query(int o,int l,int r,int L,int R) &#123; if(root.id) &#123; if(k[root.id]&lt;0) ans=min(ans,calc(root.id,min(r,R))); else ans=min(ans,calc(root.id,max(l,L))); &#125; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; ans=min(ans,root.mi); return; &#125; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) query(root.ls,l,mid,L,R); if(R&gt;mid) query(root.rs,mid+1,r,L,R); &#125;&#125;T;void Modifiy1(int x,int lca,int A,int B)&#123; tmp=B; while(top[x]!=top[lca]) &#123; k[++cnt]=-A; b[cnt]=tmp+1LL*A*dist[dfn[x]]; int L=dfn[top[x]],R=dfn[x]; T.upd(1,1,n,L,R,cnt); tmp+=1LL*(dist[R]-dist[L]+distofa[top[x]])*A; x=fa[top[x]]; &#125; k[++cnt]=-A; b[cnt]=tmp+1LL*A*dist[dfn[x]]; int L=dfn[lca],R=dfn[x]; T.upd(1,1,n,L,R,cnt); tmp+=1LL*(dist[R]-dist[L])*A;&#125;void Modifiy2(int x,int lca,int A,int B)&#123; tmp+=1LL*(dist[dfn[x]]-dist[dfn[lca]])*A; while(top[x]!=top[lca]) &#123; k[++cnt]=A; b[cnt]=tmp-1LL*A*dist[dfn[x]]; int L=dfn[top[x]],R=dfn[x]; T.upd(1,1,n,L,R,cnt); tmp-=1LL*(dist[R]-dist[L]+distofa[top[x]])*A; x=fa[top[x]]; &#125; if(x!=lca) &#123; k[++cnt]=A; b[cnt]=tmp-1LL*A*dist[dfn[x]]; int L=dfn[lca]+1,R=dfn[x]; T.upd(1,1,n,L,R,cnt); &#125;&#125;void Query(int x,int lca)&#123; while(top[x]!=top[lca]) &#123; int L=dfn[top[x]],R=dfn[x]; T.query(1,1,n,L,R); x=fa[top[x]]; &#125; int L=dfn[lca],R=dfn[x]; T.query(1,1,n,L,R);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; dfs1(1,0); dfs2(1,1,0); T.BuildTree(1,n); while(m--) &#123; int tp=read(); int x=read(),y=read(); int lca=Query_LCA(x,y); if(tp==1) &#123; int A=read(),B=read(); Modifiy1(x,lca,A,B); Modifiy2(y,lca,A,B); &#125; else &#123; ans=inf; Query(x,lca); Query(y,lca); printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树链剖分</tag>
        <tag>李超线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4514 数字配对]]></title>
    <url>%2F2019%2F06%2F12%2Fbzoj-4514-%E6%95%B0%E5%AD%97%E9%85%8D%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[费用流. 将每个数字 $a_i$ 拆成入点 $p_i$ 和出点 $q_i$,对于 $S\to p_i,q_i\to T$ 连费用为 $0$ ,容量为 $b_i$ 的边. 若 $a_i,a_j$ 之间可以配对,就对于 $p_i\to q_j,p_j\to q_i$ 连费用为 $-c_i\cdot c_j$ ,容量为 $inf$ 的边. 跑 $mcmf$ ,每次 $spfa$ 完之后判一下是否会使得费用 $&gt;0$ ,若会,就加上限制下的最大流量,然后退出即可. 这样做每对的贡献都被算了 $2$ 次,所以最后答案要 $/2$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;const ll inf=1e18;int head[MAXN],ecnt=-1,pcnt=0;struct Edge&#123; int to,nx; ll flow,val;&#125;E[MAXN];void addedge(int u,int v,ll flow,ll val)&#123; ++ecnt; E[ecnt].to=v; E[ecnt].nx=head[u]; E[ecnt].flow=flow; E[ecnt].val=val; head[u]=ecnt;&#125;void ins(int u,int v,ll flow,ll val)&#123; addedge(u,v,flow,val); addedge(v,u,0,-val);&#125;int n,a[MAXN],b[MAXN],c[MAXN];int p[MAXN],q[MAXN];bool is_prime(int x)&#123; if(x==1) return false; for(int i=2;i*i&lt;=x;++i) if(x%i==0) return false; return true;&#125;int vis[MAXN],pre[MAXN],lst[MAXN];ll dis[MAXN],flow[MAXN];bool spfa(int S,int T)&#123; for(int i=1;i&lt;=pcnt;++i) dis[i]=inf,flow[i]=inf,vis[i]=0; pre[T]=-1; queue&lt;int&gt; q; dis[S]=0; vis[S]=1; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; for(int i=head[u];i!=-1;i=E[i].nx) &#123; int v=E[i].to; if(E[i].flow&gt;0 &amp;&amp; dis[v]-dis[u]&gt;E[i].val) &#123; dis[v]=dis[u]+E[i].val; pre[v]=u; lst[v]=i; flow[v]=min(flow[u],E[i].flow); if(!vis[v]) &#123; q.push(v); vis[v]=1; &#125; &#125; &#125; &#125; return pre[T]!=-1;&#125;ll mcmf(int S,int T)&#123; ll maxflow=0,mincost=0; while(spfa(S,T)) &#123; if(mincost+flow[T]*dis[T]&gt;0) &#123; ll tmp=-mincost; maxflow+=tmp/dis[T]; return maxflow; &#125; maxflow+=flow[T]; mincost+=flow[T]*dis[T]; int now=T; while(now!=S) &#123; E[lst[now]].flow-=flow[T]; E[lst[now]^1].flow+=flow[T]; now=pre[now]; &#125; &#125; return maxflow;&#125;int main()&#123; memset(head,-1,sizeof head); int S=++pcnt,T=++pcnt; n=read(); for(int i=1;i&lt;=n;++i) p[i]=++pcnt,q[i]=++pcnt; for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=1;i&lt;=n;++i) &#123; b[i]=read(); ins(S,p[i],b[i],0); ins(q[i],T,b[i],0); &#125; for(int i=1;i&lt;=n;++i) c[i]=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;i;++j) &#123; int x=max(a[i],a[j]),y=min(a[i],a[j]); if(x%y==0 &amp;&amp; is_prime(x/y)) &#123; ins(p[i],q[j],inf,-1LL*c[i]*c[j]); ins(p[j],q[i],inf,-1LL*c[i]*c[j]); &#125; &#125; int ans=mcmf(S,T); cout&lt;&lt;ans/2&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4584 赛艇]]></title>
    <url>%2F2019%2F06%2F12%2Fbzoj-4584-%E8%B5%9B%E8%89%87%2F</url>
    <content type="text"><![CDATA[$dp$ + 组合数学. 如果值域很小,那么可以直接设 $f(i,j)$ 表示考虑了前 $i$ 个人,第 $i$ 个人选 $j$ 的方案数. 于是考虑离散化.将这些区间离散化为 $O(n)$ 个区间,区间按 $l$ 从小到大排序,且互不相交. 设 $f(i,j)$ 表示考虑了前 $i$ 个人,第 $i$ 个人参了赛,且选择的数在第 $j$ 个区间内的方案数. 那么 $1\sim i-1$ 这些人选择的数有在区间 $j$ 内的,也有不在区间 $j$ 内的.若有 $m$ 个在区间 $j$ 内的,区间 $j$ 的长度为 $L$ ,那么方案数为 ${L+m-1\choose m}$ ,因为 $i$ 必须选.而不在区间 $j$ 内的部分就是个前缀和. 于是大力枚举从 $k$ 转移来,前 $p$ 个人都没选在区间 $j$ 内,用前缀和优化一下转移就好了. 时间复杂度 $O(n^3)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=500+10;int n,a[MAXN],b[MAXN],num[MAXN&lt;&lt;1],tot,g[MAXN],C[MAXN],inv[MAXN];void pre_inv()&#123; inv[1]=1; for(int i=2;i&lt;=n;++i) inv[i]=1LL*(P-P/i)*inv[P%i]%P;&#125;int main()&#123; n=read(); pre_inv(); for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); b[i]=read(); num[++tot]=a[i]; num[++tot]=b[i]+1; &#125; sort(num+1,num+1+tot); tot=unique(num+1,num+1+tot)-num-1; for(int i=1;i&lt;=n;++i) &#123; a[i]=lower_bound(num+1,num+1+tot,a[i])-num; b[i]=lower_bound(num+1,num+1+tot,b[i]+1)-num; &#125; C[0]=1; g[0]=1; for(int j=1;j&lt;tot;++j) &#123; int len=num[j+1]-num[j]; for(int i=1;i&lt;=n;++i) C[i]=mul(mul(C[i-1],len+i-1),inv[i]); for(int i=n;i&gt;=1;--i) &#123; if(a[i]&gt;j || b[i]&lt;j+1) continue; int f=0,m=1,c=len; for(int p=i-1;p&gt;=0;--p) &#123; f=add(f,mul(c,g[p])); if(a[p]&lt;=j &amp;&amp; j+1&lt;=b[p]) c=C[++m]; &#125; g[i]=add(g[i],f); &#125; &#125; int ans=0; for(int i=1;i&lt;=n;++i) ans=add(ans,g[i]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4596 黑暗前的幻想乡]]></title>
    <url>%2F2019%2F06%2F11%2Fbzoj-4596-%E9%BB%91%E6%9A%97%E5%89%8D%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%2F</url>
    <content type="text"><![CDATA[矩阵树定理 + 容斥原理. 如果把所有出现的边都加上,直接算生成树个数,可能会包括了有某些公司没有用边的情况. 于是减去 $1$ 个公司不修路,其他公司随便修的方案数.再加上 $2$ 个公司不修路的方案数… 二进制大力枚举每个公司的边考不考虑,用矩阵树定理算方案数,乘上容斥系数即可. 时间复杂度 $O(2^n\cdot n^3)$ . 二进制表示状态的题,下标从 $0$ 开始会方便一些. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;inline int count(int x)&#123; int s=0; while(x) s+=x&amp;1,x&gt;&gt;=1; return s;&#125;const int MAXN=20;typedef pair&lt;int,int&gt; pii;#define mp make_pairint n,ans=0;vector&lt;pii&gt; E[MAXN];int A[MAXN][MAXN];int sgn;void SwapRow(int x,int y,int k)&#123; for(int i=k;i&lt;n;++i) swap(A[x][i],A[y][i]);&#125;void GCD(int x,int y)&#123; if(!A[y][x]) return; int t=A[x][x]/A[y][x]; for(int i=x;i&lt;n;++i) A[x][i]=add(A[x][i],P-mul(t,A[y][i])); SwapRow(x,y,x); sgn*=-1; GCD(x,y);&#125;void Gauss(int x)&#123; if(x==n-1) return; if(!A[x][x]) &#123; for(int i=x+1;i&lt;n;++i) if(A[i][x]) &#123; SwapRow(x,i,x); sgn*=-1; break; &#125; &#125; if(!A[x][x]) return; for(int i=x+1;i&lt;n;++i) if(A[i][x]) GCD(x,i); Gauss(x+1);&#125;int det()&#123; int res=1; sgn=1; Gauss(1); for(int i=1;i&lt;n;++i) res=mul(res,A[i][i]); return add(P,sgn*res);&#125;int main()&#123; n=read(); for(int i=0;i&lt;n-1;++i) &#123; int m=read(); for(int j=1;j&lt;=m;++j) &#123; int u=read(),v=read(); E[i].push_back(mp(u-1,v-1)); &#125; &#125; int mx=1&lt;&lt;(n-1); for(int st=0;st&lt;mx;++st) &#123; memset(A,0,sizeof A); int tot=count(st); for(int i=0;i&lt;n-1;++i) &#123; if((st&gt;&gt;i)&amp;1) continue; int siz=E[i].size(); for(int j=0;j&lt;siz;++j) &#123; int u=E[i][j].first; int v=E[i][j].second; ++A[u][u],++A[v][v]; A[u][v]=add(A[u][v],P-1); A[v][u]=add(A[v][u],P-1); &#125; &#125; if(tot&amp;1) ans=add(ans,P-det()); else ans=add(ans,det()); &#125; cout&lt;&lt;add(ans%P,P)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>高斯消元</tag>
        <tag>矩阵树定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190611]]></title>
    <url>%2F2019%2F06%2F11%2Ftest20190611%2F</url>
    <content type="text"><![CDATA[$noip$ 模拟题? $exam$ 贪心. 显然是每 $k$ 题安排错一次能使得分最小.若能通过安排使得没有 $k$ 个连续正确,那么答案就是 $m$ . 否则,一定会出现连续对 $k$ 次,我们尽量把它们安排在前面,错的题安排在后面.这样后面贡献就是做对的题目数,前面的贡献是连续做对 $x$ 道题目得分.这个得分单独算一下就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;inline int read()&#123; int x=0,k=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') &#123;if(ch=='-') k=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return k*x;&#125;const int P=1e9+9;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int n,m,k;int calc(int x)&#123; int t=x/k; int tmp=fpow(2,t+1); tmp=add(tmp,P-2-t); tmp=mul(tmp,k); return add(tmp,x);&#125;int main()//use dp to check&#123; freopen("exam.in","r",stdin); freopen("exam.out","w",stdout); n=read(),m=read(),k=read(); m=n-m; int tot=n/k; int ans=0; if(tot&lt;=m) &#123; ans=n-m; cout&lt;&lt;ans&lt;&lt;endl; &#125; else &#123; int x=n-m*k; ans=calc(x); ans=add(ans,mul(m,k-1)); cout&lt;&lt;add(ans%P,P)&lt;&lt;endl; &#125; return 0;&#125; $genes$ 线段树. 其实只有 $n$ 种情况,每次将第一个元素放到最后,并检验当前是否合法,做 $n$ 次即可. 用线段树来维护每个元素当前对应的前缀和就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;inline int read()&#123; int x=0,k=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') &#123;if(ch=='-') k=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return k*x;&#125;const int MAXN=1e6+10;int n,a[MAXN],sum[MAXN],tot;struct Segtree&#123; int val[MAXN&lt;&lt;2]; int tag[MAXN&lt;&lt;2];#define root val[o]#define lson val[o&lt;&lt;1]#define rson val[o&lt;&lt;1|1] void pushup(int o) &#123; root=min(lson,rson); &#125; void modifiy(int o,int c) &#123; root+=c; tag[o]+=c; &#125; void pushdown(int o) &#123; if(tag[o]) &#123; modifiy(o&lt;&lt;1,tag[o]); modifiy(o&lt;&lt;1|1,tag[o]); tag[o]=0; &#125; &#125; void BuildTree(int o,int l,int r) &#123; tag[o]=0; if(l==r) &#123; root=sum[l]; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; void upd(int o,int l,int r,int L,int R,int c) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125; int query(int o,int l,int r,int pos) &#123; if(l==r) return root; int mid=(l+r)&gt;&gt;1; pushdown(o); if(pos&lt;=mid) return query(o&lt;&lt;1,l,mid,pos); else return query(o&lt;&lt;1|1,mid+1,r,pos); &#125; int check() &#123; return val[1]&gt;=0; &#125;&#125;T;int main()//use bf to check&#123; freopen("genes.in","r",stdin); freopen("genes.out","w",stdout); n=read(); for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); sum[i]=sum[i-1]+a[i]; &#125; tot=sum[n]; T.BuildTree(1,1,n); int ans=0; for(int i=1;i&lt;=n;++i) &#123; int tmp=T.query(1,1,n,i); T.upd(1,1,n,i,i,tot-tmp); if(i&gt;1) T.upd(1,1,n,1,i-1,-tmp); if(i&lt;n) T.upd(1,1,n,i+1,n,-tmp); ans+=T.check(); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; $paths$ $dp$ . 其实就是要求两条不相交路径总长最小值.设 $f(i,j)$ 表示当前一条路径的最后一个点是 $i$ ,另一条路径的最后一个点是 $j$ 时的最短长度. 每次用 $f(i,j)$ 去更新 $f(i,1+\max(i,j)),f(1+\max(i,j),j)$ 就可以保证每个点恰好被选一次了. 特殊点和起点终点特判一下就可以了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define rg registerusing namespace std;inline int read()&#123; int x=0,k=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') &#123; if(ch=='-') k=-1; ch=getchar(); &#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0'; ch=getchar(); &#125; return k*x;&#125;const int MAXN=1e3+10;const double inf=1e18;int n,x[MAXN],y[MAXN],b1,b2;double dis[MAXN][MAXN],f[MAXN][MAXN];double calcModulus(int i,int j)&#123; return sqrt(1.0*(x[i]-x[j])*(x[i]-x[j])+1.0*(y[i]-y[j])*(y[i]-y[j]));&#125;int main()&#123; freopen("paths.in","r",stdin); freopen("paths.out","w",stdout); n=read(),b1=read()+1,b2=read()+1; for(int i=1; i&lt;=n; ++i) &#123; x[i]=read(); y[i]=read(); for(int j=1; j&lt;i; ++j) dis[i][j]=dis[j][i]=calcModulus(i,j); &#125; for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=n; ++j) f[i][j]=inf; f[1][1]=0; for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=n; ++j) &#123; if(i==n &amp;&amp; j==n) break; int k=max(i,j)+1; if(k&gt;n) --k; if(k!=b2) f[k][j]=min(f[k][j],f[i][j]+dis[i][k]); if(k!=b1) f[i][k]=min(f[i][k],f[i][j]+dis[j][k]); &#125; printf("%.2f\n",f[n][n]); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>线段树</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4590 自动刷题机]]></title>
    <url>%2F2019%2F06%2F10%2Fbzoj-4590-%E8%87%AA%E5%8A%A8%E5%88%B7%E9%A2%98%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[二分答案. 不难发现 $n$ 增大,切题数不会增多, $n$ 减小,切题数不会减少. 于是分别二分 $n$ 的最小值与最大值,检验直接模拟操作就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,k,x[MAXN];bool checkmin(ll mid)&#123; int tot=0; ll len=0; for(int i=1;i&lt;=n;++i) &#123; len+=x[i]; len=max(len,0LL); if(len&gt;=mid) len=0,++tot; &#125; if(len&gt;=mid) len=0,++tot; return tot&lt;=k;&#125;ll solvemin()&#123; ll L=1,R=1e18; ll ans=-1; while(L&lt;=R) &#123; ll mid=(L+R)&gt;&gt;1; if(checkmin(mid)) ans=mid,R=mid-1; else L=mid+1; &#125; return ans;&#125;bool checkmax(ll mid)&#123; int tot=0; ll len=0; for(int i=1;i&lt;=n;++i) &#123; len+=x[i]; len=max(len,0LL); if(len&gt;=mid) len=0,++tot; &#125; if(len&gt;=mid) len=0,++tot; return tot&gt;=k;&#125;ll solvemax()&#123; ll L=1,R=1e18; ll ans=-1; while(L&lt;=R) &#123; ll mid=(L+R)&gt;&gt;1; if(checkmax(mid)) ans=mid,L=mid+1; else R=mid-1; &#125; return ans;&#125;int main()&#123; n=read(),k=read(); for(int i=1;i&lt;=n;++i) x[i]=read(); ll a=solvemin(),b=solvemax(); if(a&gt;b || a&lt;0 || b&lt;0) puts("-1"); else cout&lt;&lt;a&lt;&lt;' '&lt;&lt;b&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1173]]></title>
    <url>%2F2019%2F06%2F08%2FCF1173%2F</url>
    <content type="text"><![CDATA[$Div.2$ 官方题解 A Nauuo and Votes 签到题. B Nauuo and Chess 构造题. 可以将所有数沿着第一列与最后一行放成一个 $L$ 形.容易验证一定是合法的. 这样构造, $m=\lfloor \frac n 2 \rfloor+1$ .而考虑首尾两个位置,有$$|r_1-r_n|+|c_1-c_n|\geq n-1$$ 而 $|r_1-r_n|\leq m-1,|c_1-c_n|\leq m-1$ ,所以 $2m-2\geq n-1$ , $m$ 为整数,可得到 $m\geq \lfloor \frac n 2 \rfloor+1$ . 所以这样构造一定是一个最优解. C Nauuo and Cards 策略是如果能不打 $0$ 直接完成,就直接完成,否则先打若干 $0$ ,然后再也不打 $0$ . 考虑如果已经打了若干 $0$ ,开始一直打数字牌,那么此时 $1$ 必定在手中, $2$ 必定在手中或在牌堆的第 $1$ 个位置(打了 $1$ 就会被摸到手中), $3$ 必定在手中或在第 $2$ 个位置,以此类推. 如果有一些牌的位置不合要求,那么我们需要先打空白牌来将他们加入到手中或是放到正确的位置. 在手中可以看做位置 $0$ ,记 $p_i$ 为 $i$ 的初始位置,那么答案就是 $n+\max\limits_{i=1}^n (p_i-i+1)$ . $n$ 是因为要连续打出 $1\sim n$ 这些牌,后面的部分是将 $p_i$ 调整到 $i-1$ 所需打出的 $0$ 的数目. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,a[MAXN],b[MAXN],p[MAXN];int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=1;i&lt;=n;++i) p[b[i]=read()]=i; if(p[1]) &#123; int x; for(x=2;p[x]==p[1]+x-1;++x); if(p[x-1]==n) &#123; int y; for(y=x;y&lt;=n &amp;&amp; p[y]&lt;=y-x;++y); if(y&gt;n) &#123; cout&lt;&lt;n-x+1&lt;&lt;endl; return 0; &#125; &#125; &#125; int ans=0; for(int i=1;i&lt;=n;++i) ans=max(ans,p[i]-i+1); cout&lt;&lt;ans+n&lt;&lt;endl; return 0;&#125; D Nauuo and Circle $dp$ 计数. 考虑 $dp$ ,设 $f_u$ 表示子树 $u$ 的方案数,先钦定根节点为 $1$ ,最后答案就是 $n\cdot f_1$ . 画子树时,先要给所有儿子,若不为根,还有自己排序,转移有 $f_u=(|son_u|+[u==1])!\cdot \prod\limits_{v \in son_u}f_v$ . 把 $dp$ 的式子展开,可以发现答案就是 $n\cdot \prod\limits _{i=1}^n deg_i$ , $deg$ 表示度数. 待续…]]></content>
      <tags>
        <tag>树形dp</tag>
        <tag>dp计数</tag>
        <tag>构造</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4805 欧拉函数求和]]></title>
    <url>%2F2019%2F06%2F08%2Fbzoj-4805-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[练习了min_25筛.跑得挺快的. 注意将所有数都当成质数时, $f(x)=x-1$ ,但它并不是个完全积性函数. 所以要拆成 $f(x)=1,g(x)=x$ 两个函数分别预处理,然后相减. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int cnt=0,prime[MAXN],ism[MAXN];ll sumphi[MAXN];void init_prime(int n)&#123; ism[1]=1; for(int i=2;i&lt;=n;++i) &#123; if(!ism[i]) prime[++cnt]=i; for(int j=1;j&lt;=cnt &amp;&amp; i*prime[j]&lt;=n;++j) &#123; ism[i*prime[j]]=1; if(i%prime[j]==0) break; &#125; &#125; for(int i=1;i&lt;=cnt;++i) sumphi[i]=sumphi[i-1]+prime[i]-1;&#125;ll calcsum(int x)&#123; return 1LL*(2+x)*(x-1)/2;&#125;int tot=0,w[MAXN],id1[MAXN],id2[MAXN];ll f[MAXN],g[MAXN];int N,sqN;ll S(int n,int j)&#123; if(n&lt;=1 || prime[j]&gt;n) return 0; int id=n; if(id&lt;=sqN) id=id1[id]; else id=id2[N/id]; ll res=g[id]-sumphi[j-1]; for(int k=j;k&lt;=cnt &amp;&amp; 1LL*prime[k]*prime[k]&lt;=n;++k) &#123; ll pw1=prime[k],pw2=prime[k]*prime[k]; for(int e=1;pw2&lt;=n;++e) &#123; ll tmp=pw1/prime[k]*(prime[k]-1); tmp*=S(n/pw1,k+1); tmp+=pw2/prime[k]*(prime[k]-1); res+=tmp; pw1*=prime[k],pw2*=prime[k]; &#125; &#125; return res;&#125;int main()&#123; N=read(); sqN=(sqrt(N)); init_prime(sqN); for(int l=1,r;l&lt;=N;l=r+1) &#123; r=N/(N/l); w[++tot]=N/l; if(N/l&lt;=sqN) id1[N/l]=tot; else id2[N/(N/l)]=tot; &#125; for(int i=1;i&lt;=tot;++i) f[i]=w[i]-1,g[i]=calcsum(w[i]); for(int j=1;j&lt;=cnt;++j) for(int i=1;i&lt;=tot &amp;&amp; prime[j]*prime[j]&lt;=w[i];++i) &#123; int k=w[i]/prime[j]; if(k&lt;=sqN) k=id1[k]; else k=id2[N/k]; g[i]-=1LL*(prime[j])*(g[k]-sumphi[j-1]-j+1); f[i]-=f[k]-j+1; &#125; for(int i=1;i&lt;=tot;++i) g[i]-=f[i]; ll ans=S(N,1)+1; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[min_25筛学习笔记]]></title>
    <url>%2F2019%2F06%2F05%2Fmin-25%E7%AD%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一篇比较详细的学习笔记. 由于渲染有点小问题,所以就直接传 $PDF$ 了.]]></content>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4667 小y的密码]]></title>
    <url>%2F2019%2F06%2F04%2Fbzoj-4667-%E5%B0%8Fy%E7%9A%84%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[排列/组合计数. 限制是否满足只与 $0\sim 9$ 这些数字各自出现了多少次有关.所以可以 $dfs$ 大力枚举这些数字各自的出现次数. 若限制满足,再计算用这些数字能组合出多少 $\leq n$ 的数. 若这些数个数不足 $n$ 的位数,那么就是带重复元素的排列数.注意减掉有前导 $0$ 的情况. 若个数达到了 $n$ 的位数,就枚举从哪一位开始可以不用考虑限制(就相当于数位 $dp$ 里面那个 $limit$ ). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int n,k,limit;int t,pw[11];int a[11],tot[11],fig[11],m=0;int fac[11];ll ans=0;bool check()&#123; if(!m || !a[m]) return false; int mid=a[(m+1)&gt;&gt;1]; ll sum=0; for(int i=1;i&lt;=m &amp;&amp; sum&lt;=limit;++i) &#123; ll tmp=1; for(int j=1;j&lt;=k;++j) tmp*=a[i]-mid; sum+=tmp; &#125; return sum&lt;=limit;&#125;int calc(int x)&#123; int res=fac[x]; for(int i=0;i&lt;=9;++i) res/=fac[tot[i]]; return res;&#125;void solve()&#123; memset(tot,0,sizeof tot); for(int i=1;i&lt;=m;++i) ++tot[a[i]]; if(m&lt;t) &#123; ans+=calc(m); if(tot[0]) &#123; --tot[0]; ans-=calc(m-1); &#125; &#125; else &#123; bool flag=true; int tmp=t; for(int i=t;i&gt;=1;--i) &#123; for(int j=(i==t);j&lt;fig[i];++j) if(tot[j]) &#123; --tot[j]; --tmp; ans+=calc(tmp); ++tot[j]; ++tmp; &#125; if(!tot[fig[i]]) &#123; flag=false; break; &#125; --tot[fig[i]]; --tmp; &#125; ans+=(int)flag; &#125;&#125;void dfs(int x)&#123; if(check()) solve(); if(m==t) return; for(int i=x;i&lt;=9;++i) &#123; ++m; a[m]=i; dfs(i); --m; &#125;&#125;int main()&#123; fac[0]=1; for(int i=1;i&lt;=9;++i) fac[i]=fac[i-1]*i; n=read(),k=read(),limit=read(); while(n) fig[++t]=n%10,n/=10; dfs(0); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4606 DNA]]></title>
    <url>%2F2019%2F06%2F04%2Fbzoj-4606-DNA%2F</url>
    <content type="text"><![CDATA[$dp$ 计数. 求第 $R$ 大,可以想到把某一类的方案数全部算出来,用 $R$ 去减,就和用平衡树求第 $k$ 大,用 $k$ 减 $siz$ 的操作类似. 题面都明示了? 设 $f(i,j,k)$ 表示第 $i$ 个字符填 $j$ ,至少需要分成 $k$ 个不下降段的方案数.倒着 $dp$ 即可. 最后就从前往后匹配,一边匹配一边减就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e4+10;int n,m,a[MAXN],id[400];char s[MAXN],invid[5]=&#123;'A','C','G','T'&#125;;ll f[MAXN][5][11],R;int main()&#123; for(int i=0;i&lt;4;++i) id[invid[i]]=i; id['N']=4; n=read(),m=read(); R=read(); scanf("%s",s+1); for(int i=1;i&lt;=n;++i) a[i]=id[s[i]]; if(a[n]==4) for(int i=0;i&lt;4;++i) f[n][i][1]=1; else f[n][a[n]][1]=1; for(int i=n-1;i&gt;=1;--i) &#123; if(a[i]==4) &#123; for(int j=0;j&lt;4;++j) for(int k=1;k&lt;=m;++k) for(int l=0;l&lt;4;++l) f[i][j][k]+=f[i+1][l][k-(j&gt;l)]; &#125; else &#123; for(int k=1;k&lt;=m;++k) for(int l=0;l&lt;4;++l) f[i][a[i]][k]+=f[i+1][l][k-(a[i]&gt;l)]; &#125; &#125; for(int i=1;i&lt;=n;++i) for(int j=0;j&lt;4;++j) for(int k=1;k&lt;=m;++k) f[i][j][k]+=f[i][j][k-1]; a[0]=0; for(int i=1;i&lt;=n;++i) &#123; if(a[i]==4) &#123; for(int j=0;j&lt;4;++j) &#123; ll tmp=(j&lt;a[i-1])?f[i][j][m-1]:f[i][j][m]; if(R&gt;tmp) R-=tmp; else &#123; a[i]=j; break; &#125; &#125; &#125; if(a[i]&lt;a[i-1]) --m; printf("%c",invid[a[i]]); &#125; puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4600 硬币游戏]]></title>
    <url>%2F2019%2F06%2F04%2Fbzoj-4600-%E7%A1%AC%E5%B8%81%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[博弈论. 操作一枚硬币,它只能影响到 $c$ 与自己相同的硬币.于是 $SG$ 函数就只需要 $a,b$ 两个状态. 而 $a,b$ 是指数,非常小,所以状态数目也很少,直接暴力计算 $SG$ 函数即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=25;int SG[MAXN][MAXN][MAXN];void init_SG(int maxq)&#123; vector&lt;int&gt; s; int tmp=0; for(int a=0;a&lt;=20;++a) for(int b=0;b&lt;=20;++b) &#123; s.clear(); for(int p=1;p&lt;=20;++p,tmp=0) for(int q=1;q&lt;=maxq &amp;&amp; p*q&lt;=a;++q) &#123; tmp^=SG[maxq][a-p*q][b]; s.push_back(tmp); &#125; for(int p=1;p&lt;=20;++p,tmp=0) for(int q=1;q&lt;=maxq &amp;&amp; p*q&lt;=b;++q) &#123; tmp^=SG[maxq][a][b-p*q]; s.push_back(tmp); &#125; sort(s.begin(),s.end()); int siz=s.size(); if(!siz || s[0]) &#123; SG[maxq][a][b]=0; continue; &#125; for(int i=1;i&lt;siz;++i) &#123; if(s[i]-s[i-1]&gt;=2) &#123; SG[maxq][a][b]=s[i-1]+1; break; &#125; &#125; if(!SG[maxq][a][b]) SG[maxq][a][b]=s[siz-1]+1; &#125;&#125;int n,maxq;int main()&#123; for(int i=1;i&lt;=20;++i) init_SG(i); int T=read(); while(T--) &#123; n=read(),maxq=read(); int ans=0; for(int i=1;i&lt;=n;++i) &#123; int dir=read(); if(dir) continue; int x=i,a=0,b=0; while(x%2==0) ++a,x/=2; while(x%3==0) ++b,x/=3; ans^=SG[maxq][a][b]; &#125; if(ans) puts("win"); else puts("lose"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4602 齿轮]]></title>
    <url>%2F2019%2F06%2F04%2Fbzoj-4602-%E9%BD%BF%E8%BD%AE%2F</url>
    <content type="text"><![CDATA[图的 $dfs$ 遍历. 方向和速度显然可以分开判. 方向就是判二分图.而对于速度,走过一条边,相对速度可以看做乘了一个比值. 因为 $x,y\leq 100$ ,所以可以直接分解质因数,像染色那样做就可以了. 时间复杂度 $O(25m)$ . 另外一种更优雅的方法是直接在模大质数意义下做乘除法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e4+10;int ism[101],cnt=0,prime[101];void init_prime()&#123; ism[1]=1; for(int i=2;i&lt;=100;++i) &#123; if(!ism[i]) prime[++cnt]=i; for(int j=1;j&lt;=cnt &amp;&amp; prime[j]*i&lt;=100;++j) &#123; ism[prime[j]*i]=1; if(i%prime[j]==0) break; &#125; &#125;&#125;int ecnt,head[MAXN];struct edge&#123; int to,nx; int dir; int x,y;&#125;E[MAXN&lt;&lt;1];void addedge(int u,int v,int x,int y)&#123; ++ecnt; E[ecnt].to=v; E[ecnt].nx=head[u]; E[ecnt].dir=(x*y&lt;0)?-1:1; E[ecnt].x=abs(x); E[ecnt].y=abs(y); head[u]=ecnt;&#125;int n,m;int dir[MAXN],factor[MAXN][26];void init()&#123; ecnt=0; memset(head,0,sizeof head); memset(dir,0,sizeof dir); memset(factor,0,sizeof factor);&#125;int transfac[26];void add(int x,int c)&#123; for(int i=1;i&lt;=cnt &amp;&amp; prime[i]&lt;=x;++i) while(x%prime[i]==0) &#123; x/=prime[i]; transfac[i]+=c; &#125;&#125;bool dfs(int u)&#123; bool flag=true; for(int i=head[u];i &amp;&amp; flag;i=E[i].nx) &#123; int v=E[i].to; memset(transfac,0,sizeof transfac); add(E[i].y,1); add(E[i].x,-1); if(dir[v]) &#123; if(dir[u]*E[i].dir!=dir[v]) return false; for(int i=1;i&lt;=25;++i) if(factor[u][i]+transfac[i]!=factor[v][i]) return false; &#125; else &#123; dir[v]=dir[u]*E[i].dir; for(int i=1;i&lt;=25;++i) factor[v][i]=factor[u][i]+transfac[i]; flag&amp;=dfs(v); &#125; &#125; return flag;&#125;int main()&#123; init_prime(); int T=read(); for(int casenum=1;casenum&lt;=T;++casenum) &#123; init(); n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(),x=read(),y=read(); addedge(u,v,x,y); addedge(v,u,y,x); &#125; bool flag=true; for(int i=1;i&lt;=n &amp;&amp; flag;++i) if(!dir[i]) &#123; dir[i]=1; flag&amp;=dfs(i); &#125; if(flag) printf("Case #%d: Yes\n",casenum); else printf("Case #%d: No\n",casenum); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4627 回转寿司]]></title>
    <url>%2F2019%2F06%2F03%2Fbzoj-4627-%E5%9B%9E%E8%BD%AC%E5%AF%BF%E5%8F%B8%2F</url>
    <content type="text"><![CDATA[线段树. 区间和可以转化为前缀和之差.记前缀和为 $sum$ ,从前往后加入数,加入到第 $i$ 个数的时候,就要算 $L\leq sum_i-sum_j\leq R,0\leq j&lt;i$ 的 $j$ 的数目. 不等式变一下,就是求 $sum_i-R\leq sum_j\leq sum_i-L$ 的数目.用权值线段树来维护,动态开点即可. 注意权值可能是负的,所以根节点的 $l,r$ 分别为 $-inf,inf$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;const ll inf=1e10;int n,L,R;struct Segtree&#123; int idx; struct node &#123; int cnt; int ls,rs; node()&#123;cnt=ls=rs=0;&#125; &#125;Tree[MAXN*50]; Segtree()&#123;idx=0;&#125;#define root Tree[o] void upd(int &amp;o,ll l,ll r,ll pos) &#123; if(!o) o=++idx; ++root.cnt; if(l==r) return; ll mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(root.ls,l,mid,pos); else upd(root.rs,mid+1,r,pos); &#125; int query(int o,ll l,ll r,ll L,ll R) &#123; if(L&gt;R || R&lt;l || l&gt;R) return 0; if(L&lt;=l &amp;&amp; r&lt;=R) return root.cnt; int res=0; ll mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res+=query(root.ls,l,mid,L,R); if(R&gt;mid) res+=query(root.rs,mid+1,r,L,R); return res; &#125;&#125;T;int rt=0;ll ans=0,sum=0;int main()&#123; n=read(); L=read(),R=read(); T.upd(rt,-inf,inf,0); for(int i=1;i&lt;=n;++i) &#123; sum+=read(); ans+=T.query(rt,-inf,inf,sum-R,sum-L); T.upd(rt,-inf,inf,sum); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4662 snow]]></title>
    <url>%2F2019%2F06%2F02%2Fbzoj-4662-snow%2F</url>
    <content type="text"><![CDATA[线段树. 考虑将 $L$ 离散化后,用线段树来维护每个清理工当前的工作长度. 若一个人将区间 $[L,R]$ 清扫后,被影响的人 $i$ 应该满足 $L&lt;L_i\leq R$ 或 $R_i\geq L&gt;L_i$ ,编号是一个区间. 显然不能直接修改,因为对它们的影响是不一样的.但对于所有影响到的 $L_i$ 相同的 $i$ 或所有 $R_i$ 相同的 $i$ 的影响是一样的,而这些人的编号也是一个区间. 于是可以用一个 $set$ 存储所有的三元组 $(l,r,pos)$ 表示编号在区间 $l,r$ 内的人,均满足 $L_i=pos$ .再用一个 $set$ 存储 $R_i=pos$ 的所有三元组. 修改时暴力取出所有的三元组,在线段树上修改后将它们合并成一个三元组放回去.而合并只会使区间变大,操作总次数是 $O(n)$ 的,所以时间复杂度是对的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;const int inf=1e9;int n,t,L[MAXN],R[MAXN];struct Segtree&#123; struct node &#123; int tag,val; node()&#123;tag=val=0;&#125; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.val=min(lson.val,rson.val); &#125; void modifiy(int o,int c) &#123; root.tag+=c; root.tag=min(root.tag,inf); root.val+=c; root.val=min(root.val,inf); &#125; void pushdown(int o) &#123; if(root.tag) &#123; modifiy(o&lt;&lt;1,root.tag); modifiy(o&lt;&lt;1|1,root.tag); root.tag=0; &#125; &#125; void BuildTree(int o,int l,int r) &#123; if(l==r) &#123; root.val=R[l]-L[l]+1; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; void upd(int o,int l,int r,int L,int R,int c)//[L,R]+=c &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c); return; &#125; pushdown(o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125; int query(int o,int l,int r) &#123; if(l==r) return l; pushdown(o); int mid=(l+r)&gt;&gt;1; if(lson.val&lt;=rson.val) return query(o&lt;&lt;1,l,mid); else return query(o&lt;&lt;1|1,mid+1,r); &#125;&#125;Seg;struct Fenwicktree&#123; int bit[MAXN]; Fenwicktree()&#123;memset(bit,0,sizeof bit);&#125;#define lowbit(x) x&amp;(-x) void add(int x,int c) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=c,bit[x]=min(bit[x],inf); &#125; int query(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x],s=min(s,inf); return s; &#125; void upd(int L,int R,int c) &#123; add(L,c); add(R+1,-c); &#125;&#125;Fenwick;struct interval&#123; int l,r,pos; interval(int l=0,int r=0,int pos=0):l(l),r(r),pos(pos) &#123;&#125; bool operator &lt; (const interval &amp;rhs) const &#123; return pos&lt;rhs.pos; &#125;&#125;;set&lt;interval&gt; SL,SR;set&lt;interval&gt;::iterator it,tt;int main()&#123; t=read(),n=read(); for(int i=1;i&lt;=n;++i) &#123; L[i]=read(); R[i]=read(); &#125; for(int i=1;i&lt;=n;++i) &#123; Fenwick.add(i,L[i]-L[i-1]); SL.insert(interval(i,i,L[i])); SR.insert(interval(i,i,R[i])); &#125; Seg.BuildTree(1,1,n); SL.insert(interval(0,0,0)); SL.insert(interval(0,0,t+1)); SR.insert(interval(0,0,0)); SR.insert(interval(0,0,t+1)); for(int i=1;i&lt;=n;++i) &#123; int x=Seg.query(1,1,n); printf("%d\n",x); int l=Fenwick.query(x); int r=l+Seg.Tree[1].val-1; if(l!=r) &#123; int lx=n+1,rx=1; interval tmp=interval(0,0,l); it=SL.lower_bound(tmp); while((*it).pos&lt;=r) &#123; rx=max(rx,(*it).r); lx=min(lx,(*it).l); Fenwick.upd((*it).l,(*it).r,r-(*it).pos); Seg.upd(1,1,n,(*it).l,(*it).r,(*it).pos-r); tt=it; ++it; SL.erase(tt); &#125; SL.insert(interval(lx,rx,r)); lx=n+1,rx=1; tmp=interval(0,0,r); it=SR.lower_bound(tmp); while((*it).pos&gt;l) &#123; rx=max(rx,(*it).r); lx=min(lx,(*it).l); Seg.upd(1,1,n,(*it).l,(*it).r,l-(*it).pos); tt=it; --it; SR.erase(tt); &#125; SR.insert(interval(lx,rx,l)); &#125; Seg.upd(1,1,n,x,x,inf); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4663 hack]]></title>
    <url>%2F2019%2F05%2F30%2Fbzoj-4663-hack%2F</url>
    <content type="text"><![CDATA[最小割. 如果没有只能经过 $1$ 条被 $hack$ 边的限制,就是个裸的最小割. 解决的方法就是反向边的权值建成 $inf$ .感性理解一下,看下面这个图(图来自出题人): 在没有建 $inf$ 边前,割掉图中两条红色标记边是最优方案.而加上 $inf$ 后,就会出现 $st\to b\to a\to ed$ 这条路径.还需要割掉其他的边. 这样一来,不同时割掉两条红色标记边(即在一条路径上的边)就不会变得更劣. 还要注意将 $st$ 原来到不了的点预处理出来,将它们打上标记删去.否则可能出现如下情况(图来自出题人): 本来 $st$ 到不了 $a$ ,但加了 $inf$ 边后就连通了,会导致割掉额外的边. 这大概是几个月前考试做的?犹记李巨随手切了此题. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e2+10,MAXM=1e4+10;const ll inf=1e18;int ecnt=-1,head[MAXN];struct Edge&#123; int to,nx; ll flow;&#125;E[MAXM];void addedge(int u,int v,ll flow)&#123; ++ecnt; E[ecnt].to=v; E[ecnt].nx=head[u]; E[ecnt].flow=flow; head[u]=ecnt;&#125;int n,m;bool reachable[MAXN];void init()&#123; queue&lt;int&gt; q; reachable[1]=true; q.push(1); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u];i!=-1;i=E[i].nx) &#123; int v=E[i].to; if(reachable[v] || E[i].flow&gt;=inf) continue; reachable[v]=true; q.push(v); &#125; &#125;&#125;int dep[MAXN],cur[MAXN];bool bfs(int S,int T)&#123; for(int i=1;i&lt;=n;++i) cur[i]=head[i]; memset(dep,-1,sizeof dep); dep[S]=0; queue&lt;int&gt; q; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u];i!=-1;i=E[i].nx) &#123; int v=E[i].to; if(!reachable[v] || E[i].flow&lt;=0 || dep[v]!=-1) continue; dep[v]=dep[u]+1; q.push(v); &#125; &#125; return dep[T]!=-1;&#125;ll dfs(int u,int T,ll limit)&#123; if(u==T || !limit) return limit; ll f,flow=0; for(int i=cur[u];i!=-1;i=E[i].nx) &#123; cur[u]=i; int v=E[i].to; if(!reachable[v]) continue; if(E[i].flow&gt;0 &amp;&amp; dep[v]==dep[u]+1 &amp;&amp; (f=dfs(v,T,min(limit,E[i].flow)))) &#123; flow+=f; limit-=f; E[i].flow-=f; E[i^1].flow+=f; if(!limit) break; &#125; &#125; return flow;&#125;ll Dinic(int S,int T)&#123; ll maxflow=0; while(bfs(S,T)) maxflow+=dfs(S,T,inf); return maxflow;&#125;int main()&#123; memset(head,-1,sizeof head); n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read()+1; int v=read()+1; int w=read(); addedge(u,v,w); addedge(v,u,inf); &#125; init(); ll ans=Dinic(1,n); if(ans&lt;0 || ans&gt;=inf) puts("-1"); else cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4681 旅行]]></title>
    <url>%2F2019%2F05%2F30%2Fbzoj-4681-%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[最短路. 这类点,边数目比较少,却有一些奇奇怪怪的条件的最短路,大多都是拆点.然而实现时并不需要真的拆点,只需要在做最短路的时候给 $dis$ 多加几维即可. 考虑暴力做法,应该是 $dfs$ 找出每一条路径,贪心地将不在路径上最短的边与在路径上最长的边交换,最多 $k$ 次. 然而路径条数可以被随便搞到指数级. 沿用贪心的思想,最后最优路径中的边一定会包含全部前 $L$ 小的边,可以将边排序,枚举 $L$ ,结合最短路解决. 设 $f(u,j,k)$ 表示从 $1$ 到 $u$ ,路径上有 $j$ 条前 $L$ 小的边,交换了 $k$ 次时的最短路.转移时分当前边不在前 $L$ 小与当前边在前 $L$ 小,用 $Dijkstra$ 转移即可. 注意正反加了两条边,实际排名需 $/2$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=151;int ans=0x7fffffff;int ecnt=0,head[MAXN],nx[MAXN&lt;&lt;1],to[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;struct Edge&#123; int u,v,len; bool operator &lt; (const Edge &amp;rhs) const &#123; return len&lt;rhs.len; &#125;&#125;E[MAXN];struct node&#123; int u,j,k,dis; bool operator &lt; (const node &amp;rhs) const &#123; return dis&gt;rhs.dis; &#125; node(int u=0,int j=0,int k=0,int dis=0):u(u),j(j),k(k),dis(dis) &#123;&#125;&#125;;int N,M,K;int dis[MAXN][MAXN][MAXN],vis[MAXN][MAXN][MAXN];priority_queue&lt;node&gt; q;void Dijkstra(int L)&#123; memset(vis,0,sizeof vis); memset(dis,63,sizeof dis); node p=node(1,0,0,0); dis[1][0][0]=0; q.push(p); while(!q.empty()) &#123; p=q.top(); q.pop(); int u=p.u,j=p.j,k=p.k; if(vis[u][j][k]) continue; vis[u][j][k]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(i&lt;=L*2) &#123; if(j&lt;L &amp;&amp; dis[v][j+1][k]-dis[u][j][k]&gt;E[j+1].len) &#123; dis[v][j+1][k]=dis[u][j][k]+E[j+1].len; p=node(v,j+1,k,dis[v][j+1][k]); q.push(p); &#125; &#125; else &#123; if(j&lt;L &amp;&amp; k&lt;K &amp;&amp; dis[v][j+1][k+1]-dis[u][j][k]&gt;E[j+1].len) &#123; dis[v][j+1][k+1]=dis[u][j][k]+E[j+1].len; p=node(v,j+1,k+1,dis[v][j+1][k+1]); q.push(p); &#125; if(dis[v][j][k]-dis[u][j][k]&gt;E[(i+1)&gt;&gt;1].len) &#123; dis[v][j][k]=dis[u][j][k]+E[(i+1)&gt;&gt;1].len; p=node(v,j,k,dis[v][j][k]); q.push(p); &#125; &#125; &#125; &#125; for(int i=0;i&lt;=K;++i) ans=min(ans,dis[N][L][i]);&#125;int main()&#123; N=read(),M=read(),K=read(); for(int i=1;i&lt;=M;++i) &#123; E[i].u=read(); E[i].v=read(); E[i].len=read(); &#125; sort(E+1,E+1+M); for(int i=1;i&lt;=M;++i) &#123; addedge(E[i].u,E[i].v); addedge(E[i].v,E[i].u); &#125; for(int i=0;i&lt;=M;++i) Dijkstra(i); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4669 抢夺]]></title>
    <url>%2F2019%2F05%2F30%2Fbzoj-4669-%E6%8A%A2%E5%A4%BA%2F</url>
    <content type="text"><![CDATA[二分答案 + 费用流. 答案显然可以二分,只需要如何验证一个答案 $mid$ 是否合法. 考虑第一波同时出发的人,他们会选择最优的路径,而后来的人选择的路径必定与他们相同. 于是可以通过增广计算出在 $mid$ 天内到达的人数.而退流操作对应的贡献也是正确的,所以不需要另外考虑. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e4+10;const int inf=1e9;int ecnt=-1,head[MAXN];struct edge&#123; int nx,to,flow,dis;&#125;E[MAXN];void addedge(int u,int v,int flow,int dis)&#123; ++ecnt; E[ecnt].nx=head[u]; E[ecnt].to=v; E[ecnt].flow=flow; E[ecnt].dis=dis; head[u]=ecnt;&#125;void ins(int u,int v,int flow,int dis)&#123; addedge(u,v,flow,dis); addedge(v,u,0,-dis);&#125;int n,m,k;int dis[MAXN],flow[MAXN],pre[MAXN],lst[MAXN],vis[MAXN];queue&lt;int&gt; q;bool spfa(int S,int T)&#123; while(!q.empty()) q.pop(); for(int i=1;i&lt;=n;++i) &#123; vis[i]=0; flow[i]=inf; dis[i]=inf; &#125; pre[T]=-1; vis[S]=1; dis[S]=0; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; for(int i=head[u];i!=-1;i=E[i].nx) &#123; int v=E[i].to; if(E[i].flow&gt;0 &amp;&amp; dis[v]&gt;dis[u]+E[i].dis) &#123; dis[v]=dis[u]+E[i].dis; flow[v]=min(flow[u],E[i].flow); pre[v]=u; lst[v]=i; if(!vis[v]) &#123; vis[v]=1; q.push(v); &#125; &#125; &#125; &#125; return pre[T]!=-1;&#125;int Dist[MAXN],Flow[MAXN],tot=0;int mcmf(int S,int T)&#123; while(spfa(S,T)) &#123; int now=T; while(now!=S) &#123; E[lst[now]].flow-=flow[T]; E[lst[now]^1].flow+=flow[T]; now=pre[now]; &#125; ++tot; Dist[tot]=dis[T]; Flow[tot]=flow[T]; &#125;&#125;void init()&#123; memset(head,-1,sizeof head); ecnt=-1; tot=0;&#125;bool check(int mid)&#123; ll tmp=k; for(int i=1;i&lt;=tot &amp;&amp; tmp&gt;0;++i) tmp-=1LL*(mid-Dist[i]+1)*Flow[i]; return tmp&lt;=0;&#125;int main()&#123; while(~scanf("%d%d%d",&amp;n,&amp;m,&amp;k)) &#123; init(); for(int i=1;i&lt;=m;++i) &#123; int u=read()+1,v=read()+1,c=read(); ins(u,v,c,1); &#125; mcmf(1,n); int ans=-1,L=0,R=n+k+1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid)) ans=mid,R=mid-1; else L=mid+1; &#125; if(ans==-1) puts("No solution"); else printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4621 Tc605]]></title>
    <url>%2F2019%2F05%2F29%2Fbzoj-4621-Tc605%2F</url>
    <content type="text"><![CDATA[$dp$ . 一个数字只可以往左右拓展,把周围的数变成和它一样的数.所以最终状态一定是一些数字段拼起来的,而且数字之间相对的前后顺序不会改变. 对最终状态进行 $dp$ .设 $f(i,j)$ 表示考虑了前 $i$ 个位置,操作了 $j$ 次的情况总数.一个数字段最多操作一次,处理出每个数字左右延伸的范围,枚举拓展的右端点进行转移即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=512;int n,m,a[MAXN],f[MAXN][MAXN];int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); f[0][0]=1; for(int i=1;i&lt;=n;++i) &#123; int l=i; while(l&gt;1 &amp;&amp; a[l-1]&lt;a[i]) --l; int r=i; while(r&lt;n &amp;&amp; a[r+1]&lt;a[i]) ++r; f[i][m]=add(f[i][m],f[i-1][m]); for(int j=m;j&gt;=1;--j) &#123; int tmp=f[l-1][j-1]; for(int k=l;k&lt;=r;++k) &#123; f[k][j]=add(f[k][j],tmp); tmp=add(tmp,f[k][j-1]); &#125; f[i][j-1]=add(f[i][j-1],f[i-1][j-1]); f[i][j]=add(f[i][j],-f[i-1][j-1]); &#125; &#125; int ans=0; for(int i=0;i&lt;=m;++i) ans=add(ans,f[n][i]); cout&lt;&lt;add(ans,P)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4658 rescue]]></title>
    <url>%2F2019%2F05%2F29%2Fbzoj-4658-rescue%2F</url>
    <content type="text"><![CDATA[$dp$ + 线段树. 显然只有关键点有用.设 $f(i)$ 表示到了第 $i$ 个关键点时的最小损失.把起点看做第 $0$ 个关键点,转移有: $$f(i)=\min_{j=0}^{i-1}\lbrace f(j)+ \lceil \frac {T_i-T_j} D \rceil\cdot A\rbrace - b_i$$ 这样大力转移是 $O(n^2)$ 的.注意到 $D$ 是固定的,考虑把 $T$ 写成 $T=C\cdot D+E,0\leq E&lt;D$ . 那么原式就可以变成 $$f(i)=\min_{j=0}^{i-1}\lbrace f(j)+ A\cdot (C_i-C_j)+[E_i&gt;E_j]\cdot A\rbrace - b_i$$ 以 $E$ 为下标建一颗动态开点的线段树,在 $E_j&lt; E_i,E_j\geq E_i$ 两部分分别查询 $f_j-A\cdot C_j$ 的最小值即可. 注意把 $Tree[0].val$ 初始化为 $inf$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;const ll inf=1e18;struct Segtree&#123; int idx; Segtree()&#123;idx=0;Tree[0].ls=Tree[0].rs=0;Tree[0].val=inf;&#125; struct node &#123; int ls,rs; ll val; &#125;Tree[MAXN*30];#define root Tree[o]#define lson Tree[root.ls]#define rson Tree[root.rs] void pushup(int o) &#123; root.val=min(lson.val,rson.val); &#125; void ins(int &amp;o,int l,int r,int pos,ll c) &#123; if(!o) &#123; o=++idx; root.val=inf; root.ls=root.rs=0; &#125; if(l==r) &#123; root.val=min(root.val,c); return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(root.ls,l,mid,pos,c); else ins(root.rs,mid+1,r,pos,c); pushup(o); &#125; ll query(int o,int l,int r,int L,int R) &#123; if(!o || L&gt;R) return inf; if(L&lt;=l &amp;&amp; r&lt;=R) return root.val; ll res=inf; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res=min(res,query(root.ls,l,mid,L,R)); if(R&gt;mid) res=min(res,query(root.rs,mid+1,r,L,R)); return res; &#125;&#125;T;int n,rt=0;int A,B[MAXN],C[MAXN],D,E[MAXN],K,M;ll f[MAXN];void update_info(int x)&#123; T.ins(rt,0,D-1,E[x],f[x]-1LL*A*C[x]);&#125;int main()&#123; K=read(),M=read(),D=read(),A=read(); n=read(); C[0]=K/D,E[0]=K%D,B[0]=0; ++n; C[n]=M/D,E[n]=M%D,B[n]=0; f[0]=0; update_info(0); for(int i=1;i&lt;n;++i) &#123; int T=read(); C[i]=T/D; E[i]=T%D; B[i]=read(); &#125; for(int i=1;i&lt;=n;++i) &#123; f[i]=1LL*C[i]*A-B[i]; ll tmp=T.query(rt,0,D-1,0,E[i]-1)+A; tmp=min(tmp,T.query(rt,0,D-1,E[i],D-1)); f[i]+=tmp; update_info(i); &#125; cout&lt;&lt;(-f[n])&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4659 lcm]]></title>
    <url>%2F2019%2F05%2F28%2Fbzoj-4659-lcm%2F</url>
    <content type="text"><![CDATA[莫比乌斯反演. 转化一下条件,数对 $(a,b)$ 符合要求等价于 $\mu(gcd(a,b))\not=0​$ . 为了方便,记 $m=\min(A,B)$ , 集合 $S=\lbrace x|\mu(x)\not=0\rbrace$ ,$sum(x)=\frac {x(x+1)} 2$ . 则答案 $ans$ 为: 到这一步,直接用两个整除分块算,时间复杂度 $O(T\cdot n^{\frac 3 4})$. 然而发现极限数据要跑 $10s+$ . 再变一步,将枚举 $x,d$ 变为先枚举 $D=xd$ ,再枚举 $x$. $$ans=\sum_{D=1}^{m}D \sum_{x|D} \mu(x)^2\mu(\frac D x)\frac D x \sum_{a=1}^{A/D}\sum_{b=1}^{B/D} ab$$ 设三个函数 $f,g,h$ : 函数 $g,h$ 显然都是积性函数.而 $f=g*h$ ,也为积性函数.于是可以线性筛预处理 $f$ ,然后对 $D$ 整除分块. 时间复杂度优化到 $O(T\cdot \sqrt n)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1&lt;&lt;30;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P; &#125;const int MAXN=4e6+10;int prime[MAXN],cnt=0,ism[MAXN],mu[MAXN];int f[MAXN],sumfx[MAXN];void init(int N)&#123; ism[1]=1,mu[1]=1; sumfx[1]=1; f[1]=1; for(int i=2;i&lt;=N;++i) &#123; if(!ism[i]) &#123; prime[++cnt]=i; mu[i]=-1; f[i]=-i+1; &#125; for(int j=1;j&lt;=cnt &amp;&amp; prime[j]*i&lt;=N;++j) &#123; ism[prime[j]*i]=1; if(i%prime[j]) &#123; mu[i*prime[j]]=-mu[i]; f[i*prime[j]]=mul(f[i],f[prime[j]]); &#125; else &#123; mu[i*prime[j]]=0; if((1LL*i)%(1LL*prime[j]*prime[j])==0) f[i*prime[j]]=0; else f[i*prime[j]]=mul(f[i/prime[j]],-prime[j]); break; &#125; &#125; sumfx[i]=add(sumfx[i-1],mul(i,f[i])); &#125;&#125;int sum(int x)&#123; return (1LL*x*(x+1)/2)%P;&#125;int main()&#123; init(4000000); int T=read(); while(T--) &#123; int ans=0; int A=read(),B=read(); int m=min(A,B); for(int LD=1,RD;LD&lt;=m;LD=RD+1) &#123; RD=min(A/(A/LD),B/(B/LD)); ans=add(ans,mul(sumfx[RD]-sumfx[LD-1],mul(sum(A/LD),sum(B/LD)))); &#125; printf("%d\n",add(ans,P)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4657 tower]]></title>
    <url>%2F2019%2F05%2F28%2Fbzoj-4657-tower%2F</url>
    <content type="text"><![CDATA[最小割. 想到网络流应该不难,但关键是怎样建模. 因为只有横向炮塔与竖向炮塔可能发生冲突,所以可以先套路地把一个点拆成一个横点和一个竖点,横点向对应竖点之间连一条边权为 $inf$ 的边.然后从源点 $S$ 向每个竖向攻击的炮塔的竖点连边权为 $inf$ 的边,从每个横向攻击的炮塔的横点向汇点 $T$ 连一条边权为 $inf$ 的边. 考虑每个炮塔,选择一个点进行攻击,这个点显然是从炮塔出发到最大贡献所在点这条路径 $p$ 上的某个点. 那么对于一个竖向攻击的炮塔,沿着路径 $p$ ,从炮塔到最大贡献点,相邻两点的竖点连上边. 对于一个横向攻击的炮塔,沿着路径 $p$ ,从最大贡献点到炮塔,相邻两点的横点连上边. 开始时钦定每个炮塔都打各自最大贡献点,收益为 $\sum max_i$ ,但这样会有路径相交,在图中表现为 $S$ 与 $T$ 连通.若一个炮塔改为打点 $u$ ,就把对应的路径 $p$ 上以 $u$ 为一端,另一端远离炮塔的点的边割掉就行了.减少的收益是 $max_i-val_u$ .可以发现,最后 $S$ 与 $T$ 不连通就与炮弹路径不相交是等价的. 于是在路径 $p$ 上连边时,将边权设置为 $max_i-val_u$ ,用 $\sum max_i$ 减去最小割即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=2e5+10;int ecnt=-1,head[MAXN],cur[MAXN],tot=0;struct edge&#123; int nx,to,flow;&#125;E[MAXN];void addedge(int u,int v,int w)&#123; ++ecnt; E[ecnt].to=v; E[ecnt].nx=head[u]; E[ecnt].flow=w; head[u]=ecnt;&#125;void ins(int u,int v,int w)&#123; addedge(u,v,w); addedge(v,u,0);&#125;int dep[MAXN];bool bfs(int S,int T)&#123; queue&lt;int&gt; q; while(!q.empty()) q.pop(); for(int i=1;i&lt;=tot;++i) cur[i]=head[i]; memset(dep,-1,sizeof dep); dep[S]=0; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u];i!=-1;i=E[i].nx) &#123; int v=E[i].to; if(dep[v]==-1 &amp;&amp; E[i].flow) &#123; dep[v]=dep[u]+1; q.push(v); &#125; &#125; &#125; return dep[T]!=-1;&#125;int dfs(int u,int T,int limit)&#123; if(u==T || !limit) return limit; int f,flow=0; for(int i=cur[u];i!=-1;i=E[i].nx) &#123; cur[u]=i; int v=E[i].to; if(dep[v]==dep[u]+1 &amp;&amp; (f=dfs(v,T,min(limit,E[i].flow)))) &#123; limit-=f; flow+=f; E[i].flow-=f; E[i^1].flow+=f; if(!limit) break; &#125; &#125; return flow;&#125;int Dinic(int S,int T)&#123; int maxflow=0; while(bfs(S,T)) maxflow+=dfs(S,T,inf); return maxflow;&#125;int n,m;int node_id[51][51][2];//0:up/down 1:left/rightint org_graph[51][51];int S,T,ans=0;void build_graph(int x,int y,int tp)&#123; org_graph[x][y]=0; if(tp==1 || tp==2) &#123; ins(S,node_id[x][y][0],inf); int mx=0,maxpos=-1; if(tp==1) &#123; for(int i=x-1;i&gt;=1;--i) if(org_graph[i][y]&gt;mx) mx=org_graph[i][y],maxpos=i; if(maxpos==-1) return; for(int i=x-1;i&gt;=maxpos;--i) ins(node_id[i+1][y][0],node_id[i][y][0],mx-org_graph[i+1][y]); &#125; else &#123; for(int i=x+1;i&lt;=n;++i) if(org_graph[i][y]&gt;mx) mx=org_graph[i][y],maxpos=i; if(maxpos==-1) return; for(int i=x+1;i&lt;=maxpos;++i) ins(node_id[i-1][y][0],node_id[i][y][0],mx-org_graph[i-1][y]); &#125; ans+=mx; &#125; else &#123; ins(node_id[x][y][1],T,inf); int mx=0,maxpos=-1; if(tp==3) &#123; for(int j=y-1;j&gt;=1;--j) if(org_graph[x][j]&gt;mx) mx=org_graph[x][j],maxpos=j; if(maxpos==-1) return; for(int j=y-1;j&gt;=maxpos;--j) ins(node_id[x][j][1],node_id[x][j+1][1],mx-org_graph[x][j+1]); &#125; else &#123; for(int j=y+1;j&lt;=m;++j) if(org_graph[x][j]&gt;mx) mx=org_graph[x][j],maxpos=j; if(maxpos==-1) return; for(int j=y+1;j&lt;=maxpos;++j) ins(node_id[x][j][1],node_id[x][j-1][1],mx-org_graph[x][j-1]); &#125; ans+=mx; &#125;&#125;int main()&#123; memset(head,-1,sizeof head); n=read(),m=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) &#123; org_graph[i][j]=read(); node_id[i][j][0]=++tot; node_id[i][j][1]=++tot; ins(tot-1,tot,inf); &#125; S=++tot,T=++tot; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) if(org_graph[i][j]&lt;0) build_graph(i,j,-org_graph[i][j]); ans-=Dinic(S,T); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6053 简单的函数]]></title>
    <url>%2F2019%2F05%2F28%2FLoj-6053-%E7%AE%80%E5%8D%95%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[min_25 筛 . 除了 $2$ 之外的质数 $p$ 都是奇数, $f(p)=p-1$ ,而 $f(2)=3$ . 把 $f(p)$ 都当成 $f(p)=p-1$ ,用 min_25 筛法来做.有 $2$ 就特判一下, $+2$ 就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;const int P=1e9+7;const int inv2=(P+1)&gt;&gt;1;inline int add(ll a,ll b)&#123; a%=P; b%=P; return (a + b) % P;&#125;inline int mul(ll a,ll b)&#123; a%=P; b%=P; return 1LL * a * b % P;&#125;ll n,sqr,w[MAXN];int cnt=0,ism[MAXN],sump[MAXN],m;ll prime[MAXN];ll id1[MAXN],id2[MAXN];void init(int N)&#123; ism[1]=1; for(int i=2;i&lt;=N;++i) &#123; if(!ism[i]) &#123; prime[++cnt]=i; sump[cnt]=add(sump[cnt-1],i); &#125; for(int j=1;j&lt;=cnt &amp;&amp; prime[j]*i&lt;=N;++j) &#123; ism[prime[j]*i]=1; if(i%prime[j]==0) break; &#125; &#125;&#125;int h[MAXN],g[MAXN],ans;int S(ll x,int y)&#123; if(x&lt;=1 || prime[y]&gt;x) return 0; int k=(x&lt;=sqr)?id1[x]:id2[n/x]; int res=add(g[k]-sump[y-1],y-h[k]-1); if(y==1) res+=2; for(int i=y;i&lt;=cnt &amp;&amp; 1LL*prime[i]*prime[i]&lt;=x;++i) &#123; ll pow1=prime[i],pow2=1LL*prime[i]*prime[i]; for(int e=1;pow2&lt;=x;++e,pow1=pow2,pow2*=prime[i]) &#123; int tmp=mul(S(x/pow1,i+1),prime[i]^e); tmp=add(tmp,prime[i]^(e+1)); res=add(res,tmp); &#125; &#125; return res;&#125;int main()&#123; n=read(); sqr=sqrt(n); init(sqr); for(ll l=1,r;l&lt;=n;l=r+1) &#123; ll &amp;i=l,&amp;j=r; r=n/(n/l); w[++m]=n/l; h[m]=add(w[m]%P,-1); g[m]=mul(w[m],w[m]+1); g[m]=mul(g[m],inv2); g[m]=add(g[m],-1); if(w[m]&lt;=sqr) id1[n/l]=m; else id2[r]=m; &#125; for(int j=1;j&lt;=cnt;++j) for(int i=1;i&lt;=m &amp;&amp; prime[j]*prime[j]&lt;=w[i];++i) &#123; int k=(w[i]/prime[j]&lt;=sqr)?id1[w[i]/prime[j]]:id2[n/(w[i]/prime[j])]; g[i]=add(g[i],-mul(prime[j],add(g[k],-sump[j-1]))); h[i]=add(h[i],j-h[k]-1); &#125; ans=add(S(n,1),1); cout&lt;&lt;(ans+P)%P&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4665 小w的喜糖]]></title>
    <url>%2F2019%2F05%2F27%2Fbzoj-4665-%E5%B0%8Fw%E7%9A%84%E5%96%9C%E7%B3%96%2F</url>
    <content type="text"><![CDATA[容斥 + $dp$ . 要求有重复元素的错排方案数. 设 $f(i,j)$ 表示考虑前 $i$ 种糖,钦定 $j$ 个人拿到原来的糖,其他 $(n-j)$ 个人乱拿的方案数. $cnt_x$ 表示第 $x$ 种糖的数目. 枚举第 $i$ 种糖被 $k$ 个原来的人拿到,有 $f(i,j)=\sum_{k\leq j,k\leq cnt_i} f(i-1,j-k)\times {cnt_i \choose k}\times [(cnt_i-k)!]^{-1}$ . 最终答案为 $ans=\sum_{i=0}^n (-1)^i \times f(n,i) \times (n-i)!$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+9;inline int add(int a,int b)&#123; return (a + b) % P; &#125; inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;const int MAXN=2019;int n,cnt[MAXN],fac[MAXN],invfac[MAXN];int ans=0,f[MAXN][MAXN];void init()&#123; fac[0]=1; for(int i=1;i&lt;=n;++i) fac[i]=mul(fac[i-1],i); invfac[n]=inv(fac[n]); for(int i=n-1;i&gt;=0;--i) invfac[i]=mul(invfac[i+1],i+1);&#125;int C(int M,int N)// M \choose N&#123; if(M&lt;0 || N&lt;0 || M&lt;N) return 0; return mul(fac[M],mul(invfac[M-N],invfac[N]));&#125;int main()&#123; n=read(); init(); for(int i=1;i&lt;=n;++i) &#123; int x=read(); ++cnt[x]; &#125; f[0][0]=1; int sum=0; for(int i=1;i&lt;=n;++i) &#123; sum+=cnt[i]; for(int j=0;j&lt;=sum;++j) for(int k=0;k&lt;=cnt[i] &amp;&amp; k&lt;=j;++k) &#123; int tmp=mul(f[i-1][j-k],C(cnt[i],k)); tmp=mul(tmp,invfac[cnt[i]-k]); f[i][j]=add(f[i][j],tmp); &#125; &#125; for(int i=0;i&lt;=n;++i) &#123; int tmp=(i&amp;1)?(-1):(1); tmp=mul(tmp,f[n][i]); tmp=mul(tmp,fac[n-i]); ans=add(ans,tmp); &#125; cout&lt;&lt;add(ans,P)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190526]]></title>
    <url>%2F2019%2F05%2F26%2Ftest20190526%2F</url>
    <content type="text"><![CDATA[感觉 $T3$ 很假. $tweak$ 题面有误.题意是每次可以选一条边,权值修改为任意非负整数,问至少改多少条可以使 $1\to n$ 的最短路 $\leq c$ . 显然可以贪心,每次修改时都改成 $0$ .设 $f(i,j)$ 表示 $1\to i$ ,改了 $j$ 条边时的最短路.用 $spfa$ 转移即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;inline int read()&#123; int x=0,k=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') &#123;if(ch=='-') k=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return k*x;&#125;const int MAXN=1e3+10;int ecnt=0,head[MAXN],to[MAXN],nx[MAXN],val[MAXN];inline void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;int n,m,c;int f[MAXN][MAXN],tot=0;int vis[MAXN];queue&lt;int&gt; q;void spfa()&#123; memset(f,63,sizeof f); int inf=f[0][0]; f[1][0]=0; vis[1]=1; q.push(1); while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; bool flag=false; for(int j=0;j&lt;=m;++j) &#123; if(f[u][j]&gt;=inf) break; if(f[u][j]&lt;=f[v][j+1]) &#123; f[v][j+1]=f[u][j]; &#125; if(f[u][j]+val[i]&lt;=f[v][j]) &#123; f[v][j]=f[u][j]+val[i]; if(!j) flag=true; &#125; &#125; if(flag &amp;&amp; !vis[v]) &#123; vis[v]=1; q.push(v); &#125; &#125; &#125;&#125;int main()&#123; freopen("tweak.in","r",stdin); freopen("tweak.out","w",stdout); n=read(),m=read(),c=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); &#125; spfa(); for(int i=0;i&lt;=m;++i) if(f[n][i]&lt;=c) &#123; cout&lt;&lt;i&lt;&lt;endl; return 0; &#125; return 0;&#125; $coins$ 把每个硬币看做多项式 $(x^{a_i}+1)$ ,如果每个硬币都可以用,方案数就是 $\prod (x^{a_i}+1)$ 这个多项式中系数非零的 $x^k(k&gt;0)$ 的个数. 限定某个硬币 $i$ 不能用,只需要在多项式 $\prod (x^{a_i}+1)$ 中把 $(x^{a_i}+1)$ 除去,然后统计答案. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline int read()&#123; int x=0,k=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') &#123;if(ch=='-') k=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return k*x;&#125;int n,a[101];const int MAXN=3e5+10;ll poly[MAXN],tmp[MAXN];ll stk[MAXN],sk[MAXN];int deg=0,tp=0;int query(int p)&#123; tp=0; int Deg=deg,res=0; while(Deg) &#123; ll s=poly[Deg]; if(!s) &#123; --Deg; continue; &#125; if(!tmp[Deg-p] &amp;&amp; Deg-p) ++res; tmp[Deg-p]+=s; stk[++tp]=Deg-p; poly[Deg-p]-=s; sk[tp]=s; --Deg; &#125; for(int i=1;i&lt;=tp;++i) &#123; tmp[stk[i]]=0; poly[stk[i]]+=sk[i]; &#125; return res;&#125;int main()&#123; freopen("coin.in","r",stdin); freopen("coin.out","w",stdout); n=read(); poly[0]=1; for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); for(int j=deg;j&gt;=0;--j) poly[a[i]+j]+=poly[j]; deg+=a[i]; &#125; for(int i=1;i&lt;=n;++i) printf("%d\n",query(a[i])); return 0;&#125; $cakes$ $std:$ 维护一个堆,存储每种大小的元素数目.每次取出顶部三个,做最多的三元组,把剩余的放回去. 并不知道我的贪心哪里出了问题.]]></content>
      <tags>
        <tag>数学</tag>
        <tag>STL</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4653 区间]]></title>
    <url>%2F2019%2F05%2F26%2Fbzoj-4653-%E5%8C%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[线段树. 可以先将区间按照大小从小到大排序,并将端点离散化. 枚举以第 $i$ 个区间为最短区间时的答案,从 $i$ 开始往后面添加区间,直到有个点被覆盖 $m$ 次. 更新答案后,下次枚举不需要重新加入,只需要把第 $i$ 个区间删除即可. 用线段树支持区间覆盖与撤销,并维护被覆盖次数的最大值. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e5+10,inf=2e9;int n,m,ans=inf;int A[MAXN&lt;&lt;1],cnt=0;struct interval&#123; int l,r,len; bool operator &lt; (const interval &amp;rhs) const &#123; return len &lt; rhs.len; &#125;&#125;I[MAXN];int rk(int x)&#123; return lower_bound(A+1,A+1+cnt,x)-A;&#125;struct Segtree&#123; struct node &#123; int tag,mx; node()&#123;tag=mx=0;&#125; &#125;Tree[MAXN&lt;&lt;3];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] int query() &#123; return Tree[1].mx; &#125; void pushup(int o) &#123; root.mx=max(lson.mx,rson.mx); &#125; void modifiy(int o,int c) &#123; root.tag+=c; root.mx+=c; &#125; void pushdown(int o) &#123; if(root.tag) &#123; modifiy(o&lt;&lt;1,root.tag); modifiy(o&lt;&lt;1|1,root.tag); root.tag=0; &#125; &#125; void upd(int o,int l,int r,int L,int R,int c) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125;&#125;T;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; A[++cnt]=I[i].l=read(); A[++cnt]=I[i].r=read(); I[i].len=I[i].r-I[i].l; &#125; sort(I+1,I+1+n); sort(A+1,A+1+cnt); cnt=unique(A+1,A+1+cnt)-(A+1); for(int i=1;i&lt;=n;++i) &#123; I[i].l=rk(I[i].l); I[i].r=rk(I[i].r); &#125; int head=1,tail=0; while(head&lt;=n) &#123; while(T.query()&lt;m &amp;&amp; tail&lt;n) &#123; ++tail; T.upd(1,1,cnt,I[tail].l,I[tail].r,1); &#125; if(T.query()==m) ans=min(ans,I[tail].len-I[head].len); T.upd(1,1,cnt,I[head].l,I[head].r,-1); ++head; &#125; cout&lt;&lt;(ans==inf?-1:ans)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4767 两双手]]></title>
    <url>%2F2019%2F05%2F26%2Fbzoj-4767-%E4%B8%A4%E5%8F%8C%E6%89%8B%2F</url>
    <content type="text"><![CDATA[容斥 +$dp$ . 把两种移动方式看做两个向量 $\vec a,\vec b$ .因为题目保证它们不共线,所以每个点都可以被写成 $x\cdot \vec a+y\cdot \vec b$ . 那么以解出来的 $(x,y)$ 代替原来的坐标,问题就变成了每次可以向右或向上走一步,求方案数. 如果没有障碍,答案显然是 $C_{x+y}^x$ .但现在有障碍.直接递推显然不行,因为新坐标可以达到 $2\times 500^2$ . 考虑容斥.将障碍点,目标点视为关键点,做坐标转换(如果不是整数就直接舍去),然后排序.原点为第 $0$ 个关键点. 设 $f(i)$ 表示从原点到达第 $i$ 个关键点而不经过其他关键点的方案数. $g(i,j)$ 表示从第 $i$ 个关键点到第 $j$ 个关键点的所有方案数.转移有 $f(i)=g(0,i)-\sum_{j=1}^{i-1} g(j,i)\cdot f(j)$ .而 $g$ 不需要考虑障碍,显然就是组合数. 时间复杂度 $O(n^2)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;const int P=1e9+7;const int inf=1e9;inline int add(int a,int b)&#123; return (a + b &gt;= P) ? (a + b - P) : (a + b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;typedef pair&lt;int,int&gt; pii;const pii badp=make_pair(inf,inf);int n,k=0,ax,ay,bx,by;int ex=inf,ey=inf;pii p[MAXN];pii trans(int M,int N)&#123; int x,y; int up=ay*M-ax*N,down=bx*ay-by*ax; if(up%down || up/down&lt;0) return badp; y=up/down; up=M*by-N*bx,down=ax*by-ay*bx; if(up%down || up/down&lt;0) return badp; x=up/down; if(x&gt;ex || y&gt;ey) return badp; return make_pair(x,y);&#125;int fac[MAXN],invfac[MAXN];void init()&#123; int N=MAXN-10; fac[0]=1; for(int i=1;i&lt;=N;++i) fac[i]=mul(fac[i-1],i); invfac[N]=fpow(fac[N],P-2); for(int i=N-1;i&gt;=0;--i) invfac[i]=mul(invfac[i+1],i+1);&#125;int C(int N,int M)&#123; return mul(fac[M],mul(invfac[N],invfac[M-N]));&#125;int g(int i,int j)&#123; int x=p[j].first-p[i].first,y=p[j].second-p[i].second; if(x&lt;0 || y&lt;0) return 0; return C(x,x+y);&#125;int f[MAXN];int main()&#123; init(); int Ex=read(),Ey=read(); n=read(),ax=read(),ay=read(),bx=read(),by=read(); p[++k]=trans(Ex,Ey); if(p[k]==badp) &#123; puts("0"); return 0; &#125; ex=p[k].first,ey=p[k].second; for(int i=1;i&lt;=n;++i) &#123; int x=read(),y=read(); pii tmp=trans(x,y); x=tmp.first,y=tmp.second; if(ex&lt;x || ey&lt;y) continue; assert(tmp!=badp); p[++k]=tmp; &#125; p[0]=make_pair(0,0); ++k; sort(p,p+k); f[0]=1; for(int i=1;i&lt;k;++i) &#123; f[i]=g(0,i); for(int j=1;j&lt;i;++j) f[i]=add(f[i],P-mul(g(j,i),f[j])); &#125; cout&lt;&lt;f[k-1]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Beginner Contest 127]]></title>
    <url>%2F2019%2F05%2F25%2FAtcoder-Beginner-Contest-127%2F</url>
    <content type="text"><![CDATA[被 $E$ 给卡住了.数据范围读错还行. 前 $3$ 道题目主要考察读入和输出. D Integer Cards 贪心 + 二分. 显然可以随意安排操作的顺序.于是可以给操作按照 $c$ 从大到小排序,那么前面的操作就不会影响后面的操作. 于是每次操作的时候贪心选小的替换,替换后直接将那部分删去就可以了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,m,a[MAXN];ll t[MAXN],sum[MAXN];struct opt&#123; int b,c; bool operator &lt; (const opt &amp;rhs) const &#123; return c&gt;rhs.c; &#125;&#125;q[MAXN];ll ans=0;int head,tail;int bs(int x)&#123; int L=head,R=tail,res=-1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(a[mid]&lt;x) L=mid+1,res=mid; else R=mid-1; &#125; return res;&#125;int main()&#123; n=read(); m=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); sort(a+1,a+1+n); for(int i=1;i&lt;=n;++i) sum[i]=sum[i-1]+a[i]; for(int i=1;i&lt;=m;++i) &#123; q[i].b=read(); q[i].c=read(); &#125; sort(q+1,q+1+m); head=1,tail=n; for(int i=1;i&lt;=m;++i) &#123; int pos=bs(q[i].c); if(pos==-1) continue; int tmp=min(q[i].b,pos-head+1); ans+=1LL*tmp*q[i].c; head=head+tmp; &#125; while(head&lt;=tail) &#123; ans+=a[head]; ++head; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; E Cell Distance $N\times M\leq 2\times 10^5$ ,我看成 $N,M\leq 2\times 10^5$ 了… 考虑一对点 $p,q$ ,它们显然会在 $C^{K-2}_{NM}$ 个方案中被计入贡献. 于是只需要枚举每个点,计算它到其他点的距离和,再乘上 $C_{NM}^{K-2}$ ,最后还要除以 $2$ . F Absolute Minima 平衡树 + 线段树. 那个 $b$ 显然没什么用,可以单独算. 问题就变成可以在数轴上插入点,每次询问到这些点距离和最小的位置与这个距离和. 若现在有 $k$ 个点,第一问,显然应该取中位数.这个可以用一颗平衡树维护答案. 第二问,把绝对值拆开,只需要询问当前比 $x$ 小的数总和,当前比 $x$ 大的数总和.用了离散化 + 权值线段树.感觉应该有更简单的方法? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;struct FhqTreap&#123;#define rt treap[o]#define ls treap[treap[o].lson]#define rs treap[treap[o].rson] int x,y,z,ans; int idx; FhqTreap() &#123; x=y=z=0; idx=0; &#125; struct node &#123; int lson,rson,key,weight,size; &#125; treap[MAXN]; inline int newnode(int key) &#123; ++idx; treap[idx].size=1; treap[idx].weight=rand(); treap[idx].key=key; return idx; &#125; inline void pushup(int o) &#123; rt.size=ls.size+rs.size+1; &#125; void split(int&amp; x,int&amp; y,int key,int o)//小于等于key的分在x中 &#123; if(!o) x=y=0; else &#123; if(rt.key&lt;=key) &#123; x=o; split(rt.rson,y,key,rt.rson); &#125; else &#123; y=o; split(x,rt.lson,key,rt.lson); &#125; pushup(o); &#125; &#125; int merge(int x,int y)//合并,保证x的权值小于y的权值. key_x&lt;key_y &#123; if(x==0||y==0) return x+y; if(treap[x].weight&lt;treap[y].weight) &#123; treap[x].rson=merge(treap[x].rson,y); pushup(x); return x; &#125; else &#123; treap[y].lson=merge(x,treap[y].lson); pushup(y); return y; &#125; &#125; inline int Rank(int&amp;root,int key)//get the node (which key equals to the key)'s rank. &#123; split(x,y,key-1,root); ans=treap[x].size+1; root=merge(x,y); return ans; &#125; inline int kth(int o,int rank)// find the id of the node which rank is the rank in the tree which root is o. &#123; while(1) &#123; if(ls.size&gt;=rank) o=rt.lson;//the answer must be in o's lson,search in it. else if(ls.size+1==rank) return treap[o].key;//o is the rank'th. else &#123; rank-=ls.size+1; o=rt.rson;//cannot find in o and o's lson,search in o's rson. &#125; &#125; &#125; inline void Insert(int&amp;root,int key)// insert a node which key is the key in whole the tree. &#123; split(x,y,key,root); root=merge(merge(x,newnode(key)),y); &#125;&#125; T;ll bsum=0;int Q,k=0,Rt=0;struct query&#123; int op,a,b;&#125;q[MAXN];int A[MAXN],cnt=0;struct Segtree&#123; struct node &#123; ll sum,tot; int l,r; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.sum=lson.sum+rson.sum; &#125; void BuildTree(int o,int l,int r) &#123; root.l=l,root.r=r; root.sum=0; if(l==r) return; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); &#125; void upd(int o,int pos,int c) &#123; int l=root.l,r=root.r; if(l==r) &#123; root.sum+=c; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(o&lt;&lt;1,pos,c); else upd(o&lt;&lt;1|1,pos,c); pushup(o); &#125; ll query(int o,int L,int R) &#123; if(L&gt;R) return 0; int l=root.l,r=root.r; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; ll res=0; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res+=query(o&lt;&lt;1,L,R); if(R&gt;mid) res+=query(o&lt;&lt;1|1,L,R); return res; &#125;&#125;Seg;int rnk(int x)&#123; return lower_bound(A+1,A+1+cnt,x)-A;&#125;int main()&#123; Q=read(); for(int i=1;i&lt;=Q;++i) &#123; q[i].op=read(); if(q[i].op==1) &#123; A[++cnt]=q[i].a=read(); q[i].b=read(); &#125; &#125; sort(A+1,A+1+cnt); cnt=unique(A+1,A+1+cnt)-(A+1); Seg.BuildTree(1,1,cnt); for(int i=1;i&lt;=Q;++i) &#123; if(q[i].op==1) &#123; int a=q[i].a,b=q[i].b; ++k; bsum+=b; Seg.upd(1,rnk(a),a); T.Insert(Rt,a); &#125; else &#123; int rk=(k+1)&gt;&gt;1; int x=T.kth(Rt,rk); rk=T.Rank(Rt,x); int pos=rnk(x); ll res=1LL*(rk-1)*x-Seg.query(1,1,pos-1)-1LL*(k-rk+1)*x+Seg.query(1,pos,cnt); printf("%d %lld\n",x,res+bsum); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Atcoder</tag>
        <tag>二分</tag>
        <tag>贪心</tag>
        <tag>平衡树</tag>
        <tag>线段树</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4670 佛罗里达]]></title>
    <url>%2F2019%2F05%2F24%2Fbzoj-4670-%E4%BD%9B%E7%BD%97%E9%87%8C%E8%BE%BE%2F</url>
    <content type="text"><![CDATA[随机乱搞. 随机做很多次,每次 $random\ shuffle$ 出一个加点的序列,然后按照这个序列加点. 每次贪心判,加在哪个集合里面能使答案增加的量更小,就加在哪个里面. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int T=800;const int inf=0x7fffffff;const int MAXN=256;int n,val[MAXN][MAXN],p[MAXN];int A[MAXN],sizA,B[MAXN],sizB,mxA,mxB;ll ans;int main()&#123; srand(time(NULL)); while(~scanf("%d",&amp;n)) &#123; ans=inf; memset(val,0,sizeof val); for(int i=1;i&lt;n;++i) for(int j=i+1;j&lt;=n;++j) val[i][j]=val[j][i]=read(); for(int i=1;i&lt;=n;++i) p[i]=i; for(int t=1;t&lt;=T;++t) &#123; ll res=0; random_shuffle(p+1,p+1+n); sizA=sizB=0; mxA=mxB=0; for(int i=1;i&lt;=n;++i) &#123; int valA=0,valB=0; for(int j=1;j&lt;=sizA;++j) valA=max(valA,val[p[i]][A[j]]); for(int j=1;j&lt;=sizB;++j) valB=max(valB,val[p[i]][B[j]]); if(valA&lt;=mxA &amp;&amp; valB&lt;=mxB) &#123; int k=rand()&amp;1; if(k) A[++sizA]=p[i]; else B[++sizB]=p[i]; continue; &#125; if(valA-mxA&lt;=valB-mxB) &#123; if(valA-mxA&gt;0) &#123; res+=valA-mxA; mxA=valA; &#125; A[++sizA]=p[i]; &#125; else &#123; if(valB-mxB&gt;0) &#123; res+=valB-mxB; mxB=valB; &#125; B[++sizB]=p[i]; &#125; if(res&gt;=ans) break; &#125; ans=min(ans,res); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>近似算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4675 点对游戏]]></title>
    <url>%2F2019%2F05%2F23%2Fbzoj-4675-%E7%82%B9%E5%AF%B9%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[点分治. 表面上看是个期望的题,然而跟期望没多大关系. 每个人的答案显然是 能选的点对数目/总点对数目*幸运点对的总数目 . 只需要求幸运点对的总数目.由于 $m$ 很小,所以直接点分治就可以了.时间复杂度 $O(nmlogn)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=5e4+10;int n,m,luckynum[11];ll sum=0;int ecnt=0,head[MAXN],nx[MAXN&lt;&lt;1],to[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int totsiz,siz[MAXN],mi,rt,vis[MAXN];void getroot(int u,int fa)&#123; siz[u]=1; int sonsiz=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v] || v==fa) continue; getroot(v,u); siz[u]+=siz[v]; sonsiz=max(sonsiz,siz[v]); &#125; sonsiz=max(sonsiz,totsiz-siz[u]); if(sonsiz&lt;mi) mi=sonsiz,rt=u;&#125;int dis[MAXN],bucket[MAXN],stk1[MAXN],tp1=0,stk2[MAXN],tp2=0;void getdis(int u,int fa)&#123; stk2[++tp2]=u; dis[u]=dis[fa]+1; for(int i=1;i&lt;=m;++i) if(luckynum[i]&gt;=dis[u]) sum+=bucket[luckynum[i]-dis[u]]; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v] || v==fa) continue; getdis(v,u); &#125;&#125;void solve(int u)&#123; while(tp1) bucket[dis[stk1[tp1--]]]=0; dis[u]=0;//先清空,再设dis[u]=0,否则可能清空错误 bucket[0]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v]) continue; tp2=0; getdis(v,u); while(tp2) &#123; stk1[++tp1]=stk2[tp2]; ++bucket[dis[stk2[tp2]]]; --tp2; &#125; &#125;&#125;void divide(int u)&#123; solve(u); vis[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v]) continue; mi=inf,totsiz=siz[v]; getroot(v,0); divide(rt); &#125;&#125;void getsum()&#123; mi=inf,totsiz=n; getroot(1,0); divide(rt);&#125;double calc(ll pairs)&#123; return (double(pairs)) * (double(sum)) / (double(1LL * n * (n-1) )) ;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) luckynum[i]=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; getsum(); int p=(n+2)/3; printf("%.2f\n",calc(1LL*p*(p-1))); p=(n+1)/3; printf("%.2f\n",calc(1LL*p*(p-1))); p=n/3; printf("%.2f\n",calc(1LL*p*(p-1))); return 0;&#125;]]></content>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4698 Sandy的卡片]]></title>
    <url>%2F2019%2F05%2F23%2Fbzoj-4698-Sandy%E7%9A%84%E5%8D%A1%E7%89%87%2F</url>
    <content type="text"><![CDATA[$SAM$ . 相同的定义比较奇怪,其实只需要差分一下就可以了,问题就是求这些串的最长公共子串.用 $SAM$ 解决. 答案就是求出的公共子串 $+1$ ?但有可能没有位置补,比如 $s_1=”23”,s_2=”23”$ ,答案应该是 $2$ 而不是 $3$ . 解决办法也很简单,在每个串后面加一个独特的且不在字符集中的标识符就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int Siz=1500,MAXN=2e3+10;int buf[MAXN];int L,n,T=0;struct SuffixAutoMation&#123; int idx,lst; int fa[MAXN],ch[MAXN][Siz]; int len[MAXN],siz[MAXN]; int A[MAXN],t[MAXN]; int mxl[MAXN],res[MAXN]; SuffixAutoMation() &#123; idx=lst=1; &#125; void Extend(int c) &#123; int p=lst,np=++idx; lst=np; res[np]=len[np]=len[p]+1; siz[np]=1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; res[nq]=len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125; void topsort() &#123; for(int i=1; i&lt;=idx; ++i) ++t[len[i]]; for(int i=1; i&lt;=idx; ++i) t[i]+=t[i-1]; for(int i=1; i&lt;=idx; ++i) A[t[len[i]]--]=i; &#125; void solve() &#123; L=read(); for(int i=1; i&lt;=L; ++i) buf[i]=read()-2; buf[L+1]=T+200,buf[L+2]=0; ++L; for(int i=1; i&lt;=L; ++i) buf[i]=buf[i+1]-buf[i]+1200; memset(mxl,0,sizeof mxl); int p=1,tmp=0; for(int i=1; i&lt;=L; ++i) &#123; int c=buf[i]; while(p &amp;&amp; ch[p][c]==0) p=fa[p]; if(p==0) p=1,tmp=0; else &#123; tmp=min(tmp,len[p])+1; p=ch[p][c]; &#125; mxl[p]=max(mxl[p],tmp); &#125; for(int i=idx; i&gt;=1; --i) &#123; int u=A[i]; mxl[fa[u]]=max(mxl[fa[u]],mxl[u]); &#125; for(int i=1; i&lt;=idx; ++i) res[i]=min(res[i],mxl[i]); &#125; void pr() &#123; int ans=0; for(int i=1; i&lt;=idx; ++i) ans=max(ans,res[i]); cout&lt;&lt;ans+1&lt;&lt;endl; &#125;&#125; SAM;int main()&#123; n=read(); L=read(); for(int i=1; i&lt;=L; ++i) buf[i]=read()-2; ++T; buf[L+1]=T+200,buf[L+2]=0; ++L; for(int i=1; i&lt;=L; ++i) &#123; buf[i]=buf[i+1]-buf[i]+1200; SAM.Extend(buf[i]); &#125; SAM.topsort(); for(int i=1; i&lt;n; ++i) &#123; ++T; SAM.solve(); &#125; SAM.pr(); return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4668 冷战]]></title>
    <url>%2F2019%2F05%2F22%2Fbzoj-4668-%E5%86%B7%E6%88%98%2F</url>
    <content type="text"><![CDATA[并查集按秩合并. 除了维护连通性,还需要维护每个点与它父亲的边被连上的时间. 用路径压缩会破坏树内部的结构,使用按秩合并就可以了.这样合并,树高不超过 $logn$ ,询问时,直接暴力跳到 $LCA$ ,路径上边被连上的最晚时间即为答案. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e5+10;int n,m,lastans=0;int fa[MAXN],siz[MAXN],t[MAXN],dep[MAXN],tid=0;int Find(int x)&#123; if(x==fa[x]) return x; int fx=Find(fa[x]); dep[x]=dep[fa[x]]+1; return fx;&#125;void merge(int x,int y)&#123; x=Find(x),y=Find(y); if(x==y) return; if(siz[x]&lt;siz[y]) swap(x,y); siz[x]+=siz[y]; fa[y]=x; t[y]=tid;&#125;int query(int x,int y)&#123; int fx=Find(x),fy=Find(y); if(fx!=fy) return 0; int res=0; while(x!=y) &#123; if(dep[x]&lt;dep[y]) swap(x,y); res=max(res,t[x]); x=fa[x]; &#125; return res;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) siz[i]=1,fa[i]=i; for(int i=1;i&lt;=m;++i) &#123; int tp=read(); if(!tp) &#123; int u=read()^lastans,v=read()^lastans; ++tid; merge(u,v); &#125; else &#123; int u=read()^lastans,v=read()^lastans; lastans=query(u,v); printf("%d\n",lastans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4700 适者]]></title>
    <url>%2F2019%2F05%2F22%2Fbzoj-4700-%E9%80%82%E8%80%85%2F</url>
    <content type="text"><![CDATA[李超线段树. 如果没有秒杀,就是个简单的贪心.算出第 $i$ 个敌人需要攻击的次数 $T_i$ ,考虑在攻击顺序中,交换两个相邻敌人带来的影响. 容易发现按照 $\frac {T_i} {A_i}$ 从小到大排序就可以了. 现在可以秒杀两个敌人,先按照 $\frac {T_i} {A_i}$ 从小到大排个序.但肯定不能贪心秒杀前两个.因为原来是考虑了击杀时间,而秒杀没有击杀时间.可以随意举出反例. 考虑秒杀 $i,j(i&lt;j)$ 时,答案会减少的值.记 $preT,sufA$ 分别表示 $T$ 的前缀和, $A$ 的后缀和.贡献就有 $i,j,[i+1,j-1],[j+1,n]$ 这四段. 发现如果固定 $i$ ,那么就是要求 $-A_j\cdot T_i+b_j$ 的最大值,其中 $b_j$ 是可以预处理的,是仅和 $j$ 有关的一个量. 那么就是求 $x=T_i$ 这条直线与 $j&gt;i$ 的这些直线 $(-A_j,b_j)$ 交点纵坐标最大值.枚举 $i$ 时从大到小,就只需要维护加入直线和询问这两个操作.用李超线段树维护一下就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int n,ATK;ll k[MAXN],b[MAXN],ans=0,delta=0;ll calc(int seg,int pos)&#123; return 1LL * k[seg] * pos + b[seg];&#125;bool is_cover(int a,int b,int pos)&#123; return calc(a,pos)&gt;=calc(b,pos);&#125;struct Segtree&#123; int v[MAXN&lt;&lt;2]; void ins(int o,int l,int r,int c) &#123; if(l==r) &#123; if(is_cover(c,v[o],l)) v[o]=c; return; &#125; int mid=(l+r)&gt;&gt;1; if(k[c]&gt;k[v[o]]) &#123; if(is_cover(c,v[o],mid)) ins(o&lt;&lt;1,l,mid,c),v[o]=c; else ins(o&lt;&lt;1|1,mid+1,r,c); &#125; else &#123; if(is_cover(c,v[o],mid)) ins(o&lt;&lt;1|1,mid+1,r,c),v[o]=c; else ins(o&lt;&lt;1,l,mid,c); &#125; &#125; ll query(int o,int l,int r,int pos) &#123; ll res=calc(v[o],pos); if(l==r) return res; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) res=max(res,query(o&lt;&lt;1,l,mid,pos)); else res=max(res,query(o&lt;&lt;1|1,mid+1,r,pos)); return res; &#125;&#125;T;struct enemy&#123; int a,t; bool operator &lt; (const enemy &amp;rhs) const &#123; return a*rhs.t&gt;rhs.a*t; &#125;&#125;p[MAXN];ll preT[MAXN],sufA[MAXN];int main()&#123; n=read(),ATK=read(); for(int i=1;i&lt;=n;++i) &#123; p[i].a=read(); int D=read(); p[i].t=(D+ATK-1)/ATK; &#125; sort(p+1,p+1+n); for(int i=1;i&lt;=n;++i) preT[i]=preT[i-1]+p[i].t; for(int i=n;i&gt;=1;--i) sufA[i]=sufA[i+1]+p[i].a; for(int i=1;i&lt;=n;++i) &#123; k[i]=-p[i].a; b[i]=sufA[i]*p[i].t+preT[i-1]*p[i].a-p[i].a; ans+=p[i].t*sufA[i]-p[i].a; &#125; T.ins(1,1,n,n); for(int i=n-1;i&gt;=1;--i) &#123; delta=max(delta,T.query(1,1,n,p[i].t)+b[i]); T.ins(1,1,n,i); &#125; ans-=delta; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>李超线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3073 Journeys]]></title>
    <url>%2F2019%2F05%2F21%2Fbzoj-3073-Journeys%2F</url>
    <content type="text"><![CDATA[线段树优化连边. 边是双向的.开两颗线段树, $A$ 里面节点表示一条有向边的起点,儿子向父亲连边, $B$ 里面节点表示一条有向边的终点,父亲向儿子连边, $B$ 向 $A$ 中对应的节点连边. 区间连边时,新建一个节点,将区间在线段树上拆成 $log$ 个区间进行连边就好了. 最后跑一次 $Dijkstra$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e5+10,MAXM=2220000;int n,m,S;int ecnt=0,head[MAXM],to[MAXM],nx[MAXM],val[MAXM];void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;struct node&#123; int ls,rs;&#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]int pos[MAXN],tot=0;void bd1(int &amp;o,int l,int r)&#123; o=++tot; if(l==r) &#123; pos[l]=o; return; &#125; int mid=(l+r)&gt;&gt;1; bd1(root.ls,l,mid); bd1(root.rs,mid+1,r); addedge(root.ls,o,0); addedge(root.rs,o,0);&#125;void bd2(int &amp;o,int l,int r)&#123; o=++tot; if(l==r) &#123; addedge(o,pos[l],0); return; &#125; int mid=(l+r)&gt;&gt;1; bd2(root.ls,l,mid); bd2(root.rs,mid+1,r); addedge(o,root.ls,0); addedge(o,root.rs,0);&#125;void upd1(int o,int l,int r,int L,int R)&#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; addedge(o,tot,1); return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd1(root.ls,l,mid,L,R); if(R&gt;mid) upd1(root.rs,mid+1,r,L,R);&#125;void upd2(int o,int l,int r,int L,int R)&#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; addedge(tot,o,1); return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd2(root.ls,l,mid,L,R); if(R&gt;mid) upd2(root.rs,mid+1,r,L,R);&#125;int rt1=0,rt2=0;int vis[MAXM],dis[MAXM];typedef pair&lt;int,int&gt; pii;#define mp make_pairpriority_queue&lt;pii&gt; q;void Dijkstra()&#123; memset(dis,0x7f,sizeof dis); dis[pos[S]]=0; q.push(mp(0,pos[S])); while(!q.empty()) &#123; int u=q.top().second; q.pop(); if(vis[u]) continue; vis[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(dis[v]-dis[u]&gt;val[i]) &#123; dis[v]=dis[u]+val[i]; q.push(mp(-dis[v],v)); &#125; &#125; &#125;&#125;int main()&#123; n=read(),m=read(),S=read(); bd1(rt1,1,n); bd2(rt2,1,n); while(m--) &#123; int x1=read(),y1=read(),x2=read(),y2=read(); ++tot;upd1(rt1,1,n,x1,y1);upd2(rt2,1,n,x2,y2); ++tot;upd1(rt1,1,n,x2,y2);upd2(rt2,1,n,x1,y1); &#125; Dijkstra(); for(int i=1;i&lt;=n;++i) printf("%d\n",dis[pos[i]]&gt;&gt;1); return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>线段树连边</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4762 最小集合]]></title>
    <url>%2F2019%2F05%2F21%2Fbzoj-4762-%E6%9C%80%E5%B0%8F%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[状压 $dp$ . 如果把所有元素 $xor\ 1023$ ,那么就等价于集合内元素 $or$ 和为 $1023$ ,去掉任意一个后 $or$ 和不为 $1023$ . 设 $f(i,j,k)$ 表示考虑了前 $i$ 个数,前面已经选择的数 $or$ 和为 $j$ ,期望后面选出的数 $or$ 和包含 $k$ 时的方案数. 若第 $i+1$ 个数为 $x$ ,不选它,则有 $f(i+1,j,k)+=f(i,j,k)$ . 如果选了它,假设能转移到 $f(i+1,j|x,k’)$ ,那么 $k’$ 需要满足: $k’|x=k$ . $k’|j|x\not= k’|j$ .这是为了保证去掉 $x$ 后就不合法了. 如果只考虑满足第一个条件的,就有 $f(i+1,j|x,k\ xor\ (k\&amp;x) )+=f(i,j,k)$ .因为 $x,k$ 都为 $1$ 的位置上可以随便选. 还要减去满足第一个条件,但不满足第二个条件的部分. $f(i+1,j|x,(k\ xor\ (k\&amp;x))|(x\ xor (x\&amp; j)) )-=f(i,j,k)$ . 后面括号表示 $x$ 对 $j$ 产生的贡献,即将原来的 $0$ 变为了 $1$ .如果 $k’$ 的这些位上也是 $1$ ,就不满足第二个条件了. 初始有 $f(0,0,0)=1$ ,答案为 $f(n,1023,0)$ .这样做是 $O(n\cdot 4^{10})$ 的. 注意到若 $f(i,j,k)\not = 0$ ,则一定有 $k$ 是 $j$ 的子集.于是枚举 $k$ 时只用枚举 $j$ 的子集.时间复杂度 $O(n\cdot 3^{10})$ . 滚掉第一维,优化空间. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b &gt;= P)? (a + b - P) : (a + b); &#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int N=1023;int n,a[N+10],f[2][N+10][N+10];int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read()^N; int id=0; f[0][0][0]=1; for(int i=1;i&lt;=n;++i) &#123; int x=a[i]; memset(f[id^1],0,sizeof f[id^1]); for(int j=0;j&lt;=N;++j) &#123; for(int k=j;;k=(k-1)&amp;j) &#123; if(f[id][j][k]) &#123; f[id^1][j][k]=add(f[id^1][j][k],f[id][j][k]); f[id^1][j|x][k^(k&amp;x)]=add(f[id^1][j|x][k^(k&amp;x)],f[id][j][k]); f[id^1][j|x][(k^(k&amp;x))|(x^(x&amp;j))]=add(f[id^1][j|x][(k^(k&amp;x))|(x^(x&amp;j))],P-f[id][j][k]); &#125; if(!k) break; &#125; &#125; id^=1; &#125; cout&lt;&lt;f[id][N][0]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4754 独特的树叶]]></title>
    <url>%2F2019%2F05%2F21%2Fbzoj-4754-%E7%8B%AC%E7%89%B9%E7%9A%84%E6%A0%91%E5%8F%B6%2F</url>
    <content type="text"><![CDATA[树 $hash$ . 要判断树的同构,自然要用到 $hash$ .但 $hash$ 的方法很多,我们要选取一种 优美 的方式.比如说字符串中,进制 $hash$ 就很优美,它可以 $O(1)$ 计算一个子串的 $hash$ 值. 在树中,一般是将一个点的 $hash$ 值设为所有儿子 $hash$ 值从小到大排序组成的串的进制 $hash$ 值,再乘上这个点的子树大小.若为叶子节点,则 $hash$ 值为 $1$ . 上面是对有根树的操作.然而这道题是无根树.找重心转成有根树十分麻烦(因为多了一个点),考虑换根,求出以每个点作为根节点的 $hash$ 值. 设 $f(i),g(i),h(i)$ 分别表示以 $1$ 为根时节点 $i$ 的 $hash$ 值,以 $fa_i$ 为根并去掉子树 $i$ 后 $fa_i$ 的 $hash$ 值,以 $i$ 为根时节点 $i$ 的 $hash$ 值. 对 $A,B$ 两棵树都做一次 $hash$ ,将 $A$ 中每个节点的 $h(i)$ 放入 $set$ 中,然后从小到大枚举 $B$ 树中度数为 $1$ 的点 $x$ .如果它连在 $y$ 上,由于我们 优美 的 $hash$ 定义,删去它后以 $y$ 为根, $y$ 的 $hash$ 值应该是 $\frac {h(x)} {n+1}$ .在 $set$ 中查询是否出现即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef pair&lt;int,int&gt; pii;#define mp make_pairconst int MAXN=1e5+10;const int P=998244353;inline int add(int a,int b)&#123; return (a + b &gt;= P)? (a + b - P) : (a + b); &#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int Pow[MAXN],Base=37,val[MAXN];int pre[MAXN],suf[MAXN];pii vp[MAXN];set&lt;int&gt; s;struct Tree&#123; int n; int ecnt,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1]; int f[MAXN],g[MAXN],h[MAXN],siz[MAXN]; int deg[MAXN]; void addedge(int u,int v) &#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt; &#125; void init() &#123; ecnt=0; for(int i=1;i&lt;=n;++i) head[i]=f[i]=g[i]=h[i]=deg[i]=0; for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); ++deg[u],++deg[v]; &#125; &#125; void dfs1(int u,int fa) &#123; siz[u]=1; int tot=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa) continue; dfs1(v,u); siz[u]+=siz[v]; &#125; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v!=fa) val[++tot]=f[v]; &#125; sort(val+1,val+1+tot); int tmp=1; for(int i=1;i&lt;=tot;++i) &#123; f[u]=add(f[u],mul(tmp,val[i])); tmp=mul(tmp,Base); &#125; f[u]=mul(f[u],siz[u]); if(!tot) f[u]=1; &#125; void dfs2(int u,int fa) &#123; int tot=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa) continue; vp[++tot]=mp(f[v],v); &#125; if(fa) vp[++tot]=mp(g[u],-1); sort(vp+1,vp+1+tot); pre[0]=suf[tot+1]=0; for(int i=1;i&lt;tot;++i) pre[i]=add(pre[i-1],mul(Pow[i-1],vp[i].first)); for(int i=tot;i&gt;1;--i) suf[i]=add(suf[i+1],mul(Pow[i-2],vp[i].first)); for(int i=1;i&lt;=tot;++i) &#123; if(vp[i].second==-1) continue; g[vp[i].second]=mul(n-siz[vp[i].second],pre[i-1]+suf[i+1]); &#125; if(!fa &amp;&amp; tot==1) g[vp[1].second]=1; int tmp=1; for(int i=1;i&lt;=tot;++i) &#123; h[u]=add(h[u],mul(vp[i].first,tmp)); tmp=mul(tmp,Base); &#125; h[u]=mul(h[u],n); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v!=fa) dfs2(v,u); &#125; &#125; void solve(int id) &#123; dfs1(1,0); dfs2(1,0); if(!id) &#123; for(int i=1;i&lt;=n;++i) s.insert(h[i]); &#125; else &#123; int inv=fpow(n,P-2); for(int i=1;i&lt;=n;++i) &#123; if(deg[i]!=1) continue; int tmp=mul(h[i],inv); if(s.find(tmp)!=s.end()) &#123; cout&lt;&lt;i&lt;&lt;endl; return; &#125; &#125; &#125; &#125;&#125;A,B;int main()&#123; int n=read(); Pow[0]=1; for(int i=1;i&lt;=n+1;++i) Pow[i]=mul(Pow[i-1],Base); A.n=n,B.n=n+1; A.init(); B.init(); A.solve(0); B.solve(1); return 0;&#125;]]></content>
      <tags>
        <tag>树形dp</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190519]]></title>
    <url>%2F2019%2F05%2F20%2Ftest20190519%2F</url>
    <content type="text"><![CDATA[$T3$ 题意理解错了.直接爆炸. $sequence$ 考虑一段区间 $[l,r]$ 合法,则显然 $\forall\ l\leq i\leq r,b_i\geq \max_{j=l}^i a_j$ . 这个东西对于 $l,r$ 两边来说都是具有单调性的, $two\ pointer$ 扫一遍即可. 用线段树做 $RMQ$ 为 $O(nlogn)$ ,用 $ST$ 表则为 $O(n)$ . $circulate$ 考虑枚举循环节循环次数,对于每个确定的循环次数,二分出循环节数字的最大值. 为了计算不重不漏,容斥一下,该循环次数的质因子个数为奇数,则加上,否则减去. $2\times 10^{18}$ 有 $19$ 个数字…考试没加 $19$ 的情况,丢了 $20$ 分. $cannon$ 题意搞错了,没注意到一座山被轰了几次后高度减低,可以换其他的炮轰… $80pts$ 很简单.设 $f(i)$ 表示轰平一座高度为 $i$ 的山最少需要轰几次,然后从低到高判断能否轰即可. 转移就有 $\forall x\leq 0,f(x)=0.f(i)=1+f(i-max_D)$ , $max_D$ 表示 $A_j\geq i$ 中最大的 $D_j$ . $100pts$ 的做法就是在上面改一下.因为 $D\leq 300$ ,所以上面的 $f$ 数组有用的只有 $M\cdot D$ 个.用 $map$ 做即可.]]></content>
      <tags>
        <tag>二分</tag>
        <tag>STL</tag>
        <tag>two pointer</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4755 扭动的回文串]]></title>
    <url>%2F2019%2F05%2F20%2Fbzoj-4755-%E6%89%AD%E5%8A%A8%E7%9A%84%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[二分 + $Hash​$ . 先补充上多余字符,将回文串全部弄成奇回文串.然后二分 + $Hash$ 预处理出每个位置的最大回文半径. 对于第三种情况,可以枚举回文中心,显然往两边拓展时,过了最大回文半径时就换到另一个串是最优的.于是可以二分在另一个串中的长度, $Hash$ 判断合法性.拼接位置的处理比较麻烦,可以调用补字符前的原串 $Hash$ 值. 时间复杂度 $O(nlogn)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef unsigned long long ull;const int MAXN=2e5+10;const ull Base=137;ull Pow[MAXN],Hash[4][MAXN],revHash[4][MAXN];int n,ans=1;char s[2][MAXN],buf[2][MAXN];int cnt;ull calc(int k,int l,int r)&#123; return Hash[k][r]-Pow[r-l+1]*Hash[k][l-1];&#125;ull revcalc(int k,int l,int r)&#123; return revHash[k][l]-Pow[r-l+1]*revHash[k][r+1];&#125;bool check(int k,int pos,int len)&#123; ull Left=calc(k,pos-len,pos-1); ull Right=revcalc(k,pos+1,pos+len); return Left==Right;&#125;int r[2][MAXN];int solve(int L,int R)&#123; int l=1,r=min(L,n-R+1),res=0; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(calc(2,L-mid+1,L)==revcalc(3,R,R+mid-1)) res=mid,l=mid+1; else r=mid-1; &#125; return res;&#125;int main()&#123; n=read(); scanf("%s%s",s[0]+1,s[1]+1); for(int k=0;k&lt;2;++k) &#123; for(int i=1;i&lt;=n;++i) Hash[k+2][i]=Hash[k+2][i-1]*Base+s[k][i]; for(int i=n;i&gt;=1;--i) revHash[k+2][i]=revHash[k+2][i+1]*Base+s[k][i]; &#125; n=cnt; Pow[0]=1; for(int i=1;i&lt;=n;++i) Pow[i]=Pow[i-1]*Base; for(int k=0;k&lt;2;++k) &#123; for(int i=1;i&lt;=n;++i) Hash[k][i]=Hash[k][i-1]*Base+(buf[k][i]); for(int i=n;i&gt;=1;--i) revHash[k][i]=revHash[k][i+1]*Base+(buf[k][i]); &#125; for(int k=0;k&lt;2;++k) &#123; for(int pos=1;pos&lt;=n;++pos) &#123; int L=1,R=(n-1)&gt;&gt;1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(k,pos,mid)) r[k][pos]=mid,L=mid+1; else R=mid-1; &#125; &#125; &#125; for(int i=1;i&lt;=n;++i) &#123; int L=(i-r[0][i]+1)&gt;&gt;1,R=(i+r[0][i])&gt;&gt;1; ans=max(ans,r[0][i]+solve(L-1,R)*2); &#125; for(int i=1;i&lt;=n;++i) &#123; int L=(i-r[1][i]+1)&gt;&gt;1,R=(i+r[1][i])&gt;&gt;1; ans=max(ans,r[1][i]+solve(L,R+1)*2); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4771 七彩树]]></title>
    <url>%2F2019%2F05%2F19%2Fbzoj-4771-%E4%B8%83%E5%BD%A9%E6%A0%91%2F</url>
    <content type="text"><![CDATA[主席树. 询问的点要求在子树 $x$ 内,并且 $dep\leq dep_x+d$ ,这样就有 $dfn,dep$ 上的两维限制,所以可以用主席树把符合条件的点抠出来. 只需要考虑怎么计算不同颜色的种数.对于一种颜色,可以在每个点的位置让权值 $+1$ ,而在 $LCA$ 处让权值 $-1$ .只需要处理 $dfs$ 序相邻的两个点的 $LCA$ (因为最深)就可以保证询问子树时贡献不会被重复计算了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;struct PreSegtree&#123; int idx; void init()&#123;idx=0;Tree[0].siz=Tree[0].ls=Tree[0].rs=0;&#125; struct node &#123; int ls,rs,siz; &#125;Tree[MAXN*50];#define root Tree[o] void insert(int &amp;o,int lst,int l,int r,int pos,int c) &#123; o=++idx; root=Tree[lst]; root.siz+=c; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) insert(root.ls,Tree[lst].ls,l,mid,pos,c); else insert(root.rs,Tree[lst].rs,mid+1,r,pos,c); &#125; int query(int o,int l,int r,int L,int R) &#123; if(L&gt;r || l&gt;R || !o) return 0; if(L&lt;=l &amp;&amp; r&lt;=R) return root.siz; int mid=(l+r)&gt;&gt;1; int res=0; if(L&lt;=mid) res+=query(root.ls,l,mid,L,R); if(R&gt;mid) res+=query(root.rs,mid+1,r,L,R); return res; &#125;&#125;T;int rt[MAXN];int ecnt=0,head[MAXN],to[MAXN],nx[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int n,m;int dfnidx=0,dfn[MAXN],rnk[MAXN],siz[MAXN],dep[MAXN];int fa[MAXN][20],Log[MAXN];int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=Log[dep[x]-dep[y]];i&gt;=0;--i) if(dep[fa[x][i]]&gt;=dep[y]) x=fa[x][i]; if(x==y) return x; for(int i=Log[dep[x]];i&gt;=0;--i) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;void dfs(int u)&#123; dfn[u]=++dfnidx; rnk[dfnidx]=u; siz[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; dep[v]=dep[u]+1; dfs(v); siz[u]+=siz[v]; &#125;&#125;set&lt;int&gt; S[MAXN];set&lt;int&gt;::iterator it;void init()&#123; ecnt=0; dfnidx=0; T.init(); memset(head,0,sizeof head); memset(rt,0,sizeof rt); memset(fa,0,sizeof fa); dep[1]=1;&#125;int pd[MAXN],v[MAXN];bool cmp(int x,int y)&#123; return dep[x]&lt;dep[y];&#125;void solve()&#123; int lastans=0; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; v[i]=read(); S[i].clear(); pd[i]=i; &#125; for(int i=2;i&lt;=n;++i) &#123; fa[i][0]=read(); addedge(fa[i][0],i); &#125; dfs(1); for(int j=1;j&lt;=Log[n];++j) for(int i=1;i&lt;=n;++i) fa[i][j]=fa[fa[i][j-1]][j-1]; sort(pd+1,pd+1+n,cmp); for(int i=1;i&lt;=n;++i) &#123; int j=pd[i]; int a=0,b=0; it=S[v[j]].lower_bound(dfn[j]); T.insert(rt[dep[j]],rt[dep[pd[i-1]]],1,n,dfn[j],1); if(it!=S[v[j]].end()) &#123; b=rnk[*it]; T.insert(rt[dep[j]],rt[dep[j]],1,n,dfn[LCA(b,j)],-1); &#125; if(it!=S[v[j]].begin()) &#123; --it; a=rnk[*it]; T.insert(rt[dep[j]],rt[dep[j]],1,n,dfn[LCA(a,j)],-1); &#125; if(a &amp;&amp; b) T.insert(rt[dep[j]],rt[dep[j]],1,n,dfn[LCA(a,b)],1); S[v[j]].insert(dfn[j]); &#125; while(m--) &#123; int x=read()^lastans; int d=read()^lastans; lastans=T.query(rt[min(dep[x]+d,dep[pd[n]])],1,n,dfn[x],dfn[x]+siz[x]-1); lastans-=T.query(rt[dep[x]-1],1,n,dfn[x],dfn[x]+siz[x]-1); printf("%d\n",lastans); &#125;&#125;int main()&#123; Log[1]=0; for(int i=2;i&lt;MAXN;++i) Log[i]=Log[i&gt;&gt;1]+1; int Testcases=read(); while(Testcases--) &#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4773 负环]]></title>
    <url>%2F2019%2F05%2F19%2Fbzoj-4773-%E8%B4%9F%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[$floyd$ + 倍增. 写保卫王国那道题的时候学习了 Min-plus matrix multiplication ,即将矩阵乘法中的乘法换成加法,加法换成取 $\min$ .这东西还有其他的用法.若一个图的邻接矩阵的 $k$ 次方为 $A$ (在这样运算下), 则 $A_{i,j}$ 表示图中从 $i$ 到 $j$ ,经过 $k$ 条边的最短路长度. 为啥?因为这样运算其实就是 $floyd$ 的转移,只不过恰好也满足了结合律. 要找最短的负环,可以设 $f[k]$ 为原邻接矩阵的 $2^k$ 次方,倍增解决即可,环的大小即为边的数目. 时间复杂度 $O(n^3logn)$ . 注意要将邻接矩阵中自己到自己的距离设为 $0$ ,这样答案才满足单调性. 也可以直接二分答案,时间复杂度为 $O(n^3log^2n)$ ,但对于 $n\leq 300$ 来说差异不大. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=300+10;int n,m;struct Matrix&#123; int A[MAXN][MAXN]; Matrix()&#123;memset(A,63,sizeof A);&#125; Matrix operator * (const Matrix &amp;rhs) const &#123; Matrix res; for(int k=1;k&lt;=n;++k) for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) res.A[i][j]=min(res.A[i][j],A[i][k]+rhs.A[k][j]); return res; &#125;&#125;f[10],cur,nx;int Log[MAXN];int main()&#123; Log[1]=0; for(int i=2;i&lt;MAXN;++i) Log[i]=Log[i&gt;&gt;1]+1; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(),w=read(); f[0].A[u][v]=w; &#125; for(int i=1;i&lt;=n;++i) cur.A[i][i]=f[0].A[i][i]=0; int mx=Log[n]; for(int i=1;i&lt;=mx;++i) f[i]=f[i-1]*f[i-1]; int ans=0; for(int i=mx;i&gt;=0;--i) &#123; bool flag=false; nx=f[i]*cur; for(int j=1;j&lt;=n &amp;&amp; !flag;++j) if(nx.A[j][j]&lt;0) flag=true; if(!flag) ans+=1&lt;&lt;i,cur=nx; &#125; printf("%d",ans+1&gt;n?0:ans+1); return 0;&#125;]]></content>
      <tags>
        <tag>floyd</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4774 修路]]></title>
    <url>%2F2019%2F05%2F17%2Fbzoj-4774-%E4%BF%AE%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[斯坦纳树 + 状压 . 开始感觉直接做一颗最小生成树出来,把没用的边割掉就好了.然而随手画几个图发现是错的. 然后学习了一波 最小斯坦纳树 .这东西可以看做是最小生成树的一般情况.生成树是求一个选边方案,将所有的点加入联通块中.斯坦纳树是把指定点集中的点加入联通块中,也可以加入不在点集中的点来辅助. 求解最小斯坦纳树是 $NP$ 的,没有多项式算法,用状压做.设 $f[S][i]$ 为指定点的连通状态为 $S$ ,最小斯坦纳树的根节点为 $i$ 时的最小权值.转移有两种.第一种是将当前集合拆成两个不相交的子集, $f[S][i]\leftarrow f[S_1][i]+f[S_2][i],S_1,S_2\subset S,S_1 \&amp; S_2=0$ .另一种是换根, $f[S][i]\leftarrow f[S][j]+val_{i,j}$ ,后者表示连接 $i,j$ 的边权.这东西有后效性,用 $Spfa$ 转移. 而这道题是指定点对间连通,可以看做最小斯坦纳森林.设 $g[S]$ 表示连通了点集 $S$ 的最小斯坦纳森林的权值. 转移有 $g[S]\leftarrow g[S_1]+g[S_2],S_1,S_2\subset S,S_1 \&amp; S_2=0​$ .即将 $S​$ 拆成两个不相交子集. $S_1,S_2​$ 都需要满足每对对应点要么都不在其中,要么都在其中. 最后答案就是 $g[S_0]$ , $S_0$ 表示将那 $2d$ 个点都连通的状态. 小心爆 $int$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e4+10,MAXS=1&lt;&lt;8;int inf;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN&lt;&lt;1];inline void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;int f[MAXS][MAXN],g[MAXS];int n,m,D;queue&lt;int&gt; q;int vis[MAXN];void SPFA(int S)&#123; while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(f[S][v]-f[S][u]&gt;val[i]) &#123; f[S][v]=f[S][u]+val[i]; if(!vis[v]) &#123; vis[v]=1; q.push(v); &#125; &#125; &#125; &#125;&#125;bool check(int S)&#123; return (S&amp;((1&lt;&lt;D)-1))==(S&gt;&gt;D);&#125;int main()&#123; n=read(),m=read(),D=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; memset(f,63,sizeof f); memset(g,63,sizeof g); inf=f[0][0]; for(int i=1;i&lt;=D;++i) f[1&lt;&lt;(i-1)][i]=f[1&lt;&lt;(D+i-1)][n-i+1]=0; int mx=1&lt;&lt;(2*D); for(int S=0;S&lt;mx;++S) &#123; for(int i=1;i&lt;=n;++i) &#123; for(int S1=(S-1)&amp;S;S1;S1=(S1-1)&amp;S) f[S][i]=min(f[S][i],f[S1][i]+f[S^S1][i]); if(f[S][i]&lt;inf) &#123; q.push(i); vis[i]=1; &#125; &#125; SPFA(S); for(int i=1;i&lt;=n;++i) g[S]=min(g[S],f[S][i]); &#125; for(int S=0;S&lt;mx;++S) for(int S1=(S-1)&amp;S;S1;S1=(S1-1)&amp;S) if(check(S1) &amp;&amp; check(S^S1)) g[S]=min(g[S],g[S1]+g[S^S1]); if(g[mx-1]&gt;=inf) puts("-1"); else cout&lt;&lt;g[mx-1]; return 0;&#125;]]></content>
      <tags>
        <tag>状压dp</tag>
        <tag>斯坦纳树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4735 你的生命已如风中残烛]]></title>
    <url>%2F2019%2F05%2F16%2Fbzoj-4735-%E4%BD%A0%E7%9A%84%E7%94%9F%E5%91%BD%E5%B7%B2%E5%A6%82%E9%A3%8E%E4%B8%AD%E6%AE%8B%E7%83%9B%2F</url>
    <content type="text"><![CDATA[一道短小精悍(指代码)的数学题. 把每个位置上的数都 $-1$ ,于是要求就变为每个位置的前缀和都是非负数. 如果在最后再加入一个 $-1$ ,那么就只有最后一个位置前缀和为 $-1$ ,其他位置都是非负数. 这样就可证明,对于一个序列的所有循环同构,有且仅有一种序列是合法的. 因为只有把多出来的 $-1$ 放在最后才合法.因为总和为 $-1$ ,若最后一个位置不是 $-1$ ,那么前面一个位置的前缀和一定为负. 而这个 $-1$ 可以是原有的与新加的共 $m-n+1$ 个 $-1$ 中的任意一个,所以应除去. $$ans=\frac {m!} {m-n+1}$$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; int n=read(),m=0; for(int i=1;i&lt;=n;++i) m+=read(); int ans=1; for(int i=2;i&lt;=m;++i) ans=mul(ans,i); ans=mul(ans,fpow(m-n+1,P-2)); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4860 树的难题]]></title>
    <url>%2F2019%2F05%2F16%2Fbzoj-4860-%E6%A0%91%E7%9A%84%E9%9A%BE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[点分治 + 线段树合并. 英语月考的时候一直在想这个题… 有路径长度的限制,可以考虑点分治.然后发现在合并两条路径时有两种情况. 靠近当前分治中心的那两条边如果颜色不同,就直接将两条路径权值加起来.否则还要减去那条边的颜色权值. 分治时把子树按照与当前分支中心连接的边的颜色排序,扫一遍,维护两颗线段树,分别表示连到分治中心的边与当前颜色不同的最大权值与相同的最大权值. 处理完一种颜色的时候把两颗线段树合并起来就好了.时间复杂度 $O(nlog^2n)$ . bzoj 不支持 C++11​ 是真的毒瘤… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define mp make_pairtypedef pair&lt;int,int&gt; pii;const ll inf=1e18;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,m,limL,limR,roota,rootb,cnt;struct node&#123; int ls,rs; ll mxv;&#125;Tree[MAXN*30];#define root Tree[o]int newnode()&#123; int o=++cnt; root.ls=root.rs=0; root.mxv=-inf; return o;&#125;void pushup(int o)&#123; root.mxv=max(Tree[root.ls].mxv,Tree[root.rs].mxv);&#125;int merge(int a,int b)&#123; if(!a || !b) return a+b; Tree[a].mxv=max(Tree[a].mxv,Tree[b].mxv); Tree[a].ls=merge(Tree[a].ls,Tree[b].ls); Tree[a].rs=merge(Tree[a].rs,Tree[b].rs); return a;&#125;void insert(int &amp;o,int l,int r,int pos,ll c)&#123; if(!o) o=newnode(); if(l==r) &#123; root.mxv=max(root.mxv,c); return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) insert(root.ls,l,mid,pos,c); else insert(root.rs,mid+1,r,pos,c); pushup(o);&#125;ll query(int o,int l,int r,int L,int R)&#123; if(!o) return -inf; if(L&lt;=l &amp;&amp; r&lt;=R) return root.mxv; ll res=-inf; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res=max(res,query(root.ls,l,mid,L,R)); if(R&gt;mid) res=max(res,query(root.rs,mid+1,r,L,R)); return res;&#125;vector&lt;pii&gt; edge[MAXN];ll ans=-inf,mi;int rt=0,totsize,vis[MAXN],siz[MAXN];int val[MAXN];void Findrt(int u)&#123; siz[u]=1; vis[u]=1; int sonsize=0; int SIZ=edge[u].size(); for(int id=0;id&lt;SIZ;++id) &#123; pii i=edge[u][id]; int v=i.second; if(vis[v]) continue; Findrt(v); siz[u]+=siz[v]; sonsize=max(sonsize,siz[v]); &#125; sonsize=max(sonsize,totsize-siz[u]); if(sonsize&lt;mi) rt=u,mi=sonsize; vis[u]=0;&#125;void getsize(int u)&#123; ++totsize; vis[u]=1; int SIZ=edge[u].size(); for(int id=0;id&lt;SIZ;++id) &#123; pii i=edge[u][id]; int v=i.second; if(!vis[v]) getsize(v); &#125; vis[u]=0;&#125;ll mx[MAXN];void dfs(int u,ll c,int len,int curcol)&#123; if(len&gt;limR) return; vis[u]=1; mx[len]=max(mx[len],c); int SIZ=edge[u].size(); for(int id=0;id&lt;SIZ;++id) &#123; pii i=edge[u][id]; int v=i.second,r=i.first; ll newc=c; if(r!=curcol) newc+=val[r]; if(!vis[v]) dfs(v,newc,len+1,r); &#125; vis[u]=0;&#125;void solve(int u)&#123; totsize=cnt=roota=rootb=0; mi=inf; getsize(u); Findrt(u); int Rt=rt; getsize(Rt); vis[Rt]=1; int precol=0; int SIZ=edge[Rt].size(); for(int id=0;id&lt;SIZ;++id) &#123; pii e=edge[Rt][id]; int v=e.second,r=e.first; if(vis[v]) continue; for(int k=0;k&lt;=siz[v];++k) mx[k]=-inf; if(rootb &amp;&amp; r!=precol) &#123; roota=merge(roota,rootb); rootb=0; &#125; dfs(v,val[r],1,r); for(int i=1;i&lt;=siz[v] &amp;&amp; i&lt;limR &amp;&amp; mx[i]!=mx[0];++i) &#123; ll tmp=max(ans,i&gt;=limL &amp;&amp; i&lt;=limR? mx[i]:-inf); tmp=max(tmp,query(roota,1,limR,max(1,limL-i),limR-i)+mx[i]); tmp=max(tmp,query(rootb,1,limR,max(1,limL-i),limR-i)-val[r]+mx[i]); ans=max(ans,tmp); &#125; for(int i=1;i&lt;=siz[v] &amp;&amp; i&lt;limR &amp;&amp; mx[i]!=mx[0];++i) &#123; insert(rootb,1,limR,i,mx[i]); &#125; precol=r; &#125; for(int id=0;id&lt;SIZ;++id) &#123; pii e=edge[Rt][id]; int v=e.second; if(!vis[v]) solve(v); &#125;&#125;int main()&#123; Tree[0].mxv=-inf; n=read(),m=read(),limL=read(),limR=read(); for(int i=1;i&lt;=m;++i) val[i]=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(),c=read(); edge[u].push_back(mp(c,v)); edge[v].push_back(mp(c,u)); &#125; for(int i=1;i&lt;=n;++i) sort(edge[i].begin(),edge[i].end()); solve(1); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>线段树合并</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4916 神犇与蒟蒻]]></title>
    <url>%2F2019%2F05%2F14%2Fbzoj-4916-%E7%A5%9E%E7%8A%87%E4%B8%8E%E8%92%9F%E8%92%BB%2F</url>
    <content type="text"><![CDATA[杜教筛小水题. 根据 $\mu$ 的定义,第一个式子显然为 $1$ . 根据 $\varphi$ 的定义,第二个式子显然为 $\sum_{i=1}^N i\cdot \varphi(i)$ ,直接杜教筛即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P; &#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv2,inv6;inline int sumh(int x)&#123; int s=mul(x,x+1); s=mul(s,2*x+1); s=mul(s,inv6); return s;&#125;inline int sumg(int l,int r)&#123; return mul(mul(l+r,r-l+1),inv2);&#125;const int N=32000,MAXN=N+10;int phi[MAXN],cnt=0,prime[MAXN],ism[MAXN],sum[MAXN];void init()&#123; phi[1]=1,ism[1]=1; for(int i=2;i&lt;=N;++i) &#123; if(!ism[i]) prime[++cnt]=i,phi[i]=i-1; for(int j=1;j&lt;=cnt &amp;&amp; i*prime[j]&lt;=N;++j) &#123; ism[i*prime[j]]=1; if(i%prime[j]==0) &#123; phi[i*prime[j]]=mul(phi[i],prime[j]); break; &#125; phi[i*prime[j]]=mul(phi[i],prime[j]-1); &#125; &#125; for(int i=1;i&lt;=N;++i) sum[i]=add(sum[i-1],mul(i,phi[i]));&#125;map&lt;int,int&gt; mp;int calc(int n)&#123; if(n&lt;=N) return sum[n]; if(mp.find(n)!=mp.end()) return mp[n]; int res=sumh(n); for(int l=2,r;l&lt;=n;l=r+1) &#123; r=n/(n/l); res=add(res,P-mul(sumg(l,r),calc(n/l))); &#125; return mp[n]=res;&#125;int main()&#123; inv2=fpow(2,P-2); inv6=fpow(6,P-2); init(); int n=read(); printf("%d\n%d\n",1,calc(n)); return 0;&#125;]]></content>
      <tags>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4926 皮皮妖的递推]]></title>
    <url>%2F2019%2F05%2F14%2Fbzoj-4926-%E7%9A%AE%E7%9A%AE%E5%A6%96%E7%9A%84%E9%80%92%E6%8E%A8%2F</url>
    <content type="text"><![CDATA[构造. 发现这个迭代过程与斐波那契数列有相似之处,构造 $g(i)=g(i-1)+g(i-m),g(0)=1$ . 把 $n$ 拆成 $k$ 个 $g_i$ 的和, $n=\sum_{i=1}^k g(a_i)$ ,则 $f_n=\sum_{i=1}^k g(a_i-1)$ . 证明:将 $f$ 定义式变形得到 $f(n)+f^m(n-1)=n$ .而 $n=\sum_{i=1}^k g(a_i),f_n=\sum_{i=1}^k g(a_i-1)$ . $f^2(n)=\sum_{i=1}^k g(a_i-2)$ ,依次计算,可得 $f^m(n)=\sum_{i=1}^k g(a_i-m)$ . 而现在需要的是 $f^m(n-1)$ ,而 $n$ 只比 $n-1$ 多了个 $1$ ,把 $g(0)$ 设为 $1$ 即可. 那么就有 $\sum_{i=1}^k g(a_i-1)+\sum_{i=1}^k g(a_i-m)=\sum_{i=1}^k g(a_i)$ .于是 $g(i)=g(i-1)+g(i-m),g(0)=1$ . 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e6+10;ll g[MAXN];int main()&#123; ll n=read(),m=read(); for(int i=0;i&lt;=m;++i) g[i]=1; int mx=m+1; for(;;++mx) &#123; g[mx]=g[mx-1]+g[mx-m]; if(g[mx]&gt;n) break; &#125; --mx; ll ans=0; for(int i=mx;i&gt;=1 &amp;&amp; n;--i) if(n&gt;=g[i]) n-=g[i],ans+=g[i-1]; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4962 简单的字符串]]></title>
    <url>%2F2019%2F05%2F14%2Fbzoj-4962-%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[$Manacher$ . 不知道性质的话应该挺难做的… 先枚举子串中心,往两侧拓展,将走到的位置的字符交替写下来,记作 $S$ . 比如字符串是 $abcdacce$ ,以 $d$ 右侧的那个位置为中心,则 $S=daccbcae$ (此处先写左边). 若中心的两侧长度为 $L$ 的两个子串循环同构,则 $S$ 中对应的长度为 $2L$ 的前缀能被 $1$ 或 $2$ 个偶回文串拼接成. 证明:如果左右两个子串完全相同,那么这个长度为 $2L$ 的前缀自身就是一个偶回文串.否则,若左右两个子串不同,但循环同构,那么设右边的串为 $s_1,s_2,\dots s_L$ ,左边的串为 $s_i,s_{i+1},\dots,s_L,s_1,s_2\dots,s_{i-1}$ . 那么这个长度为 $2L$ 的前缀就应该是 $(s_{i-1},s_1,s_{i-2},s_2,\dots,s_1,s_{i-1})+(s_L,s_i,s_{L-1},s_{i+1},\dots,s_i,s_L)$ . 显然加号两边的串都是偶回文串. 还有一个性质,若 $S=u+v$ , $u$ 和 $v$ 都是偶回文串,那么要么 $u$ 是 $S$ 的最长偶回文前缀,要么 $v$ 是 $S$ 的最长偶回文后缀.Claris的证明 于是用 $Manacher$ 跑出每个位置的最长回文半径 $rmax$ ,对于每个前缀判断一下拆成 最长偶回文前缀 + 偶回文串 与拆成 偶回文串 + 最长偶回文后缀 是否有一个合法即可. 时间复杂度 $O(n^2)$ . 若用 $Hash$ 代替 $Manacher$ 则为 $O(n^2 logn)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e3+10;int ch[MAXN],s[MAXN];int n,rmax[MAXN],pre[MAXN];int solve(int p)&#123; int len=0; for(int i=p,j=p+1;i&gt;=1 &amp;&amp; j&lt;=n;--i,++j) s[++len]=ch[i],s[++len]=ch[j]; fill(pre+1,pre+2+len,0); int r=0,pos=1; for(int i=1;i&lt;=len;++i) &#123; int mx=min(max(r-i,0),rmax[2*pos-i]); while(i+mx+1&lt;=n &amp;&amp; i-mx&gt;0 &amp;&amp; s[i+mx+1]==s[i-mx]) ++mx; rmax[i]=mx; if(i+mx&gt;=r) r=i+mx,pos=i; pre[i+rmax[i]]=max(pre[i+rmax[i]],rmax[i]); &#125; for(int i=len;i&gt;=1;--i) pre[i]=max(pre[i],pre[i+1]-1); for(int i=len;i&gt;=1;i-=2) pre[i]&lt;&lt;=1; int mx=0,res=0; for(int i=2;i&lt;=len;i+=2) &#123; if(rmax[i/2]==i/2) mx=i; if(rmax[(i+mx)/2]&gt;=(i-mx)/2 || rmax[(i-pre[i])/2]&gt;=(i-pre[i])/2) ++res; &#125; return res;&#125;int main()&#123; int ans=0; n=read(); for(int i=1;i&lt;=n;++i) ch[i]=read(); for(int i=1;i&lt;n;++i) ans+=solve(i); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4985 评分]]></title>
    <url>%2F2019%2F05%2F14%2Fbzoj-4985-%E8%AF%84%E5%88%86%2F</url>
    <content type="text"><![CDATA[二分答案 + $dp$ . 这种只有比较大小的操作的题,套路大多是二分答案 $x$ ,将大于等于 $x$ 的视作 $1$ ,其余视作 $0$ ,再考虑判断. 此题二分答案后,可以设 $f(i)$ 表示要将位置 $i$ 上的数确定为 $1$ ,至少需要在前面填几个 $1$ (已确定的位置不算). 那么初始时,若 $i$ 的值未确定,则 $f(i)=1$ ,若 $\geq x$ ,则为 $0$ ,若 $&lt;x$ ,则为 $inf$ . 转移时用队列,将前三个取出来,将最小的两个值加起来放在最后.因为要让最后一个为 $1$ ,则这三个中至少有两个 $1$ . 只剩下一个数时,判断它是否不超过可以随便填的 $1$ 的数目即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;const int inf=1e9;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,m;int d[MAXN];int fd[MAXN];queue&lt;int&gt; q;bool check(int x)&#123; while(!q.empty()) q.pop(); int fcnt=0; for(int i=1;i&lt;=n-m;++i) if(fd[i]&gt;=x) ++fcnt; for(int i=1;i&lt;=n;++i) &#123; if(d[i]==0) q.push(1); else if(d[i]&gt;=x) q.push(0); else q.push(inf); &#125; while(1) &#123; int a=q.front(); q.pop(); if(q.empty()) return a&lt;=fcnt; int b=q.front(); q.pop(); int c=q.front(); q.pop(); q.push(min(inf,min(a+b,min(a+c,b+c)))); &#125;&#125;int main()&#123; n=read(),m=read(); int L=1,R=0; for(int i=1;i&lt;=m;++i) &#123; int x=read(),pos=read(); d[pos]=x; R=max(R,x); &#125; for(int i=1;i&lt;=n-m;++i) &#123; fd[i]=read(); R=max(R,fd[i]); &#125; int ans=0; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid)) ans=mid,L=mid+1; else R=mid-1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4998 星球联盟]]></title>
    <url>%2F2019%2F05%2F13%2Fbzoj-4998-%E6%98%9F%E7%90%83%E8%81%94%E7%9B%9F%2F</url>
    <content type="text"><![CDATA[离线,并查集维护点双. 一个比较直接的做法是将点双缩点,然后用 $LCT$ 维护缩点后的树. 其实也可以直接用并查集做.因为只有加边的操作,所以可以离线处理出最后图的一颗生成树. 然后加边时,若为树边,答案显然是 $No$ .否则用并查集将那两个点合并起来,同时维护 $siz$ 就好了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,m,q;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;2],nx[MAXN&lt;&lt;2];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int f[MAXN],siz[MAXN];int Find(int x)&#123; return x==f[x]?x:(f[x]=Find(f[x]));&#125;int U[MAXN&lt;&lt;1],V[MAXN&lt;&lt;1];int fa[MAXN],dep[MAXN];void dfs(int u,int Fa)&#123; fa[u]=Fa; dep[u]=dep[Fa]+1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v!=Fa) dfs(v,u); &#125;&#125;int treeedge[MAXN&lt;&lt;1];void merge(int x,int y)&#123; x=Find(x),y=Find(y); while(x!=y) &#123; if(dep[x]&lt;dep[y]) swap(x,y); int fx=Find(fa[x]); f[x]=fx; siz[fx]+=siz[x]; x=fx; &#125;&#125;int main()&#123; n=read(),m=read(),q=read(); for(int i=1;i&lt;=n;++i) f[i]=i; for(int i=1;i&lt;=m+q;++i) &#123; int u=read(),v=read(); U[i]=u,V[i]=v; int x=Find(u),y=Find(v); if(x!=y) &#123; f[x]=y; addedge(u,v); addedge(v,u); treeedge[i]=1; &#125; &#125; for(int i=1;i&lt;=n;++i) if(!fa[i]) dfs(i,i); for(int i=1;i&lt;=n;++i) f[i]=i,siz[i]=1; for(int i=1;i&lt;=m;++i) if(!treeedge[i]) merge(U[i],V[i]); for(int i=m+1;i&lt;=m+q;++i) &#123; if(treeedge[i]) puts("No"); else &#123; merge(U[i],V[i]); printf("%d\n",siz[Find(U[i])]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190512]]></title>
    <url>%2F2019%2F05%2F12%2Ftest20190512%2F</url>
    <content type="text"><![CDATA[普及组套题.可能就 $AK$ 了. 前两题很 $sb$ ,没啥可说的. 考后发现 $T3$ 是个普及组模拟赛的题?还是入门 $OJ$ 上的… Link 考试做法:考虑枚举答案为 $t$ ,那么前 $t$ 天不割的总长是确定的,为 $\sum h_i+t\cdot grow_i$ .需要最大化 $t$ 次割草割去的长度总和. 一株草显然可以只割一次,割多次和只割最后一次是等价的.那么枚举范围就可以设为 $1\sim n$ . 而同一天也不能割两株草.所以 $n$ 株草, $t$ 天就形成了一个 $n\times t$ 的矩阵,每个点有权值,现在每一行每一列最多选 $1$ 个,要求共选 $t​$ 个的最大收益,就成了经典模型. 用一个大数 $inf$ 减去原权值作为权值,就是最小费用最大流,最后算一下就可以了.由于 $n\leq 50​$ ,肯定能过. 大家的做法:枚举答案 $t$ ,将草按 $grow$ 排序,先割 $grow$ 小的,再割大的,总共割 $t$ 次. 然后设 $f(i,j)$ 表示前 $i$ 株草割了 $j$ 株能获得的最大收益就好了. 贪心部分的正确性可以用经典套路证明,尝试交换两株草被割的次序,答案不会变得更优. 顿时感觉自己好 $sb​$ 啊.如果这题把数据出大点今天可能就凉了…]]></content>
      <tags>
        <tag>test</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5479 tree]]></title>
    <url>%2F2019%2F05%2F12%2Fbzoj-5479-tree%2F</url>
    <content type="text"><![CDATA[欧拉序 + 贪心 + 二分. $LCA$ 问题首先可以处理出欧拉序,将树上问题转化成序列问题. 于是就变成了给出一些 $A$ 类点,一些 $B$ 类点,选两个不同类的点作为区间,求区间内 $dep$ 的最小值的最大值. 看上去可以直接二分,然而没什么用,因为区间数目是 $|A|\cdot |B|$ 的. 考虑贪心.对于一个 $B$ 类点,如果我们钦定它作为左端点,那么那个作为右端点的 $A$ 类点应该越靠左越好.如果钦定它为右端点,那么那个 $A$ 类点应该越靠左越好. 于是对每个 $B$ 类点二分出左/右最近的 $A$ 类点,将这两个区间的 $dep$ 最小值加入贡献. 预处理 $ST$ 表,时间复杂度 $O(\sum |B| \cdot log|A|)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,m;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int dep[MAXN],dfn[MAXN],idx;int a[MAXN&lt;&lt;1];void dfs(int u,int fa)&#123; dep[u]=dep[fa]+1; dfn[u]=++idx; a[idx]=dep[u]; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa) continue; dfs(v,u); a[++idx]=dep[u]; &#125;&#125;const int LogN=20;int st[MAXN&lt;&lt;1][LogN];int Log[MAXN&lt;&lt;1];void init_ST()&#123; for(int i=1;i&lt;=2*n-1;++i) st[i][0]=a[i]; for(int j=1;(1&lt;&lt;j)&lt;=2*n-1;++j) for(int i=1;i+(1&lt;&lt;j)-1&lt;=2*n-1;++i) st[i][j]=min(st[i][j-1],st[i+(1&lt;&lt;(j-1))][j-1]);&#125;int query(int l,int r)&#123; int k=Log[r-l+1]; return min(st[l][k],st[r-(1&lt;&lt;k)+1][k]);&#125;void reset()&#123; ecnt=0; idx=0; for(int i=1;i&lt;=n;++i) head[i]=0;&#125;int dfnset[MAXN&lt;&lt;1],A;int pre(int x)&#123; return dfnset[upper_bound(dfnset,dfnset+A,x)-dfnset-1];&#125;int suf(int x)&#123; return dfnset[lower_bound(dfnset,dfnset+A,x)-dfnset];&#125;int main()&#123; Log[1]=0; for(int i=2;i&lt;=200000;++i) Log[i]=Log[i&gt;&gt;1]+1; int T=read(); while(T--) &#123; n=read(),m=read(); reset(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs(1,0); init_ST(); while(m--) &#123; int ans=0; A=read(); for(int i=1;i&lt;=A;++i) dfnset[i]=dfn[read()]; sort(dfnset+1,dfnset+1+A); dfnset[0]=0,dfnset[A+1]=2*n; A+=2; int B=read(); for(int i=1;i&lt;=B;++i) &#123; int x=dfn[read()]; int lx=pre(x),rx=suf(x); if(lx) ans=max(ans,query(lx,x)); if(rx!=2*n) ans=max(ans,query(x,rx)); &#125; printf("%d\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
        <tag>dfs序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5478 gcd]]></title>
    <url>%2F2019%2F05%2F11%2Fbzoj-5478-gcd%2F</url>
    <content type="text"><![CDATA[莫比乌斯反演. 题面有误, $a$ 应该是 $1\sim n$ 的一个排列.因为这个卡了好久… 用 $\varphi$ 反演就很好做. $O(n)$ 大力枚举 $d$ ,因为 $a$ 是个排列,所以可以大力枚举集合中的每个数的约数,对 $1\sim n$ 中每个数记录一下有 $f(i)$ 个数是它的倍数,那么后面那坨就是 $\sum f(i)^2$ 了. 集合大小总和是个调和级数,总时间复杂度应该是 $O(nlog^3n)$ .(其实我不会证) 直接 $memset$ 会 $T$ ,可能需要一点卡常的奇技淫巧. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;const int MAXN=1e5+10;inline int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int n,a[MAXN];int phi[MAXN],ism[MAXN],cnt=0,prime[MAXN];vector&lt;int&gt; factor[MAXN];void init()&#123; for(int i=1;i&lt;=n;++i) for(int j=i;j&lt;=n;j+=i) factor[j].push_back(i); ism[1]=1,phi[1]=1; for(int i=2;i&lt;=n;++i) &#123; if(!ism[i]) prime[++cnt]=i,phi[i]=i-1; for(int j=1;j&lt;=cnt &amp;&amp; i*prime[j]&lt;=n;++j) &#123; ism[i*prime[j]]=1; if(i%prime[j]==0) &#123; phi[i*prime[j]]=mul(phi[i],prime[j]); break; &#125; phi[i*prime[j]]=mul(phi[i],prime[j]-1); &#125; &#125;&#125;int f[MAXN],vis[MAXN];int main()&#123; n=read(); init(); for(int i=1;i&lt;=n;++i) a[i]=read(); int ans=0; for(int i=1;i&lt;=n;++i) &#123; int res=0; for(int j=i;j&lt;=n;j+=i) &#123; int p=a[j]; int siz=factor[p].size(); for(int k=0;k&lt;siz;++k) &#123; int q=factor[p][k]; if(vis[q]!=i) &#123; f[q]=1; vis[q]=i; &#125; else ++f[q]; res=add(res,mul(2*f[q]-1,phi[q])); &#125; &#125; res=mul(res,phi[i]); ans=add(ans,res); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5477 星际穿越]]></title>
    <url>%2F2019%2F05%2F10%2Fbzoj-5477-%E6%98%9F%E9%99%85%E7%A9%BF%E8%B6%8A%2F</url>
    <content type="text"><![CDATA[$dfs$ 序 + 树状数组. 由于路径的权是点权,可以考虑每个点被多少条路径经过,乘上它的点权即为贡献. 假设当前询问是在子树 $p$ 内,考虑一个点 $i$ ,在子树 $i$ 内与不在子树 $i$ 内的点形成了 $siz[i]\cdot (siz[p]-siz[i]+1)$ 条路径,都经过了点 $i$ . 还有一部分路径是将 $i$ 作为 $LCA$ 经过.显然每两个在 $i$ 的不同儿子形成的子树内的点都会经过 $i$ .这部分路径数目可以在 $dfs$ 时利用前缀和算出,记作 $k[i]$ . 由于修改只会单点修改点权,不改变树的形态,把那个 $siz[p]$ 拆出去算,预处理出每个点的剩下的系数. 直接利用 $dfs$ 序,树状数组维护答案. 记 $w[i]=k[i]+siz[i]\cdot (1-siz[u])​$ . 那么每次询问的答案就是子树 $p​$ 内的 $siz[p]\cdot (\sum siz[i]\cdot val[i])+(\sum w[i]\cdot val[i])​$ . 开两个树状数组分别维护前缀 $\sum siz\cdot val$ 与 $\sum siz\cdot w$ 就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;const int P=1e9+7;int n,m;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;struct FenwickTree&#123; #define lowbit(x) x&amp;(-x) int bit[MAXN]; FenwickTree()&#123;memset(bit,0,sizeof bit);&#125; void upd(int x,int c) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]=add(bit[x],c); &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s=add(s,bit[x]); return s; &#125; int query(int l,int r) &#123; return add(sum(r),P-sum(l-1)); &#125;&#125;;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int siz[MAXN],dfn[MAXN],idx=0;int k[MAXN],w[MAXN];void dfs(int u,int fa)&#123; dfn[u]=++idx; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa) continue; dfs(v,u); k[u]=add(k[u],mul(siz[v],siz[u])); siz[u]+=siz[v]; &#125; siz[u]++;&#125;FenwickTree T1;//siz*valFenwickTree T2;//w*valvoid init()&#123; for(int i=1;i&lt;=n;++i) &#123; T1.upd(dfn[i],mul(siz[i],val[i])); w[i]=add(k[i],mul(siz[i],P+1-siz[i])); T2.upd(dfn[i],mul(w[i],val[i])); &#125;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;n;++i) &#123; val[i]=1; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; val[n]=1; dfs(1,0); init(); while(m--) &#123; int op=read(); if(op==1) &#123; int p=read(),x=read(); T1.upd(dfn[p],mul(siz[p],x)); T2.upd(dfn[p],mul(w[p],x)); &#125; else &#123; int p=read(); int ans=T2.query(dfn[p],dfn[p]+siz[p]-1); ans=add(ans,mul(siz[p],T1.query(dfn[p],dfn[p]+siz[p]-1))); printf("%d\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>dfs序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5476 位运算]]></title>
    <url>%2F2019%2F05%2F09%2Fbzoj-5476-%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[树状数组. 如果直接离散化 + 莫队,时间复杂度 $O(m\sqrt n)$ ,无法通过. 如果在计算异或和时,一个数在区间内出现了 $k$ 次,使最后一次不计入贡献,那么就只算了 $k-1$ 次. 这样得到的答案就是出现偶数次的数的异或和. 将询问离线,并按照 $r$ 排序,于是可以从前往后一个个加入数.加入一个数 $a_i$ 后,就处理所有 $r=i$ 的询问. 每次加入数 $x$ 时,在它的上一次出现的位置(若有)加入贡献即可.用树状数组维护前缀异或和. $bzoj$ 上数据有点毒.还需要开 $long\ long$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;ll a[MAXN],A[MAXN];int n,m,tot;ll res[MAXN];struct qry&#123; int l,r; int id; bool operator &lt; (const qry &amp;rhs) const &#123; return r==rhs.r?l&lt;rhs.l:r&lt;rhs.r; &#125;&#125;q[MAXN];#define lowbit(x) x&amp;(-x)ll bit[MAXN];void add(int x,ll c)&#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]^=c;&#125;ll sum(int x)&#123; ll s=0; for(;x&gt;0;x-=lowbit(x)) s^=bit[x]; return s;&#125;ll query(int l,int r)&#123; return sum(r)^sum(l-1);&#125;int lstpos[MAXN];int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) A[i]=a[i]=read(); sort(A+1,A+1+n); tot=unique(A+1,A+1+n)-A-1; m=read(); for(int i=1;i&lt;=m;++i) &#123; q[i].l=read(),q[i].r=read(); q[i].id=i; &#125; sort(q+1,q+1+m); for(int i=1,j=1;i&lt;=n;++i) &#123; int x=lower_bound(A+1,A+1+tot,a[i])-A; if(lstpos[x]) add(lstpos[x],A[x]); lstpos[x]=i; for(;j&lt;=m &amp;&amp; q[j].r==i;++j) res[q[j].id]=query(q[j].l,q[j].r); &#125; for(int i=1;i&lt;=m;++i) printf("%lld\n",res[i]); return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>离线</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5496 字符串问题]]></title>
    <url>%2F2019%2F05%2F09%2Fbzoj-5496-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[$SAM$ 优化连边 + $DAG$ 上 $dp$ . 首先可以搞一个 $n_a+n_b$ 个节点的图.如果一个 $A$ 串支配了一个 $B$ 串,就从这个 $A$ 串对应的点向 $B$ 串对应的点连一条有向边.如果一个 $B$ 串是一个 $A$ 串的前缀,就从这个 $B$ 串对应的点向 $A$ 串对应的点连一条有向边. 然后判环,如果没有环就在 $DAG$ 上 $dp$ 找最长路径.节点数目为 $O(n_a+n_b)$ ,可以接受. 但是暴力连边的时间复杂度高达 $O(n_an_b)$ ,于是获得 $40$ 分好成绩. 考虑利用 $SAM$ 的 $parent$ 树自带的树形结构来优化连边. 第一类边,对于一个 $A$ 串,我们可以在 $SAM$ 上倍增找到它对应的节点,然后对于每个它支配的 $B$ 串也用倍增找到节点,从 $A$ 串节点向 $B$ 串节点连一条有向边. 第二类边,要求 $B$ 串是 $A$ 串前缀.我们如果把主串反过来,就变成了 $B$ 串是 $A$ 串的后缀.在 $parent$ 树上显然表现为 $B$ 对应的节点是 $A$ 对应的节点的祖先.那么建 $parent$ 树时就从父亲到儿子连有向边,边自动就连好了. 这样连边的时间复杂度为 $O(|S|log|S|)$ ,节点数目为 $O(|S|)$ ,均可以接受. 但还存在一个问题. $parent$ 树上一个节点对应的子串不止一个.可能出现两个 $A$ 串都被定位到一个节点上.于是每次 $A$ 串定位到一个位置时就新建一个节点栽上去.新建 $n_a​$ 个节点,不会爆炸. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef pair&lt;int,int&gt; pii;const int Siz=26,MAXN=1e6+10;int lst,idx,tmp;int n,m,K;int siz[MAXN],pos[MAXN];int ch[MAXN][Siz],fa[MAXN];int len[MAXN];void Extend(int c,int id)&#123; int p=lst,np=++idx; lst=np; pos[id]=np; siz[np]=1; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125;&#125;int L;int Lg[MAXN];int ecnt=0,head[MAXN],to[MAXN],nx[MAXN],eval[MAXN],indeg[MAXN];ll dp[MAXN];int val[MAXN],dep[MAXN],g[MAXN];vector&lt;pii&gt; d[MAXN];vector&lt;int&gt; v[MAXN];set&lt;pii&gt; s;int l[MAXN],r[MAXN],p[MAXN];int A[MAXN],t[MAXN];void topsort()&#123; for(int i=1;i&lt;=idx;++i) t[len[i]]++; for(int i=1;i&lt;=L;++i) t[i]+=t[i-1]; for(int i=idx;i&gt;=1;--i) A[t[len[i]]--]=i; for(int i=1;i&lt;=idx;++i) &#123; int u=A[i]; dep[u]=dep[fa[u]]+1; v[fa[u]].push_back(u); &#125; for(int i=1;i&lt;=L;++i) t[i]=0;&#125;inline void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; ++indeg[v]; eval[ecnt]=w; head[u]=ecnt;&#125;const int Logn=20;int f[MAXN][Logn];int jump(int u,int l)&#123; for(int i=Lg[dep[u]];i&gt;=0;--i) if(len[f[u][i]]&gt;=l) u=f[u][i]; pii t=make_pair(u,l); if(s.find(t)==s.end()) &#123; g[u]++; s.insert(t); &#125; return u;&#125;void dfs(int u,int Fa)&#123; if(Fa) addedge(Fa,u,0); int h=0; sort(d[u].begin(),d[u].end()); if(d[u].size()) &#123; p[d[u][0].second]=u; for(int i=1;i&lt;d[u].size();++i) &#123; if(d[u][i].first!=d[u][i-1].first) &#123; h=i; break; &#125; p[d[u][i].second]=u; &#125; &#125; int pre=u; while(g[u]&gt;1) &#123; ++idx; --g[u]; p[d[u][h].second]=idx; for(int i=h+1;i&lt;d[u].size();++i) &#123; if(d[u][i].first!=d[u][i-1].first) &#123; h=i; break; &#125; p[d[u][i].second]=idx; &#125; addedge(pre,idx,0); pre=idx; &#125; for(int i=0;i&lt;v[u].size();++i) dfs(v[u][i],pre);&#125;char buf[MAXN];void init()&#123; s.clear(); ecnt=0; for(int i=1;i&lt;=idx;++i) &#123; dep[i]=0; head[i]=0; indeg[i]=0; dp[i]=0; val[i]=0; &#125; for(int i=1;i&lt;=tmp;++i) &#123; v[i].clear(); d[i].clear(); memset(ch[i],0,sizeof ch[i]); fa[i]=0; g[i]=0; &#125; lst=idx=1;&#125;int q[MAXN];void solve()&#123; scanf("%s",buf+1); L=strlen(buf+1); for(int i=L;i&gt;=1;--i) Extend(buf[i]-'a',i); topsort(); for(int i=2;i&lt;=idx;++i) f[i][0]=fa[i]; for(int j=1;j&lt;=Lg[L];++j) for(int i=2;i&lt;=idx;++i) f[i][j]=f[f[i][j-1]][j-1]; n=read(); for(int i=1;i&lt;=n;++i) &#123; l[i]=read(); r[i]=read(); p[i]=jump(pos[l[i]],r[i]-l[i]+1); &#125; m=read(); for(int i=n+1;i&lt;=n+m;++i) &#123; l[i]=read(); r[i]=read(); p[i]=jump(pos[l[i]],r[i]-l[i]+1); &#125; for(int i=1;i&lt;=n+m;++i) d[p[i]].push_back(make_pair(r[i]-l[i]+1,i)); tmp=idx; dfs(1,0); for(int i=1;i&lt;=n;++i) val[p[i]]=r[i]-l[i]+1; K=read(); for(int i=1;i&lt;=K;++i) &#123; int x=read(),y=read(); addedge(p[x],p[y+n],r[x]-l[x]+1); &#125; int tot=0; ll ans=0; q[++tot]=1; for(int i=1;i&lt;=tot;++i) &#123; int U=q[i]; ans=max(ans,dp[U]+val[U]); for(int j=head[U];j;j=nx[j]) &#123; int V=to[j]; indeg[V]--; dp[V]=max(dp[V],dp[U]+eval[j]); if(!indeg[V]) q[++tot]=V; &#125; &#125; if(tot&lt;idx) puts("-1"); else printf("%lld\n",ans);&#125;int main()&#123; for(int i=2;i&lt;MAXN;++i) Lg[i]=Lg[i&gt;&gt;1]+1; int T=read(); while(T--) &#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>DAG</tag>
        <tag>倍增</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 5358 快速查询]]></title>
    <url>%2F2019%2F05%2F08%2FLuogu-5358-%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[乱搞 $STL$ + 线性筛乘法逆元. 乱搞 $STL$ + 线性筛乘法逆元. 因为只有 $10^5$ 种操作,所以被单独赋值的位置最多也就 $10^5$ 个,这些可以开 $map$ 记录,其他位置可以整体维护. 维护 $mul,add,sum,v$ 四个标记, $mul,add$ 表示 $map$ 中存储的值为 $x$ ,实际上是 $mul\cdot x+add$ . $sum$ 表示当前所有元素的和. $v$ 表示不在 $map​$ 中的数统一的值. 初始 $mul=1,add=sum=v=0.​$ 几种操作仔细推一下就好了: 操作 $1$ :先用操作 $5$ 查询 $a_i$ ,算出新的 $sum$ ,再将 $map$ 中位置 $i$ 改为 $(val-add)\cdot mul^{-1}$ . 操作 $2$ : $sum+=val\cdot n,add+=val,v+=val.$ 操作 $3$ : 若 $val\not = 0,sum\times =val,mul\times =val,add\times =val,v\times =val.$ 若 $val=0$ ,执行操作 $4$ ,将所有值都赋为 $0$,否则会使 $mul=0$ ,要用到 $mul^{-1}​$ 时就炸了 . 操作 $4$ : 将 $map$ 清空, $sum=val\cdot n,mul=1,add=0,v=val$ . 操作 $5$ : 若 $a_i$ 在 $map$ 中有权值 $x$ ,那么就是 $mul\cdot x+add$ ,否则为 $v$ . 操作 $6$ : 当前的 $sum​$ . $O(P)$ 预处理乘法逆元,并使用 $unordered$_$map$ ,时间复杂度即为 $O(tq)$ .123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e7+19;int inv[P+10];void init()&#123; inv[1]=1; for(int i=2;i&lt;P;++i) &#123; inv[i]=1LL*(P-P/i)*inv[P%i]%P;// assert(1LL*inv[i]*i%P==1); &#125;&#125;inline int Add(int a,int b)&#123; return (a+b)%P;&#125;inline int Mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=1e5+10;unordered_map&lt;int,int&gt; mp;int n,q,t;int opt[MAXN],qx[MAXN],qy[MAXN];int add=0,mul=1,sum=0,v=0;int ans=0;int query(int x)&#123; if(mp.find(x)!=mp.end()) &#123; int key=mp[x]; return Add(add,Mul(key,mul)); &#125; else return v;&#125;void operate(int id)&#123; int val,op=opt[id],i; if(op==1) &#123; i=qx[id]; val=qy[id]; int org=query(i); sum=Add(sum,val-org); mul=Add(mul,P); int curv=Mul(inv[mul],Add(val,-add)); mp[i]=curv; return; &#125; if(op==2) &#123; val=qx[id]; sum=Add(sum,Mul(val,n)); add=Add(add,val); v=Add(v,val); return; &#125; bool trans=false; if(op==3) &#123; val=qx[id]; if(val) &#123; sum=Mul(sum,val); mul=Mul(mul,val); add=Mul(add,val); v=Mul(v,val); return; &#125; else op=4,trans=true; &#125; if(op==4) &#123; val=trans?0:qx[id]; mp.clear(); sum=Mul(val,n); mul=1,add=0; v=val; return; &#125; if(op==5) &#123; i=qx[id]; ans=Add(ans,query(i)); return; &#125; if(op==6) &#123; ans=Add(ans,sum); return; &#125;&#125;int main()&#123; init(); n=read(),q=read(); for(int i=1;i&lt;=q;++i) &#123; opt[i]=read(); if(opt[i]!=6) qx[i]=read(); if(opt[i]==1) qy[i]=read(); &#125; t=read(); while(t--) &#123; int a=read(),b=read(); for(int j=1;j&lt;=q;++j) operate((a+1LL*j*b)%q+1); &#125; printf("%d\n",(ans%P+P)%P); return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1149]]></title>
    <url>%2F2019%2F05%2F07%2FCF1149%2F</url>
    <content type="text"><![CDATA[$Div.1$ CF1149A Prefix Sum Primes 构造 + 贪心. 可以先线性筛预处理一个质数表.于是就变成了用一定数量的 $1,2​$ 来填每个位置差分的值. 从前往后填,如果当前能放 $2​$ 的话肯定不会劣于放两个 $1​$ .于是能放 $2​$ 就放,否则放 $1​$ ,直到放完为止. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;int prime[MAXN],cnt=0,ism[MAXN];void init(int N)&#123; ism[1]=1; for(int i=2;i&lt;=N;++i) &#123; if(!ism[i]) prime[++cnt]=i; for(int j=1;j&lt;=cnt &amp;&amp; i*prime[j]&lt;=N;++j) &#123; ism[i*prime[j]]=1; if(i%prime[j]==0) break; &#125; &#125;&#125;int bgs[3];void solve()&#123; for(int i=1;i&lt;=cnt;++i) &#123; int dif=prime[i]-prime[i-1]; int us2=min(bgs[2],dif/2); for(int j=1;j&lt;=us2;++j) printf("2 "); bgs[2]-=us2; dif-=2*us2; int us1=min(bgs[1],dif); for(int j=1;j&lt;=us1;++j) printf("1 "); bgs[1]-=us1; if(bgs[1]+bgs[2]==0) return; &#125;&#125;int main()&#123; init(1000000); int n=read(); for(int i=1;i&lt;=n;++i) bgs[read()]++; solve(); return 0;&#125; CF1149B Three Religions 贪心 + $dp$ . 首先可以发现如果三个串匹配到了一定位置,最后在原串中用的字符位置肯定越靠前越好. 于是可以设 $f(i,j,k)$ 表示三个串分别匹配了 $i,j,k$ 的长度时,最后用的字符在原串中的位置. 可以预处理 $nx(i,j)$ 表示原串中第 $i$ 个字符往后跳,跳到的第一个字符为 $j$ 的位置.跳不到设为 $n+1$ .那么就可以借助 $nx$ 来完成 $f$ 的转移. 那么计算完成后,只需要判断 $f(len_1,len_2,len_3)\leq n$ 是否成立.成立则为 $YES$ ,否则为 $NO$ . 并不能 $O(q\cdot 250^3)$ 暴力 $dp$ .注意每次加一个字符时(假定加在第一个串上),前面的 $dp$ 值不会被影响,只需计算 $f(len_1+1,j,k)$ 这 $250^2$ 个状态.每次删字符时直接让 $len$ 减 $1$ 就可以了.下次会覆盖掉多余的值. 时间复杂度 $O(q\cdot 250^2)$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10,L=251;const int Siz=26;char buf[MAXN];int n,Q,nx[MAXN][Siz];int minpos[Siz];int f[L][L][L];int len[4];int s[4][L];int main()&#123; n=read(); Q=read(); scanf("%s\n",buf+1); for(int i=0;i&lt;Siz;++i) minpos[i]=n+1; buf[0]='a'; for(int i=n+1;i&gt;=0;--i) &#123; memcpy(nx[i],minpos,sizeof minpos); minpos[buf[i]-'a']=i; &#125; f[0][0][0]=0; while(Q--) &#123; char tp[2],newchar[2]; int id; scanf("%s%d",tp,&amp;id); if(tp[0]=='+') &#123; scanf("%s",&amp;newchar); s[id][++len[id]]=newchar[0]-'a'; if(id==1) &#123; for(int i=len[1];i&lt;=len[1];++i) for(int j=0;j&lt;=len[2];++j) for(int k=0;k&lt;=len[3];++k) &#123; int res=n+1; if(i) res=min(res,nx[f[i-1][j][k]][s[1][i]]); if(j) res=min(res,nx[f[i][j-1][k]][s[2][j]]); if(k) res=min(res,nx[f[i][j][k-1]][s[3][k]]); f[i][j][k]=res; &#125; &#125; else if(id==2) &#123; for(int i=0;i&lt;=len[1];++i) for(int j=len[2];j&lt;=len[2];++j) for(int k=0;k&lt;=len[3];++k) &#123; int res=n+1; if(i) res=min(res,nx[f[i-1][j][k]][s[1][i]]); if(j) res=min(res,nx[f[i][j-1][k]][s[2][j]]); if(k) res=min(res,nx[f[i][j][k-1]][s[3][k]]); f[i][j][k]=res; &#125; &#125; else &#123; for(int i=0;i&lt;=len[1];++i) for(int j=0;j&lt;=len[2];++j) for(int k=len[3];k&lt;=len[3];++k) &#123; int res=n+1; if(i) res=min(res,nx[f[i-1][j][k]][s[1][i]]); if(j) res=min(res,nx[f[i][j-1][k]][s[2][j]]); if(k) res=min(res,nx[f[i][j][k-1]][s[3][k]]); f[i][j][k]=res; &#125; &#125; &#125; else --len[id]; puts(f[len[1]][len[2]][len[3]]&lt;=n?"YES":"NO"); &#125; return 0;&#125; CF1149C Tree Generator™ 给的括号序列就是一个欧拉序(进出都记录). 容易处理出每个点的 $dep​$ ,遇见 $(​$ 就 $+1​$ ,否则 $-1​$ . 考虑两个点的距离为 $dep_u+dep_v-2dep_{lca}​$ ,在欧拉序中.和用 $RMQ​$ 做 $LCA​$ 一样,两个点的 $lca​$ 一定位于这两个点的中间,且深度最小. 那么找直径就转化为找三个位置 $u\leq lca\leq v$ ,使得 $dep_u+dep_v-2dep_{lca}$ 最大. 每次修改交换两个括号,中间那一段 $dep$ 都会 $+2/-2$ .于是用线段树维护每个位置的 $dep$ , $dep_l-2dep_i$ , $dep_r-2dep_i$ 的 $max$ 即可. 注意合并节点,标记的细节. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,Q;int dep[MAXN];struct SegTree&#123; struct node &#123; int res;//dep[l]+dep[r]-2dep[i] int tag; int mxdep,negdep;//dep[i],-2dep[i] int ldep,rdep;//dep[l]-2dep[i],dep[r]-2dep[i] &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.mxdep=max(lson.mxdep,rson.mxdep); root.negdep=max(lson.negdep,rson.negdep); root.ldep=max(lson.ldep,rson.ldep); root.ldep=max(root.ldep,lson.mxdep+rson.negdep); root.rdep=max(lson.rdep,rson.rdep); root.rdep=max(root.rdep,lson.negdep+rson.mxdep); root.res=max(lson.res,rson.res); root.res=max(root.res,lson.mxdep+rson.rdep); root.res=max(root.res,lson.ldep+rson.mxdep); &#125; void BuildTree(int o,int l,int r) &#123; root.tag=0; if(l==r) &#123; root.mxdep=dep[l]; root.negdep=-2*dep[l]; root.rdep=root.ldep=-dep[l]; root.res=0; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; void modifiy(int o,int c) &#123; root.tag+=c; root.mxdep+=c; root.negdep-=2*c; root.ldep-=c; root.rdep-=c; &#125; void pushdown(int o) &#123; if(root.tag) &#123; modifiy(o&lt;&lt;1,root.tag); modifiy(o&lt;&lt;1|1,root.tag); root.tag=0; &#125; &#125; void update(int o,int l,int r,int L,int R,int c) &#123; if(L&gt;r || l&gt;R || L&gt;R) return; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c); return; &#125; pushdown(o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) update(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) update(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125;&#125;T;#define pr printf("%d\n",T.Tree[1].res);char buf[MAXN];int main()&#123; n=read(),Q=read(); scanf("%s",buf+1); for(int i=1;i&lt;=2*n-2;++i) &#123; dep[i]=dep[i-1]; if(buf[i]=='(') ++dep[i]; else --dep[i]; &#125; T.BuildTree(1,1,2*n-2); pr; while(Q--) &#123; int L=read(),R=read(); if(L&gt;R) swap(L,R); if(buf[L]=='(') T.update(1,1,2*n-2,L,R-1,-2); else T.update(1,1,2*n-2,L,R-1,2); pr; swap(buf[L],buf[R]); &#125; return 0;&#125; CF1149D Abandoning Roads 最小生成树 + 状压 $dp$. 用 $kruskal$ 做最小生成树的时候,会先考虑权值为 $a$ 的边,那么可以先预处理出由 $a$ 边连接出的联通块. 从 $1$ 到 $p$ 跑最短路,每条 $b$ 边会连接两个联通块,将联通块状压,就可以记录哪些联通块已经走过了. 注意到对一个点数 $\leq 3$ 的联通块,不可能进入它后再走出去,因为这样的长度至少为 $2b$ ,而它内部长度最长才 $2a$ .所以可以不记这些联通块.状态数目在 $O(2^{n/4}m)$ 级别,就可以直接做了. CF1149E Election Promises 博弈论. 结论: $SG_u=mex(SG_v),sum(x)=\oplus_{SG_i=x}h_i$ , $\oplus$ 表示异或和.先手能胜,当且仅当 $\exists x ,sum(x)\not=0​$ . 如果所有的 $sum$ 都为 $0$ ,那么先手随意操作一次,都会使得有 $sum$ 变为非 $0$ .然后后手再操作一次,所有 $sum$ 又可以被修改为 $0$ :找到最大的 $x$ , $sum(x)&gt;0$ 进行修改.]]></content>
      <tags>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>线段树</tag>
        <tag>博弈论</tag>
        <tag>codeforces</tag>
        <tag>状压dp</tag>
        <tag>dfs序</tag>
        <tag>最小生成树</tag>
        <tag>自动机dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2286 消耗战]]></title>
    <url>%2F2019%2F05%2F06%2Fbzoj-2286-%E6%B6%88%E8%80%97%E6%88%98%2F</url>
    <content type="text"><![CDATA[虚树 + 树形 $dp$ . 考虑最暴力的树形 $dp$.设 $f_u$ 表示使得子树 $u$ 中所有关键点都与 $1$ 断开的最小代价. 那么对于 $u$ 的所有儿子 $v$ ,如果 $v$ 是关键点,代价为 $val(u,v)$ ,否则为 $min(val(u,v),f_v)$ . $f_u$ 就是所有儿子的代价之和,最终答案即为 $f_1$ . 这样暴力 $dp$ 是 $O(nm)$ 的,无法通过.但注意到关键点数目总和 $\sum k\leq 5\times 10^5$ ,所以可以使用 虚树 进行处理. 虚树 就是新建出的一颗树,只保留原树中所有关键节点与它们所有的 $LCA$ ,而原图中其它的链被简化成边或点. 这样一颗 虚树 的节点数目不会超过 $2k-1$.因为 $k$ 个关键节点所有不同的 $LCA$ 最多 $k-1$ 个. 构造时,先在原树中预处理 $dfs$ 序,子树大小 $siz$ ,并预处理倍增数组,以快速查找 $LCA$ 以及一条链上最小边. 然后将所有关键点加入一个数组中,按照 $dfs$ 序排序,再将相邻两个点的 $LCA$ 也放入数组中,再放入 $1$ . 再按照 $dfs$ 序排序,去重,就得到了我们在虚树上的 $dfs$ 遍历顺序.按照这个顺序进行 $dfs$ ,判断下个点是继续$dfs$ 还是回溯回来,只需用预处理的 $dfs$ 序和 $siz$ 判断下个点是否在当前的子树中. 在虚树上 $dfs$ 的同时像原来一样进行树形 $dp$ .不过虚树中两个点的边在原图中实际是一条链.在虚树中直接割断两个点的花费是连接这两个点的链上所有边的最小边权.用预处理的倍增数组进行查询即可. 时间复杂度 $O(\sum klogk)$ . 开始写的时候预处理倍增数组居然没有按拓扑序,而是直接按照节点编号顺序处理.这样居然还能有 $90pts$ .出计数不好吗,非要出最优化让人水过去. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=250010;int ecnt,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN&lt;&lt;1];inline void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; val[ecnt]=w; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int n,m,k;int tid=0,marked[MAXN];int fa[MAXN][20],minc[MAXN][20];void init()&#123; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=19;++j) &#123; fa[i][j]=fa[fa[i][j-1]][j-1]; minc[i][j]=min(minc[i][j-1],minc[fa[i][j-1]][j-1]); &#125;&#125;int dfsidx=0,dfn[MAXN],siz[MAXN],dep[MAXN];void dfs(int u,int f)&#123; siz[u]=1; dep[u]=dep[f]+1; dfn[u]=++dfsidx; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==f) continue; fa[v][0]=u; minc[v][0]=val[i]; dfs(v,u); siz[u]+=siz[v]; &#125;&#125;int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=19;i&gt;=0;--i) if(dep[x]-(1&lt;&lt;i)&gt;=dep[y]) x=fa[x][i]; if(x==y) return x; for(int i=19;i&gt;=0;--i) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;int minval(int x,int lca)&#123; int res=1e9; for(int i=19;i&gt;=0;--i) if(dep[x]-(1&lt;&lt;i)&gt;=dep[lca]) &#123; res=min(res,minc[x][i]); x=fa[x][i]; &#125; return res;&#125;bool cmp(int x,int y)&#123; return dfn[x]&lt;dfn[y];&#125;int q[MAXN&lt;&lt;1],tot;int id;ll f[MAXN];void dfs_vtree()&#123; int u=q[id]; f[u]=1e18; ll res=0; while(1) &#123; if(id==tot) break; if(dfn[q[id+1]]&lt;=dfn[u]+siz[u]-1) &#123; int v=q[++id]; if(marked[v]==tid) &#123; dfs_vtree(); f[v]=minval(v,u); &#125; else &#123; dfs_vtree(); f[v]=min(f[v],1LL*minval(v,u)); &#125; res+=f[v]; &#125; else break; &#125; if(res) f[u]=min(f[u],res);&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; dfs(1,0); init(); m=read(); while(m--) &#123; tot=0; k=read(); ++tid; for(int i=1;i&lt;=k;++i) &#123; int x=read(); marked[x]=tid; q[++tot]=x; &#125; sort(q+1,q+1+tot,cmp); for(int i=1;i&lt;k;++i) q[++tot]=LCA(q[i],q[i+1]); q[++tot]=1; sort(q+1,q+1+tot,cmp); tot=unique(q+1,q+1+tot)-q-1; id=1; dfs_vtree(); printf("%lld\n",f[1]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树形dp</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4556 字符串]]></title>
    <url>%2F2019%2F05%2F04%2Fbzoj-4556-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[$SAM$ + 倍增 + 线段树合并. 这里有两个小性质需要注意. 答案是可二分的.这个应该比较显然. 两个子串的最长公共后缀就是它们在 $SAM$ 上状态节点 $LCA$ 的 $maxlen$ .想象两个串都从前往后缩短,当两者缩到同一个串,即公共后缀时,节点也跳到了它们的 $LCA$ .长度即为 $maxlen$ . 于是把整个串翻转,询问前缀相关问题就变成了询问后缀相关问题.询问时,可以二分答案 $x$ ,转化为判定问题. 从 $d$ 对应的位置用倍增往上跳,找到 $maxlen\geq x$ 的 $dep$ 最小的祖先(其 $right$ 集合最大,为最优),判断它的 $right$ 集合中是否出现了 $[a+x-1,b]$ 中的某个位置. 如果出现了,那么从这个位置往前的 $x$ 个字符就是要找的子串,否则就找不到. 可以看出 $c$ 的作用就是限制了二分答案 $x$ 的范围,显然不能超过 $d-c+1$ 与 $b-a+1​$ . 一个点的 $right$ 集合是它所有儿子节点 $right$ 集合的并集.所以可以用线段树合并来维护. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int Siz=26,MAXN=2e5+10;int lst=1,idx=1;int n,m;int siz[MAXN],pos[MAXN],leafright[MAXN];int ch[MAXN][Siz],fa[MAXN];int len[MAXN];void Extend(int c,int id)&#123; int p=lst,np=++idx; lst=np; pos[id]=np; leafright[np]=id; siz[np]=1; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125;&#125;int ecnt=0,head[MAXN],to[MAXN],nx[MAXN];inline void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int tot=0;struct node&#123; int sum,ls,rs;&#125;Tree[MAXN*30];#define root Tree[o]#define lson Tree[root.ls]#define rson Tree[root.rs]void update(int &amp;o,int l,int r,int pos)&#123; o=++tot; ++root.sum; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(root.ls,l,mid,pos); else update(root.rs,mid+1,r,pos);&#125;void pushup(int o)&#123; root.sum=lson.sum+rson.sum;&#125;int merge(int x,int y)&#123; if(!x || !y) return x+y; int o=++tot; root.ls=merge(Tree[x].ls,Tree[y].ls); root.rs=merge(Tree[x].rs,Tree[y].rs); pushup(o); return o;&#125;int query(int o,int l,int r,int L,int R)&#123; if(L&gt;r || l&gt;R) return 0; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; int mid=(l+r)&gt;&gt;1; int res=0; if(L&lt;=mid) res+=query(root.ls,l,mid,L,R); if(R&gt;mid) res+=query(root.rs,mid+1,r,L,R); return res;&#125;int f[MAXN][18];int rt[MAXN];void mergeright(int u)&#123; f[u][0]=fa[u]; for(int i=1;i&lt;=17;++i) f[u][i]=f[f[u][i-1]][i-1]; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; mergeright(v); rt[u]=merge(rt[u],rt[v]); &#125;&#125;bool check(int x,int L,int R,int u)&#123; if(!x) return true; if(L&gt;R) return false; for(int i=17;i&gt;=0;--i) if(len[f[u][i]]&gt;=x) u=f[u][i]; return query(rt[u],1,n,L,R)&gt;0;&#125;char buf[MAXN];int main()&#123; n=read(),m=read(); scanf("%s",buf+1); for(int i=1;i&lt;(n+1-i);++i) swap(buf[i],buf[n+1-i]); for(int i=1;i&lt;=n;++i) Extend(buf[i]-'a',i); for(int i=1;i&lt;=idx;++i) addedge(fa[i],i); for(int i=1;i&lt;=idx;++i) if(leafright[i]) update(rt[i],1,n,leafright[i]); mergeright(1); while(m--) &#123; int a=read(),b=read(),c=read(),d=read(); swap(a,b),swap(c,d); a=n+1-a,b=n+1-b,c=n+1-c,d=n+1-d; int L=0,R=min(d-c+1,b-a+1); int res=0; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid,a+mid-1,b,pos[d])) res=max(res,mid),L=mid+1; else R=mid-1; &#125; printf("%d\n",res); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>倍增</tag>
        <tag>SAM</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2555 substring]]></title>
    <url>%2F2019%2F05%2F04%2Fbzoj-2555-substring%2F</url>
    <content type="text"><![CDATA[$SAM+LCT$ . 如果没有修改,就直接建出 $SAM$ ,询问时从根出发走到对应状态,该状态的 $siz$ 即为答案. 现在要支持修改,沿用上面思路,只不过要动态维护 $parent$ 树的形态,需要加边,删边. 套一个 $LCT$ 进行维护就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int Siz=26,MAXN=2e6+10;int lst=1,idx=1;int siz[MAXN],tag[MAXN];int stk[MAXN],tp=0;struct Link_Cut_Tree&#123; struct node &#123; int ch[2],fa; node()&#123;ch[0]=ch[1]=fa=0;&#125; &#125;Tree[MAXN];#define root Tree[x] bool isroot(int x) &#123; return Tree[root.fa].ch[0]!=x &amp;&amp; Tree[root.fa].ch[1]!=x; &#125; void modifiy(int x,int c) &#123; if(x) &#123; siz[x]+=c; tag[x]+=c; &#125; &#125; void pushdown(int x) &#123; if(tag[x]) &#123; modifiy(root.ch[0],tag[x]); modifiy(root.ch[1],tag[x]); tag[x]=0; &#125; &#125; void rotate(int x) &#123; int y=Tree[x].fa; int z=Tree[y].fa; if(!isroot(y)) Tree[z].ch[Tree[z].ch[1]==y]=x; Tree[x].fa=z; int k=(x==Tree[y].ch[1]); Tree[y].ch[k]=Tree[x].ch[k^1]; Tree[Tree[x].ch[k^1]].fa=y; Tree[x].ch[k^1]=y; Tree[y].fa=x; &#125; void splay(int x) &#123; stk[++tp]=x; for(int pos=x;!isroot(pos);pos=Tree[pos].fa) stk[++tp]=Tree[pos].fa; while(tp) pushdown(stk[tp--]); while(!isroot(x)) &#123; int y=Tree[x].fa; int z=Tree[y].fa; if(!isroot(y)) (Tree[z].ch[0]==y)^(Tree[y].ch[0]==x)?rotate(x):rotate(y); rotate(x); &#125; &#125; void Access(int x) &#123; for(int y=0;x;y=x,x=Tree[x].fa) &#123; splay(x); Tree[x].ch[1]=y; &#125; &#125; void link(int x,int y) &#123; Tree[x].fa=y; Access(y); splay(y); modifiy(y,siz[x]); &#125; void cut(int x) &#123; Access(x); splay(x); modifiy(Tree[x].ch[0],-siz[x]); Tree[x].ch[0]=Tree[Tree[x].ch[0]].fa=0; &#125;&#125;LCT;struct SuffixAutoMation&#123; int ch[MAXN][Siz],fa[MAXN]; int len[MAXN]; void Extend(int c) &#123; int p=lst,np=++idx; lst=np; siz[np]=1; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) &#123; fa[np]=1; LCT.link(np,1); &#125; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) &#123; fa[np]=q; LCT.link(np,q); &#125; else &#123; int nq=++idx; len[nq]=len[p]+1; LCT.link(nq,fa[q]); LCT.cut(q); LCT.link(q,nq); LCT.link(np,nq); fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125;&#125;SAM;int L;char buf[MAXN];void getinfo(int mask)&#123; scanf("%s",buf); L=strlen(buf); for(int i=0; i&lt;L; ++i) &#123; mask=(mask*131+i) % L; swap(buf[i],buf[mask]); &#125;&#125;int mask=0;int main()&#123; int Q=read(); scanf("%s",buf); L=strlen(buf); for(int i=0;i&lt;L;++i) SAM.Extend(buf[i]-'A'); while(Q--) &#123; scanf("%s",buf); if(buf[0]=='A') //Add &#123; getinfo(mask); for(int i=0;i&lt;L;++i) SAM.Extend(buf[i]-'A'); &#125; else //Query &#123; getinfo(mask); int p=1; for(int i=0;i&lt;L;++i) &#123; p=SAM.ch[p][buf[i]-'A']; &#125; if(!p) puts("0"); else &#123; LCT.splay(p); printf("%d\n",siz[p]); mask^=siz[p]; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>LCT</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190504]]></title>
    <url>%2F2019%2F05%2F04%2Ftest20190504%2F</url>
    <content type="text"><![CDATA[据说 是 $noip$ 难度. 题面 $find$ 比较简单.按照 $x$ 坐标排序后,就是以 $y$ 坐标为关键字做一个 $LIS​$ . $O(nlogn)​$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;inline int read()&#123; int x=0,k=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') &#123; if(ch=='-') k=-1; ch=getchar(); &#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=x*10+ch-'0'; ch=getchar(); &#125; return k*x;&#125;const int MAXN=1e6+10;int n=0,my,y[MAXN],Y[MAXN];pair&lt;int,int&gt; p[MAXN];int bit[MAXN];#define lowbit(x) x&amp;(-x)inline void add(int x,int c)&#123; for(; x&lt;=my; x+=lowbit(x)) bit[x]=max(bit[x],c);&#125;inline int sum(int x)&#123; int s=0; for(; x; x-=lowbit(x)) s=max(s,bit[x]); return s;&#125;int main()&#123; freopen("find.in","r",stdin); freopen("find.out","w",stdout); int N=read(); for(int i=1; i&lt;=N; ++i) &#123; int a=read(),b=read(); if(a&lt;0 || b&lt;0) continue; ++n; p[n].first=a; Y[n]=y[n]=b; &#125; sort(Y+1,Y+1+n); my=unique(Y+1,Y+1+n)-Y-1; for(int i=1; i&lt;=n; ++i) p[i].second=lower_bound(Y+1,Y+1+my,y[i])-Y; sort(p+1,p+1+n); int ans=0; for(int i=1; i&lt;=n; ++i) &#123; int ky=p[i].second; int mx=sum(ky); ans=max(ans,mx+1); add(ky,mx+1); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; $walk$ 是个套路题. 标算套路:因为询问给出的 $v$ 最大是 $10^{18}$ ,所以走不为 $1$ 的边,最多走 $60$ 次就会变成 $0$ . 于是只需要用并查集把边权为 $1$ 连接的两个点并在一起,然后跳的时候暴力跳,跳成 $0$ 或者到终点就退出. 这样最多跳 $60$ 次,而且大多数时候跳不满,所以可以过. 我的做法相当假.注意到这个操作是可合并的,直接树剖 + 线段树维护区间边权乘积. 但是区间乘积可能会爆掉 $long\ long$ . 于是每次 $pushup$ 的时候都让乘积与 $0$ 取 $max$ .这样一段爆掉的区间乘积(大概率)是 $0$ .跳的时候遇到了就直接输出 $0$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll x=0,k=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') &#123; if(ch=='-') k=-1; ch=getchar(); &#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=x*10+ch-'0'; ch=getchar(); &#125; return k*x;&#125;const int MAXN=2e5+10;int n,Q;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],fa[MAXN];int dep[MAXN];inline void addedge(int u,int v,ll w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;ll wp[MAXN];int dfn[MAXN],dfnidx=0,rnk[MAXN],siz[MAXN],mxson[MAXN],top[MAXN];void dfs1(int u,int f)&#123; fa[u]=f; siz[u]=1; dep[u]=dep[f]+1; for(int i=head[u]; i; i=nx[i]) &#123; int v=to[i]; if(v==f) continue; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; dfn[u]=++dfnidx; rnk[dfnidx]=u; top[u]=tp; if(mxson[u]) dfs2(mxson[u],tp); for(int i=head[u]; i; i=nx[i]) &#123; int v=to[i]; if(v!=mxson[u] &amp;&amp; v!=fa[u]) dfs2(v,v); &#125;&#125;ll prod[MAXN&lt;&lt;2];#define root prod[o]#define lson prod[o&lt;&lt;1]#define rson prod[o&lt;&lt;1|1]void pushup(int o)&#123; root=lson*rson; root=max(root,0LL);&#125;void bd(int o,int l,int r)&#123; if(l==r) &#123; root=wp[rnk[l]]; return; &#125; int mid=(l+r)&gt;&gt;1; bd(o&lt;&lt;1,l,mid); bd(o&lt;&lt;1|1,mid+1,r); pushup(o);&#125;void update(int o,int l,int r,int pos,ll c)&#123; if(l==r) &#123; root=c; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(o&lt;&lt;1,l,mid,pos,c); else update(o&lt;&lt;1|1,mid+1,r,pos,c); pushup(o);&#125;ll query(int o,int l,int r,int L,int R)&#123; ll res=1; if(l&gt;R || L&gt;r) return 1; if(L&lt;=l &amp;&amp; r&lt;=R) return max(0LL,root); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) &#123; res*=query(o&lt;&lt;1,l,mid,L,R); res=max(res,0LL); &#125; if(R&gt;mid) &#123; res*=query(o&lt;&lt;1|1,mid+1,r,L,R); res=max(res,0LL); &#125; return res;&#125;void solve()&#123; int idx=n; for(int i=1; i&lt;n; ++i) &#123; int u=read(),v=read(); ll w=read(); ++idx; addedge(u,idx,0); addedge(idx,u,0); addedge(idx,v,0); addedge(v,idx,0); wp[idx]=w; &#125; for(int i=1; i&lt;=n; ++i) wp[i]=1; dfs1(1,0); dfs2(1,1); bd(1,1,idx); while(Q--) &#123; int tp=read(); if(tp==1) &#123; int x=read(),y=read(); ll v=read(); while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); ll p=query(1,1,idx,dfn[top[x]],dfn[x]); if(p&lt;=0) &#123; puts("0"); continue; &#125; v/=p; x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y]) swap(x,y); ll p=query(1,1,idx,dfn[y],dfn[x]); if(p&lt;=0) &#123; puts("0"); continue; &#125; v/=p; printf("%lld\n",v); &#125; else &#123; int p=read(); ll c=read(); update(1,1,idx,dfn[p+n],c); &#125; &#125;&#125;int main()&#123; freopen("walk.in","r",stdin); freopen("walk.out","w",stdout); n=read(); Q=read(); solve(); return 0;&#125; $sunset$ 想出了正确做法,但今天是按照 $5$ 个小时的节奏在打的,实际是 $3.5h$ ,只剩了 $20min$ ,就没写了. 显然每个联通块可以分开做.对于一个联通块,做一颗 $dfs​$ 树,因为是无向图,所以除了树边之外就只有返祖边. 返祖边会形成一个环,如果这个环的大小为偶(通过 $dep​$ 之差判断),显然没有作用.若为奇,就把环上的边都打上标记. 询问时,若 $dep_x,dep_y$ 奇偶性不同,直接走树边长度就是奇数.否则如果两者路径上有被标记的边,走一个奇环再出来,长度也是奇数. 如果两种情况都不满足,就无法找到长度为奇数的路径.]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>tarjan</tag>
        <tag>树链剖分</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3926 诸神眷顾的幻想乡]]></title>
    <url>%2F2019%2F05%2F03%2Fbzoj-3926-%E8%AF%B8%E7%A5%9E%E7%9C%B7%E9%A1%BE%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%2F</url>
    <content type="text"><![CDATA[广义 $SAM$ . 广义 $SAM$ ,就是在 $Trie$ 树上建 $SAM$ .注意到树上的每个串都可以看成以某个叶子节点为根的 $Trie$ 树上的一条路径. 而叶子节点数 $\leq 20$ ,所以可以以每个叶子节点为根建 $Trie$ 树,建的时候需要注意插入一个点时,将 $lst$ 置为其父亲在 $SAM​$ 上对应的节点. 注意判重,即处理插入一个字符时, $lst$ 对应的转移边已经有点的情况.建好后就是问有多少个不同子串,每个点的贡献都是 $Max-Min+1$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e7+10;const int Siz=10;int n;struct SuffixAutoMation&#123; int idx,lst; SuffixAutoMation()&#123;lst=idx=1;&#125; int fa[MAXN],ch[MAXN][Siz]; int len[MAXN]; int Extend(int p,int c) &#123; if(ch[p][c]) &#123; int q=ch[p][c]; if(len[q]==len[p]+1) lst=q; else &#123; int nq=++idx; lst=nq; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; else &#123; int np=++idx; lst=np; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125; return lst; &#125; void solve() &#123; ll ans=0; for(int i=2;i&lt;=idx;++i) ans+=len[i]-len[fa[i]]; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;SAM;int ecnt=0,head[MAXN],to[MAXN],nx[MAXN],deg[MAXN];void addedge(int u,int v)&#123; ++deg[u]; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int col[MAXN];void dfs(int u,int fa,int lst)&#123; int newlst=SAM.Extend(lst,col[u]); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa) continue; dfs(v,u,newlst); &#125;&#125;int main()&#123; n=read(); int c=read(); for(int i=1;i&lt;=n;++i) col[i]=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; for(int i=1;i&lt;=n;++i) if(deg[i]==1) dfs(i,0,1); SAM.solve(); return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
        <tag>广义SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TJOI2019 选做]]></title>
    <url>%2F2019%2F05%2F02%2FTJOI2019-%E9%80%89%E5%81%9A%2F</url>
    <content type="text"><![CDATA[向 $CQOI\ 2018$ 致敬? 甲苯先生的字符串 矩阵快速幂. 板子题.处理相邻两个字符时改一下转移矩阵里的系数就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=26;struct matrix&#123; int v[MAXN][MAXN]; matrix()&#123;memset(v,0,sizeof v);&#125; matrix operator * (const matrix &amp;rhs) const &#123; matrix res; for(int i=0;i&lt;MAXN;++i) for(int j=0;j&lt;MAXN;++j) for(int k=0;k&lt;MAXN;++k) res.v[i][j]=add(res.v[i][j],mul(v[i][k],rhs.v[k][j])); return res; &#125;&#125;;matrix fpow(matrix a,ll b)&#123; matrix res; for(int i=0;i&lt;MAXN;++i) res.v[i][i]=1; while(b) &#123; if(b&amp;(1LL)) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;ll n;char buf[100005];int main()&#123; scanf("%lld%s",&amp;n,buf); matrix st,trans; for(int i=0;i&lt;MAXN;++i) st.v[i][0]=1; for(int i=0;i&lt;MAXN;++i) for(int j=0;j&lt;MAXN;++j) trans.v[i][j]=1; int len=strlen(buf); for(int i=1;i&lt;len;++i) &#123; int p=buf[i-1]-'a'; int q=buf[i]-'a'; trans.v[q][p]=0; &#125; st=fpow(trans,n-1)*st; int ans=0; for(int i=0;i&lt;MAXN;++i) ans=add(ans,st.v[i][0]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 甲苯先生的滚榜 平衡树. 又是板子题.随便上个啥平衡树写一下插入,删除,查询排名. 唱、跳、rap 和篮球 顶风作案,律师函警告. 容斥原理+ $dp$ 计数. 为了方便,称题目中所说的一组同学为 位置 $k$ 在讨论蔡徐坤 ,要求出没有位置在讨论蔡徐坤的方案数. 显然可以容斥原理搞一搞,只需对每个 $i$ 求出钦定 $i$ 个位置在讨论蔡徐坤,其它不涉及的位置乱选的方案数. 其它位置乱选方案数就是有重复元素的排列数,但每个元素使用次数有限制.可以构造多项式 $(x+y+z+w)^{tot}$ , $tot=n-4i$ ,将次数符合要求的对应系数求和. 二项式定理套两次,多项式展开为$$\begin{aligned}(x+y+z+w)^{tot}&amp;=\sum C_{tot}^j (x+y)^j(z+w)^{tot-j}\\&amp;=\sum C_{tot}^j(\sum C_j^p x^p y^{j-p})(\sum C_{tot-j}^q z^q w^{tot-j-q})\end{aligned}$$ 预处理组合数前缀和,把 $x,y,z,w​$ 系数都符合限制的那一段取出来计算即可. 考虑怎么求钦定 $i​$ 个位置在讨论蔡徐坤的方案数. 抽象一下就是选出 $i$ 个位置,相邻两个位置之差至少为 $4$ .需要求出每个 $i$ 的方案数. 可以设计一个三维的 $dp​$ ,状态需要记录考虑的数目,选的数目,最后一个选的位置. 注意到最后一个选的位置其实只有四种情况有区别,设 $f(j,i,0/1/2/3)$ 表示已经考虑了前 $j$ 个位置,选了 $i$ 个位置,最后选的位置分别是 $j,j-1,j-2,\leq j-3$ 时的方案数.将 $f(n-3,i,0/1/2/3)$ 求出即可. 时间复杂度 $O(n^2)​$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;void upd(int x,int &amp;y)&#123; y=add(x,y);&#125;const int MAXN=1e3+10;int n,mx;int C[MAXN][MAXN],sumc[MAXN][MAXN];int f[MAXN][MAXN][4];void init()&#123; for(int i=0;i&lt;=n;++i) C[i][0]=1; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=i;++j) C[i][j]=add(C[i-1][j],C[i-1][j-1]); for(int i=0;i&lt;=n;++i) &#123; sumc[i][0]=1; for(int j=1;j&lt;=i;++j) sumc[i][j]=add(sumc[i][j-1],C[i][j]); &#125; f[0][0][3]=1; for(int i=0;i&lt;n;++i) for(int j=0;j&lt;=mx;++j) for(int k=0;k&lt;4;++k) &#123; if(!f[i][j][k]) continue; upd(f[i][j][k],f[i+1][j][k==3?k:k+1]); if(k==3) upd(f[i][j][k],f[i+1][j+1][0]); &#125;&#125;int lim[4];int main()&#123; n=read(); for(int i=0;i&lt;4;++i) lim[i]=read(); sort(lim,lim+4); mx=min(lim[0],n/4);//最多mx个位置讨论蔡徐坤 init(); int ans=0,sgn=1; for(int i=0;i&lt;=mx;++i) &#123; int res=0,tmp=0; if(n&lt;4) tmp=1; else &#123; for(int k=0;k&lt;4;++k) tmp=add(tmp,f[n-3][i][k]); &#125; for(int k=0;k&lt;4;++k) lim[k]-=i; int tot=n-i*4; for(int j=0;j&lt;=tot;++j) &#123; int lp=max(0,j-lim[1]); int rp=min(lim[0],j); int lk=max(0,tot-j-lim[3]); int rk=min(lim[2],tot-j); if(lp&gt;rp || lk&gt;rk) continue; int t1=lp?sumc[j][rp]-sumc[j][lp-1]:sumc[j][rp]; int t2=lk?sumc[tot-j][rk]-sumc[tot-j][lk-1]:sumc[tot-j][rk]; res=add(res,mul(C[tot][j],mul(t1,t2))); &#125; res=mul(res,tmp); ans=add(ans,res*sgn); for(int k=0;k&lt;4;++k) lim[k]+=i; sgn*=-1; &#125; cout&lt;&lt;add(ans,P)&lt;&lt;endl; return 0;&#125; 甲苯先生与线段树 位运算,数位 $dp$ . 大概是个原题. 甲苯先生和大中锋的字符串 $SAM$ + 差分. 建出 $SAM$ 后在 $parent$ 树上递推 $right$ 集合的大小,若其为 $k$ ,则对 $[Minlen,Maxlen]$ 内的计数器都加 $1$ . 最后询问一次计数器最大值.可以修改差分,最后求前缀和,就可以做到 $O(n)$ 了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int Siz=26;const int MAXN=2e5+10;int n,k;int ans,mxt;int dif[MAXN];struct SuffixAutoMation&#123; int lst,idx; int fa[MAXN],siz[MAXN]; int ch[MAXN][Siz],len[MAXN]; int A[MAXN],t[MAXN]; SuffixAutoMation()&#123;lst=idx=1;&#125; void Extend(int c) &#123; int p=lst,np=++idx; lst=np; siz[np]=1; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; fa[nq]=fa[q]; fa[q]=fa[np]=nq; for(int i=0;i&lt;Siz;++i) ch[nq][i]=ch[q][i]; len[nq]=len[p]+1; siz[nq]=0; while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125; void topsort() &#123; for(int i=1;i&lt;=idx;++i) ++t[len[i]]; for(int i=1;i&lt;=n;++i) t[i]+=t[i-1]; for(int i=1;i&lt;=idx;++i) A[t[len[i]]--]=i; &#125; void solve() &#123; topsort(); for(int i=idx;i&gt;=1;--i) &#123; int u=A[i]; siz[fa[u]]+=siz[u]; if(siz[u]==k &amp;&amp; u!=1) &#123; int mx=len[u],mi=len[fa[u]]+1; ++dif[mi]; --dif[mx+1]; &#125; &#125; int sum=0; for(int i=1;i&lt;=n;++i) &#123; sum+=dif[i]; if(sum&gt;=mxt) mxt=sum,ans=i; &#125; printf("%d\n",mxt==0?-1:ans); &#125; void reset() &#123; for(int i=1;i&lt;=n+1;++i) dif[i]=0; for(int i=0;i&lt;=n;++i) t[i]=0; for(int i=1;i&lt;=idx;++i) memset(ch[i],0,sizeof ch[i]); mxt=0; lst=idx=1; &#125;&#125;SAM;char buf[MAXN];int main()&#123; int T=read(); while(T--) &#123; scanf("%s",buf); n=strlen(buf); scanf("%d",&amp;k); cout&lt;&lt;k&lt;&lt;endl; for(int i=0;i&lt;n;++i) SAM.Extend(buf[i]-'a'); SAM.solve(); SAM.reset(); &#125; return 0;&#125; 读入格式很诡异.用快读读 $k​$ 会炸两个点,原因不明. 大中锋的游乐场 最短路. 记 $dis[i][j]$ 表示从起点出发到节点 $i$ ,经过的 $1$ 减去经过的 $2$ 的数目为 $j$ 时的最短路长度. 用 $Dijkstra$ 进行转移即可.]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>平衡树</tag>
        <tag>矩阵优化</tag>
        <tag>容斥原理</tag>
        <tag>最短路</tag>
        <tag>差分</tag>
        <tag>位运算</tag>
        <tag>数位dp</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1137]]></title>
    <url>%2F2019%2F04%2F28%2FCF1137%2F</url>
    <content type="text"><![CDATA[$Div.1​$ CF1137A Skyscrapers 二分. 通过观察可以发现,对于每个询问,如果交点位置的值是 $x$ ,那么答案就是该列比 $x$ 小的数字种数与该行比 $x$ 小的数字种数的较大值+该列比 $x$ 小的数字种数与该行比 $x$ 小的数字种数的较大值 + $1$ . 离散化后二分一下就可以求出了. CF1137B Camp Schedule 贪心 + $kmp$ . 这个东西显然可以贪心,构造字符串时先放一个目标串,然后后面从最长 $border$ 那里接上去继续放,直到放完或者 $0/1$ 不够用. 用 $kmp$ 搞一下最长 $border$ 长度就好了. CF1137C Museums Tour $tarjan$ 缩点, $DAG$ 上 $dp$ . 注意到 $d$ 较小,所以首先可以把原来的每个点拆成 $d$ 个点,并连上合法的转移边.这样每个点有两个值 $(x,t)$ ,如果城市 $x$ 在当天有展览,这个点权值为 $1$ ,否则为 $0$ . 用 $tarjan$ 搞出每个强连通分量,缩成一个点,那么这个新点的权值就是这个 $SCC$ 内有展览的城市数目和. 注意到同一个城市拆出来的点 $(x,t)$ 与 $(x,t’)$ 路径可逆(连续走 $d-1$ 次),要么彼此都不可达,对应的两个 $SCC$ 不连通;要么彼此都可达.在同一个 $SCC$ 内. 所以在 $DAG$ 上 $dp$ 的话,两个 $SCC$ 内相同城市拆出来的点贡献不会叠加. 那么就可以直接从 $(1,0)$ 所在的强连通分量出发,在 $DAG$ 上找一条点权和最大的路径,可以 $dp$ 解决. 时间复杂度 $O(nd)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int N=1e5+10;const int MAXN=5e6+10;int n,m,d;vector&lt;int&gt; graph[MAXN];int eu[N],ev[N];int on_display[MAXN];char schedule[51];bool vis[N];int low[MAXN],dfn[MAXN],idx=0;int stk[MAXN],tp=0;int scc[MAXN],scc_cnt=0,sccval[MAXN];void tarjan(int u)&#123; stk[++tp]=u; dfn[u]=low[u]=++idx; for(auto v:graph[u]) &#123; if(!dfn[v]) &#123; tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(!scc[v]) low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u]) &#123; ++scc_cnt; while(tp) &#123; int v=stk[tp--]; scc[v]=scc_cnt; if(on_display[v]) &#123; sccval[scc_cnt]+=(int)(!vis[(v/d)+1]); vis[(v/d)+1]=true; &#125; if(v==u) break; &#125; &#125;&#125;int f[MAXN];int dfs(int u)&#123; if(f[u]!=-1) return f[u]; f[u]=0; for(auto v:graph[u]) f[u]=max(f[u],dfs(v)); f[u]+=sccval[u]; return f[u];&#125;int main()&#123; n=read(),m=read(),d=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); eu[i]=u,ev[i]=v; for(int ut=0;ut&lt;d;++ut) &#123; int vt=(ut+1)%d; graph[(u-1)*d+ut].push_back((v-1)*d+vt); &#125; &#125; for(int i=1;i&lt;=n;++i) &#123; scanf("%s",schedule); for(int j=0;j&lt;d;++j) on_display[(i-1)*d+j]=schedule[j]-'0'; &#125; tarjan((1-1)*d+0); for(int i=0;i&lt;n*d;++i) graph[i].clear(); for(int i=1;i&lt;=m;++i) &#123; int u=eu[i],v=ev[i]; for(int ut=0;ut&lt;d;++ut) &#123; int vt=(ut+1)%d; if(scc[(u-1)*d+ut] &amp;&amp; scc[(u-1)*d+ut]!=scc[(v-1)*d+vt]) graph[scc[(u-1)*d+ut]].push_back(scc[(v-1)*d+vt]); &#125; &#125; memset(f,-1,sizeof f); int ans=dfs(scc[(1-1)*d+0]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 然而需要卡空间.懒得卡了. CF1137D Cooperative Game 交互题. 这个模型可以考虑 $floyd$ 判圈算法.即 $A$ 的速度是 $2$ , $B$ 的速度是 $1$ ,同时从起点出发,当两人重新相遇时,快的那个人比慢的那个人多走了 $k$ 圈,即 $k\cdot c$ 步.操作时可以让 $A,B$ 一起走一步,再让 $A$ 走一步. 相遇时, $B$ 肯定还没有走完一圈.记此时 $B$ 在圈内走了 $x$ 步( $x&lt;c$ ),那么 $B$ 一共走了 $t+x$ 步, $A$ 一共走了 $t+x+kc$ 步.而 $A$ 走的步数恰好是 $B$ 的二倍. 所以可以得到 $kc=t+x$ .那么此时这两个人再一起往前走 $t$ 步就可以一起到达环的起点. 而剩余的人还在出发点,也是再往前走 $t$ 步到达环的起点.于是相遇后所有人一起走,到达同一个位置时就结束了. 分析一下总步数. $A,B$ 相遇前要进行 $2(t+x)$ 个操作,相遇后要进行 $t$ 个操作.总操作数不会大于 $3(t+c)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int groups;char buf[10][10];void getinfo()&#123; groups=read(); for(int i=0;i&lt;groups;++i) scanf("%s",buf[i]);&#125;void moveA()&#123; puts("next 0"); fflush(stdout);&#125;void moveAB()&#123; puts("next 0 1"); fflush(stdout);&#125;void moveAll()&#123; puts("next 0 1 2 3 4 5 6 7 8 9"); fflush(stdout);&#125;void Done()&#123; puts("done"); fflush(stdout);&#125;void stage_catch()&#123; while(1) &#123; moveAB(); getinfo(); moveA(); getinfo(); for(int i=0;i&lt;groups;++i) &#123; bool fa=false,fb=false; int len=strlen(buf[i]); for(int j=0;j&lt;len;++j) &#123; if(buf[i][j]=='0') fa=true; if(buf[i][j]=='1') fb=true; if(fa &amp;&amp; fb) return; &#125; &#125; &#125;&#125;void stage_meet()&#123; while(1) &#123; moveAll(); getinfo(); if(groups==1) &#123; Done(); return; &#125; &#125;&#125;int main()&#123; stage_catch(); stage_meet(); return 0;&#125; CF1137F Matches Are Not a Child’s Play 树剖 + 线段树. $compare$ 询问显然不用单独考虑,做两次 $when$ 询问就可以了. 初始的删点序列我们可以暴力搞出,只需要考虑每次 $up$ 操作带来的影响. 首先可以发现在一条路径上,只能从两边往中间删.,若 $up$ 当前权值最大的节点,就没有影响.否则,如果把 $u$ 改成了最大, $v$ 是原来最大的点, $v\not = u$ ,那么 $v-u$ 这条路径一定是最后被删除的,且删除顺序是严格按照 $v\rightarrow u$ 这条单向路径. 不在这条路径上的点被删除的相对顺序显然不会变.即, $up$ 操作一次之后,先删除不在这条路径上的点,顺序是操作前被删除的相对顺序,再沿路径 $v\rightarrow u$ 顺次删除. 实现可以通过染色,第 $i$ 次 $up$ 操作时把 $v_i\rightarrow u_i$ 这条路径上的点颜色染为 $i$ .那么询问 $when(x)$ 的答案就是颜色序号比 $col_x$ 小的节点数加上路径 $v_{colx} \rightarrow x$ 的节点数目.初始化可以看做进行了 $n$ 次 $up$ 操作. 染色用树剖+线段树实现,答案的两部分,前者用线段树维护每种颜色的节点数目,后者只需要记录每次的 $v_i$ ,利用树剖维护的 $dep,top$ 计算. 时间复杂度 $O(qlog^2n)$ .]]></content>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
        <tag>线段树</tag>
        <tag>DAG</tag>
        <tag>codeforces</tag>
        <tag>kmp</tag>
        <tag>tarjan</tag>
        <tag>非传统题</tag>
        <tag>floyd判圈</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNA分子计数]]></title>
    <url>%2F2019%2F04%2F28%2FDNA%E5%88%86%E5%AD%90%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[怎么生物课也遇到计数题啊… 今天生物课老师直接说: $n$ 个碱基对的 $DNA$ 种类数目就是 $4^n$ ,如果还要考虑对称的话太麻烦了… 于是就想了一下考虑对称同构怎么算.讨论前后翻转,两条链交换,中心对称都算一种的话的情况. 考虑 $Burnside$ 引理,显然可以构造出置换群 ${ \text{不变,左右翻转,上下翻转,中心对称}}$ ,中心对称其实就是左右翻转与上下翻转都操作了一次. 那么现在只需要计算出每种变换的不动点数目,求其平均数即可. 不变 的不动点数目显然是 $4^n$ . 左右翻转 的不动点数目显然是 $0$ .因为碱基互补,不可能两条链相同. 上下翻转 的不动点数目其实就是回文串的数目. $n$ 为偶数时为 $2^n$ , $n$ 为奇数时为 $2^{n+1}$ . 中心对称 的不动点数目,其实就是第 $i$ 个位置恰好与第 $n+i-1$ 个位置互补的数目. $n$ 为偶数时为 $2^n$ . $n$ 为奇数时,中间那个位置要求与自己互补,这是不可能的,数目为 $0$ . 对 $4$ 种变换的不动点数目求平均值,得到答案 $4^{n-1}+2^{n-1}$ . 其实 $DNA$ 分子好像只有中心对称这一种变换?因为左右翻转和上下翻转后其实裸露的那两个磷酸分子旁边的东西的是不一样的???但总之无论考虑哪些变换都可以用 $Burnside$ 像上面那样直接搞吧…]]></content>
      <tags>
        <tag>Burnside/Polya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2946 公共串]]></title>
    <url>%2F2019%2F04%2F28%2Fbzoj-2946-%E5%85%AC%E5%85%B1%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[$SAM$ 解决多个串的最长公共子串. $SAM$. 显然可以 二分 + $hash$ 做,时间复杂度 $O(logL\cdot L \cdot n)$. 考虑 $SAM$ 的做法.对第一个串建个 $SAM$ ,然后每读入一个新串就把它放在自动机上匹配. 匹配时维护每个状态能与每个串都匹配的最大长度.最后的答案就是所有状态能匹配长度的最大值. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int Siz=26,MAXN=4e3+10;char buf[MAXN];int L,n;struct SuffixAutoMation&#123; int idx,lst; int fa[MAXN],ch[MAXN][Siz]; int len[MAXN],siz[MAXN]; int A[MAXN],t[MAXN]; int mxl[MAXN],res[MAXN]; SuffixAutoMation()&#123;idx=lst=1;&#125; void Extend(int c) &#123; int p=lst,np=++idx; lst=np; res[np]=len[np]=len[p]+1; siz[np]=1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; res[nq]=len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125; void topsort() &#123; for(int i=1;i&lt;=idx;++i) ++t[len[i]]; for(int i=1;i&lt;=idx;++i) t[i]+=t[i-1]; for(int i=1;i&lt;=idx;++i) A[t[len[i]]--]=i; &#125; void solve() &#123; scanf("%s",buf+1); memset(mxl,0,sizeof mxl); L=strlen(buf+1); int p=1,tmp=0; for(int i=1;i&lt;=L;++i) &#123; int c=buf[i]-'a'; while(p &amp;&amp; ch[p][c]==0) p=fa[p]; if(p==0) p=1,tmp=0; else &#123; tmp=min(tmp,len[p])+1; p=ch[p][c]; &#125; mxl[p]=max(mxl[p],tmp); &#125; for(int i=idx;i&gt;=1;--i) &#123; int u=A[i]; mxl[fa[u]]=max(mxl[fa[u]],mxl[u]); &#125; for(int i=1;i&lt;=idx;++i) res[i]=min(res[i],mxl[i]); &#125; void pr() &#123; int ans=0; for(int i=1;i&lt;=idx;++i) ans=max(ans,res[i]); cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;SAM;int main()&#123; n=read(); scanf("%s",buf+1); L=strlen(buf+1); for(int i=1;i&lt;=L;++i) SAM.Extend(buf[i]-'a'); SAM.topsort(); for(int i=1;i&lt;n;++i) SAM.solve(); SAM.pr(); return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1396 识别子串]]></title>
    <url>%2F2019%2F04%2F27%2Fbzoj-1396-%E8%AF%86%E5%88%AB%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[$SAM$ + 线段树. 先建出 $parent$ 树,按照题意,我们只需要处理 $right$ 集合大小为 $1$ 的节点. 如下图,先算出这样的一个节点合法长度的 $max,min$ ( $min$ 可以用 $max(fa)+1$ 计算). 那么区域 $I$ 内每个点的贡献就是区域 $II$ 的长度加上这个点到区域 $II$ 的距离. 区域 $II$ 内每个点的贡献就是区间 $II$ 的长度.开两颗线段树分别修改就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int Siz=26,MAXN=2e5+10;const int inf=1e9;#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1]struct SegTree&#123; struct node &#123; int l,r; int mi,tag; &#125;Tree[MAXN&lt;&lt;2]; void pushup(int o) &#123; root.mi=min(lson.mi,rson.mi); &#125; void modifiy(int o,int c) &#123; root.mi=min(root.mi,c); root.tag=min(root.tag,c); &#125; void pushdown(int o) &#123; if(root.tag&lt;inf) &#123; modifiy(o&lt;&lt;1,root.tag); modifiy(o&lt;&lt;1|1,root.tag); root.tag=inf; &#125; &#125; void BuildTree(int o,int l,int r) &#123; root.mi=root.tag=inf; root.l=l,root.r=r; if(l==r) return; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); &#125; void update(int o,int L,int R,int c) &#123; int l=root.l,r=root.r; if(L&gt;r || l&gt;R || L&gt;R) return; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) update(o&lt;&lt;1,L,R,c); if(R&gt;mid) update(o&lt;&lt;1|1,L,R,c); pushup(o); &#125;&#125;T1,T2;int ans[MAXN];void query(int o,int l,int r)&#123; if(l==r) &#123; int res=min(T1.Tree[o].mi-l,T2.Tree[o].mi); ans[l]=res; return; &#125; int mid=(l+r)&gt;&gt;1; T1.pushdown(o); T2.pushdown(o); query(o&lt;&lt;1,l,mid); query(o&lt;&lt;1|1,mid+1,r);&#125;char buf[MAXN];int L;int t[MAXN],A[MAXN];struct SuffixAutomation&#123; int lst,idx; int ch[MAXN][Siz],fa[MAXN]; int siz[MAXN],len[MAXN]; int pos[MAXN]; SuffixAutomation()&#123;lst=idx=1;&#125; void Extend(int c,int curl) &#123; int p=lst,np=++idx; lst=np; siz[np]=1; len[np]=len[p]+1; pos[np]=curl; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125; void solve() &#123; for(int i=1;i&lt;=idx;++i) ++t[len[i]]; for(int i=1;i&lt;=idx;++i) t[i]+=t[i-1]; for(int i=1;i&lt;=idx;++i) A[t[len[i]]--]=i; T1.BuildTree(1,1,L); T2.BuildTree(1,1,L); for(int i=idx;i&gt;=1;--i) &#123; int u=A[i]; siz[fa[u]]+=siz[u]; pos[fa[u]]=pos[u]; if(u==1 || siz[u]&gt;1) continue; int l=pos[u]-len[u]+1,r=pos[u]-(len[fa[u]]+1)+1; T1.update(1,l,r-1,pos[u]+1); T2.update(1,r,pos[u],pos[u]-r+1); &#125; query(1,1,L); for(int i=1;i&lt;=L;++i) printf("%d\n",ans[i]); &#125;&#125;SAM;int main()&#123; scanf("%s",buf+1); L=strlen(buf+1); for(int i=1;i&lt;=L;++i) SAM.Extend(buf[i]-'a',i); SAM.solve(); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3998 弦论]]></title>
    <url>%2F2019%2F04%2F27%2Fbzoj-3998-%E5%BC%A6%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[$SAM​$ 的入门练习题. 先把 $SAM​$ 建出来,每个节点的 $right​$ 集合大小就是走到这个节点时对应的子串出现次数. 如果 $t=0​$ ,那么这些位置只能被算一次,把每个点的 $right​$ 集合大小都置为 $1​$ ,否则就拓扑排序后(桶排),在$parent​$ 树上递推得出真正的 $right​$ 集合大小. 注意根节点处对应的子串都是空串,不能算入贡献,要把根节点的 $siz$ 置为 $0$ . 再在转移图中递推得到每个点能转移到的所有点的子串出现次数 $sum$ ,然后从根节点出发贪心走就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int Siz=26,MAXN=2e6+10;int t[MAXN],A[MAXN];int T,K;struct SuffixAutomation&#123; int idx,lst; int ch[MAXN][Siz]; int siz[MAXN],len[MAXN]; int fa[MAXN]; int sum[MAXN]; SuffixAutomation()&#123;idx=lst=1;&#125; void Extend(int c) &#123; int p=lst,np=++idx; lst=np; siz[np]=1; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125; void solve() &#123; for(int i=1;i&lt;=idx;++i) ++t[len[i]]; for(int i=1;i&lt;=idx;++i) t[i]+=t[i-1]; for(int i=1;i&lt;=idx;++i) A[t[len[i]]--]=i; if(T==0) &#123; for(int i=1;i&lt;=idx;++i) siz[i]=1; &#125; else &#123; for(int i=idx;i&gt;=1;--i) &#123; int u=A[i]; siz[fa[u]]+=siz[u]; &#125; &#125; siz[1]=0;//在根节点处的串都是空串,不能计入 for(int i=idx;i&gt;=1;--i) &#123; int u=A[i]; sum[u]=siz[u]; for(int j=0;j&lt;26;++j) if(ch[u][j]) sum[u]+=sum[ch[u][j]]; &#125; int u=1; if(sum[u]&lt;K) &#123; puts("-1"); return; &#125; while(K) &#123; for(int i=0;i&lt;Siz;++i) &#123; if(K&lt;=sum[ch[u][i]]) &#123; putchar('a'+i); K-=siz[ch[u][i]]; u=ch[u][i]; break; &#125; else K-=sum[ch[u][i]]; &#125; &#125; puts(""); &#125;&#125;SAM;char buf[MAXN];int main()&#123; scanf("%s",buf+1); int L=strlen(buf+1); for(int i=1;i&lt;=L;++i) SAM.Extend(buf[i]-'a'); T=read(),K=read(); SAM.solve(); return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1151]]></title>
    <url>%2F2019%2F04%2F25%2FCF1151%2F</url>
    <content type="text"><![CDATA[一场难度略高于普及组的 $Div.2$ . CF1151C Problem for Nazar 二分. 转化成求前缀和 $sum(r)-sum(l-1)$ .算每个前缀和的时候二分出整的前 $2^k$ 个数,剩下的单独算就好了. CF1151D Stas and the Queue at the Buffet 贪心. 考虑当前的两个位置 $i,j\ (i&lt;j)$ , 有 $x,y$ 两个元素,若交换这两个元素,对答案的影响. 化简出来发现只需要将所有元素按 $a_i-b_i$ 从大到小排序就好了. 这种判定贪心的可行性及怎样贪心的方法很常见,就是考虑交换两个元素对答案的影响. CF1151E Number of Components 构造. 考虑若当前计算的权值区间是 $(l,r)$ ,那么把在这个范围内的点权值赋为 $1$ ,否则赋为 $0$. 再在位置 $0$ 处补上一个权值 $0$ ,可以发现此时对于这对 $(l,r)$ 的答案就是相邻的 $(0,1)$ 对数. 那么我们直接来算每两个相邻位置的贡献,即 $a_i,a_{i+1}$ 在多少组 $(l,r)$ 中被赋的权值不同就好了. CF1153F Sonya and Informatics 概率+矩阵快速幂. 设 $f(i,j)$ 表示操作了 $j$ 次,当前最后一个 $1$ 在位置 $i$ 的概率. 每次 $j\rightarrow j+1$ 转移的时候分类讨论一下选了哪两个位置,写出转移矩阵,转移 $k$ 次,矩阵快速幂加速即可. 时间复杂度 $O(n^3logk)$ .]]></content>
      <tags>
        <tag>构造</tag>
        <tag>二分</tag>
        <tag>贪心</tag>
        <tag>概率/期望</tag>
        <tag>codeforces</tag>
        <tag>矩阵优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GXOI/GZOI2019 选做]]></title>
    <url>%2F2019%2F04%2F21%2FGXOI-GZOI2019-%E9%80%89%E5%81%9A%2F</url>
    <content type="text"><![CDATA[广西/贵州 $OI$ . 题面Day 1Day 2 与或和 显然可以每一位分开做. 或就是用总子矩阵数目减去全 $0$ 子矩阵数目.与就是全 $1$ 子矩阵数目.单调栈经典问题. 时间复杂度 $O(32n^2)​$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7,inv2=(P+1)&gt;&gt;1;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=1e3+10;int n,a[MAXN][MAXN];int d[MAXN][MAXN];int ansand=0,ansor=0;int stk[MAXN],tp;int calc(int k,int v)//submatrix all of v&#123;#define val ((a[i][j]&gt;&gt;k)&amp;1) for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=n;++j) &#123; if(val!=v) d[i][j]=0; else d[i][j]=d[i-1][j]+1; &#125; &#125; int s,res=0; for(int i=1;i&lt;=n;++i) &#123; tp=0; s=0; for(int j=1;j&lt;=n;++j) &#123; s=add(s,d[i][j]); while(tp &amp;&amp; d[i][stk[tp]]&gt;=d[i][j]) &#123; int del=mul(add(stk[tp],P-stk[tp-1]),add(d[i][stk[tp]],P-d[i][j])); s=add(s,P-del); --tp; &#125; res=add(res,s); stk[++tp]=j; &#125; &#125; return res;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) a[i][j]=read(); int tot=mul(n,n+1); tot=mul(tot,inv2); tot=mul(tot,tot); for(int k=0;k&lt;31;++k) &#123; int tmpand=calc(k,1); tmpand=mul(tmpand,1&lt;&lt;k); ansand=add(ansand,tmpand); int tmpor=add(tot,P-calc(k,0)); tmpor=mul(tmpor,1&lt;&lt;k); ansor=add(ansor,tmpor); &#125; cout&lt;&lt;ansand&lt;&lt;' '&lt;&lt;ansor&lt;&lt;endl; return 0;&#125; 宝牌一大堆 怎么又是 $mahjong$ …是不是可以专门出一类 麻将 $dp$ 啊. 七对子和国士无双可以单独做.七对子可以 $dp$ , $g(i,j)$ 表示考虑前 $i$ 种牌,组成 $j$ 个对子的最大得分.国士无双可以大力枚举一下哪张幺九牌有两张. 对于普通的 $3\times 4+2$ 的胡牌,把牌搞上标号,使得顺子的标号是连续的.记 $f[i][j][k][l][m][n]$ 表示考虑了前 $i$ 种牌,形成了 $j$ 个面子, $k$ 个雀头, $i-2,i-1,i$ 已经选了 $l,m,n$ 个时,前 $i-3$ 种牌能获得的最大得分. 转移时枚举一下 $i$ 这张牌不选/成刻子/成杠子/与 $i-2,i-1$ 成顺子的几种情况即可,注意判断合法性. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;ll g[35][35];ll f[35][5][2][5][5][5],ans;int a[35],c[5][5],d[35];bool shunend[]=&#123;0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0&#125;;void init()&#123; memset(f,0,sizeof f); memset(g,0,sizeof g); ans=0; for(int i=1;i&lt;=34;++i) d[i]=0,a[i]=4;&#125;// 1m 2m ... 9m 1p 2p ... 9p 1s 2s ... 9s E S W N Z B Fint id(char s[])&#123; if(s[0]=='E') return 28; if(s[0]=='S') return 29; if(s[0]=='W') return 30; if(s[0]=='N') return 31; if(s[0]=='Z') return 32; if(s[0]=='B') return 33; if(s[0]=='F') return 34; if(s[1]=='m') return s[0]-'0'; if(s[1]=='p') return s[0]-'0'+9; if(s[1]=='s') return s[0]-'0'+18; return 0;&#125;void upd(ll &amp;x,ll y)&#123; if(y&gt;x) x=y;&#125;ll dora(int idx,int cnt)&#123; if(d[idx]) return 1LL&lt;&lt;cnt; return 1LL;&#125;ll MaHu()&#123; ll res=0; f[1][0][0][0][0][0]=1; for(int i=1;i&lt;=34;++i) for(int j=0;j&lt;=4;++j) for(int k=0;k&lt;=1;++k) for(int l=0;l&lt;=4;++l) for(int m=0;m&lt;=4;++m) for(int n=0;n&lt;=4;++n) &#123; ll cur=f[i][j][k][l][m][n]; if(!cur) continue; if(i&lt;34) upd(f[i+1][j][k][m][n][0],cur*(i&gt;2?c[a[i-2]][l]*dora(i-2,l):1));//give up if(j&lt;4 &amp;&amp; a[i]-n&gt;=3) upd(f[i][j+1][k][l][m][n+3],cur);//kezi if(j&lt;4 &amp;&amp; a[i]-n&gt;=4) upd(f[i][j+1][k][l][m][n+4],cur);//gangzi if(j&lt;4 &amp;&amp; shunend[i] &amp;&amp; a[i]-n &amp;&amp; a[i-1]-m &amp;&amp; a[i-2]-l) upd(f[i][j+1][k][l+1][m+1][n+1],cur);//shunzi if(!k &amp;&amp; a[i]-n&gt;=2) upd(f[i][j][k+1][l][m][n+2],cur); if(i==34 &amp;&amp; j==4 &amp;&amp; k==1) &#123; ll s=cur*c[a[i]][n]*c[a[i-1]][m]*c[a[i-2]][l]; s*=dora(i,n)*dora(i-1,m)*dora(i-2,l); upd(res,s); &#125; &#125; return res;&#125;ll QiDuizi()&#123; g[0][0]=1; for(int i=1;i&lt;=34;++i) for(int j=0;j&lt;=7;++j) &#123; if(!g[i-1][j]) continue; upd(g[i][j],g[i-1][j]); if(j&lt;7) upd(g[i][j+1],g[i-1][j]*c[a[i]][2]*dora(i,2)); &#125; return g[34][7]*7;&#125;int yao[13]=&#123;1,9,10,18,19,27,28,29,30,31,32,33,34&#125;;ll GSWS()&#123; ll res=0; for(int i=0;i&lt;13;++i) &#123; if(a[yao[i]]==0) return 0; if(a[yao[i]]==1) continue; ll tmp=c[a[yao[i]]][2]*dora(yao[i],2); for(int j=0;j&lt;13;++j) &#123; if(i==j) continue; tmp*=c[a[yao[j]]][1]*dora(yao[j],1); &#125; upd(res,tmp); &#125; return res*13;&#125;int main()&#123; for(int i=0;i&lt;=4;++i) c[i][0]=1; for(int i=1;i&lt;=4;++i) for(int j=1;j&lt;=4;++j) c[i][j]=c[i-1][j]+c[i-1][j-1]; int T=read(); while(T--) &#123; init(); char s[5]; while(1) &#123; scanf("%s",s); int x=id(s); if(x) --a[x]; else break; &#125; while(1) &#123; scanf("%s",s); int x=id(s); if(x) d[x]=1; else break; &#125; upd(ans,MaHu()); upd(ans,QiDuizi()); upd(ans,GSWS()); printf("%lld\n",ans); &#125; return 0;&#125; 特技飞行 无论怎样决策,所有交点的位置是确定的.所以 $c$ 的贡献可以和 $a,b$ 分开算. 所有合法决策最值,一定是一个使 对向交换 的次数最多,另一个使 对向交换 的次数最少. 计算 $a,b$ 的贡献时,交点的具体位置不重要,先只考虑 $y$ 的相对大小. 对于最多的情况,我们可以在 每个 交点处都选择 对向交换 .因为每个交点其实就是二元组 $(y_0,y_1)$ 的一个逆序对产生的.那么将每个逆序对的 $y_1$ 都交换,最后就不会有逆序对(交换排序),即满足要求. 对于最少的情况,可以发现对于 $y_1$ 中的每个置换,内部需要交换大小 $-1$ 次,各个置换独立,那么总交换次数为 $n-​$ 置换数目.找到的证明. 再来算 $c$ 的贡献.可以把所有点按 $y_1$ 从大到小依次加入 $set$ 中,以 $y_0$ 为关键字,这样能产生交点的点在 $set$ 中是一个前缀部分,合法就计算交点,不合法时就跳出,加入下一个点. 曼哈顿距离不太好搞,经典套路,转化成切比雪夫距离,就变成了问每个交点是否被一些矩形中的至少一个覆盖. 把点加入 $kdtree$ 中,每个矩形给其中的点打一打标记就好了.也可以离线后扫描线+树状数组. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const double eps=1e-10;int fcmp(double x)&#123; if(fabs(x)&lt;=eps) return 0; return x&gt;0?1:-1;&#125;const int MAXN=5e5+10;typedef pair&lt;int,int&gt; pii;#define mp make_pairint n,Y0[MAXN],Y1[MAXN],st,ed,is[MAXN],tot,id[MAXN],to[MAXN],k,vis[MAXN];ll A,B,C;double mn[MAXN][2],mx[MAXN][2];int flag[MAXN],D,ch[MAXN][2],marked[MAXN];// flag表示这个点以及其管辖的点都被标记了 marked表示这个点被标记了 set&lt;pii&gt; s;set&lt;pii&gt;::iterator it;struct point&#123; double p[2]; point()&#123;p[0]=p[1]=0;&#125; point(double x,double y)&#123;p[0]=x,p[1]=y;&#125; bool operator &lt; (const point &amp;rhs) const &#123; return p[D]==rhs.p[D]?p[D^1]&lt;rhs.p[D^1]:p[D]&lt;rhs.p[D]; &#125;&#125;a[MAXN];bool cmp(int a,int b)&#123; return Y1[a]&lt;Y1[b];&#125;void pushup(int o,int x)&#123; for(int i=0;i&lt;2;++i) &#123; mn[o][i]=min(mn[o][i],mn[x][i]); mx[o][i]=max(mx[o][i],mx[x][i]); &#125;&#125;int BuildTree(int l,int r,int d)&#123; if(l&gt;r) return 0; int mid=(l+r)&gt;&gt;1; D=d; nth_element(a+l,a+mid,a+r+1); int o=mid; for(int i=0;i&lt;2;++i) mn[o][i]=mx[o][i]=a[o].p[i]; if(l&lt;=mid-1) &#123; ch[o][0]=BuildTree(l,mid-1,d^1); pushup(o,ch[o][0]); &#125; if(mid+1&lt;=r) &#123; ch[o][1]=BuildTree(mid+1,r,d^1); pushup(o,ch[o][1]); &#125; return o;&#125;void update(int x,int y,int r,int o)&#123; if(!o || flag[o] || x+r&lt;mn[o][0] || x-r&gt;mx[o][0] || y+r&lt;mn[o][1] || y-r&gt;mx[o][1]) return; double mxd=0; mxd=max(mxd,fabs(x-mn[o][0])); mxd=max(mxd,fabs(x-mx[o][0])); mxd=max(mxd,fabs(y-mn[o][1])); mxd=max(mxd,fabs(y-mx[o][1])); if(fcmp(mxd-r)&lt;=0) &#123; flag[o]=1; return; &#125; double curd=max(fabs(x-a[o].p[0]),fabs(y-a[o].p[1])); if(!marked[o] &amp;&amp; fcmp(curd-r)&lt;=0) marked[o]=1; update(x,y,r,ch[o][0]); update(x,y,r,ch[o][1]);&#125;int dfs(int o)&#123; if(flag[o]) &#123; marked[o]=1; marked[ch[o][0]]=marked[ch[o][1]]=1; flag[ch[o][0]]=flag[ch[o][1]]=1; &#125; int res=marked[o]; if(ch[o][0]) res+=dfs(ch[o][0]); if(ch[o][1]) res+=dfs(ch[o][1]); return res;&#125;int main()&#123; n=read(),A=read(),B=read(),C=read(); st=read(),ed=read(); for(int i=1;i&lt;=n;++i) Y0[i]=read(); for(int i=1;i&lt;=n;++i) Y1[i]=read(); for(int i=n;i&gt;=1;--i) &#123; for(it=s.begin();it!=s.end() &amp;&amp; it-&gt;first &lt; Y1[i];++it) &#123; int j=it-&gt;second; double t=(double)(Y0[j]-Y0[i])/(Y1[i]-Y1[j]); double ox=(t*ed+st)/(t+1); double oy=(t*Y1[j]+Y0[j])/(t+1); double x=ox+oy,y=ox-oy; a[++tot]=point(x,y); &#125; s.insert(mp(Y1[i],i)); &#125; int rt=BuildTree(1,tot,0); k=read(); for(int i=1;i&lt;=k;++i) &#123; int ox=read(),oy=read(),r=read(); int x=ox+oy,y=ox-oy; update(x,y,r,rt); &#125; ll ans=dfs(rt)*C; ll ans1=ans+tot*A; for(int i=1;i&lt;=n;++i) id[i]=i; sort(id+1,id+1+n,cmp); ll rep=n; for(int i=1;i&lt;=n;++i) if(!vis[i]) &#123; --rep; for(int j=i;!vis[j];j=id[j]) vis[j]=1; &#125; ll ans2=ans1+(tot-rep)*(B-A); if(ans1&gt;ans2) swap(ans1,ans2); printf("%lld %lld\n",ans1,ans2); return 0;&#125; 逼死强迫症 求必须用两块 $1\times 1$ 的方案,转化一下,设 $f_i$ 表示任意用砖,铺满前 $i$ 列的方案数, $g_i$ 表示只用 $1\times 2$ 的砖铺满前 $i$ 列的方案数.那么最后的答案就是 $f_n-g_n$ . $g$ 的转移很简单, $g_i=g_{i-1}+g_{i-2},g_0=1,g_1=1​$ . $f$ 的转移呢?多出来一列时,若不在这一列用 $1\times 1$ 的砖,那么方案数为 $f_{i-1}+f_{i-2}$ . 若在这一列用 $1\times 1$ 的砖,那么为了填满前 $i$ 列,另外一块 $1\times 1$ 也必须用,并且只能放在第 $1\sim i-2​$ 列. 若这两块砖中间还有偶数列,那么它们只能在同一行,否则,只能在不同的一行.看下面的图片感性理解: 那么左边那块 $1\times 1$ 的左边只能用 $1\times 2$ 填满,方案数用 $g$ 计算,右边只能有 $1$ 种填法. 枚举右边那块 $1\times 1$放在第 $1,2$ 行,左边那块 $1\times 1$ 放在第 $j$ 列. 整理一下,就有 $f_i=f_{i-1}+f_{i-2}+2\times \sum_{j=1}^{i-2} g_{j-1}$ . 边界有 $f_1=1,f_2=2$ .把 $g$ 的前缀和, $g,f$ 一起用矩阵快速幂优化转移即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;struct matrix&#123; int v[6][6]; matrix()&#123;memset(v,0,sizeof v);&#125; matrix operator * (const matrix &amp;rhs) const &#123; matrix res; for(int i=0;i&lt;6;++i) for(int j=0;j&lt;6;++j) for(int k=0;k&lt;6;++k) res.v[i][j]=add(res.v[i][j],mul(v[i][k],rhs.v[k][j])); return res; &#125;&#125;;matrix fpow(matrix a,int b)&#123; matrix res; for(int i=0;i&lt;6;++i) res.v[i][i]=1; while(b) &#123; if(b&amp;1) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;matrix trans,st;void setv(int x,int y)&#123; trans.v[x][y]+=1;&#125;void init()&#123; st.v[0][0]=5; st.v[1][0]=2; st.v[2][0]=3; st.v[3][0]=2; st.v[4][0]=1; st.v[5][0]=1;&#125;int main()&#123; setv(0,0),setv(0,1),setv(0,4),setv(0,5),setv(0,4),setv(0,5); setv(1,0); setv(2,2),setv(2,3); setv(3,2); setv(4,3); setv(5,4),setv(5,5); int T=read(); while(T--) &#123; int n=read(); if(n&lt;=3) &#123; if(n==1) cout&lt;&lt;0&lt;&lt;endl; else if(n==2) cout&lt;&lt;0&lt;&lt;endl; else if(n==3) cout&lt;&lt;2&lt;&lt;endl; continue; &#125; init(); st=fpow(trans,n-3)*st; printf("%d\n",add(st.v[0][0],P-st.v[2][0])); &#125; return 0;&#125; 旅行者 考虑将所有 感兴趣的城市 划分到两个集合 $A,B$ 中,从 $S$ 向 $A$ 中每个点连 $0$ 边,从 $B$ 中每个点向 $T$ 中连 $0$ 边. 这样从 $S$ 到 $T$ 的最短路长度就是 $A$ 与 $B$ 中两两最短路的最小值. 怎样划分才能使每对 感兴趣的城市 都被算入贡献中呢? 考虑划分 $logn$ 轮,每一轮将二进制第 $i$ 位上为 $0$ 的点划入 $A$ 中,否则划入 $B$ 中.这样两个不同的城市在至少一轮中被划分进了不同的集合,一定能产生贡献. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll inf=1e18;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10,MAXM=7e5+10;int ecnt,head[MAXN],to[MAXM],nx[MAXM],val[MAXM];void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;void init()&#123; ecnt=0; memset(head,0,sizeof head);&#125;int n,m,k;int city[MAXN],orghead[MAXN];ll dis[MAXN];bool vis[MAXN];typedef pair&lt;ll,int&gt; pli;#define mp make_pairll dij(int S,int T)&#123; for(int i=1;i&lt;=n+2;++i) &#123; dis[i]=inf; vis[i]=false; &#125; dis[S]=0; priority_queue&lt;pli&gt; q; q.push(mp(0,S)); while(!q.empty()) &#123; int u=(q.top()).second; q.pop(); if(vis[u]) continue; vis[u]=true; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(dis[u]+val[i]&lt;dis[v]) &#123; dis[v]=dis[u]+val[i]; q.push(mp(-dis[v],v)); &#125; &#125; &#125; return dis[T];&#125;int main()&#123; int Cases=read(); while(Cases--) &#123; init(); n=read(),m=read(),k=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); &#125; for(int i=1;i&lt;=k;++i) city[i]=read(); int rounds=1+(int)log2(n); int S=n+1,T=n+2; ll ans=inf; for(int p=0;p&lt;=rounds;++p) &#123; for(int i=1;i&lt;=k;++i) if((city[i]&gt;&gt;p)&amp;1) orghead[i]=head[city[i]]; for(int i=1;i&lt;=k;++i) if((city[i]&gt;&gt;p)&amp;1) addedge(city[i],T,0); else addedge(S,city[i],0); ans=min(ans,dij(S,T)); head[S]=0; for(int i=1;i&lt;=k;++i) if((city[i]&gt;&gt;p)&amp;1) head[city[i]]=orghead[i]; ecnt-=k; &#125; printf("%lld\n",ans); &#125; return 0;&#125; 旧词 先来考虑 $k=1$ 的部分,做法是将 $lca$ 处 $dep$ 的贡献摊到这个点到根的路径上. 具体来说将询问离线下来,按 $x$ 排序后就可以从小到大一个个加入点.每加入一个点的时候就把这个点到根的路径上点的权值都 $+1$ ,询问时就查询 $y$ 到根的路径上点的权值和. 考虑拓展到 $k&gt;1$ 的部分,沿用上面的思路,发现每次给路径上每个点权值 $+\ (dep_i^k-(dep_i-1)^k)$ 就好了. 这样就可以使 $lca$ 的权值恰好被摊到路径上,查询时仍然查询路径权值和就好了. 树剖+线段树维护一下,时间复杂度 $O(nlog^2n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;inline int add(int a,int b)&#123; return (a + b &gt;= P)? (a + b - P) : (a + b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=5e4+10;int n,k,Q;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];inline void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int siz[MAXN],mxson[MAXN],top[MAXN],fa[MAXN],dep[MAXN],dfn[MAXN],rnk[MAXN],idx=0;void dfs1(int u,int Fa)&#123; dep[u]=dep[Fa]+1; siz[u]=1; fa[u]=Fa; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==Fa) continue; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; top[u]=tp; dfn[u]=++idx; rnk[idx]=u; if(mxson[u]) dfs2(mxson[u],tp); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa[u] || v==mxson[u]) continue; dfs2(v,v); &#125;&#125;struct SegTree&#123; struct node &#123; int l,r; int sum,delta,tag; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.sum=add(lson.sum,rson.sum); &#125; void modifiy(int o,int c) &#123; root.tag=add(root.tag,c); root.sum=add(root.sum,mul(c,root.delta)); &#125; void pushdown(int o) &#123; if(root.tag) &#123; modifiy(o&lt;&lt;1,root.tag); modifiy(o&lt;&lt;1|1,root.tag); root.tag=0; &#125; &#125; void BuildTree(int o,int l,int r) &#123; root.l=l,root.r=r; root.tag=0; root.sum=0; if(l==r) &#123; root.delta=add(fpow(dep[rnk[l]],k),P-fpow(dep[rnk[l]]-1,k)); return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); root.delta=add(lson.delta,rson.delta); &#125; void update(int o,int L,int R,int c) &#123; int l=root.l,r=root.r; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c); return; &#125; if(l&gt;R || L&gt;r) return; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) update(o&lt;&lt;1,L,R,c); if(R&gt;mid) update(o&lt;&lt;1|1,L,R,c); pushup(o); &#125; int query(int o,int L,int R) &#123; int l=root.l,r=root.r; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; if(l&gt;R || L&gt;r) return 0; int mid=(l+r)&gt;&gt;1; pushdown(o); int res=0; if(L&lt;=mid) res=add(res,query(o&lt;&lt;1,L,R)); if(R&gt;mid) res=add(res,query(o&lt;&lt;1|1,L,R)); return res; &#125;&#125;T;int ans[MAXN];struct query&#123; int x,y,id; bool operator &lt; (const query &amp;rhs) const &#123; return x&lt;rhs.x; &#125;&#125;q[MAXN];void path_upd(int x)&#123; while(top[x]!=1) &#123; T.update(1,dfn[top[x]],dfn[x],1); x=fa[top[x]]; &#125; T.update(1,dfn[top[x]],dfn[x],1);&#125;int path_query(int x)&#123; int res=0; while(top[x]!=1) &#123; res=add(res,T.query(1,dfn[top[x]],dfn[x])); x=fa[top[x]]; &#125; res=add(res,T.query(1,dfn[top[x]],dfn[x])); return res;&#125;int main()&#123; n=read(),Q=read(),k=read(); for(int i=2;i&lt;=n;++i) &#123; int f=read(); addedge(f,i); &#125; for(int i=1;i&lt;=Q;++i) &#123; q[i].x=read(); q[i].y=read(); q[i].id=i; &#125; sort(q+1,q+1+Q); dfs1(1,0); dfs2(1,1); T.BuildTree(1,1,n); int lstx=0; for(int i=1;i&lt;=Q;++i) &#123; int x=q[i].x,y=q[i].y; for(int j=lstx+1;j&lt;=x;++j) path_upd(j); ans[q[i].id]=path_query(y); lstx=x; &#125; for(int i=1;i&lt;=Q;++i) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>矩阵优化</tag>
        <tag>最短路</tag>
        <tag>差分</tag>
        <tag>单调栈</tag>
        <tag>位运算</tag>
        <tag>kdtree</tag>
        <tag>棋牌</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tenka1 Programmer Contest 2019]]></title>
    <url>%2F2019%2F04%2F21%2FTenka1-Programmer-Contest-2019%2F</url>
    <content type="text"><![CDATA[感觉这场打得好烂… C Stones 比较弱智.最后一定是连续一段黑之后连续一段白.枚举一下这个分界位置就好了. 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;char s[MAXN];int sum1[MAXN],sum2[MAXN];int main()&#123; int n=read(); scanf("%s",s+1); int ans; for(int i=1;i&lt;=n;++i) &#123; if(s[i]=='.') ++sum1[i];//white else ++sum2[i]; sum1[i]+=sum1[i-1]; sum2[i]+=sum2[i-1]; &#125; ans=sum2[n]; for(int i=1;i&lt;=n;++i) ans=min(ans,i-sum1[i]+n-i-(sum2[n]-sum2[i-1])); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D Three Colors 两个颜色一起 $dp$ 状态数目可能很大,考虑能不能每次只 $dp$ 一种颜色. 用所有染色方案 $3^n$ 减去不合法的方案数就好了. 记所有数的和为 $sum$ ,那么不合法的方案有 $R\geq sum/2,G\geq sum/2,B\geq sum/2$ 三种. 记 $f(i,j)$ 表示前 $i$ 个数,红色数之和为 $j$ 的方案数.另外两种颜色计算方法一样,直接 $\times 3$ . 注意若 $sum$ 为偶数,这里有两个颜色都恰好等于 $sum/2$ 的方案被减了两次,要加回来,这部分是 $g(n,sum/2)\cdot {3\choose 2}$ . $f$ 转移时可以填三种颜色,而 $g$ 只能填两种. 时间复杂度为 $O(n\cdot sum)$ ,实际肯定跑不满.空间可以滚动优化一下(其实 $f,g$ 用一个数组也就 $100\ MB$). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;void upd(int &amp;x,int y)&#123; x+=y; x=(x%P+P)%P;&#125;const int MAXN=329;int a[MAXN],sum[MAXN],n;int ans=0;int f[2][MAXN*MAXN],g[2][MAXN*MAXN];int main()&#123; n=read(); for(int i=1; i&lt;=n; ++i) sum[i]=sum[i-1]+(a[i]=read()); ans=fpow(3,n); int cur=0; g[cur][0]=f[cur][0]=1; for(int i=1;i&lt;=n;++i) &#123; for(int j=0;j&lt;=sum[i];++j) f[cur^1][j]=g[cur^1][j]=0; for(int j=0;j&lt;=sum[i-1];++j) if(f[cur][j]) &#123; upd(f[cur^1][j+a[i]],f[cur][j]); upd(f[cur^1][j],mul(2,f[cur][j])); upd(g[cur^1][j+a[i]],g[cur][j]); upd(g[cur^1][j],g[cur][j]); &#125; cur^=1; &#125; for(int i=(sum[n]+1)&gt;&gt;1;i&lt;=sum[n];++i) upd(ans,-mul(3,f[cur][i])); if(!(sum[n]&amp;1)) upd(ans,mul(3,g[cur][sum[n]&gt;&gt;1])); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; E Polynomial Divisors 比赛时一直 $WA$ 后面几个点.心态有些崩.后来改了些莫名其妙的地方就过了??? 结论:题述性质成立当且仅当这个多项式在模 $p$ 意义下能被 $x^p-x$ 整除.于是只需要验证 $[2,n]$ 以内的质数,再加上所有 $a_i$ 的 $gcd$ 的质因数就好了. 证明:充分性显然.必要性:在模 $p$ 意义下, $0,1,\dots p-1$ 都是 $f$ 的根. 那么这个多项式一定有因式 $x(x-1)(x-2)\dots (x-(p-1))$. 这个因式的根与 $x^p-x$ 的根完全相同,而它们最高项系数也相同,在模 $p$ 意义下这两个式子是等价的.于是多项式 $f$ 就一定有因式 $x^p-x$ . 这部分的证明好像在 $math$ 那个题里面有? F Banned X 咕了.]]></content>
      <tags>
        <tag>atcoder</tag>
        <tag>dp计数</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[烷烃计数]]></title>
    <url>%2F2019%2F04%2F20%2F%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[大概 $OIer$ 上化学课都会想到这个吧? 今天化学课教烷烃的同分异构体,我:这烷烃不就是颗树嘛?同分异构体数目不就是无标号树的个数嘛? $prufer$ 序列随便搞一下就能算吧??? 然后发现一个碳旁边最多连四个碳,度数还要 $\leq 4$. 然后我就问旁边数竞小哥:你知道这个东西的通项嘛?他:我来找下规律.我:这东西(指数树)的规律大概率找不出来吧…他不信邪,结果找了一节课,未果,寻病终… 然后在 $dalao$ 们的博客中学习了一下.记 $f(i,j)$ 表示 $i$ 个点的有根树,根节点的度数为 $j$ 的方案数目. 在枚举儿子节点时,为了避免算重,按照子树大小从大到小来枚举.先枚举儿子中最大的子树大小 $size$ ,再枚举有 $k$ 个这样大小的儿子.记 $s=\sum_{i=0}^{j-1} f(size,i)$ ,即每个这样的子树都有 $s$ 种方案可选.那么给 $k$ 个子树安排一下方案,就相当于把 $k$ 个球放入 $s$ 个无差别盒子中,方案数为 ${s+k-1\choose k}$ . 那么转移方程就有 $f(i,j)=\sum f(i-k\times size,j-k)\cdot {s+k-1\choose k}$ . 如果是数烷基,就是无根树,直接就像上面这样算, $ans=\sum_{k=0}^3 f(n,k).​$ 如果数的是烷烃,就是无根树,所以钦定树的重心作为根节点.那么在转移时就要注意 $2\cdot size&lt;i$ ,保证根为重心. 另外,在最后计算答案时,注意到当 $n$ 为偶数时,它有两个重心,那么两边的子树可以交换,多乘上 $p_k={\sum_{k’=0}^{k-1}f(\frac n 2,k’)+1\choose 2}$. 最后就有 $ans=\sum_{k=0}^3 f(n,k)+[n\equiv 0\mod2]\cdot p_k$ .]]></content>
      <tags>
        <tag>dp计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1140]]></title>
    <url>%2F2019%2F04%2F18%2FCF1140%2F</url>
    <content type="text"><![CDATA[$Div.2$ CF1140C Playlist 将元素按 $b$ 从大到小排序,然后从后往前依次加入,每加入一个元素时它的 $b$ 都是当前最小的. 此时需要钦定选择这个元素作为最小的 $b$ ,并在已有元素中选出 $k-1$ 个 $t$ 值最大的. 这个东西用个堆维护一下当前前 $k-1$ 大的 $t$ 值就好了. CF1140D Minimum Triangulation 肯定会有一个很直观的想法:全部都以 $1$ 为一个顶点,然后 $(1,2,3),(1,3,4) \dots (1,n-1,n)$ 这样来剖. 这样做的确是正确的,即权值一定是最小的.为什么呢? 考虑若有 $x&lt;y$ ,那么把方案 $(1,n,x),(n,x,y)$ 换成 $(1,n,y),(1,x,y)$ ,总权值会减小. 于是可以直接将 $x$ 换到 $n-1$ ,然后将 $(1,n-1,n)$ 这个三角形直接割掉,对剩下的 $n-1$ 边形继续做上述操作. 这样做的话,所有的方案就一定是 $(1,2,3),(1,3,4) \dots (1,n-1,n)$ 这样的形式了. 另一个做法是 $O(n^3)$ 的区间 $dp$ ? CF1140E Palindrome-less Arrays 任意位置都不能出现长度 $\geq 3$ 的奇回文串,其实也就等价于不出现长度为 $3$ 的回文串. 也就是说总有 $a_i\not=a_{i+2}$ .这样显然可以奇偶分开算,将两个序列各自的合法方案数目乘起来. 把奇(偶)数位置拿出来,就是要求相邻两个位置都不同的方案数. 把连续的一段 $-1$ 看成一块,考虑每一块 $(a,-1,-1,\dots,-1,b)$ 怎么算方案数.首尾可能会出现没有 $a,b$ 的情况,枚举第一个/最后一个元素,算中间的就可以了(其实这部分细节挺多的?).所以下面都假定 $a,b$ 存在. 每块的方案数只与 $-1$ 的个数 $x$ 以及 $a,b$ 是否相等有关.记 $f(x)$ 表示 $a\not =b$ 时的方案数, $g(x)$ 表示相等时. 若 $x$ 为奇,枚举最中间的元素,就有:$g(x)=g(x/2)^2+(k-1)f(x/2)^2,f(x)=2f(x/2)g(x/2) + (k-2)f(x/2)^2$ . 若 $x$ 为偶,枚举第一个元素即可将 $x$ 变为奇.$g(x)=(k-1)f(x-1),f(x)=g(x-1)+(k-2)f(x-1)$ . 边界显然有 $f(0)=1,g(0)=0$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=2e5+10;int k;int f[MAXN],g[MAXN];int F(int);int G(int);int calc(int l,int r,int *a,int n)&#123; if(r&gt;=n) &#123; int len=r-l-1,res=1; if(l&lt;0) --len,res=k; if(len==0) return res; int fx=F(len-1),gx=G(len-1); return mul(res,add(gx,mul(k-1,fx))); &#125; if(l&lt;0) &#123; if(r-l==1) return 1; int fx=F(r-l-2),gx=G(r-l-2); return add(gx,mul(k-1,fx)); &#125; return a[l]==a[r]?G(r-l-1):F(r-l-1);&#125;int solve(int *a,int n)&#123; int res=1,lst=-1; for(int i=0;i&lt;n;++i) &#123; if(a[i]==-1) continue; res=mul(res,calc(lst,i,a,n)); lst=i; &#125; res=mul(res,calc(lst,n,a,n)); return res;&#125;int n,a[MAXN],b[MAXN],siza,sizb;int main()&#123; n=read(); k=read(); for(int i=1;i&lt;=n;++i) &#123; f[i]=g[i]=-1; int x=read(); if(i&amp;1) a[siza++]=x; else b[sizb++]=x; &#125; int ans=1; ans=mul(ans,solve(a,siza)); if(ans) ans=mul(ans,solve(b,sizb)); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;int F(int x)&#123; if(!x) return 1; if(f[x]!=-1) return f[x]; int &amp;res=f[x]; if(x&amp;1) &#123; res=mul(2,mul(F(x&gt;&gt;1),G(x&gt;&gt;1))); res=add(res,mul(k-2,mul(F(x&gt;&gt;1),F(x&gt;&gt;1)))); return res; &#125; else return res=add(G(x-1),mul(k-2,F(x-1))); &#125;int G(int x)&#123; if(!x) return 0; if(g[x]!=-1) return g[x]; int &amp;res=g[x]; if(x&amp;1) &#123; res=mul(G(x&gt;&gt;1),G(x&gt;&gt;1)); res=add(res,mul(k-1,mul(F(x&gt;&gt;1),F(x&gt;&gt;1)))); return res; &#125; else return res=mul(k-1,F(x-1));&#125; CF1140F Extending Set of Points 可以发现它的 $Extend$ 操作就是将每三个点加一个点补成一个矩形,直到每个可补的位置都有点为止.这里的三个点必须要有两个点的连线是平行于坐标轴的. 给每个 $x,y$ 坐标都建一个节点,加入 $(x,y)$ 就将对应的两个节点连起来,容易发现每个连通分量的贡献为不同的 $x$ 坐标个数乘上不同的 $y$ 坐标个数,此时的答案就是每个连通分量的贡献之和. 这个东西用个并查集维护,插入点很简单,删除点似乎不太好做?此时可以想到线段树分治,用线段树给每个点影响的时间区间 $(l,r)$ 打上对应的标记就好了. 打好标记,算答案的时候,递归到一个节点时,就让上面的所有标记生效,退出时再撤销就好了. 注意这里有撤销操作,需要避免路径压缩的使用.用按秩合并优化就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef pair&lt;int,int&gt; pii;const int MAXN=6e5+10;int siz[MAXN],sizx[MAXN],sizy[MAXN];#define tot(x) 1LL*sizx[x]*sizy[x]int fa[MAXN];int Find(int x)&#123; return x==fa[x]?x:Find(fa[x]);&#125;pii stk[MAXN];int tp=0;ll ans=0;void Merge(int x,int y)&#123; x=Find(x),y=Find(y); if(x==y) return; if(siz[x]&lt;siz[y]) swap(x,y); ans-=tot(x); ans-=tot(y); fa[y]=x; siz[x]+=siz[y],sizx[x]+=sizx[y],sizy[x]+=sizy[y]; ans+=tot(x); stk[++tp]=make_pair(x,y);&#125;void Split(int x,int y)&#123; ans-=tot(x); fa[y]=y; siz[x]-=siz[y],sizx[x]-=sizx[y],sizy[x]-=sizy[y]; ans+=tot(x); ans+=tot(y);&#125;int n;map&lt;pii,int&gt; mp;vector&lt;pii&gt; Tree[MAXN&lt;&lt;1];set&lt;pii&gt; s;#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1]void modifiy(int o,int l,int r,int L,int R,pii c)&#123; if(l&gt;R || L&gt;r) return; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; root.push_back(c); return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) modifiy(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) modifiy(o&lt;&lt;1|1,mid+1,r,L,R,c);&#125;void solve(int o,int l,int r)&#123; int curt=tp; int sz=root.size(); for(int i=0;i&lt;sz;++i) Merge(root[i].first,root[i].second); if(l==r) printf("%I64d ",ans); else &#123; int mid=(l+r)&gt;&gt;1; solve(o&lt;&lt;1,l,mid); solve(o&lt;&lt;1|1,mid+1,r); &#125; while(tp&gt;curt) &#123; Split(stk[tp].first,stk[tp].second); --tp; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; int x=read(),y=read()+300001; fa[x]=x,siz[x]=1,sizx[x]=1; fa[y]=y,siz[y]=1,sizy[y]=1; pii k=make_pair(x,y); if(s.find(k)==s.end()) &#123; mp[k]=i; s.insert(k); &#125; else &#123; modifiy(1,1,n,mp[k],i-1,k); mp[k]=0; s.erase(k); &#125; &#125; set&lt;pii&gt;::iterator it; for(it=s.begin();it!=s.end();++it) &#123; pii k=*it; modifiy(1,1,n,mp[k],n,k); &#125; solve(1,1,n); return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>贪心</tag>
        <tag>codeforces</tag>
        <tag>并查集</tag>
        <tag>线段树分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190417]]></title>
    <url>%2F2019%2F04%2F18%2Ftest20190417%2F</url>
    <content type="text"><![CDATA[测试. $heap$ 有多少个节点数目为 $n​$ ,权值为 $1\sim n​$ 且互不相同的二叉堆?答案对 $10^9+7​$ 取模. $n\leq 10^9​$ . $O(n)$ 的做法十分简单, 先搞出每个节点的 $siz$ ,记 $f(i)$ 表示子树 $i$ 内用 $siz_i$ 个权值能形成的合法二叉堆数目. 转移显然有 $f(i)={siz_i\choose siz_{2i}}\cdot f(2i)\cdot f(2i+1)$ ,叶子节点 $f(i)=1$ . 把组合数拆开,算算贡献,可以发现 $f(1)=\frac {n!} {\prod siz_i}$ .考虑 $siz$ 连乘积怎么算. 注意到一个点的左右子树至少有一个是满的二叉树(每一层填满),那么就可以先求出每种满二叉树的答案,此时递归入另一个子树继续计算就可以了.这部分的时间复杂度为 $O(logn)​$ . 还有一个 $n!​$ 需要计算.分块打下表,就能很快求出啦. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;int m=1000000;int calcfac(int x) &#123; int pos=x/m; int s=blockfac[pos]; for(int i=pos*m+1;i&lt;=x;++i) s=mul(s,i); return s;&#125;int n;map&lt;int,int&gt; mp;int solve(int x)//x个点,x个互异权值,siz连乘积&#123; if(x&lt;=1) return 1; if(mp.find(x)!=mp.end()) return mp[x]; int z=(int)(log2(x)); z=1&lt;&lt;z; int y=min(z-1,x-z/2); return mp[x]=mul(x,mul(solve(y),solve(x-y-1)));&#125;int main()&#123; freopen("heap.in","r",stdin); freopen("heap.out","w",stdout); n=read(); cout&lt;&lt;mul(calcfac(n),(inv(solve(n))))&lt;&lt;endl; return 0;&#125; 这里用了另一种等价的做法,意义不是很明显?略去了表的数据. $secret$ 待更. $tree$ 待更.]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>打表</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190416]]></title>
    <url>%2F2019%2F04%2F17%2Ftest20190416%2F</url>
    <content type="text"><![CDATA[来自 $GDOI​$ 的模拟题? 题面 $graph$ 貌似是第一次在考试中遇到提答题? 这题看上去十分正常,却出成提答,就是让你乱搞的…题解给的做法就是退火之类的乱搞. 随便估价乱搞一下就可以获得 $80+$ 的好成绩? $guess$ 自己的联想发散能力还是有问题,没看出可以建网络流模型,只会打暴力… 正解:要求的就是所有合法配对方案中,出现原来配对情况的最小数目. 先离散化一下数字大小,建一个费用流的模型,从 $S$ 向左边每个数字连其在 $x$ 坐标中出现的次数作为流量, $0$ 作为费用的边. $y$ 坐标连类似的边连向 $T$ .中间对于每个原来有的配对,连一条流量为 $1$ ,费用为 $1$ 的边.这样就限制了不会出现重复的配对. 跑一遍 $mcmf$ 即为答案. $room$ 最开始想到最小割去了..然后发现好像不太现实,暴力转移的 $dp$ 倒是很普及… 设 $f[i][j][k]$ 表示已经走了前 $i$ 层,第 $i$ 层开的门分别为 $j,k​$ 时的最小体力花费. 这个东西显然可以 $O(nm^4)$ 大力转移. $f[1][j][k]=t[1][j]+t[1][k]$$f[i][j][k]=\min_{x\not = y} f[i-1][x][y]+K\cdot (|j-x|+|k-y|),2\leq i \leq n.​$ 后两维交换是没有影响的,所以在枚举是可以直接钦定 $j&lt;k,x&lt;y$ ,优化了 $16$ 倍常数.这样就有 $60pts$ 了. $100pts?$ 转移时允许在同层转移,形成一个类似前缀 $\min$ 的优化,即可做到 $O(nm^2)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define rg registerusing namespace std;typedef long long ll;const int inf=1e9;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=329;int n,m,K;int t[MAXN][MAXN];int f[MAXN][MAXN][MAXN];void solve()&#123; int ans=inf; memset(f,0x7f,sizeof f); for(rg int j=1;j&lt;m;++j) for(rg int k=j+1;k&lt;=m;++k) f[1][j][k]=t[1][j]+t[1][k]; for(rg int i=2;i&lt;=n;++i) &#123; for(rg int j=1;j&lt;m;++j) for(rg int k=j+1;k&lt;=m;++k) f[i][j][k]=min(K+min(f[i][j-1][k],f[i][j][k-1]),f[i-1][j][k]); for(rg int j=m-1;j&gt;=1;--j) for(int k=m;k&gt;j;--k) f[i][j][k]=min(f[i][j][k],K+min(f[i][j+1][k],f[i][j][k+1])); for(rg int j=1;j&lt;=m;++j) for(rg int k=j+1;k&lt;=m;++k) f[i][j][k]+=t[i][j]+t[i][k]; &#125; for(rg int j=1;j&lt;m;++j) for(rg int k=j+1;k&lt;=m;++k) ans=min(ans,f[n][j][k]); cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123; freopen("room.in","r",stdin); freopen("room.out","w",stdout); n=read(),m=read(),K=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) t[i][j]=read(); solve(); return 0;&#125; 可以滚掉第一维?空间没卡的话就随便吧…]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>test</tag>
        <tag>近似算法</tag>
        <tag>前缀和优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1153]]></title>
    <url>%2F2019%2F04%2F16%2FCF1153%2F</url>
    <content type="text"><![CDATA[$Div.2$ CF1153B Serval and Toy Bricks 贪心+构造. 能放行 $\max$ 而不爆列 $\max$ 的位置都放行 $\max$ , 能放列 $\max$ 而不爆行 $\max$ 的位置都放列 $\max$ . 这样每个位置显然不会被定为两个不同的值.对于其他有而未放的位置直接都放 $1$ 就好了. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=128;int n,m,H;int a[MAXN],b[MAXN];int c[MAXN][MAXN],h[MAXN][MAXN];int main()&#123; n=read(),m=read(),H=read(); for(int i=1;i&lt;=m;++i) a[i]=read(); for(int i=1;i&lt;=n;++i) b[i]=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) h[i][j]=read(); for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=m;++j) &#123; if(h[i][j]) &#123; if(a[j]&lt;=b[i]) c[i][j]=a[j]; else c[i][j]=b[i]; &#125; printf("%d ",c[i][j]); &#125; puts(""); &#125; return 0;&#125; CF1153C Serval and Parenthesis Sequence 贪心+构造.显然可以将左括号,右括号的权值分别赋为 $1,-1$. 那么容易发现题中限制条件就是权值前缀和 $sum(n)=0,sum(i)&gt;0,\forall i&lt;n$. 将所有未确定的位置赋为 $1$ ,可以算出 $sum(n)=k$ ,需要将 $\frac k 2$ 个位置改为 $-1$. 从后往前贪心改,能改的位置就改.判一下不合法的情况, $k$ 为奇数,负数或不够改. 改完后再从前往后 $check$ 一次就可以了. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define GG return puts(":("),0;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int n;char buf[MAXN];int a[MAXN];int main()&#123; n=read(); scanf("%s",buf+1); int k=0,tot=0; for(int i=1;i&lt;=n;++i) &#123; if(buf[i]==')') --k,a[i]=-1; else if(buf[i]=='(') ++k,a[i]=1; else ++k,a[i]=1,++tot; &#125; if(k&lt;0 || k%2==1 || k/2&gt;tot) GG for(int i=n;i&gt;=1 &amp;&amp; k&gt;0;--i) &#123; if(buf[i]=='?') a[i]=-1,k-=2; &#125; int sum=0; for(int i=1;i&lt;n;++i) &#123; sum+=a[i]; if(sum&lt;=0) GG &#125; for(int i=1;i&lt;=n;++i) &#123; if(a[i]==1) putchar('('); else putchar(')'); &#125; puts(""); return 0;&#125; CF1153D Serval and Rooted Tree 树形 $dp$ .(一定思维难度?) 考虑一颗子树,若其中有 $p$ 个叶子节点,任意选择 $p$ 个互不相同的权值,经过最优排列后,这个根节点的权值的相对大小,即排名,一定是确定的,即与选择了哪些权值无关. 那么记 $f_i$ 表示给子树 $i$ 中的叶子节点最优赋值后,节点 $i$ 上的权值是这些叶子节点权值中的第 $f_i$ 大. 对于叶子节点 ,显然 $f_u=1$ . 若操作符为 $\min$ ,可以证明感性理解, $f_u=\sum f_v$ .若操作符为 $\max$ ,可以证明感性理解, $f_u=\min f_v$ ,其中 $v$ 为 $u$ 的儿子. 共有 $k$ 个叶子节点,最后答案即为 $k+1-f_1$ ,即全部可用的权值的第 $f_1$ 大. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int head[MAXN],nx[MAXN],to[MAXN],ecnt=0;inline void addedge(int u,int v)&#123; ++ecnt; nx[ecnt]=head[u]; to[ecnt]=v; head[u]=ecnt;&#125;int n;int opt[MAXN],f[MAXN],outdeg[MAXN],k=0;void dfs(int u)&#123; if(!outdeg[u]) &#123; ++k; f[u]=1; return; &#125; if(opt[u]==1) f[u]=MAXN+1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; dfs(v); if(!opt[u]) f[u]+=f[v]; else f[u]=min(f[u],f[v]); &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) opt[i]=read(); for(int i=2;i&lt;=n;++i) &#123; int fa=read(); addedge(fa,i); ++outdeg[fa]; &#125; dfs(1); cout&lt;&lt;k+1-f[1]&lt;&lt;endl; return 0;&#125; CF1153F Serval and Bonus Problem 概率/期望,计数, $dp$ . 随便在线段上钦定 $2n$ 个点,分割成 $2n+1$ 段区间,所以每段区间的期望长度就是 $\frac l {2n+1}$ .于是只需要再乘上一段区间至少被 $k$ 条线段覆盖的概率就好了. 设 $f(i,j)$ 表示考虑 $i$ 个端点,第 $i$ 个端点后面的区间恰好被 $j$ 条线段所覆盖的方案数.转移时枚举 $i$ 是作为左端点还是右端点, $O(n^2)$ 大力转移. 最后将所有合法方案数目求和,除以 $f(2n,0)$ 得到概率. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;const int MAXN=2019&lt;&lt;1;int n,l,k;int fac[MAXN];int f[MAXN][MAXN];int main()&#123; n=read(),k=read(); l=read(); int perl=mul(l,inv(2*n+1)); fac[0]=1; for(int i=1;i&lt;=n;++i) fac[i]=mul(fac[i-1],i); f[0][0]=1; for(int i=0;i&lt;2*n;++i) &#123; for(int j=n&lt;i?n:i;j&gt;=0;--j) &#123; f[i+1][j+1]=add(f[i+1][j+1],f[i][j]); if(j) f[i+1][j-1]=add(f[i+1][j-1],mul(f[i][j],j)); &#125; &#125; int ans=0; for(int i=1;i&lt;2*n;++i) for(int j=k;j&lt;=n;++j) &#123; int tmp=mul(f[i][j],f[2*n-i][j]); tmp=mul(tmp,fac[j]); ans=add(ans,tmp); &#125; cout&lt;&lt;mul(ans,mul(perl,inv(f[2*n][0]))); return 0;&#125;]]></content>
      <tags>
        <tag>树形dp</tag>
        <tag>dp计数</tag>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>概率/期望</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCOI2019游记]]></title>
    <url>%2F2019%2F04%2F11%2FSCOI2019%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[梦之浮桥 $Day\ -3$ $NamelessOIer$ 在写退役记 .毕姥爷:你写一篇退役记,进队了来看,岂不是很爽? 奶一口 NamelessOIer 进队. $Day\ -2$ 怎么回事啊,考前天天考一些奥妙重重的数学题,自闭了. 我:省选前打几道数据结构题练练手.旁边的 achen :我刚刚写到数据结构写多了让人退役. 被钦点退役了. $Day\ -1$ 背了背笔试,据说 $SCOI$ 不上机笔试?快捷键警告. $Day\ 0$ 早上破天荒地去食堂吃了顿饭,也遇到了很多熟人.但大家的心境似乎不太一样呢… $noip$ 考完后还说着有半年才省选,转眼间也就到了呢… 怎么有点感冒啊,头倒不是很昏,就是一直流鼻涕… $Day\ 1$ 看完题,啥思路都没有…先写了后两个题的暴力,然后再看第一题. 发现其实就是一个像九连环或者汉诺塔之类的递归式子的题目？迅速写完 $50$ 分,然后开始想后面的部分. 可能这就是思维江化吧,觉得输入可能很大,就以为是读入的时候取模,高精是啥?推了很久,感觉很不可做.(不是自己都说了像九连环嘛…) 于是又把后面的部分分写了一点,大概还有 $15$ 分钟下考的样子?发现 $T1$ 的复杂度跑所有点都是可以的,带个高精就好了… 于是迅速 $rush$ 了一个高精,并且和前面的部分分情况做,又过了一次大样例. 预计 $50/100+20+30=100/150$ ,下午看分: $0+20+20=40$. $T3$ 挂了 $10分$ ,$T1$ 直接 $fst$ 了???怎么目前为止每次 $D1T1$ 都 $fst$ 啊??? 心态有些炸裂. $Day\ 2$ 也不指望能翻盘了.把自己能打的打好就可以了吧. 开题之后,误以为 $T1$ 非常普及,打了将近个一小时后发现是假的… 迅速写了个最暴力的 $O(n^3)$ 暴力,去看后面两个题. 姿势水平不够,依然只能打暴力. $T2$ 的暴力写了 $6kb$ , $T3$ 写了个暴力+线性基的部分分. 回过来看 $T1$ ,发现直接用最大子段和做是 $O(nm)$ 的,但我觉得直接把前面的线段树改一下,也就多个 $log$ 啊? 写完之后才发现这一档是 $n,m\leq 10^4$…测了一下自己的 $O(nmlogn)$ ,跑了 $7s,O2\ 1.7s$ ,但 $T1$ 偏偏 $2s$ ,无优化? 钦定卡常可还行?觉得自己改成 $O(nm)$ 也不太稳,于是就没有写,把 $T2$ 的树剖+树状数组的暴力再看了几遍… 预估 $20+40+40=100$ ,实际: $20+40+20=80$. $T3$ 线性基求秩咋挂的啊…感觉暴力挂掉的可能更大啊… 后记 已编辑并删除部分过激言论. 今年我们学校 achen 以女选手的身份进队,虽然以她的水平这次其实也有一些失误的? NamelessOIer 和 autoint都在 $40$ 名左右,刚好可以买 $D$ 的样子??? 各位, $NOIP\ 2019$ ,有缘再会.]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018游记]]></title>
    <url>%2F2018%2F11%2F11%2FNOIP2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[物语之始 $Day\ -1$ 上午考试…打开一看是noip2017的题,心态崩了…. xjb敲了一会,最后我的模拟 $FST$ 了… 下午开始巨tm难受,感冒了…头昏脑胀,慌得一匹… $Day\ 0$ 上午还是考试…结果是神仙题… 三道数学,T1压位高精努力打了一下,后面就乱搞了… 今天不应该出所有人都AK的题吗??? 下午坐车去成都… 晚上一直在看费用流和数学相关的东西,恍恍惚惚混过去了,感觉很慌… $Day\ 1$ 进了考场不让碰键盘鼠标就很难受… 开考的时候反而不是很紧张,因为在那里干坐了许久… 大致浏览了一遍…怎么没有%你题? 开始搞T1…搞不出来自己乱想了个东西,锤了一发,秒过大样例,就不管了… T2 像是大凯的疑惑…不过这题wys给我讲过升级版的…那道题是转化成图论跑最短路… 这道题连边权都不用考虑,一个 $bfs$ +时间戳优化卡常. 然后看 $T3​$ ,不会做. 开始打 $subtask$ ,打到11点的样子,打完了55分的 $subtask$ ,然后写个暴力开始逐个拍… day1 预估 $100+100+55=255.$ upd: T1我作了大死: 12while(!d[curp]) ++curp; 没有限制$curp\leq n$.在本机上这样写,溢出之后会访问奇怪的内存,不为0,就会自动跳出…所以我才丝毫没有发觉… 然而在Noi Linux环境下这样写就会导致全部RE… 这下凉的透彻.1=都很难说了. $Day\ 2$ T1先写了个树的 $60pts$ .然后基环树没想出来…一直在想 $O(nlogn)$ 的算法…据说是有的,但是我太菜了… T2我的状压,猜的结论是错的,死活过不了 $n=3$ 的样例…找了一波 $n=2$ 的规律,手算前面部分,$50pts$… T3 动态dp啊…然而时间不多了,也不太敢写…就写了个 $50pts$ 的暴力更新和 $18pts$ 的 $subtask$ . day2 预估 $60+50+68=178.​$ 后记 所以本来上个400应该还是没啥问题吧,然后T1原地爆炸… 目标从保$400pts$变到保1=…这是何等的凄凉… 现在只能给$CCF$上香…保住我的1=不爆炸….T1不RE还是别奢求了 等1920号公布成绩了. upd:凉凉.289.求不被卡1=. $D1T1$ 爆零,意料之中; $D1T3$ 被少爷机卡了 $25pts$ , $D2T3$ 的子任务应该是打炸了,只有 $44pts$ 的弱智分…]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
</search>
